/*
Copyright DHTMLX LTD. http://www.dhtmlx.com
To use this library please contact sales@dhtmlx.com to obtain license
*/

dhtmlx=function(obj){
	for (var a in obj) dhtmlx[a]=obj[a];
	return dhtmlx; //simple singleton
};
dhtmlx.extend_api=function(name,map,ext){
	var t = window[name];
	if (!t) return; //component not defined
	window[name]=function(obj){
		if (obj && typeof obj == "object" && !obj.tagName){
			var that = t.apply(this,(map._init?map._init(obj):arguments));
			//global settings
			for (var a in dhtmlx)
				if (map[a]) this[map[a]](dhtmlx[a]);			
			//local settings
			for (var a in obj){
				if (map[a]) this[map[a]](obj[a]);
				else if (a.indexOf("on")==0){
					this.attachEvent(a,obj[a]);
				}
			}
		} else
			var that = t.apply(this,arguments);
		if (map._patch) map._patch(this);
		return that||this;
	};
	window[name].prototype=t.prototype;
	if (ext)
		dhtmlXHeir(window[name].prototype,ext);
};

dhtmlxAjax={
	get:function(url,callback){
		var t=new dtmlXMLLoaderObject(true);
		t.async=(arguments.length<3);
		t.waitCall=callback;
		t.loadXML(url)
		return t;
	},
	post:function(url,post,callback){
		var t=new dtmlXMLLoaderObject(true);
		t.async=(arguments.length<4);
		t.waitCall=callback;
		t.loadXML(url,true,post)
		return t;
	},
	getSync:function(url){
		return this.get(url,null,true)
	},
	postSync:function(url,post){
		return this.post(url,post,null,true);		
	}
}

/**
  *     @desc: xmlLoader object
  *     @type: private
  *     @param: funcObject - xml parser function
  *     @param: object - jsControl object
  *     @param: async - sync/async mode (async by default)
  *     @param: rSeed - enable/disable random seed ( prevent IE caching)
  *     @topic: 0
  */
function dtmlXMLLoaderObject(funcObject, dhtmlObject, async, rSeed){
	this.xmlDoc="";

	if (typeof (async) != "undefined")
		this.async=async;
	else
		this.async=true;

	this.onloadAction=funcObject||null;
	this.mainObject=dhtmlObject||null;
	this.waitCall=null;
	this.rSeed=rSeed||false;
	return this;
};

dtmlXMLLoaderObject.count = 0;

/**
  *     @desc: xml loading handler
  *     @type: private
  *     @param: dtmlObject - xmlLoader object
  *     @topic: 0
  */
dtmlXMLLoaderObject.prototype.waitLoadFunction=function(dhtmlObject){
	var once = true;
	this.check=function (){
		if ((dhtmlObject)&&(dhtmlObject.onloadAction != null)){
			if ((!dhtmlObject.xmlDoc.readyState)||(dhtmlObject.xmlDoc.readyState == 4)){
				if (!once)
					return;

				once=false; //IE 5 fix
				dtmlXMLLoaderObject.count++;
				if (typeof dhtmlObject.onloadAction == "function")
					dhtmlObject.onloadAction(dhtmlObject.mainObject, null, null, null, dhtmlObject);

				if (dhtmlObject.waitCall){
					dhtmlObject.waitCall.call(this,dhtmlObject);
					dhtmlObject.waitCall=null;
				}
			}
		}
	};
	return this.check;
};

/**
  *     @desc: return XML top node
  *     @param: tagName - top XML node tag name (not used in IE, required for Safari and Mozilla)
  *     @type: private
  *     @returns: top XML node
  *     @topic: 0  
  */
dtmlXMLLoaderObject.prototype.getXMLTopNode=function(tagName, oldObj){
	if (this.xmlDoc.responseXML){
		var temp = this.xmlDoc.responseXML.getElementsByTagName(tagName);
		if(temp.length==0 && tagName.indexOf(":")!=-1)
			var temp = this.xmlDoc.responseXML.getElementsByTagName((tagName.split(":"))[1]);
		var z = temp[0];
	} else
		var z = this.xmlDoc.documentElement;

	if (z){
		this._retry=false;
		return z;
	}

	if (!this._retry&&_isIE){
		this._retry=true;
		var oldObj = this.xmlDoc;
		this.loadXMLString(this.xmlDoc.responseText.replace(/^[\s]+/,""), true);
		return this.getXMLTopNode(tagName, oldObj);
	}

	dhtmlxError.throwError("LoadXML", "Incorrect XML", [
		(oldObj||this.xmlDoc),
		this.mainObject
	]);

	return document.createElement("DIV");
};

/**
  *     @desc: load XML from string
  *     @type: private
  *     @param: xmlString - xml string
  *     @topic: 0  
  */
dtmlXMLLoaderObject.prototype.loadXMLString=function(xmlString, silent){

	if (!_isIE){
		var parser = new DOMParser();
		this.xmlDoc=parser.parseFromString(xmlString, "text/xml");
	} else {
		this.xmlDoc=new ActiveXObject("Microsoft.XMLDOM");
		this.xmlDoc.async=this.async;
		this.xmlDoc.onreadystatechange = function(){};
		this.xmlDoc["loadXM"+"L"](xmlString);
	}
	
	if (silent)
		return;

	if (this.onloadAction)
		this.onloadAction(this.mainObject, null, null, null, this);

	if (this.waitCall){
		this.waitCall();
		this.waitCall=null;
	}
}
/**
  *     @desc: load XML
  *     @type: private
  *     @param: filePath - xml file path
  *     @param: postMode - send POST request
  *     @param: postVars - list of vars for post request
  *     @topic: 0
  */
dtmlXMLLoaderObject.prototype.loadXML=function(filePath, postMode, postVars, rpc){
	if (this.rSeed)
		filePath+=((filePath.indexOf("?") != -1) ? "&" : "?")+"a_dhx_rSeed="+(new Date()).valueOf();
	this.filePath=filePath;

	if ((!_isIE)&&(window.XMLHttpRequest))
		this.xmlDoc=new XMLHttpRequest();
	else {
		this.xmlDoc=new ActiveXObject("Microsoft.XMLHTTP");
	}

	if (this.async)
		this.xmlDoc.onreadystatechange=new this.waitLoadFunction(this);
	this.xmlDoc.open(postMode ? "POST" : "GET", filePath, this.async);

	if (rpc){
		this.xmlDoc.setRequestHeader("User-Agent", "dhtmlxRPC v0.1 ("+navigator.userAgent+")");
		this.xmlDoc.setRequestHeader("Content-type", "text/xml");
	}

	else if (postMode)
		this.xmlDoc.setRequestHeader('Content-type', (this.contenttype || 'application/x-www-form-urlencoded'));
		
	this.xmlDoc.setRequestHeader("X-Requested-With","XMLHttpRequest");
	this.xmlDoc.send(null||postVars);

	if (!this.async)
		(new this.waitLoadFunction(this))();
};
/**
  *     @desc: destructor, cleans used memory
  *     @type: private
  *     @topic: 0
  */
dtmlXMLLoaderObject.prototype.destructor=function(){
	this._filterXPath = null;
	this._getAllNamedChilds = null;
	this._retry = null;
	this.async = null;
	this.rSeed = null;
	this.filePath = null;
	this.onloadAction = null;
	this.mainObject = null;
	this.xmlDoc = null;
	this.doXPath = null;
	this.doXPathOpera = null;
	this.doXSLTransToObject = null;
	this.doXSLTransToString = null;
	this.loadXML = null;
	this.loadXMLString = null;
	// this.waitLoadFunction = null;
	this.doSerialization = null;
	this.xmlNodeToJSON = null;
	this.getXMLTopNode = null;
	this.setXSLParamValue = null;
	return null;
}

dtmlXMLLoaderObject.prototype.xmlNodeToJSON = function(node){
        var t={};
        for (var i=0; i<node.attributes.length; i++)
            t[node.attributes[i].name]=node.attributes[i].value;
        t["_tagvalue"]=node.firstChild?node.firstChild.nodeValue:"";
        for (var i=0; i<node.childNodes.length; i++){
            var name=node.childNodes[i].tagName;
            if (name){
                if (!t[name]) t[name]=[];
                t[name].push(this.xmlNodeToJSON(node.childNodes[i]));
            }            
        }        
        return t;
    }

/**  
  *     @desc: Call wrapper
  *     @type: private
  *     @param: funcObject - action handler
  *     @param: dhtmlObject - user data
  *     @returns: function handler
  *     @topic: 0  
  */
function callerFunction(funcObject, dhtmlObject){
	this.handler=function(e){
		if (!e)
			e=window.event;
		funcObject(e, dhtmlObject);
		return true;
	};
	return this.handler;
};

/**  
  *     @desc: Calculate absolute position of html object
  *     @type: private
  *     @param: htmlObject - html object
  *     @topic: 0  
  */
function getAbsoluteLeft(htmlObject){
	return getOffset(htmlObject).left;
}
/**
  *     @desc: Calculate absolute position of html object
  *     @type: private
  *     @param: htmlObject - html object
  *     @topic: 0  
  */
function getAbsoluteTop(htmlObject){
	return getOffset(htmlObject).top;
}

function getOffsetSum(elem) {
	var top=0, left=0;
	while(elem) {
		top = top + parseInt(elem.offsetTop);
		left = left + parseInt(elem.offsetLeft);
		elem = elem.offsetParent;
	}
	return {top: top, left: left};
}
function getOffsetRect(elem) {
	var box = elem.getBoundingClientRect();
	var body = document.body;
	var docElem = document.documentElement;
	var scrollTop = window.pageYOffset || docElem.scrollTop || body.scrollTop;
	var scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft;
	var clientTop = docElem.clientTop || body.clientTop || 0;
	var clientLeft = docElem.clientLeft || body.clientLeft || 0;
	var top  = box.top +  scrollTop - clientTop;
	var left = box.left + scrollLeft - clientLeft;
	return { top: Math.round(top), left: Math.round(left) };
}
function getOffset(elem) {
	if (elem.getBoundingClientRect) {
		return getOffsetRect(elem);
	} else {
		return getOffsetSum(elem);
	}
}

/**  
*     @desc: Convert string to it boolean representation
*     @type: private
*     @param: inputString - string for covertion
*     @topic: 0
*/
function convertStringToBoolean(inputString){
	if (typeof (inputString) == "string")
		inputString=inputString.toLowerCase();

	switch (inputString){
		case "1":
		case "true":
		case "yes":
		case "y":
		case 1:
		case true:
			return true;
			break;

		default: return false;
	}
}

/**  
*     @desc: find out what symbol to use as url param delimiters in further params
*     @type: private
*     @param: str - current url string
*     @topic: 0  
*/
function getUrlSymbol(str){
	if (str.indexOf("?") != -1)
		return "&"
	else
		return "?"
}

function dhtmlDragAndDropObject(){
	if (window.dhtmlDragAndDrop)
		return window.dhtmlDragAndDrop;

	this.lastLanding=0;
	this.dragNode=0;
	this.dragStartNode=0;
	this.dragStartObject=0;
	this.tempDOMU=null;
	this.tempDOMM=null;
	this.waitDrag=0;
	window.dhtmlDragAndDrop=this;

	return this;
};

dhtmlDragAndDropObject.prototype.removeDraggableItem=function(htmlNode){
	htmlNode.onmousedown=null;
	htmlNode.dragStarter=null;
	htmlNode.dragLanding=null;
}
dhtmlDragAndDropObject.prototype.addDraggableItem=function(htmlNode, dhtmlObject){
	htmlNode.onmousedown=this.preCreateDragCopy;
	htmlNode.dragStarter=dhtmlObject;
	this.addDragLanding(htmlNode, dhtmlObject);
}
dhtmlDragAndDropObject.prototype.addDragLanding=function(htmlNode, dhtmlObject){
	htmlNode.dragLanding=dhtmlObject;
}
dhtmlDragAndDropObject.prototype.preCreateDragCopy=function(e){
	if ((e||window.event) && (e||event).button == 2)
		return;

	if (window.dhtmlDragAndDrop.waitDrag){
		window.dhtmlDragAndDrop.waitDrag=0;
		document.body.onmouseup=window.dhtmlDragAndDrop.tempDOMU;
		document.body.onmousemove=window.dhtmlDragAndDrop.tempDOMM;
		return false;
	}
	
	if (window.dhtmlDragAndDrop.dragNode)
		window.dhtmlDragAndDrop.stopDrag(e);	

	window.dhtmlDragAndDrop.waitDrag=1;
	window.dhtmlDragAndDrop.tempDOMU=document.body.onmouseup;
	window.dhtmlDragAndDrop.tempDOMM=document.body.onmousemove;
	window.dhtmlDragAndDrop.dragStartNode=this;
	window.dhtmlDragAndDrop.dragStartObject=this.dragStarter;
	document.body.onmouseup=window.dhtmlDragAndDrop.preCreateDragCopy;
	document.body.onmousemove=window.dhtmlDragAndDrop.callDrag;
	window.dhtmlDragAndDrop.downtime = new Date().valueOf();
	

	if ((e)&&(e.preventDefault)){
		e.preventDefault();
		return false;
	}
	return false;
};
dhtmlDragAndDropObject.prototype.callDrag=function(e){
	if (!e)
		e=window.event;
	dragger=window.dhtmlDragAndDrop;
	if ((new Date()).valueOf()-dragger.downtime<100) return;

	//if ((e.button == 0)&&(_isIE))
	//	return dragger.stopDrag();

	if (!dragger.dragNode){
		if (dragger.waitDrag){
			dragger.dragNode=dragger.dragStartObject._createDragNode(dragger.dragStartNode, e);
	
			if (!dragger.dragNode)
				return dragger.stopDrag();
	
			dragger.dragNode.onselectstart=function(){return false;}
			dragger.gldragNode=dragger.dragNode;
			document.body.appendChild(dragger.dragNode);
			document.body.onmouseup=dragger.stopDrag;
			dragger.waitDrag=0;
			dragger.dragNode.pWindow=window;
			dragger.initFrameRoute();
		} 
		else return dragger.stopDrag(e, true);
	}

	if (dragger.dragNode.parentNode != window.document.body && dragger.gldragNode){
		var grd = dragger.gldragNode;

		if (dragger.gldragNode.old)
			grd=dragger.gldragNode.old;

		//if (!document.all) dragger.calculateFramePosition();
		grd.parentNode.removeChild(grd);
		var oldBody = dragger.dragNode.pWindow;

		if (grd.pWindow &&	grd.pWindow.dhtmlDragAndDrop.lastLanding)
			grd.pWindow.dhtmlDragAndDrop.lastLanding.dragLanding._dragOut(grd.pWindow.dhtmlDragAndDrop.lastLanding);	
			
		//		var oldp=dragger.dragNode.parentObject;
		if (_isIE){
			var div = document.createElement("Div");
			div.innerHTML=dragger.dragNode.outerHTML;
			dragger.dragNode=div.childNodes[0];
		} else
			dragger.dragNode=dragger.dragNode.cloneNode(true);

		dragger.dragNode.pWindow=window;
		//		dragger.dragNode.parentObject=oldp;

		dragger.gldragNode.old=dragger.dragNode;
		document.body.appendChild(dragger.dragNode);
		oldBody.dhtmlDragAndDrop.dragNode=dragger.dragNode;
	}

	dragger.dragNode.style.left=e.clientX+15+(dragger.fx
		? dragger.fx*(-1)
		: 0)
		+(document.body.scrollLeft||document.documentElement.scrollLeft)+"px";
	dragger.dragNode.style.top=e.clientY+3+(dragger.fy
		? dragger.fy*(-1)
		: 0)
		+(document.body.scrollTop||document.documentElement.scrollTop)+"px";

	if (!e.srcElement)
		var z = e.target;
	else
		z=e.srcElement;
	dragger.checkLanding(z, e);
}

dhtmlDragAndDropObject.prototype.calculateFramePosition=function(n){
	//this.fx = 0, this.fy = 0;
	if (window.name){
		var el = parent.frames[window.name].frameElement.offsetParent;
		var fx = 0;
		var fy = 0;

		while (el){
			fx+=el.offsetLeft;
			fy+=el.offsetTop;
			el=el.offsetParent;
		}

		if ((parent.dhtmlDragAndDrop)){
			var ls = parent.dhtmlDragAndDrop.calculateFramePosition(1);
			fx+=ls.split('_')[0]*1;
			fy+=ls.split('_')[1]*1;
		}

		if (n)
			return fx+"_"+fy;
		else
			this.fx=fx;
		this.fy=fy;
	}
	return "0_0";
}
dhtmlDragAndDropObject.prototype.checkLanding=function(htmlObject, e){
	if ((htmlObject)&&(htmlObject.dragLanding)){
		if (this.lastLanding)
			this.lastLanding.dragLanding._dragOut(this.lastLanding);
		this.lastLanding=htmlObject;
		this.lastLanding=this.lastLanding.dragLanding._dragIn(this.lastLanding, this.dragStartNode, e.clientX,
			e.clientY, e);
		this.lastLanding_scr=(_isIE ? e.srcElement : e.target);
	} else {
		if ((htmlObject)&&(htmlObject.tagName != "BODY"))
			this.checkLanding(htmlObject.parentNode, e);
		else {
			if (this.lastLanding)
				this.lastLanding.dragLanding._dragOut(this.lastLanding, e.clientX, e.clientY, e);
			this.lastLanding=0;

			if (this._onNotFound)
				this._onNotFound();
		}
	}
}
dhtmlDragAndDropObject.prototype.stopDrag=function(e, mode){
	dragger=window.dhtmlDragAndDrop;

	if (!mode){
		dragger.stopFrameRoute();
		var temp = dragger.lastLanding;
		dragger.lastLanding=null;

		if (temp)
			temp.dragLanding._drag(dragger.dragStartNode, dragger.dragStartObject, temp, (_isIE
				? event.srcElement
				: e.target));
	}
	dragger.lastLanding=null;

	if ((dragger.dragNode)&&(dragger.dragNode.parentNode == document.body))
		dragger.dragNode.parentNode.removeChild(dragger.dragNode);
	dragger.dragNode=0;
	dragger.gldragNode=0;
	dragger.fx=0;
	dragger.fy=0;
	dragger.dragStartNode=0;
	dragger.dragStartObject=0;
	document.body.onmouseup=dragger.tempDOMU;
	document.body.onmousemove=dragger.tempDOMM;
	dragger.tempDOMU=null;
	dragger.tempDOMM=null;
	dragger.waitDrag=0;
}

dhtmlDragAndDropObject.prototype.stopFrameRoute=function(win){
	if (win)
		window.dhtmlDragAndDrop.stopDrag(1, 1);

	for (var i = 0; i < window.frames.length; i++){
		try{
		if ((window.frames[i] != win)&&(window.frames[i].dhtmlDragAndDrop))
			window.frames[i].dhtmlDragAndDrop.stopFrameRoute(window);
		} catch(e){}
	}

	try{
	if ((parent.dhtmlDragAndDrop)&&(parent != window)&&(parent != win))
		parent.dhtmlDragAndDrop.stopFrameRoute(window);
	} catch(e){}
}
dhtmlDragAndDropObject.prototype.initFrameRoute=function(win, mode){
	if (win){
		window.dhtmlDragAndDrop.preCreateDragCopy();
		window.dhtmlDragAndDrop.dragStartNode=win.dhtmlDragAndDrop.dragStartNode;
		window.dhtmlDragAndDrop.dragStartObject=win.dhtmlDragAndDrop.dragStartObject;
		window.dhtmlDragAndDrop.dragNode=win.dhtmlDragAndDrop.dragNode;
		window.dhtmlDragAndDrop.gldragNode=win.dhtmlDragAndDrop.dragNode;
		window.document.body.onmouseup=window.dhtmlDragAndDrop.stopDrag;
		window.waitDrag=0;

		if (((!_isIE)&&(mode))&&((!_isFF)||(_FFrv < 1.8)))
			window.dhtmlDragAndDrop.calculateFramePosition();
	}
	try{
	if ((parent.dhtmlDragAndDrop)&&(parent != window)&&(parent != win))
		parent.dhtmlDragAndDrop.initFrameRoute(window);
	}catch(e){}

	for (var i = 0; i < window.frames.length; i++){
		try{
		if ((window.frames[i] != win)&&(window.frames[i].dhtmlDragAndDrop))
			window.frames[i].dhtmlDragAndDrop.initFrameRoute(window, ((!win||mode) ? 1 : 0));
		} catch(e){}
	}
}

 _isFF = false;
 _isIE = false;
 _isOpera = false;
 _isKHTML = false;
 _isMacOS = false;
 _isChrome = false;
 _FFrv = false;
 _KHTMLrv = false;
 _OperaRv = false;

if (navigator.userAgent.indexOf('Macintosh') != -1)
	_isMacOS=true;


if (navigator.userAgent.toLowerCase().indexOf('chrome')>-1)
	_isChrome=true;

if ((navigator.userAgent.indexOf('Safari') != -1)||(navigator.userAgent.indexOf('Konqueror') != -1)){
	 _KHTMLrv = parseFloat(navigator.userAgent.substr(navigator.userAgent.indexOf('Safari')+7, 5));

	if (_KHTMLrv > 525){ //mimic FF behavior for Safari 3.1+
		_isFF=true;
		 _FFrv = 1.9;
	} else
		_isKHTML=true;
} else if (navigator.userAgent.indexOf('Opera') != -1){
	_isOpera=true;
	_OperaRv=parseFloat(navigator.userAgent.substr(navigator.userAgent.indexOf('Opera')+6, 3));
}


else if (navigator.appName.indexOf("Microsoft") != -1){
	_isIE=true;
	if ((navigator.appVersion.indexOf("MSIE 8.0")!= -1 || 
		 navigator.appVersion.indexOf("MSIE 9.0")!= -1 || 
		 navigator.appVersion.indexOf("MSIE 10.0")!= -1 ||
		 document.documentMode > 7) && 
			document.compatMode != "BackCompat"){
		_isIE=8;
	}
} else if (navigator.appName  == 'Netscape' && navigator.userAgent.indexOf("Trident") != -1){
	//ie11
	_isIE=8;
} else {
	_isFF=true;
	 _FFrv = parseFloat(navigator.userAgent.split("rv:")[1])
}


//multibrowser Xpath processor
dtmlXMLLoaderObject.prototype.doXPath=function(xpathExp, docObj, namespace, result_type){
	if (_isKHTML || (!_isIE && !window.XPathResult))
		return this.doXPathOpera(xpathExp, docObj);

	if (_isIE){ //IE
		if (!docObj)
			if (!this.xmlDoc.nodeName)
				docObj=this.xmlDoc.responseXML
			else
				docObj=this.xmlDoc;

		if (!docObj)
			dhtmlxError.throwError("LoadXML", "Incorrect XML", [
				(docObj||this.xmlDoc),
				this.mainObject
			]);

		if (namespace != null)
			docObj.setProperty("SelectionNamespaces", "xmlns:xsl='"+namespace+"'"); //

		if (result_type == 'single'){
			return docObj.selectSingleNode(xpathExp);
		}
		else {
			return docObj.selectNodes(xpathExp)||new Array(0);
		}
	} else { //Mozilla
		var nodeObj = docObj;

		if (!docObj){
			if (!this.xmlDoc.nodeName){
				docObj=this.xmlDoc.responseXML
			}
			else {
				docObj=this.xmlDoc;
			}
		}

		if (!docObj)
			dhtmlxError.throwError("LoadXML", "Incorrect XML", [
				(docObj||this.xmlDoc),
				this.mainObject
			]);

		if (docObj.nodeName.indexOf("document") != -1){
			nodeObj=docObj;
		}
		else {
			nodeObj=docObj;
			docObj=docObj.ownerDocument;
		}
		var retType = XPathResult.ANY_TYPE;

		if (result_type == 'single')
			retType=XPathResult.FIRST_ORDERED_NODE_TYPE
		var rowsCol = new Array();
		var col = docObj.evaluate(xpathExp, nodeObj, function(pref){
			return namespace
		}, retType, null);

		if (retType == XPathResult.FIRST_ORDERED_NODE_TYPE){
			return col.singleNodeValue;
		}
		var thisColMemb = col.iterateNext();

		while (thisColMemb){
			rowsCol[rowsCol.length]=thisColMemb;
			thisColMemb=col.iterateNext();
		}
		return rowsCol;
	}
}

function _dhtmlxError(type, name, params){
	if (!this.catches)
		this.catches=new Array();

	return this;
}

_dhtmlxError.prototype.catchError=function(type, func_name){
	this.catches[type]=func_name;
}
_dhtmlxError.prototype.throwError=function(type, name, params){
	if (this.catches[type])
		return this.catches[type](type, name, params);

	if (this.catches["ALL"])
		return this.catches["ALL"](type, name, params);
    if (arguments[0] != "LoadXML" || arguments[1] != "Incorrect XML")
	alert("Error type: "+arguments[0]+"\nDescription: "+arguments[1]);
	return null;
}

window.dhtmlxError=new _dhtmlxError();


//opera fake, while 9.0 not released
//multibrowser Xpath processor
dtmlXMLLoaderObject.prototype.doXPathOpera=function(xpathExp, docObj){
	//this is fake for Opera
	var z = xpathExp.replace(/[\/]+/gi, "/").split('/');
	var obj = null;
	var i = 1;

	if (!z.length)
		return [];

	if (z[0] == ".")
		obj=[docObj]; else if (z[0] == ""){
		obj=(this.xmlDoc.responseXML||this.xmlDoc).getElementsByTagName(z[i].replace(/\[[^\]]*\]/g, ""));
		i++;
	} else
		return [];

	for (i; i < z.length; i++)obj=this._getAllNamedChilds(obj, z[i]);

	if (z[i-1].indexOf("[") != -1)
		obj=this._filterXPath(obj, z[i-1]);
	return obj;
}

dtmlXMLLoaderObject.prototype._filterXPath=function(a, b){
	var c = new Array();
	var b = b.replace(/[^\[]*\[\@/g, "").replace(/[\[\]\@]*/g, "");

	for (var i = 0; i < a.length; i++)
		if (a[i].getAttribute(b))
			c[c.length]=a[i];

	return c;
}
dtmlXMLLoaderObject.prototype._getAllNamedChilds=function(a, b){
	var c = new Array();

	if (_isKHTML)
		b=b.toUpperCase();

	for (var i = 0; i < a.length; i++)for (var j = 0; j < a[i].childNodes.length; j++){
		if (_isKHTML){
			if (a[i].childNodes[j].tagName&&a[i].childNodes[j].tagName.toUpperCase() == b)
				c[c.length]=a[i].childNodes[j];
		}

		else if (a[i].childNodes[j].tagName == b)
			c[c.length]=a[i].childNodes[j];
	}

	return c;
}

function dhtmlXHeir(a, b){
	for (var c in b)
		if (typeof (b[c]) == "function")
			a[c]=b[c];
	return a;
}

function dhtmlxEvent(el, event, handler){
	if (el.addEventListener)
		el.addEventListener(event, handler, false);

	else if (el.attachEvent)
		el.attachEvent("on"+event, handler);
}

//============= XSL Extension ===================================

dtmlXMLLoaderObject.prototype.xslDoc=null;
dtmlXMLLoaderObject.prototype.setXSLParamValue=function(paramName, paramValue, xslDoc){
	if (!xslDoc)
		xslDoc=this.xslDoc

	if (xslDoc.responseXML)
		xslDoc=xslDoc.responseXML;
	var item =
		this.doXPath("/xsl:stylesheet/xsl:variable[@name='"+paramName+"']", xslDoc,
			"http:/\/www.w3.org/1999/XSL/Transform", "single");

	if (item != null)
		item.firstChild.nodeValue=paramValue
}
dtmlXMLLoaderObject.prototype.doXSLTransToObject=function(xslDoc, xmlDoc){
	if (!xslDoc)
		xslDoc=this.xslDoc;

	if (xslDoc.responseXML)
		xslDoc=xslDoc.responseXML

	if (!xmlDoc)
		xmlDoc=this.xmlDoc;

	if (xmlDoc.responseXML)
		xmlDoc=xmlDoc.responseXML

	//MOzilla
	if (!_isIE){
		if (!this.XSLProcessor){
			this.XSLProcessor=new XSLTProcessor();
			this.XSLProcessor.importStylesheet(xslDoc);
		}
		var result = this.XSLProcessor.transformToDocument(xmlDoc);
	} else {
		var result = new ActiveXObject("Msxml2.DOMDocument.3.0");
		try{
			xmlDoc.transformNodeToObject(xslDoc, result);
		}catch(e){
			result = xmlDoc.transformNode(xslDoc);
		}
	}
	return result;
}

dtmlXMLLoaderObject.prototype.doXSLTransToString=function(xslDoc, xmlDoc){
	var res = this.doXSLTransToObject(xslDoc, xmlDoc);
	if(typeof(res)=="string")
		return res;
	return this.doSerialization(res);
}

dtmlXMLLoaderObject.prototype.doSerialization=function(xmlDoc){
	if (!xmlDoc)
			xmlDoc=this.xmlDoc;
	if (xmlDoc.responseXML)
			xmlDoc=xmlDoc.responseXML
	if (!_isIE){
		var xmlSerializer = new XMLSerializer();
		return xmlSerializer.serializeToString(xmlDoc);
	} else
		return xmlDoc.xml;
}

/**
*   @desc: 
*   @type: private
*/
dhtmlxEventable=function(obj){
		obj.attachEvent=function(name, catcher, callObj){
			name='ev_'+name.toLowerCase();
			if (!this[name])
				this[name]=new this.eventCatcher(callObj||this);
				
			return(name+':'+this[name].addEvent(catcher)); //return ID (event name & event ID)
		}
		obj.callEvent=function(name, arg0){ 
			name='ev_'+name.toLowerCase();
			if (this[name])
				return this[name].apply(this, arg0);
			return true;
		}
		obj.checkEvent=function(name){
			return (!!this['ev_'+name.toLowerCase()])
		}
		obj.eventCatcher=function(obj){
			var dhx_catch = [];
			var z = function(){
				var res = true;
				for (var i = 0; i < dhx_catch.length; i++){
					if (dhx_catch[i] != null){
						var zr = dhx_catch[i].apply(obj, arguments);
						res=res&&zr;
					}
				}
				return res;
			}
			z.addEvent=function(ev){
				if (typeof (ev) != "function")
					ev=eval(ev);
				if (ev)
					return dhx_catch.push(ev)-1;
				return false;
			}
			z.removeEvent=function(id){
				dhx_catch[id]=null;
			}
			return z;
		}
		obj.detachEvent=function(id){
			if (id != false){
				var list = id.split(':');           //get EventName and ID
				this[list[0]].removeEvent(list[1]); //remove event
			}
		}
		obj.detachAllEvents = function(){
			for (var name in this){
				if (name.indexOf("ev_")==0){
					this.detachEvent(name);
					this[name] = null;
				}
			}
		}
		obj = null;
};

//v.3.6 build 131108

/*
Copyright DHTMLX LTD. http://www.dhtmlx.com
To use this component please contact sales@dhtmlx.com to obtain license
*/
if(!window.dhtmlx)
	window.dhtmlx = {};

(function(){
	var _dhx_msg_cfg = null;
	function callback(config, result){
			var usercall = config.callback;
			modality(false);
			config.box.parentNode.removeChild(config.box);
			_dhx_msg_cfg = config.box = null;
			if (usercall)
				usercall(result);
	}
	function modal_key(e){
		if (_dhx_msg_cfg){
			e = e||event;
			var code = e.which||event.keyCode;
			if (dhtmlx.message.keyboard){
				if (code == 13 || code == 32)
					callback(_dhx_msg_cfg, true);
				if (code == 27)
					callback(_dhx_msg_cfg, false);
			}
			if (e.preventDefault)
				e.preventDefault();
			return !(e.cancelBubble = true);
		}
	}
	if (document.attachEvent)
		document.attachEvent("onkeydown", modal_key);
	else
		document.addEventListener("keydown", modal_key, true);
		
	function modality(mode){
		if(!modality.cover){
			modality.cover = document.createElement("DIV");
			//necessary for IE only
			modality.cover.onkeydown = modal_key;
			modality.cover.className = "dhx_modal_cover";
			document.body.appendChild(modality.cover);
		}
		var height =  document.body.scrollHeight;
		modality.cover.style.display = mode?"inline-block":"none";
	}

	function button(text, result){
		return "<div class='dhtmlx_popup_button' result='"+result+"' ><div>"+text+"</div></div>";
	}

	function info(text){
		if (!t.area){
			t.area = document.createElement("DIV");
			t.area.className = "dhtmlx_message_area";
			t.area.style[t.position]="5px";
			document.body.appendChild(t.area);
		}

		t.hide(text.id);
		var message = document.createElement("DIV");
		message.innerHTML = "<div>"+text.text+"</div>";
		message.className = "dhtmlx-info dhtmlx-" + text.type;
		message.onclick = function(){
			t.hide(text.id);
			text = null;
		};

		if (t.position == "bottom" && t.area.firstChild)
			t.area.insertBefore(message,t.area.firstChild);
		else
			t.area.appendChild(message);
		
		if (text.expire > 0)
			t.timers[text.id]=window.setTimeout(function(){
				t.hide(text.id);
			}, text.expire);

		t.pull[text.id] = message;
		message = null;

		return text.id;
	}
	function _boxStructure(config, ok, cancel){
		var box = document.createElement("DIV");
		box.className = " dhtmlx_modal_box dhtmlx-"+config.type;
		box.setAttribute("dhxbox", 1);
			
		var inner = '';

		if (config.width)
			box.style.width = config.width;
		if (config.height)
			box.style.height = config.height;
		if (config.title)
			inner+='<div class="dhtmlx_popup_title">'+config.title+'</div>';
		inner+='<div class="dhtmlx_popup_text"><span>'+(config.content?'':config.text)+'</span></div><div  class="dhtmlx_popup_controls">';
		if (ok)
			inner += button(config.ok || "OK", true);
		if (cancel)
			inner += button(config.cancel || "Cancel", false);
		if (config.buttons){
			for (var i=0; i<config.buttons.length; i++)
				inner += button(config.buttons[i],i);
		}
		inner += '</div>';
		box.innerHTML = inner;

		if (config.content){
			var node = config.content;
			if (typeof node == "string") 
				node = document.getElementById(node);
			if (node.style.display == 'none')
				node.style.display = "";
			box.childNodes[config.title?1:0].appendChild(node);
		}

		box.onclick = function(e){
			e = e ||event;
			var source = e.target || e.srcElement;
			if (!source.className) source = source.parentNode;
			if (source.className == "dhtmlx_popup_button"){
				var result = source.getAttribute("result");
				result = (result == "true")||(result == "false"?false:result);
				callback(config, result);
			}
		};
		config.box = box;
		if (ok||cancel)
			_dhx_msg_cfg = config;

		return box;
	}
	function _createBox(config, ok, cancel){
		var box = config.tagName ? config : _boxStructure(config, ok, cancel);
		
		if (!config.hidden)
			modality(true);
		document.body.appendChild(box);
		var x = config.left||Math.abs(Math.floor(((window.innerWidth||document.documentElement.offsetWidth) - box.offsetWidth)/2));
		var y = config.top||Math.abs(Math.floor(((window.innerHeight||document.documentElement.offsetHeight) - box.offsetHeight)/2));
		if (config.position == "top")
			box.style.top = "-3px";
		else
			box.style.top = y+'px';
		box.style.left = x+'px';
		//necessary for IE only
		box.onkeydown = modal_key;

		box.focus();
		if (config.hidden)
			dhtmlx.modalbox.hide(box);

		return box;
	}

	function alertPopup(config){
		return _createBox(config, true, false);
	}
	function confirmPopup(config){
		return _createBox(config, true, true);
	}
	function boxPopup(config){
		return _createBox(config);
	}
	function box_params(text, type, callback){
		if (typeof text != "object"){
			if (typeof type == "function"){
				callback = type;
				type = "";
			}
			text = {text:text, type:type, callback:callback };
		}
		return text;
	}
	function params(text, type, expire, id){
		if (typeof text != "object")
			text = {text:text, type:type, expire:expire, id:id};
		text.id = text.id||t.uid();
		text.expire = text.expire||t.expire;
		return text;
	}
	dhtmlx.alert = function(){
		var text = box_params.apply(this, arguments);
		text.type = text.type || "confirm";
		return alertPopup(text);
	};
	dhtmlx.confirm = function(){
		var text = box_params.apply(this, arguments);
		text.type = text.type || "alert";
		return confirmPopup(text);
	};
	dhtmlx.modalbox = function(){
		var text = box_params.apply(this, arguments);
		text.type = text.type || "alert";
		return boxPopup(text);
	};
	dhtmlx.modalbox.hide = function(node){
		while (node && node.getAttribute && !node.getAttribute("dhxbox"))
			node = node.parentNode;
		if (node){
			node.parentNode.removeChild(node);
			modality(false);
		}
	};
	var t = dhtmlx.message = function(text, type, expire, id){
		text = params.apply(this, arguments);
		text.type = text.type||"info";

		var subtype = text.type.split("-")[0];
		switch (subtype){
			case "alert":
				return alertPopup(text);
			case "confirm":
				return confirmPopup(text);
			case "modalbox":
				return boxPopup(text);
			default:
				return info(text);
			break;
		}
	};

	t.seed = (new Date()).valueOf();
	t.uid = function(){return t.seed++;};
	t.expire = 4000;
	t.keyboard = true;
	t.position = "top";
	t.pull = {};
	t.timers = {};

	t.hideAll = function(){
		for (var key in t.pull)
			t.hide(key);
	};
	t.hide = function(id){
		var obj = t.pull[id];
		if (obj && obj.parentNode){
			window.setTimeout(function(){
				obj.parentNode.removeChild(obj);
				obj = null;
			},2000);
			obj.className+=" hidden";
			
			if(t.timers[id])
				window.clearTimeout(t.timers[id]);
			delete t.pull[id];
		}
	};
})();
//v.3.6 build 131108

/*
Copyright DHTMLX LTD. http://www.dhtmlx.com
To use this component please contact sales@dhtmlx.com to obtain license
*/
//latest dev. version

/*_TOPICS_
@0:initialization
@1:selection control
@2:rows control
@3:colums control
@4:cells controll
@5:data manipulation
@6:appearence control
@7:overal control
@8:tools
@9:treegrid
@10: event handlers
@11: paginal output
*/

var globalActiveDHTMLGridObject;
String.prototype._dhx_trim=function(){
	return this.replace(/&nbsp;/g, " ").replace(/(^[ \t]*)|([ \t]*$)/g, "");
}

function dhtmlxArray(ar){
	return dhtmlXHeir((ar||new Array()), dhtmlxArray._master);
};
dhtmlxArray._master={
	_dhx_find:function(pattern){
		for (var i = 0; i < this.length; i++){
			if (pattern == this[i])
				return i;
		}
		return -1;
	},
	_dhx_insertAt:function(ind, value){
		this[this.length]=null;
		for (var i = this.length-1; i >= ind; i--)
			this[i]=this[i-1]
		this[ind]=value
	},
	_dhx_removeAt:function(ind){
			this.splice(ind,1)
	},
	_dhx_swapItems:function(ind1, ind2){
		var tmp = this[ind1];
		this[ind1]=this[ind2]
		this[ind2]=tmp;
	}
}

/**
*   @desc: dhtmlxGrid constructor
*   @param: id - (optional) id of div element to base grid on
*   @returns: dhtmlxGrid object
*   @type: public
*/
function dhtmlXGridObject(id){
	if (_isIE)
		try{
			document.execCommand("BackgroundImageCache", false, true);
		}
		catch (e){}

	if (id){
		if (typeof (id) == 'object'){
			this.entBox=id
			if (!this.entBox.id) this.entBox.id="cgrid2_"+this.uid();
		} else
			this.entBox=document.getElementById(id);
	} else {
		this.entBox=document.createElement("DIV");
		this.entBox.id="cgrid2_"+this.uid();
	}
	this.entBox.innerHTML="";
	dhtmlxEventable(this);

	var self = this;

	this._wcorr=0;
	this.fontWidth = 7;
	this.cell=null;
	this.row=null;
	this.iconURL="";
	this.editor=null;
	this._f2kE=true;
	this._dclE=true;
	this.combos=new Array(0);
	this.defVal=new Array(0);
	this.rowsAr={
	};

	this.rowsBuffer=dhtmlxArray();
	this.rowsCol=dhtmlxArray(); //array of rows by index

	this._data_cache={
	};

	this._ecache={
	}

	this._ud_enabled=true;
	this.xmlLoader=new dtmlXMLLoaderObject(this.doLoadDetails, this, true, this.no_cashe);

	this._maskArr=[];
	this.selectedRows=dhtmlxArray(); //selected rows array

	this.UserData={};//hash of row related userdata (and for grid - "gridglobaluserdata")
	this._sizeFix=this._borderFix=0;
	/*MAIN OBJECTS*/

	this.entBox.className+=" gridbox";

	this.entBox.style.width=this.entBox.getAttribute("width")
		||(window.getComputedStyle
			? (this.entBox.style.width||window.getComputedStyle(this.entBox, null)["width"])
			: (this.entBox.currentStyle
				? this.entBox.currentStyle["width"]
				: this.entBox.style.width||0))
		||"100%";

	this.entBox.style.height=this.entBox.getAttribute("height")
		||(window.getComputedStyle
			? (this.entBox.style.height||window.getComputedStyle(this.entBox, null)["height"])
			: (this.entBox.currentStyle
				? this.entBox.currentStyle["height"]
				: this.entBox.style.height||0))
		||"100%";
	//cursor and text selection
	this.entBox.style.cursor='default';

	this.entBox.onselectstart=function(){
		return false
	}; //avoid text select
	var t_creator=function(name){
		var t=document.createElement("TABLE");
		t.cellSpacing=t.cellPadding=0;
		t.style.cssText='width:100%;table-layout:fixed;';
		t.className=name.substr(2);
		return t;
	}
	this.obj=t_creator("c_obj");
	this.hdr=t_creator("c_hdr");
	this.hdr.style.marginRight="20px";
	this.hdr.style.paddingRight="20px";
	
	this.objBox=document.createElement("DIV");
	this.objBox.style.width="100%";
	this.objBox.style.overflow="auto";
	this.objBox.appendChild(this.obj);
	this.objBox.className="objbox";

	if (dhtmlx.$customScroll)
		dhtmlx.CustomScroll.enable(this);

	this.hdrBox=document.createElement("DIV");
	this.hdrBox.style.width="100%"
	this.hdrBox.style.height="25px";
	this.hdrBox.style.overflow="hidden";
	this.hdrBox.className="xhdr";
	

	this.preloadImagesAr=new Array(0)

	this.sortImg=document.createElement("IMG")
	this.sortImg.style.display="none";
	
	this.hdrBox.appendChild(this.sortImg)
	this.hdrBox.appendChild(this.hdr);
	this.hdrBox.style.position="relative";

	this.entBox.appendChild(this.hdrBox);
	this.entBox.appendChild(this.objBox);
	
	//add links to current object
	this.entBox.grid=this;
	this.objBox.grid=this;
	this.hdrBox.grid=this;
	this.obj.grid=this;
	this.hdr.grid=this;
	
	/*PROPERTIES*/
	this.cellWidthPX=[];                      //current width in pixels
	this.cellWidthPC=[];                      //width in % if cellWidthType set in pc
	this.cellWidthType=this.entBox.cellwidthtype||"px"; //px or %

	this.delim=this.entBox.delimiter||",";
	this._csvDelim=",";

	this.hdrLabels=[];
	this.columnIds=[];
	this.columnColor=[];
	this._hrrar=[];
	this.cellType=dhtmlxArray();
	this.cellAlign=[];
	this.initCellWidth=[];
	this.fldSort=[];
	this._srdh=(_isIE && (document.compatMode != "BackCompat") ? 22 : 20);
	this.imgURL=window.dhx_globalImgPath||""; 
	this.isActive=false; //fl to indicate if grid is in work now
	this.isEditable=true;
	this.useImagesInHeader=false; //use images in header or not
	this.pagingOn=false;          //paging on/off
	this.rowsBufferOutSize=0;     //number of rows rendered at a moment
	/*EVENTS*/
	dhtmlxEvent(window, "unload", function(){
		try{
			if (self.destructor) self.destructor();
		}
		catch (e){}
	});

	/*XML LOADER(S)*/
	/**
	*   @desc: set one of predefined css styles (xp, mt, gray, light, clear, modern)
	*   @param: name - style name
	*   @type: public
	*   @topic: 0,6
	*/
	this.setSkin=function(name){
		this.skin_name=name;
		var classname = this.entBox.className.split(" gridbox")[0];
		this.entBox.className=classname + " gridbox gridbox_"+name;
		this.skin_h_correction=0;
		
//#alter_css:06042008{		
		this.enableAlterCss("ev_"+name, "odd_"+name, this.isTreeGrid())
		this._fixAlterCss()
//#}
		switch (name){
			case "clear":
				this._topMb=document.createElement("DIV");
				this._topMb.className="topMumba";
				this._topMb.innerHTML="<img style='left:0px'   src='"+this.imgURL
					+"skinC_top_left.gif'><img style='right:20px' src='"+this.imgURL+"skinC_top_right.gif'>";
				this.entBox.appendChild(this._topMb);
				this._botMb=document.createElement("DIV");
				this._botMb.className="bottomMumba";
				this._botMb.innerHTML="<img style='left:0px'   src='"+this.imgURL
					+"skinD_bottom_left.gif'><img style='right:20px' src='"+this.imgURL+"skinD_bottom_right.gif'>";
				this.entBox.appendChild(this._botMb);
				if (this.entBox.style.position != "absolute") 
					this.entBox.style.position="relative";
				this.skin_h_correction=20;
				break;

			case "dhx_terrace":
				this._srdh=40;
				this.forceDivInHeader=true;
				break;

			case "dhx_skyblue":
			case "dhx_web":
			case "glassy_blue":
			case "dhx_black":
			case "dhx_blue":
			case "modern":
			case "light":
				this._srdh=20;
				this.forceDivInHeader=true;
				break;
				
			case "xp":
				this.forceDivInHeader=true;
				if ((_isIE)&&(document.compatMode != "BackCompat"))
					this._srdh=26;
				else this._srdh=22;
				break;

			case "mt":
				if ((_isIE)&&(document.compatMode != "BackCompat"))
					this._srdh=26;
				else this._srdh=22;
				break;

			case "gray":
				if ((_isIE)&&(document.compatMode != "BackCompat"))
					this._srdh=22;
				break;
			case "sbdark":
				break;
		}

		if (_isIE&&this.hdr){
			var d = this.hdr.parentNode;
			d.removeChild(this.hdr);
			d.appendChild(this.hdr);
		}
		this.setSizes();
	}

	if (_isIE)
		this.preventIECaching(true);
	if (window.dhtmlDragAndDropObject)
		this.dragger=new dhtmlDragAndDropObject();

	/*METHODS. SERVICE*/
	/**
	*   @desc: on scroll grid inner actions
	*   @type: private
	*   @topic: 7
	*/
	this._doOnScroll=function(e, mode){
		this.callEvent("onScroll", [
			this.objBox.scrollLeft,
			this.objBox.scrollTop
		]);

		this.doOnScroll(e, mode);
	}
	/**
	*   @desc: on scroll grid more inner action
	*   @type: private
	*   @topic: 7
	*/
	this.doOnScroll=function(e, mode){
		this.hdrBox.scrollLeft=this.objBox.scrollLeft;
		if (this.ftr)
			this.ftr.parentNode.scrollLeft=this.objBox.scrollLeft;

		if (mode)
			return;

		if (this._srnd){
			if (this._dLoadTimer)
				window.clearTimeout(this._dLoadTimer);
			this._dLoadTimer=window.setTimeout(function(){
				if (self._update_srnd_view)
					self._update_srnd_view();
			}, 100);
		}
	}
	/**
	*   @desc: attach grid to some object in DOM
	*   @param: obj - object to attach to
	*   @type: public
	*   @topic: 0,7
	*/
	this.attachToObject=function(obj){
		obj.appendChild(this.globalBox?this.globalBox:this.entBox);
		//this.objBox.style.height=this.entBox.style.height;
		this.setSizes();
	}
	/**
	*   @desc: initialize grid
	*   @param: fl - if to parse on page xml data island 
	*   @type: public
	*   @topic: 0,7
	*/
	this.init=function(fl){
		if ((this.isTreeGrid())&&(!this._h2)){
			this._h2=new dhtmlxHierarchy();

			if ((this._fake)&&(!this._realfake))
				this._fake._h2=this._h2;
			this._tgc={
				imgURL: null
				};
		}

		if (!this._hstyles)
			return;

		this.editStop()
		/*TEMPORARY STATES*/
		this.lastClicked=null;                //row clicked without shift key. used in multiselect only
		this.resized=null;                    //hdr cell that is resized now
		this.fldSorted=this.r_fldSorted=null; //hdr cell last sorted
		//empty grid if it already was initialized
		this.cellWidthPX=[];
		this.cellWidthPC=[];

		if (this.hdr.rows.length > 0){
			var temp = this.xmlFileUrl;
			this.clearAll(true);
			this.xmlFileUrl = temp;
		}

		var hdrRow = this.hdr.insertRow(0);

		for (var i = 0; i < this.hdrLabels.length; i++){
			hdrRow.appendChild(document.createElement("TH"));
			hdrRow.childNodes[i]._cellIndex=i;
			hdrRow.childNodes[i].style.height="0px";
		}

		if (_isIE && _isIE<8 && document.body.style.msTouchAction == this.undefined)
			hdrRow.style.position="absolute";
		else
			hdrRow.style.height='auto';

		var hdrRow = this.hdr.insertRow(_isKHTML ? 2 : 1);

		hdrRow._childIndexes=new Array();
		var col_ex = 0;

		for (var i = 0; i < this.hdrLabels.length; i++){
			hdrRow._childIndexes[i]=i-col_ex;

			if ((this.hdrLabels[i] == this.splitSign)&&(i != 0)){
				if (_isKHTML)
					hdrRow.insertCell(i-col_ex);
				hdrRow.cells[i-col_ex-1].colSpan=(hdrRow.cells[i-col_ex-1].colSpan||1)+1;
				hdrRow.childNodes[i-col_ex-1]._cellIndex++;
				col_ex++;
				hdrRow._childIndexes[i]=i-col_ex;
				continue;
			}

			hdrRow.insertCell(i-col_ex);

			hdrRow.childNodes[i-col_ex]._cellIndex=i;
			hdrRow.childNodes[i-col_ex]._cellIndexS=i;
			this.setColumnLabel(i, this.hdrLabels[i]);
		}

		if (col_ex == 0)
			hdrRow._childIndexes=null;
		this._cCount=this.hdrLabels.length;

		if (_isIE)
			window.setTimeout(function(){
				if (self.setSizes)
					self.setSizes();
			}, 1);

		//create virtual top row
		if (!this.obj.firstChild)
			this.obj.appendChild(document.createElement("TBODY"));

		var tar = this.obj.firstChild;

		if (!tar.firstChild){
			tar.appendChild(document.createElement("TR"));
			tar=tar.firstChild;

			if (_isIE && _isIE<8 && document.body.style.msTouchAction == this.undefined)
				tar.style.position="absolute";
			else
				tar.style.height='auto';

			for (var i = 0; i < this.hdrLabels.length; i++){
				tar.appendChild(document.createElement("TH"));
				tar.childNodes[i].style.height="0px";
			}
		}

		this._c_order=null;

		if (this.multiLine != true)
			this.obj.className+=" row20px";

		//
		//this.combos = new Array(this.hdrLabels.length);
		//set sort image to initial state
		this.sortImg.style.position="absolute";
		this.sortImg.style.display="none";
		this.sortImg.src=this.imgURL+"sort_desc.gif";
		this.sortImg.defLeft=0;

		if (this.noHeader){
			this.hdrBox.style.display='none';
		}
		else {
			this.noHeader=false
		}
//#__pro_feature:21092006{
//#column_hidden:21092006{
		if (this._ivizcol)
			this.setColHidden();
//#}
//#}
//#header_footer:06042008{		
		this.attachHeader();
		this.attachHeader(0, 0, "_aFoot");
//#}
		this.setSizes();

		if (fl)
			this.parseXML()
		this.obj.scrollTop=0

		if (this.dragAndDropOff)
			this.dragger.addDragLanding(this.entBox, this);

		if (this._initDrF)
			this._initD();

		if (this._init_point)
			this._init_point();
	};
	
	this.setColumnSizes=function(gridWidth){
		var summ = 0;
		var fcols = []; //auto-size columns

		var fix = 0;
		for (var i = 0; i < this._cCount; i++){
			if ((this.initCellWidth[i] == "*") && !this._hrrar[i]){
				this._awdth=false; //disable auto-width
				fcols.push(i);
				continue;
			}

			if (this.cellWidthType == '%'){
				if (typeof this.cellWidthPC[i]=="undefined")
					this.cellWidthPC[i]=this.initCellWidth[i];
				var cwidth = (gridWidth*this.cellWidthPC[i]/100)||0;
				if (fix>0.5){
					cwidth++;
					fix--;
				}
				var rwidth = this.cellWidthPX[i]=Math.floor(cwidth);
				var fix =fix + cwidth - rwidth;
			} else{
				if (typeof this.cellWidthPX[i]=="undefined")
					this.cellWidthPX[i]=this.initCellWidth[i];
			}
			if (!this._hrrar[i])
				summ+=this.cellWidthPX[i]*1;
		}

		//auto-size columns
		if (fcols.length){
			var ms = Math.floor((gridWidth-summ)/fcols.length);
			if (ms < 0) ms=1;

			for (var i = 0; i < fcols.length; i++){
				var next=Math.max((this._drsclmW ? (this._drsclmW[fcols[i]]||0) : 0),ms)
				this.cellWidthPX[fcols[i]]=next;
				summ+=next;
			}
			
			if(gridWidth > summ){
				var last=fcols[fcols.length-1];
    			this.cellWidthPX[last]=this.cellWidthPX[last] + (gridWidth-summ);
				summ = gridWidth;
			}
			
			this._setAutoResize();
		}
		
		
		this.obj.style.width=summ+"px";
		this.hdr.style.width=summ+"px";
		if (this.ftr) this.ftr.style.width=summ+"px";

		this.chngCellWidth();
		return summ;
	}
	
	/**shz)_
	*   @desc: sets sizes of grid elements
	*   @type: private
	*   @topic: 0,7
	*/
	this.setSizes=function(){
		//drop processing if grid still not initialized 
		if ((!this.hdr.rows[0])) return;

		var quirks=this.quirks = (_isIE && document.compatMode=="BackCompat");
		var outerBorder=(this.entBox.offsetWidth-this.entBox.clientWidth)/2;		
		
		if (!this.dontSetSizes){
			if (this.globalBox){
				var splitOuterBorder=(this.globalBox.offsetWidth-this.globalBox.clientWidth)/2;		
				if (this._delta_x && !this._realfake){
					var ow = this.globalBox.clientWidth;
					this.globalBox.style.width=this._delta_x;
					this.entBox.style.width=Math.max(0,(this.globalBox.clientWidth+(quirks?splitOuterBorder*2:0))-this._fake.entBox.clientWidth)+"px";
					if (ow != this.globalBox.clientWidth){
						this._fake._correctSplit(this._fake.entBox.clientWidth);
					}
				}
				if (this._delta_y && !this._realfake){
					this.globalBox.style.height = this._delta_y;
					this.entBox.style.overflow = this._fake.entBox.style.overflow="hidden";
					this.entBox.style.height = this._fake.entBox.style.height=this.globalBox.clientHeight+(quirks?splitOuterBorder*2:0)+"px";
				}
			} else {
				if (this._delta_x){
					/*when placed directly in TD tag, container can't use native percent based sizes, 
						because table auto-adjust to show all content - too clever*/
					if (this.entBox.parentNode && this.entBox.parentNode.tagName=="TD"){
						this.entBox.style.width="1px";
						this.entBox.style.width=parseInt(this._delta_x)*this.entBox.parentNode.clientWidth/100-outerBorder*2+"px";
					}else
						this.entBox.style.width=this._delta_x;
				}
				if (this._delta_y)
					this.entBox.style.height=this._delta_y;
			}
		}
			
		//if we have container without sizes, wait untill sizes defined
		window.clearTimeout(this._sizeTime);		
		if (!this.entBox.offsetWidth && (!this.globalBox || !this.globalBox.offsetWidth)){
			this._sizeTime=window.setTimeout(function(){
				if (self.setSizes)
					self.setSizes();
			}, 250);
			return;
		}		
		
		var border_x = ((!this._wthB) && ((this.entBox.cmp||this._delta_x) && (this.skin_name||"").indexOf("dhx")==0 && !quirks)?2:0);
		var border_y = ((!this._wthB) && ((this.entBox.cmp||this._delta_y) && (this.skin_name||"").indexOf("dhx")==0 && !quirks)?2:0);

		if (this._sizeFix){
			border_x -= this._sizeFix;
			border_y -= this._sizeFix;
		}
		
		var isVScroll = this.parentGrid?false:(this.objBox.scrollHeight > this.objBox.offsetHeight);
		
		var scrfix = dhtmlx.$customScroll?0:18;
		
		var gridWidth=this.entBox.clientWidth-(this.skin_h_correction||0)*(quirks?0:1)-border_x;
		var gridWidthActive=this.entBox.clientWidth-(this.skin_h_correction||0)-border_x;
		var gridHeight=this.entBox.clientHeight-border_y;
		var summ=this.setColumnSizes(gridWidthActive-(isVScroll?scrfix:0)-(this._correction_x||0));
		
		var isHScroll = this.parentGrid?false:((this.objBox.scrollWidth > this.objBox.offsetWidth)||(this.objBox.style.overflowX=="scroll")); 
		var headerHeight = this.hdr.clientHeight;
		var footerHeight = this.ftr?this.ftr.clientHeight:0;
		var newWidth=gridWidth;
		var newHeight=gridHeight-headerHeight-footerHeight;

		//if we have auto-width without limitations - ignore h-scroll
		if (this._awdth && this._awdth[0] && this._awdth[1]==99999) isHScroll=0;
		//auto-height
		if (this._ahgr){
			if (this._ahgrMA)
				newHeight=this.entBox.parentNode.clientHeight-headerHeight-footerHeight;
			else
				newHeight=this.obj.offsetHeight+(isHScroll?scrfix:0)+(this._correction_y||0);

			if (this._ahgrM){
				if (this._ahgrF) 
					newHeight=Math.min(this._ahgrM,newHeight+headerHeight+footerHeight)-headerHeight-footerHeight;
				else 
					newHeight=Math.min(this._ahgrM,newHeight);
				
			}
			if (isVScroll && newHeight>=this.obj.scrollHeight+(isHScroll?scrfix:0)){
				isVScroll=false;//scroll will be compensated;
				this.setColumnSizes(gridWidthActive-(this._correction_x||0)); //correct auto-size columns
			}
		}

		//auto-width
		if ((this._awdth)&&(this._awdth[0])){ 
			//convert percents to PX, because auto-width with procents has no sense
			if (this.cellWidthType == '%') this.cellWidthType="px";
			
			if (this._fake) summ+=this._fake.entBox.clientWidth;	//include fake grid in math
			var newWidth=Math.min(Math.max(summ+(isVScroll?scrfix:0),this._awdth[2]),this._awdth[1])+(this._correction_x||0);
			if (this._fake) newWidth-=this._fake.entBox.clientWidth;
		}

		newHeight=Math.max(0,newHeight);//validate value for IE
		
		//FF3.1, bug in table rendering engine
		this._ff_size_delta=(this._ff_size_delta==0.1)?0.2:0.1;
		if (!_isFF) this._ff_size_delta=0;
		
		if (!this.dontSetSizes){
			this.entBox.style.width=Math.max(0,newWidth+(quirks?2:0)*outerBorder+this._ff_size_delta)+"px";
			this.entBox.style.height=newHeight+(quirks?2:0)*outerBorder+headerHeight+footerHeight+"px";
		}
		this.objBox.style.height=newHeight+((quirks&&!isVScroll)?2:0)*outerBorder+"px";//):this.entBox.style.height);
		this.hdrBox.style.height=headerHeight+"px";		
		
		
		if (newHeight != gridHeight)
			this.doOnScroll(0, !this._srnd);
		var ext=this["setSizes_"+this.skin_name];
		if (ext) ext.call(this);
			
		this.setSortImgPos();	
		
		//it possible that changes of size, has changed header height 
		if (headerHeight != this.hdr.clientHeight && this._ahgr) 	
			this.setSizes();
		this.callEvent("onSetSizes",[]);
	};
	this.setSizes_clear=function(){
		var y=this.hdr.offsetHeight;
		var x=this.entBox.offsetWidth;
		var y2=y+this.objBox.offsetHeight;
			this._topMb.style.top=(y||0)+"px";
			this._topMb.style.width=(x+20)+"px";
			this._botMb.style.top=(y2-3)+"px";
			this._botMb.style.width=(x+20)+"px";
	};
	/**
	*   @desc: changes cell width
	*   @param: [ind] - index of row in grid
	*   @type: private
	*   @topic: 4,7
	*/
	this.chngCellWidth=function(){
		if ((_isOpera)&&(this.ftr))
			this.ftr.width=this.objBox.scrollWidth+"px";
		var l = this._cCount;

		for (var i = 0; i < l; i++){
			this.hdr.rows[0].cells[i].style.width=this.cellWidthPX[i]+"px";
			this.obj.rows[0].childNodes[i].style.width=this.cellWidthPX[i]+"px";
			
			if (this.ftr)
				this.ftr.rows[0].cells[i].style.width=this.cellWidthPX[i]+"px";
		}
	}
	/**
	*   @desc: set delimiter character used in list values (default is ",")
	*   @param: delim - delimiter as string
	*   @before_init: 1
	*   @type: public
	*   @topic: 0
	*/
	this.setDelimiter=function(delim){
		this.delim=delim;
	}
	/**
	*   @desc: set width of columns in percents
	*   @type: public
	*   @before_init: 1
	*   @param: wp - list of column width in percents
	*   @topic: 0,7
	*/
	this.setInitWidthsP=function(wp){
		this.cellWidthType="%";
		this.initCellWidth=wp.split(this.delim.replace(/px/gi, ""));
		if (!arguments[1]) this._setAutoResize();
	}
	/**
	*	@desc:
	*	@type: private
	*	@topic: 0
	*/
	this._setAutoResize=function(){
		if (this._realfake) return;
		var el = window;
		var self = this;
		
		dhtmlxEvent(window,"resize",function(){
			window.clearTimeout(self._resize_timer);
			if (self._setAutoResize)
				self._resize_timer=window.setTimeout(function(){
					if (self.setSizes)
						self.setSizes();
					if (self._fake)
						self._fake._correctSplit();
				}, 100);
		})
	}


	/**
	*   @desc: set width of columns in pixels
	*   @type: public
	*   @before_init: 1
	*   @param: wp - list of column width in pixels
	*   @topic: 0,7
	*/
	this.setInitWidths=function(wp){
		this.cellWidthType="px";
		this.initCellWidth=wp.split(this.delim);

		if (_isFF){
			for (var i = 0; i < this.initCellWidth.length; i++)
				if (this.initCellWidth[i] != "*")
					this.initCellWidth[i]=parseInt(this.initCellWidth[i]);
		}
	}

	/**
	*   @desc: set multiline rows support to enabled or disabled state
	*   @type: public
	*   @before_init: 1
	*   @param: state - true or false
	*   @topic: 0,7
	*/
	this.enableMultiline=function(state){
		this.multiLine=convertStringToBoolean(state);
	}

	/**
	*   @desc: set multiselect mode to enabled or disabled state
	*   @type: public
	*   @param: state - true or false
	*   @topic: 0,7
	*/
	this.enableMultiselect=function(state){
		this.selMultiRows=convertStringToBoolean(state);
	}

	/**
	*   @desc: set path to grid internal images (sort direction, any images used in editors, checkbox, radiobutton)
	*   @type: public
	*   @param: path - url (or relative path) of images folder with closing "/"
	*   @topic: 0,7
	*/
	this.setImagePath=function(path){
		this.imgURL=path;
	}
	this.setImagesPath=this.setImagePath;
	/**
	*   @desc: set path to external images used in grid ( tree and img column types )
	*   @type: public
	*   @param: path - url (or relative path) of images folder with closing "/"
	*   @topic: 0,7
	*/
	this.setIconPath=function(path){
		this.iconURL=path;
	}	
	this.setIconsPath=this.setIconPath;
//#column_resize:06042008{
	/**
	*   @desc: part of column resize routine
	*   @type: private
	*   @param: ev - event
	*   @topic: 3
	*/
	this.changeCursorState=function(ev){
		var el = ev.target||ev.srcElement;

		if (el.tagName != "TD")
			el=this.getFirstParentOfType(el, "TD")
		if (!el) return;
		if ((el.tagName == "TD")&&(this._drsclmn)&&(!this._drsclmn[el._cellIndex]))
			return el.style.cursor="default";
		var check = (ev.layerX||0)+(((!_isIE)&&(ev.target.tagName == "DIV")) ? el.offsetLeft : 0);
		if ((el.offsetWidth-(ev.offsetX||(parseInt(this.getPosition(el, this.hdrBox))-check)*-1)) < (_isOpera?20:10)){
			el.style.cursor="E-resize";
		}
		else{
		    el.style.cursor="default";
		}

		if (_isOpera)
			this.hdrBox.scrollLeft=this.objBox.scrollLeft;
	}
	/**
	*   @desc: part of column resize routine
	*   @type: private
	*   @param: ev - event
	*   @topic: 3
	*/
	this.startColResize=function(ev){
		if (this.resized) this.stopColResize();
		this.resized=null;
		var el = ev.target||ev.srcElement;
		if (el.tagName != "TD")
			el=this.getFirstParentOfType(el, "TD")
		var x = ev.clientX;
		var tabW = this.hdr.offsetWidth;
		var startW = parseInt(el.offsetWidth)

		if (el.tagName == "TD"&&el.style.cursor != "default"){
			if ((this._drsclmn)&&(!this._drsclmn[el._cellIndex]))
				return;
				
			self._old_d_mm=document.body.onmousemove;
			self._old_d_mu=document.body.onmouseup;
			document.body.onmousemove=function(e){
				if (self)
					self.doColResize(e||window.event, el, startW, x, tabW)
			}
			document.body.onmouseup=function(){
				if (self)
					self.stopColResize();
			}
		}
	}
	/**
	*   @desc: part of column resize routine
	*   @type: private
	*   @param: ev - event
	*   @topic: 3
	*/
	this.stopColResize=function(){ 
		document.body.onmousemove=self._old_d_mm||"";
		document.body.onmouseup=self._old_d_mu||"";
		this.setSizes();
		this.doOnScroll(0, 1)
		this.callEvent("onResizeEnd", [this]);
	}
	/**
	*   @desc: part of column resize routine
	*   @param: el - element (column resizing)
	*   @param: startW - started width
	*   @param: x - x coordinate to resize from
	*   @param: tabW - started width of header table
	*   @type: private
	*   @topic: 3
	*/
	this.doColResize=function(ev, el, startW, x, tabW){
		el.style.cursor="E-resize";
		this.resized=el;
		var fcolW = startW+(ev.clientX-x);
		var wtabW = tabW+(ev.clientX-x)

		if (!(this.callEvent("onResize", [
			el._cellIndex,
			fcolW,
			this
		])))
			return;

		if (_isIE)
			this.objBox.scrollLeft=this.hdrBox.scrollLeft;

		if (el.colSpan > 1){
			var a_sizes = new Array();

			for (var i = 0;
				i < el.colSpan;
				i++)a_sizes[i]=Math.round(fcolW*this.hdr.rows[0].childNodes[el._cellIndexS+i].offsetWidth/el.offsetWidth);

			for (var i = 0; i < el.colSpan; i++)
				this._setColumnSizeR(el._cellIndexS+i*1, a_sizes[i]);
		} else
			this._setColumnSizeR(el._cellIndex, fcolW);
		this.doOnScroll(0, 1);

        this.setSizes();
        if (this._fake && this._awdth) this._fake._correctSplit();
	}

	/**
	*   @desc: set width of grid columns ( zero row of header and body )
	*   @type: private
	*   @topic: 7
	*/
	this._setColumnSizeR=function(ind, fcolW){
		if (fcolW > ((this._drsclmW&&!this._notresize) ? (this._drsclmW[ind]||10) : 10)){
			this.obj.rows[0].childNodes[ind].style.width=fcolW+"px";
			this.hdr.rows[0].childNodes[ind].style.width=fcolW+"px";

			if (this.ftr)
				this.ftr.rows[0].childNodes[ind].style.width=fcolW+"px";

			if (this.cellWidthType == 'px'){
				this.cellWidthPX[ind]=fcolW;
			}
			else {
				var gridWidth = parseInt(this.entBox.offsetWidth);

				if (this.objBox.scrollHeight > this.objBox.offsetHeight)
					gridWidth-=17;
				var pcWidth = Math.round(fcolW / gridWidth*100)
				this.cellWidthPC[ind]=pcWidth;
			}
			if (this.sortImg.style.display!="none")
				this.setSortImgPos();
		}
	}
//#}
//#sorting:06042008{
	/**
	*    @desc: sets position and visibility of sort arrow
	*    @param: state - true/false - show/hide image
	*    @param: ind - index of field
	*    @param: order - asc/desc - type of image
	*    @param: row - one based index of header row ( used in multirow headers, top row by default )
	*   @type: public
	*   @topic: 7
	*/
	this.setSortImgState=function(state, ind, order, row){
		order=(order||"asc").toLowerCase();

		if (!convertStringToBoolean(state)){
			this.sortImg.style.display="none";
			this.fldSorted=this.r_fldSorted = null;
			return;
		}

		if (order == "asc")
			this.sortImg.src=this.imgURL+"sort_asc.gif";
		else
			this.sortImg.src=this.imgURL+"sort_desc.gif";

		this.sortImg.style.display="";
		this.fldSorted=this.hdr.rows[0].childNodes[ind];
		var r = this.hdr.rows[row||1];
		if (!r) return;

		for (var i = 0; i < r.childNodes.length; i++){
			if (r.childNodes[i]._cellIndexS == ind){
				this.r_fldSorted=r.childNodes[i];
				return  this.setSortImgPos();
			}
		}
		return this.setSortImgState(state,ind,order,(row||1)+1);
	}

	/**
	*    @desc: sets position and visibility of sort arrow
	*    @param: ind - index of field
	*    @param: ind - index of field
	*    @param: hRowInd - index of row in case of complex header, one-based, optional

	*   @type: private
	*   @topic: 7
	*/
	this.setSortImgPos=function(ind, mode, hRowInd, el){
		if (this._hrrar && this._hrrar[this.r_fldSorted?this.r_fldSorted._cellIndex:ind]) return;
		if (!el){
			if (!ind)
				var el = this.r_fldSorted;
			else
				var el = this.hdr.rows[hRowInd||0].cells[ind];
		}

		if (el != null){
			var pos = this.getPosition(el, this.hdrBox)
			var wdth = el.offsetWidth;
			this.sortImg.style.left=Number(pos[0]+wdth-13)+"px"; //Number(pos[0]+5)+"px";
			this.sortImg.defLeft=parseInt(this.sortImg.style.left)
			this.sortImg.style.top=Number(pos[1]+5)+"px";

			if ((!this.useImagesInHeader)&&(!mode))
				this.sortImg.style.display="inline";
			this.sortImg.style.left=this.sortImg.defLeft+"px"; //-parseInt(this.hdrBox.scrollLeft)
		}
	}
//#}
	/**
	*   @desc: manage activity of the grid.
	*   @param: fl - true to activate,false to deactivate
	*   @type: private
	*   @topic: 1,7
	*/
	this.setActive=function(fl){
		if (arguments.length == 0)
			var fl = true;

		if (fl == true){
			//document.body.onkeydown = new Function("","document.getElementById('"+this.entBox.id+"').grid.doKey()")//
			if (globalActiveDHTMLGridObject&&(globalActiveDHTMLGridObject != this)){
				globalActiveDHTMLGridObject.editStop();
				globalActiveDHTMLGridObject.callEvent("onBlur",[globalActiveDHTMLGridObject]);
			}

			globalActiveDHTMLGridObject=this;
			this.isActive=true;
		} else {
			this.isActive=false;
			this.callEvent("onBlur",[this]);
		}
	};
	/**
	*     @desc: called on click occured
	*     @type: private
	*/
	this._doClick=function(ev){
		var selMethod = 0;
		var el = this.getFirstParentOfType(_isIE ? ev.srcElement : ev.target, "TD");
		if (!el) return;
		var fl = true;

		//mm
		//markers start
		if (this.markedCells){
			var markMethod = 0;

			if (ev.shiftKey||ev.metaKey){
				markMethod=1;
			}

			if (ev.ctrlKey){
				markMethod=2;
			}
			this.doMark(el, markMethod);
			return true;
		}
		//markers end
		//mm

		if (this.selMultiRows != false){
			if (ev.shiftKey && this.row != null && this.selectedRows.length){
				selMethod=1;
			}

			if (ev.ctrlKey||ev.metaKey){
				selMethod=2;
			}
		}
		this.doClick(el, fl, selMethod)
	};

//#context_menu:06042008{
	/**
	*   @desc: called onmousedown inside grid area
	*   @type: private
	*/
	this._doContClick=function(ev){ 
		var el = this.getFirstParentOfType(_isIE ? ev.srcElement : ev.target, "TD");

		if ((!el)||( typeof (el.parentNode.idd) == "undefined")){
			this.callEvent("onEmptyClick", [ev]);
			return true;
		}

		if (ev.button == 2||(_isMacOS&&ev.ctrlKey)){
			if (!this.callEvent("onRightClick", [
				el.parentNode.idd,
				el._cellIndex,
				ev
			])){
				var z = function(e){
					(e||event).cancelBubble=true;
					return false;
				};

				(ev.srcElement||ev.target).oncontextmenu=z;
				return z(ev);
			}

			if (this._ctmndx){
				if (!(this.callEvent("onBeforeContextMenu", [
					el.parentNode.idd,
					el._cellIndex,
					this
				])))
					return true;
					
				if (_isIE)
					ev.srcElement.oncontextmenu=function(){
						event.cancelBubble=true;
						return false;
					};
					
				if (this._ctmndx.showContextMenu){
					
var dEl0=window.document.documentElement;
var dEl1=window.document.body;
var corrector = new Array((dEl0.scrollLeft||dEl1.scrollLeft),(dEl0.scrollTop||dEl1.scrollTop));
if (_isIE){
	var x= ev.clientX+corrector[0];
	var y = ev.clientY+corrector[1];
} else {
	var x= ev.pageX;
	var y = ev.pageY;
}
					this._ctmndx.showContextMenu(x-1,y-1)
					this.contextID=this._ctmndx.contextMenuZoneId=el.parentNode.idd+"_"+el._cellIndex;
					this._ctmndx._skip_hide=true;
				} else {
					el.contextMenuId=el.parentNode.idd+"_"+el._cellIndex;
					el.contextMenu=this._ctmndx;
					el.a=this._ctmndx._contextStart;
					el.a(el, ev);
					el.a=null;
				}
				ev.cancelBubble=true;
				return false;
			}
		}

		else if (this._ctmndx){
			if (this._ctmndx.hideContextMenu)
				this._ctmndx.hideContextMenu()
			else
				this._ctmndx._contextEnd();
		}
		return true;
	}
//#}
	/**
	*    @desc: occures on cell click (supports treegrid)
	*   @param: [el] - cell to click on
	*   @param:   [fl] - true if to call onRowSelect function
	*   @param: [selMethod] - 0 - simple click, 1 - shift, 2 - ctrl
	*   @param: show - true/false - scroll row to view, true by defaul    
	*   @type: private
	*   @topic: 1,2,4,9
	*/
	this.doClick=function(el, fl, selMethod, show){
		if (!this.selMultiRows) selMethod=0; //block programmatical multiselecton if mode not enabled explitly
		var psid = this.row ? this.row.idd : 0;

		this.setActive(true);

		if (!selMethod)
			selMethod=0;

		if (this.cell != null)
			this.cell.className=this.cell.className.replace(/cellselected/g, "");

		if (el.tagName == "TD"){
			if (this.checkEvent("onSelectStateChanged"))
				var initial = this.getSelectedId();
			var prow = this.row;
		if (selMethod == 1){
				var elRowIndex = this.rowsCol._dhx_find(el.parentNode)
				var lcRowIndex = this.rowsCol._dhx_find(this.lastClicked)

				if (elRowIndex > lcRowIndex){
					var strt = lcRowIndex;
					var end = elRowIndex;
				} else {
					var strt = elRowIndex;
					var end = lcRowIndex;
				}

				for (var i = 0; i < this.rowsCol.length; i++)
					if ((i >= strt&&i <= end)){
						if (this.rowsCol[i]&&(!this.rowsCol[i]._sRow)){
							if (this.rowsCol[i].className.indexOf("rowselected")
								== -1&&this.callEvent("onBeforeSelect", [
								this.rowsCol[i].idd,
								psid
							])){
								this.rowsCol[i].className+=" rowselected";
								this.selectedRows[this.selectedRows.length]=this.rowsCol[i]
							}
						} else {
							this.clearSelection();
							return this.doClick(el, fl, 0, show);
						}
					}
			} else if (selMethod == 2){
				if (el.parentNode.className.indexOf("rowselected") != -1){
					el.parentNode.className=el.parentNode.className.replace(/rowselected/g, "");
					this.selectedRows._dhx_removeAt(this.selectedRows._dhx_find(el.parentNode))
					var skipRowSelection = true;
					show = false;
				}
			}
			this.editStop()
			if (typeof (el.parentNode.idd) == "undefined")
				return true;

			if ((!skipRowSelection)&&(!el.parentNode._sRow)){
				if (this.callEvent("onBeforeSelect", [
					el.parentNode.idd,
					psid
				])){
					if (this.getSelectedRowId() != el.parentNode.idd){
						if (selMethod == 0)
							this.clearSelection();
						this.cell=el;
						if ((prow == el.parentNode)&&(this._chRRS))
							fl=false;
						this.row=el.parentNode;
						this.row.className+=" rowselected"
						
						if (this.selectedRows._dhx_find(this.row) == -1)
							this.selectedRows[this.selectedRows.length]=this.row;
					} else {
						this.cell=el;
						this.row = el.parentNode;
					}
				} else fl = false;
			} 

			if (this.cell && this.cell.parentNode.className.indexOf("rowselected") != -1)
				this.cell.className=this.cell.className.replace(/cellselected/g, "")+" cellselected";
			
			if (selMethod != 1)
				if (!this.row)
					return;
			this.lastClicked=el.parentNode;

			var rid = this.row.idd;
			var cid = this.cell;

			if (fl&& typeof (rid) != "undefined" && cid && !skipRowSelection) {
				self.onRowSelectTime=setTimeout(function(){
					if (self.callEvent)
						self.callEvent("onRowSelect", [
							rid,
							cid._cellIndex
						]);
				}, 100);
			} else this.callEvent("onRowSelectRSOnly",[rid]);

			if (this.checkEvent("onSelectStateChanged")){
				var afinal = this.getSelectedId();

				if (initial != afinal)
					this.callEvent("onSelectStateChanged", [afinal,initial]);
			}
		}
		this.isActive=true;
		if (show !== false && this.cell && this.cell.parentNode.idd)
			this.moveToVisible(this.cell)
	}

	/**
	*   @desc: select all rows in grid, it doesn't fire any events
	*   @param: edit - switch selected cell to edit mode
	*   @type: public
	*   @topic: 1,4
	*/
	this.selectAll=function(){
		this.clearSelection();

		var coll = this.rowsBuffer;
		//in paging mode, we select only current page
		if (this.pagingOn) coll = this.rowsCol;
		for (var i = 0; i<coll.length; i ++){
			this.render_row(i).className+=" rowselected";
		}
		
		this.selectedRows=dhtmlxArray([].concat(coll));
		
		if (this.selectedRows.length){
			this.row  = this.selectedRows[0];
			this.cell = this.row.cells[0];
		}

		if ((this._fake)&&(!this._realfake))
			this._fake.selectAll();
	}
	/**
	*   @desc: set selection to specified row-cell
	*   @param: r - row object or row index
	*   @param: cInd - cell index
	*   @param: [fl] - true if to call onRowSelect function
	  *   @param: preserve - preserve previously selected rows true/false (false by default)
	  *   @param: edit - switch selected cell to edit mode
	*   @param: show - true/false - scroll row to view, true by defaul         
	*   @type: public
	*   @topic: 1,4
	*/
	this.selectCell=function(r, cInd, fl, preserve, edit, show){
		if (!fl)
			fl=false;

		if (typeof (r) != "object")
			r=this.render_row(r)
		if (!r || r==-1) return null;
//#__pro_feature:21092006{
//#colspan:20092006{
		if (r._childIndexes)
			var c = r.childNodes[r._childIndexes[cInd]];
		else
//#}
//#}
			var c = r.childNodes[cInd];

		if (!c)
			c=r.childNodes[0];
        if(!this.markedCells){
			if (preserve)
				this.doClick(c, fl, 3, show)
			else
				this.doClick(c, fl, 0, show)
		}
		else 
			this.doMark(c,preserve?2:0);

		if (edit)
			this.editCell();
	}
	/**
	*   @desc: moves specified cell to visible area (scrolls)
	*   @param: cell_obj - object of the cell to work with
	*   @param: onlyVScroll - allow only vertical positioning

	*   @type: private
	*   @topic: 2,4,7
	*/
	this.moveToVisible=function(cell_obj, onlyVScroll){
		if (this.pagingOn){
			var newPage=Math.floor(this.getRowIndex(cell_obj.parentNode.idd) / this.rowsBufferOutSize)+1;
			if (newPage!=this.currentPage)
			this.changePage(newPage);
		}

		try{
			if (cell_obj.offsetHeight){
				var distance = cell_obj.offsetLeft+cell_obj.offsetWidth+20;
	
				var scrollLeft = 0;
	
				if (distance > (this.objBox.offsetWidth+this.objBox.scrollLeft)){
					if (cell_obj.offsetLeft > this.objBox.scrollLeft)
						scrollLeft=cell_obj.offsetLeft-5
				} else if (cell_obj.offsetLeft < this.objBox.scrollLeft){
					distance-=cell_obj.offsetWidth*2/3;
					if (distance < this.objBox.scrollLeft)
						scrollLeft=cell_obj.offsetLeft-5
				}
	
				if ((scrollLeft)&&(!onlyVScroll))
					this.objBox.scrollLeft=scrollLeft;
			}

			
			if (!cell_obj.offsetHeight){
				var mask=this._realfake?this._fake.rowsAr[cell_obj.parentNode.idd]:cell_obj.parentNode;
				distance = this.rowsBuffer._dhx_find(mask)*this._srdh;
			}
			else
				distance = cell_obj.offsetTop;
			var distancemax = distance + cell_obj.offsetHeight+38;

			if (distancemax > (this.objBox.offsetHeight+this.objBox.scrollTop)){
				var scrollTop = distance;
			} else if (distance < this.objBox.scrollTop){
				var scrollTop = distance-5
			}

			if (scrollTop)
				this.objBox.scrollTop=scrollTop;
		}
		catch (er){}
	}
	/**
	*   @desc: creates Editor object and switch cell to edit mode if allowed
	*   @type: public
	*   @topic: 4
	*/
	this.editCell = function(){
		if (this.editor&&this.cell == this.editor.cell)
			return; //prevent reinit for same cell

		this.editStop();

		if ((this.isEditable != true)||(!this.cell))
			return false;
		var c = this.cell;

//#locked_row:11052006{
		if (c.parentNode._locked)
			return false;
//#}

		this.editor=this.cells4(c);

		//initialize editor
		if (this.editor != null){
			if (this.editor.isDisabled()){
				this.editor=null;
				return false;
			}

			if (this.callEvent("onEditCell", [
				0,
				this.row.idd,
				this.cell._cellIndex
			]) != false&&this.editor.edit){
				this._Opera_stop=(new Date).valueOf();
				c.className+=" editable";
				this.editor.edit();
				this.callEvent("onEditCell", [
					1,
					this.row.idd,
					this.cell._cellIndex
				])
			} else { //preserve editing
				this.editor=null;
			}
		}
	}
	/**
	*   @desc: retuns value from editor(if presents) to cell and closes editor
	*   @mode: if true - current edit value will be reverted to previous one
	*   @type: public
	*   @topic: 4
	*/
	this.editStop=function(mode){
		if (_isOpera)
			if (this._Opera_stop){
				if ((this._Opera_stop*1+50) > (new Date).valueOf())
					return;

				this._Opera_stop=null;
			}

		if (this.editor&&this.editor != null){
			this.editor.cell.className=this.editor.cell.className.replace("editable", "");

			if (mode){
				var t = this.editor.val;
				this.editor.detach();
				this.editor.setValue(t);
				this.editor=null;
				
				this.callEvent("onEditCancel", [
					this.row.idd,
					this.cell._cellIndex,
					t
				]);
				return;
			}

			if (this.editor.detach())
				this.cell.wasChanged=true;

			var g = this.editor;
			this.editor=null;
			var z = this.callEvent("onEditCell", [
				2,
				this.row.idd,
				this.cell._cellIndex,
				g.getValue(),
				g.val
			]);

			if (( typeof (z) == "string")||( typeof (z) == "number"))
				g[g.setImage ? "setLabel" : "setValue"](z);

			else if (!z)
				g[g.setImage ? "setLabel" : "setValue"](g.val);
		
			if (this._ahgr && this.multiLine) this.setSizes();
		}
	}
	/**
	*	@desc: 
	*	@type: private
	*/
	this._nextRowCell=function(row, dir, pos){
		row=this._nextRow((this._groups?this.rowsCol:this.rowsBuffer)._dhx_find(row), dir);

		if (!row)
			return null;

		return row.childNodes[row._childIndexes ? row._childIndexes[pos] : pos];
	}
	/**
	*	@desc: 
	*	@type: private
	*/
	this._getNextCell=function(acell, dir, i){

		acell=acell||this.cell;

		var arow = acell.parentNode;

		if (this._tabOrder){
			i=this._tabOrder[acell._cellIndex];

			if (typeof i != "undefined")
				if (i < 0)
					acell=this._nextRowCell(arow, dir, Math.abs(i)-1);
				else
					acell=arow.childNodes[i];
		} else {
			var i = acell._cellIndex+dir;

			if (i >= 0&&i < this._cCount){
				if (arow._childIndexes)
					i=arow._childIndexes[acell._cellIndex]+dir;
				acell=arow.childNodes[i];
			} else {

				acell=this._nextRowCell(arow, dir, (dir == 1 ? 0 : (this._cCount-1)));
			}
		}

		if (!acell){
			if ((dir == 1)&&this.tabEnd){
				this.tabEnd.focus();
				this.tabEnd.focus();
				this.setActive(false);
			}

			if ((dir == -1)&&this.tabStart){
				this.tabStart.focus();
				this.tabStart.focus();
				this.setActive(false);
			}
			return null;
		}

		//tab out

		// tab readonly
		if (acell.style.display != "none"
			&&(!this.smartTabOrder||!this.cells(acell.parentNode.idd, acell._cellIndex).isDisabled()))
			return acell;
		return this._getNextCell(acell, dir);
	// tab readonly

	}
	/**
	*	@desc: 
	*	@type: private
	*/
	this._nextRow=function(ind, dir){
		var r = this.render_row(ind+dir);
		if (!r || r==-1) return null;
		if (r&&r.style.display == "none")
			return this._nextRow(ind+dir, dir);

		return r;
	}
	/**
	*	@desc: 
	*	@type: private
	*/
	this.scrollPage=function(dir){ 
		if (!this.rowsBuffer.length) return;
		var master = this._realfake?this._fake:this;
		var new_ind = Math.floor((master._r_select||this.getRowIndex(this.row.idd)||0)+(dir)*this.objBox.offsetHeight / (this._srdh||20));

		if (new_ind < 0)
			new_ind=0;
		if (new_ind >= this.rowsBuffer.length)
			new_ind=this.rowsBuffer.length-1;

		if (this._srnd && !this.rowsBuffer[new_ind]){			
			this.objBox.scrollTop+=Math.floor((dir)*this.objBox.offsetHeight / (this._srdh||20))*(this._srdh||20);
			if (this._fake) this._fake.objBox.scrollTop = this.objBox.scrollTop;
			master._r_select=new_ind;
		} else {
			this.selectCell(new_ind, this.cell._cellIndex, true, false,false,(this.multiLine || this._srnd));
			if (!this.multiLine && !this._srnd && !this._realfake){
				this.objBox.scrollTop=this.getRowById(this.getRowId(new_ind)).offsetTop;
				if (this._fake) this._fake.objBox.scrollTop = this.objBox.scrollTop;
			}
			master._r_select=null;
		}
	}

	/**
	*   @desc: manages keybord activity in grid
	*   @type: private
	*   @topic: 7
	*/
	this.doKey=function(ev){
		if (!ev)
			return true;

		if ((ev.target||ev.srcElement).value !== window.undefined){
			var zx = (ev.target||ev.srcElement);

			if ((!zx.parentNode)||(zx.parentNode.className.indexOf("editable") == -1))
				return true;
		}

		if ((globalActiveDHTMLGridObject)&&(this != globalActiveDHTMLGridObject))
			return globalActiveDHTMLGridObject.doKey(ev);

		if (this.isActive == false){
			//document.body.onkeydown = "";
			return true;
		}

		if (this._htkebl)
			return true;

		if (!this.callEvent("onKeyPress", [
			ev.keyCode,
			ev.ctrlKey,
			ev.shiftKey,
			ev
		]))
			return false;

		var code = "k"+ev.keyCode+"_"+(ev.ctrlKey ? 1 : 0)+"_"+(ev.shiftKey ? 1 : 0);

		if (this.cell){ //if selection exists in grid only
			if (this._key_events[code]){
				if (false === this._key_events[code].call(this))
					return true;

				if (ev.preventDefault)
					ev.preventDefault();
				ev.cancelBubble=true;
				return false;
			}

			if (this._key_events["k_other"])
				this._key_events.k_other.call(this, ev);
		}

		return true;
	}
	
	/**
	*   @desc: selects row (and first cell of it)
	*   @param: r - row index or row object
	*   @param: fl - if true, then call function on select
	*   @param: preserve - preserve previously selected rows true/false (false by default)
	*   @param: show - true/false - scroll row to view, true by defaul    
	*   @type: public
	*   @topic: 1,2
	*/
	this.selectRow=function(r, fl, preserve, show){
		if (typeof (r) != 'object')
			r=this.render_row(r);
		this.selectCell(r, 0, fl, preserve, false, show)
	};

	/**
	*   @desc: called when row was double clicked
	*   @type: private
	*   @topic: 1,2
	*/
	this.wasDblClicked=function(ev){
		var el = this.getFirstParentOfType(_isIE ? ev.srcElement : ev.target, "TD");

		if (el){
			var rowId = el.parentNode.idd;
			return this.callEvent("onRowDblClicked", [
				rowId,
				el._cellIndex,
				ev
			]);
		}
	}

	/**
	*   @desc: called when header was clicked
	*   @type: private
	*   @topic: 1,2
	*/
	this._onHeaderClick=function(e, el){
		var that = this.grid;
		el=el||that.getFirstParentOfType(_isIE ? event.srcElement : e.target, "TD");

		if (this.grid.resized == null){
			if (!(this.grid.callEvent("onHeaderClick", [
				el._cellIndexS,
				(e||window.event)
			])))
				return false;
//#sorting:06042008{				
			that.sortField(el._cellIndexS, false, el)
//#}
		}
		this.grid.resized = null;
	}

	/**
	*   @desc: deletes selected row(s)
	*   @type: public
	*   @topic: 2
	*/
	this.deleteSelectedRows=function(){
		var num = this.selectedRows.length //this.obj.rows.length

		if (num == 0)
			return;

		var tmpAr = this.selectedRows;
		this.selectedRows=dhtmlxArray()
		for (var i = num-1; i >= 0; i--){
			var node = tmpAr[i]

			if (!this.deleteRow(node.idd, node)){
				this.selectedRows[this.selectedRows.length]=node;
			}
			else {
				if (node == this.row){
					var ind = i;
				}
			}
/*
						   this.rowsAr[node.idd] = null;
						   var posInCol = this.rowsCol._dhx_find(node)
						   this.rowsCol[posInCol].parentNode.removeChild(this.rowsCol[posInCol]);//nb:this.rowsCol[posInCol].removeNode(true);
						   this.rowsCol._dhx_removeAt(posInCol)*/
		}

		if (ind){
			try{
				if (ind+1 > this.rowsCol.length) //this.obj.rows.length)
					ind--;
				this.selectCell(ind, 0, true)
			}
			catch (er){
				this.row=null
				this.cell=null
			}
		}
	}

	/**
	*   @desc: gets selected row id
	*   @returns: id of selected row (list of ids with default delimiter) or null if non row selected
	*   @type: public
	*   @topic: 1,2,9
	*/
	this.getSelectedRowId=function(){
		var selAr = new Array(0);
		var uni = {
		};

		for (var i = 0; i < this.selectedRows.length; i++){
			var id = this.selectedRows[i].idd;

			if (uni[id])
				continue;

			selAr[selAr.length]=id;
			uni[id]=true;
		}

		//..
		if (selAr.length == 0)
			return null;
		else
			return selAr.join(this.delim);
	}
	
	/**
	*   @desc: gets index of selected cell
	*   @returns: index of selected cell or -1 if there is no selected sell
	*   @type: public
	*   @topic: 1,4
	*/
	this.getSelectedCellIndex=function(){
		if (this.cell != null)
			return this.cell._cellIndex;
		else
			return -1;
	}
	/**
	*   @desc: gets width of specified column in pixels
	*   @param: ind - column index
	*   @returns: column width in pixels
	*   @type: public
	*   @topic: 3,7
	*/
	this.getColWidth=function(ind){
		return parseInt(this.cellWidthPX[ind]);
	}

	/**
	*   @desc: sets width of specified column in pixels (soen't works with procent based grid)
	*   @param: ind - column index
	*   @param: value - new width value
	*   @type: public
	*   @topic: 3,7
	*/
	this.setColWidth=function(ind, value){
		if (value == "*")
			this.initCellWidth[ind] = "*";
		else {
			if (this._hrrar[ind]) return; //hidden
			if (this.cellWidthType == 'px')
				this.cellWidthPX[ind]=parseInt(value);
			else
				this.cellWidthPC[ind]=parseInt(value);
		}
		this.setSizes();
	}
	/**
	*   @desc: gets row index by id (grid only)
	*   @param: row_id - row id
	*   @returns: row index or -1 if there is no row with specified id
	*   @type: public
	*   @topic: 2
	*/
	this.getRowIndex=function(row_id){
		for (var i = 0; i < this.rowsBuffer.length; i++)
			if (this.rowsBuffer[i]&&this.rowsBuffer[i].idd == row_id)
				return i;
		return -1;
	}
	/**
	*   @desc: gets row id by index
	*   @param: ind - row index
	*   @returns: row id or null if there is no row with specified index
	*   @type: public
	*   @topic: 2
	*/
	this.getRowId=function(ind){
		return this.rowsBuffer[ind] ? this.rowsBuffer[ind].idd : this.undefined;
	}
	/**
	*   @desc: sets new id for row by its index
	*   @param: ind - row index
	*   @param: row_id - new row id
	*   @type: public
	*   @topic: 2
	*/
	this.setRowId=function(ind, row_id){
		this.changeRowId(this.getRowId(ind), row_id)
	}
	/**
	*   @desc: changes id of the row to the new one
	*   @param: oldRowId - row id to change
	*   @param: newRowId - row id to set
	*   @type:public
	*   @topic: 2
	*/
	this.changeRowId=function(oldRowId, newRowId){
		if (oldRowId == newRowId)
			return;
		/*
						  for (var i=0; i<row.childNodes.length; i++)
							  if (row.childNodes[i]._code)
								  this._compileSCL("-",row.childNodes[i]);      */
		var row = this.rowsAr[oldRowId]
		row.idd=newRowId;

		if (this.UserData[oldRowId]){
			this.UserData[newRowId]=this.UserData[oldRowId]
			this.UserData[oldRowId]=null;
		}

		if (this._h2&&this._h2.get[oldRowId]){
			this._h2.get[newRowId]=this._h2.get[oldRowId];
			this._h2.get[newRowId].id=newRowId;
			delete this._h2.get[oldRowId];
		}

		this.rowsAr[oldRowId]=null;
		this.rowsAr[newRowId]=row;

		for (var i = 0; i < row.childNodes.length; i++)
			if (row.childNodes[i]._code)
				row.childNodes[i]._code=this._compileSCL(row.childNodes[i]._val, row.childNodes[i]);
				
		if (this._mat_links && this._mat_links[oldRowId]){
			var a=this._mat_links[oldRowId];
			delete this._mat_links[oldRowId];
			for (var c in a)
				for (var i=0; i < a[c].length; i++)
					this._compileSCL(a[c][i].original,a[c][i]);
		}
				
		this.callEvent("onRowIdChange",[oldRowId,newRowId]);
	}
	/**
	*   @desc: sets ids to every column. Can be used then to retreive the index of the desired colum
	*   @param: [ids] - delimitered list of ids (default delimiter is ","), or empty if to use values set earlier
	*   @type: public
	*   @topic: 3
	*/
	this.setColumnIds=function(ids){
		this.columnIds=ids.split(this.delim)
	}
	/**
	*   @desc: sets ids to specified column.
	*   @param: ind- index of column
	*   @param: id- id of column
	*   @type: public
	*   @topic: 3
	*/
	this.setColumnId=function(ind, id){
		this.columnIds[ind]=id;
	}
	/**
	*   @desc: gets column index by column id
	*   @param: id - column id
	*   @returns: index of the column
	*   @type: public
	*   @topic: 3
	*/
	this.getColIndexById=function(id){
		for (var i = 0; i < this.columnIds.length; i++)
			if (this.columnIds[i] == id)
				return i;
	}
	/**
	*   @desc: gets column id of column specified by index
	*   @param: cin - column index
	*   @returns: column id
	*   @type: public
	*   @topic: 3
	*/
	this.getColumnId=function(cin){
		return this.columnIds[cin];
	}
	
	/**
	*   @desc: gets label of column specified by index
	*   @param: cin - column index
	*   @returns: column label
	*   @type: public
	*   @topic: 3
	*/
	this.getColumnLabel=function(cin, ind, hdr){
		var z = (hdr||this.hdr).rows[(ind||0)+1];
		for (var i=0; i<z.cells.length; i++)
			if (z.cells[i]._cellIndexS==cin) return (_isIE ? z.cells[i].innerText : z.cells[i].textContent);
		return "";
	};
	this.getColLabel = this.getColumnLabel;
	/**
	*   @desc: gets label of footer specified by index
	*   @param: cin - column index
	*   @returns: column label
	*   @type: public
	*   @topic: 3
	*/
	this.getFooterLabel=function(cin, ind){
		return this.getColumnLabel(cin,ind,this.ftr);
	}	
	

	/**
	*   @desc: sets row text BOLD
	*   @param: row_id - row id
	*   @type: public
	*   @topic: 2,6
	*/
	this.setRowTextBold=function(row_id){
		var r=this.getRowById(row_id)
		if (r) r.style.fontWeight="bold";
	}
	/**
	*   @desc: sets style to row
	*   @param: row_id - row id
	*   @param: styleString - style string in common format (exmpl: "color:red;border:1px solid gray;")
	*   @type: public
	*   @topic: 2,6
	*/
	this.setRowTextStyle=function(row_id, styleString){
		var r = this.getRowById(row_id)
		if (!r) return;
		for (var i = 0; i < r.childNodes.length; i++){
			var pfix = r.childNodes[i]._attrs["style"]||"";
//#__pro_feature:21092006{
//#column_hidden:21092006{
	if ((this._hrrar)&&(this._hrrar[i]))
		pfix="display:none;";
//#}
//#}
			if (_isIE)
				r.childNodes[i].style.cssText=pfix+"width:"+r.childNodes[i].style.width+";"+styleString;
			else
				r.childNodes[i].style.cssText=pfix+"width:"+r.childNodes[i].style.width+";"+styleString;
		}
	}
	/**
	*   @desc: sets background color of row (via bgcolor attribute)
	*   @param: row_id - row id
	*   @param: color - color value
	*   @type: public
	*   @topic: 2,6
	*/
	this.setRowColor=function(row_id, color){
		var r = this.getRowById(row_id)

		for (var i = 0; i < r.childNodes.length; i++)r.childNodes[i].bgColor=color;
	}
	/**
	*   @desc: sets style to cell
	*   @param: row_id - row id
	*   @param: ind - cell index
	*   @param: styleString - style string in common format (exmpl: "color:red;border:1px solid gray;")
	*   @type: public
	*   @topic: 2,6
	*/
	this.setCellTextStyle=function(row_id, ind, styleString){
		var r = this.getRowById(row_id)

		if (!r)
			return;

		var cell = r.childNodes[r._childIndexes ? r._childIndexes[ind] : ind];

		if (!cell)
			return;
		var pfix = "";
//#__pro_feature:21092006{
//#column_hidden:21092006{
		if ((this._hrrar)&&(this._hrrar[ind]))
			pfix="display:none;";
//#}
//#}
		if (_isIE)
			cell.style.cssText=pfix+"width:"+cell.style.width+";"+styleString;
		else
			cell.style.cssText=pfix+"width:"+cell.style.width+";"+styleString;
	}

	/**
	*   @desc: sets row text weight to normal
	*   @param: row_id - row id
	*   @type: public
	*   @topic: 2,6
	*/
	this.setRowTextNormal=function(row_id){
		var r=this.getRowById(row_id);
		if (r) r.style.fontWeight="normal";
	}
	/**
	*   @desc: determines if row with specified id exists
	*   @param: row_id - row id
	*   @returns: true if exists, false otherwise
	*   @type: public
	*   @topic: 2,7
	*/
	this.doesRowExist=function(row_id){
		if (this.getRowById(row_id) != null)
			return true
		else
			return false
	}
	


	/**
	*   @desc: gets number of columns in grid
	*   @returns: number of columns in grid
	*   @type: public
	*   @topic: 3,7
	*/
	this.getColumnsNum=function(){
		return this._cCount;
	}
	
	
//#moving_rows:06042008{
	/**
	*   @desc: moves row one position up if possible
	*   @param: row_id -  row id
	*   @type: public
	*   @topic: 2
	*/
	this.moveRowUp=function(row_id){
		var r = this.getRowById(row_id)

		if (this.isTreeGrid())
			return this.moveRowUDTG(row_id, -1);

		var rInd = this.rowsCol._dhx_find(r)
		if ((r.previousSibling)&&(rInd != 0)){
			r.parentNode.insertBefore(r, r.previousSibling)
			this.rowsCol._dhx_swapItems(rInd, rInd-1)
			this.setSizes();
			var bInd=this.rowsBuffer._dhx_find(r);
			this.rowsBuffer._dhx_swapItems(bInd,bInd-1);

			if (this._cssEven)
				this._fixAlterCss(rInd-1);
		}
	}
	/**
	*   @desc: moves row one position down if possible
	*   @param: row_id -  row id
	*   @type: public
	*   @topic: 2
	*/
	this.moveRowDown=function(row_id){
		var r = this.getRowById(row_id)

		if (this.isTreeGrid())
			return this.moveRowUDTG(row_id, 1);

		var rInd = this.rowsCol._dhx_find(r);
		if (r.nextSibling){ 
			this.rowsCol._dhx_swapItems(rInd, rInd+1)

			if (r.nextSibling.nextSibling)
				r.parentNode.insertBefore(r, r.nextSibling.nextSibling)
			else
				r.parentNode.appendChild(r)
			this.setSizes();
			
			var bInd=this.rowsBuffer._dhx_find(r);
			this.rowsBuffer._dhx_swapItems(bInd,bInd+1);

			if (this._cssEven)
				this._fixAlterCss(rInd);
		}
	}
//#}
//#co_excell:06042008{
	/**
	* @desc: gets Combo object of specified column. Use it to change select box value for cell before editor opened
	*   @type: public
	*   @topic: 3,4
	*   @param: col_ind - index of the column to get combo object for
	*/
	this.getCombo=function(col_ind){
		if (!this.combos[col_ind]){
			this.combos[col_ind]=new dhtmlXGridComboObject();
		}
		return this.combos[col_ind];
	}
//#}
	/**
	*   @desc: sets user data to row
	*   @param: row_id -  row id. if empty then user data is set for grid (not row)
	*   @param: name -  name of user data block
	*   @param: value -  value of user data block
	*   @type: public
	*   @topic: 2,5
	*/
	this.setUserData=function(row_id, name, value){
		if (!row_id)
			row_id="gridglobaluserdata";

		if (!this.UserData[row_id])
			this.UserData[row_id]=new Hashtable()
		this.UserData[row_id].put(name, value)
	}
	/**
	*   @desc: gets user Data
	*   @param: row_id -  row id. if empty then user data is for grid (not row)
	*   @param: name -  name of user data
	*   @returns: value of user data
	*   @type: public
	*   @topic: 2,5
	*/
	this.getUserData=function(row_id, name){
		if (!row_id)
			row_id="gridglobaluserdata";		
		this.getRowById(row_id); //parse row if necessary
		
		var z = this.UserData[row_id];
		return (z ? z.get(name) : "");
	}

	/**
	*   @desc: manage editibility of the grid
	*   @param: [fl] - set not editable if FALSE, set editable otherwise
	*   @type: public
	*   @topic: 7
	*/
	this.setEditable=function(fl){
		this.isEditable=convertStringToBoolean(fl);
	}
	/**
	*   @desc: selects row by ID
	*   @param: row_id - row id
	*   @param: multiFL - VOID. select multiple rows
	*   @param: show - true/false - scroll row to view, true by defaul    
	*   @param: call - true to call function on select
	*   @type: public
	*   @topic: 1,2
	*/
	this.selectRowById=function(row_id, multiFL, show, call){
		if (!call)
			call=false;
		this.selectCell(this.getRowById(row_id), 0, call, multiFL, false, show);
	}
	
	/**
	*   @desc: removes selection from the grid
	*   @type: public
	*   @topic: 1,9
	*/
	this.clearSelection=function(){
		this.editStop()

		for (var i = 0; i < this.selectedRows.length; i++){
			var r = this.rowsAr[this.selectedRows[i].idd];

			if (r)
				r.className=r.className.replace(/rowselected/g, "");
		}

		//..
		this.selectedRows=dhtmlxArray()
		this.row=null;

		if (this.cell != null){
			this.cell.className=this.cell.className.replace(/cellselected/g, "");
			this.cell=null;
		}
		
		this.callEvent("onSelectionCleared",[]);
	}
	/**
	*   @desc: copies row content to another existing row
	*   @param: from_row_id - id of the row to copy content from
	*   @param: to_row_id - id of the row to copy content to
	*   @type: public
	*   @topic: 2,5
	*/
	this.copyRowContent=function(from_row_id, to_row_id){
		var frRow = this.getRowById(from_row_id)

		if (!this.isTreeGrid())
			for (var i = 0; i < frRow.cells.length; i++){
				this.cells(to_row_id, i).setValue(this.cells(from_row_id, i).getValue())
			}
		else
			this._copyTreeGridRowContent(frRow, from_row_id, to_row_id);

		//for Mozilla (to avaoid visual glitches)
		if (!_isIE)
			this.getRowById(from_row_id).cells[0].height=frRow.cells[0].offsetHeight
	}
	/**
	*   @desc: sets new label for cell in footer
	*   @param: col - header column index
	*   @param: label - new label for the cpecified footer's column. Can contai img:[imageUrl]Text Label
	*	@param: ind - header row index 
	*   @type: public
	*   @topic: 3,6
	*/
	this.setFooterLabel=function(c, label, ind){
		return this.setColumnLabel(c,label,ind,this.ftr);
	};
	/**
	*   @desc: sets new column header label
	*   @param: col - header column index
	*   @param: label - new label for the cpecified header's column. Can contai img:[imageUrl]Text Label
	*	@param: ind - header row index 
	*   @type: public
	*   @topic: 3,6
	*/
	this.setColumnLabel=function(c, label, ind, hdr){
		var z = (hdr||this.hdr).rows[ind||1];
		var col = (z._childIndexes ? z._childIndexes[c] : c);
		if (!z.cells[col]) return;
		if (!this.useImagesInHeader){
			var hdrHTML = "<div class='hdrcell'>"

			if (label.indexOf('img:[') != -1){
				var imUrl = label.replace(/.*\[([^>]+)\].*/, "$1");
				label=label.substr(label.indexOf("]")+1, label.length)
				hdrHTML+="<img width='18px' height='18px' align='absmiddle' src='"+imUrl+"' hspace='2'>"
			}
			hdrHTML+=label;
			hdrHTML+="</div>";
			z.cells[col].innerHTML=hdrHTML;

			if (this._hstyles[col])
				z.cells[col].style.cssText=this._hstyles[col];
		} else { //if images in header header
			z.cells[col].style.textAlign="left";
			z.cells[col].innerHTML="<img src='"+this.imgURL+""+label+"' onerror='this.src = \""+this.imgURL
				+"imageloaderror.gif\"'>";
			//preload sorting headers (asc/desc)
			var a = new Image();
			a.src=this.imgURL+""+label.replace(/(\.[a-z]+)/, ".des$1");
			this.preloadImagesAr[this.preloadImagesAr.length]=a;
			var b = new Image();
			b.src=this.imgURL+""+label.replace(/(\.[a-z]+)/, ".asc$1");
			this.preloadImagesAr[this.preloadImagesAr.length]=b;
		}

		if ((label||"").indexOf("#") != -1){
			var t = label.match(/(^|{)#([^}]+)(}|$)/);

			if (t){
				var tn = "_in_header_"+t[2];

				if (this[tn])
					this[tn]((this.forceDivInHeader ? z.cells[col].firstChild : z.cells[col]), col, label.split(t[0]));
			}
		}
	};
	this.setColLabel = function(a,b,ind,c){
		return this.setColumnLabel(a,b,(ind||0)+1,c);
	};
	/**
	*   @desc: deletes all rows in grid
	*   @param: header - (boolean) enable/disable cleaning header
	*   @type: public
	*   @topic: 5,7,9
	*/
	this.clearAll=function(header){
	    if (!this.obj.rows[0]) return; //call before initilization
		if (this._h2){
			this._h2=new dhtmlxHierarchy();

			if (this._fake){
				if (this._realfake)
					this._h2=this._fake._h2;
				else
					this._fake._h2=this._h2;
			}
		}

		this.limit=this._limitC=0;
		this.editStop(true);

		if (this._dLoadTimer)
			window.clearTimeout(this._dLoadTimer);

		if (this._dload){
			this.objBox.scrollTop=0;
			this.limit=this._limitC||0;
			this._initDrF=true;
		}

		var len = this.rowsCol.length;

		//for some case
		len=this.obj.rows.length;

		for (var i = len-1; i > 0; i--){
			var t_r = this.obj.rows[i];
			t_r.parentNode.removeChild(t_r);
		}

		if (header){
			this._master_row=null;
			this.obj.rows[0].parentNode.removeChild(this.obj.rows[0]);

			for (var i = this.hdr.rows.length-1; i >= 0; i--){
				var t_r = this.hdr.rows[i];
				t_r.parentNode.removeChild(t_r);
			}

			if (this.ftr){
				this.ftr.parentNode.removeChild(this.ftr);
				this.ftr=null;
			}
			this._aHead=this.ftr=this.cellWidth=this._aFoot=null;
			this.cellType=dhtmlxArray();
			this._hrrar=[];
			this.columnIds=[];
			this.combos=[];
			this._strangeParams=[];
			this.defVal = [];
			this._ivizcol = null;
		}

		//..
		this.row=null;
		this.cell=null;

		this.rowsCol=dhtmlxArray()
		this.rowsAr={}; //array of rows by idd
		this._RaSeCol=[];
		this.rowsBuffer=dhtmlxArray()
		this.UserData=[]
		this.selectedRows=dhtmlxArray();

		if (this.pagingOn || this._srnd)
			this.xmlFileUrl="";
		if (this.pagingOn)
			this.changePage(1);
		
		//  if (!this._fake){
		/*
		   if ((this._hideShowColumn)&&(this.hdr.rows[0]))
			  for (var i=0; i<this.hdr.rows[0].cells.length; i++)
				  this._hideShowColumn(i,"");
	   this._hrrar=new Array();*/
		//}
		if (this._contextCallTimer)
			window.clearTimeout(this._contextCallTimer);

		if (this._sst)
			this.enableStableSorting(true);
		this._fillers=this.undefined;
		this.setSortImgState(false);
		this.setSizes();
		//this.obj.scrollTop = 0;

		this.callEvent("onClearAll", []);
	}

//#sorting:06042008{
	/**
	*   @desc: sorts grid by specified field
	*    @invoke: header click
	*   @param: [ind] - index of the field
	*   @param: [repeatFl] - if to repeat last sorting
	*   @type: private
	*   @topic: 3
	*/
	this.sortField=function(ind, repeatFl, r_el){
		if (this.getRowsNum() == 0)
			return false;

		var el = this.hdr.rows[0].cells[ind];

		if (!el)
			return; //somehow
		// if (this._dload  && !this.callEvent("onBeforeSorting",[ind,this]) ) return true;

		if (el.tagName == "TH"&&(this.fldSort.length-1) >= el._cellIndex
			&&this.fldSort[el._cellIndex] != 'na'){ //this.entBox.fieldstosort!="" &&
			var data=this.getSortingState();
			var sortType= ( data[0]==ind && data[1]=="asc" ) ? "des" : "asc";

			if (!this.callEvent("onBeforeSorting", [
				ind,
				this.fldSort[ind],
				sortType
			]))
				return;
			this.sortImg.src=this.imgURL+"sort_"+(sortType == "asc" ? "asc" : "desc")+".gif";

			//for header images
			if (this.useImagesInHeader){
				var cel = this.hdr.rows[1].cells[el._cellIndex].firstChild;

				if (this.fldSorted != null){
					var celT = this.hdr.rows[1].cells[this.fldSorted._cellIndex].firstChild;
					celT.src=celT.src.replace(/(\.asc\.)|(\.des\.)/, ".");
				}
				cel.src=cel.src.replace(/(\.[a-z]+)$/, "."+sortType+"$1")
			}
			//.
			this.sortRows(el._cellIndex, this.fldSort[el._cellIndex], sortType)
			this.fldSorted=el;
			this.r_fldSorted=r_el;
			var c = this.hdr.rows[1];
			var c = r_el.parentNode;
			var real_el = c._childIndexes ? c._childIndexes[el._cellIndex] : el._cellIndex;
			this.setSortImgPos(false, false, false, r_el);
		}
	}
//#__pro_feature:21092006{
//#custom_sort:21092006{
	/**
	*   @desc: set custom sorting (custom sort has three params - valueA,valueB,order; where order can be asc or des)
	*   @param: func - function to use for comparison
	*   @param:   col - index of column to apply custom sorting to
	*   @type: public
	*   @edition: Professional
	*   @topic: 3
	*/
	this.setCustomSorting=function(func, col){
		if (!this._customSorts)
			this._customSorts=new Array();
		this._customSorts[col]=( typeof (func) == "string") ? eval(func) : func;
		this.fldSort[col]="cus";
	}
//#}
//#}
//#}
	/**
	*   @desc: specify if values passed to Header are images file names
	*   @param: fl - true to treat column header values as image names
	*   @type: public
	*   @before_init: 1
	*   @topic: 0,3
	*/
	this.enableHeaderImages=function(fl){
		this.useImagesInHeader=fl;
	}

	/**
	*   @desc: set header label and default params for new headers
	*   @param: hdrStr - header string with delimiters
	*   @param: splitSign - string used as a split marker, optional. Default is "#cspan"
	*   @param: styles - array of header styles
	*   @type: public
	*   @before_init: 1
	*   @topic: 0,3
	*/
	this.setHeader=function(hdrStr, splitSign, styles){
		if (typeof (hdrStr) != "object")
			var arLab = this._eSplit(hdrStr);
		else
			arLab=[].concat(hdrStr);

		var arWdth = new Array(0);
		var arTyp = new dhtmlxArray(0);
		var arAlg = new Array(0);
		var arVAlg = new Array(0);
		var arSrt = new Array(0);

		for (var i = 0; i < arLab.length; i++){
			arWdth[arWdth.length]=Math.round(100 / arLab.length);
			arTyp[arTyp.length]="ed";
			arAlg[arAlg.length]="left";
			arVAlg[arVAlg.length]="middle"; //top
			arSrt[arSrt.length]="na";
		}

		this.splitSign=splitSign||"#cspan";
		this.hdrLabels=arLab;
		this.cellWidth=arWdth;
		if (!this.initCellWidth.length) this.setInitWidthsP(arWdth.join(this.delim),true);
		this.cellType=arTyp;
		this.cellAlign=arAlg;
		this.cellVAlign=arVAlg;
		this.fldSort=arSrt;
		this._hstyles=styles||[];
	}
	/**
   *   @desc: 
   *   @param: str - ...
   *   @type: private
   */
	this._eSplit=function(str){
		if (![].push)
			return str.split(this.delim);

		var a = "r"+(new Date()).valueOf();
		var z = this.delim.replace(/([\|\+\*\^])/g, "\\$1")
		return (str||"").replace(RegExp(z, "g"), a).replace(RegExp("\\\\"+a, "g"), this.delim).split(a);
	}

	/**
	*   @desc: get column type by column index
	*   @param: cInd - column index
	*   @returns:  type code
	*   @type: public
	*   @topic: 0,3,4
	*/
	this.getColType=function(cInd){
		return this.cellType[cInd];
	}

	/**
	*   @desc: get column type by column ID
	*   @param: cID - column id
	*   @returns:  type code
	*   @type: public
	*   @topic: 0,3,4
	*/
	this.getColTypeById=function(cID){
		return this.cellType[this.getColIndexById(cID)];
	}

	/**
	*   @desc: set column types
	*   @param: typeStr - type codes list (default delimiter is ",")
	*   @before_init: 2
	*   @type: public
	*   @topic: 0,3,4
	*/
	this.setColTypes=function(typeStr){
		this.cellType=dhtmlxArray(typeStr.split(this.delim));
		this._strangeParams=new Array();

		for (var i = 0; i < this.cellType.length; i++){
			if ((this.cellType[i].indexOf("[") != -1)){
				var z = this.cellType[i].split(/[\[\]]+/g);
				this.cellType[i]=z[0];
				this.defVal[i]=z[1];

				if (z[1].indexOf("=") == 0){
					this.cellType[i]="math";
					this._strangeParams[i]=z[0];
				}
			}
			if (!window["eXcell_"+this.cellType[i]]) dhtmlxError.throwError("Configuration","Incorrect cell type: "+this.cellType[i],[this,this.cellType[i]]);
		}
	}
	/**
	*   @desc: set column sort types (avaialble: str, int, date, na or function object for custom sorting)
	*   @param: sortStr - sort codes list with default delimiter
	*   @before_init: 1
	*   @type: public
	*   @topic: 0,3,4
	*/
	this.setColSorting=function(sortStr){
		this.fldSort=sortStr.split(this.delim)
//#__pro_feature:21092006{
//#custom_sort:21092006{
		for (var i = 0; i < this.fldSort.length; i++)
			if (((this.fldSort[i]).length > 4)&&( typeof (window[this.fldSort[i]]) == "function")){
				if (!this._customSorts)
					this._customSorts=new Array();
				this._customSorts[i]=window[this.fldSort[i]];
				this.fldSort[i]="cus";
			}
//#}
//#}
	}
	/**
	*   @desc: set align of values in columns
	*   @param: alStr - list of align values (possible values are: right,left,center,justify). Default delimiter is ","
	*   @before_init: 1
	*   @type: public
	*   @topic: 0,3
	*/
	this.setColAlign=function(alStr){
		this.cellAlign=alStr.split(this.delim)
		for (var i=0; i < this.cellAlign.length; i++)
			this.cellAlign[i]=this.cellAlign[i]._dhx_trim();
	}
/**
*   @desc: set vertical align of columns
*   @param: valStr - vertical align values list for columns (possible values are: baseline,sub,super,top,text-top,middle,bottom,text-bottom)
*   @before_init: 1
*   @type: public
*   @topic: 0,3
*/
	this.setColVAlign=function(valStr){
		this.cellVAlign=valStr.split(this.delim)
	}

/**
* 	@desc: create grid with no header. Call before initialization, but after setHeader. setHeader have to be called in any way as it defines number of columns
*   @param: fl - true to use no header in the grid
*   @type: public
*   @before_init: 1
*   @topic: 0,7
*/
	this.setNoHeader=function(fl){
			this.noHeader=convertStringToBoolean(fl);
	}
	/**
	*   @desc: scrolls row to the visible area
	*   @param: rowID - row id
	*   @type: public
	*   @topic: 2,7
	*/
	this.showRow=function(rowID){
		this.getRowById(rowID)

		if (this._h2) this.openItem(this._h2.get[rowID].parent.id);
		var c = this.getRowById(rowID).childNodes[0];

		while (c&&c.style.display == "none")
			c=c.nextSibling;

		if (c)
			this.moveToVisible(c, true)
	}

	/**
	*   @desc: modify default style of grid and its elements. Call before or after Init
	*   @param: ss_header - style def. expression for header
	*   @param: ss_grid - style def. expression for grid cells
	*   @param: ss_selCell - style def. expression for selected cell
	*   @param: ss_selRow - style def. expression for selected Row
	*   @type: public
	*   @before_init: 2
	*   @topic: 0,6
	*/
	this.setStyle=function(ss_header, ss_grid, ss_selCell, ss_selRow){
		this.ssModifier=[
			ss_header,
			ss_grid,
			ss_selCell,
			ss_selCell,
			ss_selRow
		];

		var prefs = ["#"+this.entBox.id+" table.hdr td", "#"+this.entBox.id+" table.obj td",
			"#"+this.entBox.id+" table.obj tr.rowselected td.cellselected",
			"#"+this.entBox.id+" table.obj td.cellselected", "#"+this.entBox.id+" table.obj tr.rowselected td"];

		var index = 0;
		while (!_isIE){
			try{
				var temp = document.styleSheets[index].cssRules.length;
			} catch(e) { index++; continue; }
			break;
		}
		
		for (var i = 0; i < prefs.length; i++)
			if (this.ssModifier[i]){
				if (_isIE)
					document.styleSheets[0].addRule(prefs[i], this.ssModifier[i]);
				else
					document.styleSheets[index].insertRule(prefs[i]+(" { "+this.ssModifier[i]+" }"), document.styleSheets[index].cssRules.length);
			}
	}
	/**
	*   @desc: colorize columns  background.
	*   @param: clr - colors list
	*   @type: public
	*   @before_init: 1
	*   @topic: 3,6
	*/
	this.setColumnColor=function(clr){
		this.columnColor=clr.split(this.delim)
	}
//#alter_css:06042008{
	/**
	*   @desc: set even/odd css styles
	*   @param: cssE - name of css class for even rows
	*   @param: cssU - name of css class for odd rows
	*   @param: perLevel - true/false - mark rows not by order, but by level in treegrid
	*   @param: levelUnique - true/false - creates additional unique css class based on row level
	*   @type: public
	*   @before_init: 1
	*   @topic: 3,6
	*/
	this.enableAlterCss=function(cssE, cssU, perLevel, levelUnique){
		if (cssE||cssU)
			this.attachEvent("onGridReconstructed",function(){
				this._fixAlterCss();
				if (this._fake)
					this._fake._fixAlterCss();
			});

		this._cssSP=perLevel;
		this._cssSU=levelUnique;
		this._cssEven=cssE;
		this._cssUnEven=cssU;
	}
//#}
	/**
	*   @desc: recolor grid from defined point
	*   @type: private
	*   @before_init: 1
	*   @topic: 3,6
	*/
	this._fixAlterCss=function(ind){
//#alter_css:06042008{		
		if (this._h2 && (this._cssSP || this._cssSU))
			return this._fixAlterCssTGR(ind);
		if (!this._cssEven && !this._cssUnEven) return;
		ind=ind||0;
		var j = ind;

		for (var i = ind; i < this.rowsCol.length; i++){
			if (!this.rowsCol[i])
				continue;

			if (this.rowsCol[i].style.display != "none"){
				if (this.rowsCol[i]._cntr) { j=1; continue; }
				if (this.rowsCol[i].className.indexOf("rowselected") != -1){
					if (j%2 == 1)
						this.rowsCol[i].className=this._cssUnEven+" rowselected "+(this.rowsCol[i]._css||"");
					else
						this.rowsCol[i].className=this._cssEven+" rowselected "+(this.rowsCol[i]._css||"");
				} else {
					if (j%2 == 1)
						this.rowsCol[i].className=this._cssUnEven+" "+(this.rowsCol[i]._css||"");
					else
						this.rowsCol[i].className=this._cssEven+" "+(this.rowsCol[i]._css||"");
				}
				j++;
			}
		}
//#}		
	}
//#__pro_feature:21092006{
	/**
	*     @desc: clear wasChanged state for all cells in grid
	*     @type: public
	*     @edition: Professional
	*     @topic: 7
	*/
	this.clearChangedState=function(){
		for (var i = 0; i < this.rowsCol.length; i++){
			var row = this.rowsCol[i];
			if (row && row.childNodes){
				var cols = row.childNodes.length;
				for (var j = 0; j < cols; j++)row.childNodes[j].wasChanged=false;
			}
		}
	};

	/**
	*     @desc: get list of IDs of changed rows
	*     @type: public
	*     @edition: Professional
	*     @return: list of ID of changed rows
	*     @topic: 7
	*/
	this.getChangedRows=function(and_added){
		var res = new Array();
		this.forEachRow(function(id){
			var row = this.rowsAr[id];
			if (row.tagName!="TR") return; 
			var cols = row.childNodes.length;
			if (and_added && row._added)
				res[res.length]=row.idd;
			else
				for (var j = 0; j < cols; j++)
					if (row.childNodes[j].wasChanged){
						res[res.length]=row.idd;
						break;
					}
		})
		return res.join(this.delim);
	};


//#serialization:21092006{

	this._sUDa=false;
	this._sAll=false;

	/**
	*     @desc: configure XML serialization
	*     @type: public
	*     @edition: Professional
	*     @param: userData - enable/disable user data serialization
	*     @param: fullXML - enable/disable full XML serialization (selection state)
	*     @param: config - serialize grid configuration
	*     @param: changedAttr - include changed attribute
	*     @param: onlyChanged - include only Changed  rows in result XML
	*     @param: asCDATA - output cell values as CDATA sections (prevent invalid XML)
	*     @topic: 0,5,7
	*/
	this.setSerializationLevel=function(userData, fullXML, config, changedAttr, onlyChanged, asCDATA){
		this._sUDa=userData;
		this._sAll=fullXML;
		this._sConfig=config;
		this._chAttr=changedAttr;
		this._onlChAttr=onlyChanged;
		this._asCDATA=asCDATA;
	}


/**
*     @desc: configure which column must be serialized (if you do not use this method, then all columns will be serialized)
*     @type: public
*     @edition: Professional
*     @param: list - list of true/false values separated by comma, if list empty then all fields will be serialized
*     @topic: 0,5,7
*/
	this.setSerializableColumns=function(list){
		if (!list){
			this._srClmn=null;
			return;
		}
		this._srClmn=(list||"").split(",");

		for (var i = 0; i < this._srClmn.length; i++)this._srClmn[i]=convertStringToBoolean(this._srClmn[i]);
	}

	/**
	*     @desc: serialize a collection of rows
	*     @type: private
	*     @topic: 0,5,7
	*/
	this._serialise=function(rCol, inner, closed){
		this.editStop()
		var out = [];
		//rows collection
		var close = "</"+this.xml.s_row+">"

		if (this.isTreeGrid()){
			this._h2.forEachChildF(0, function(el){
				var temp = this._serializeRow(this.render_row_tree(-1, el.id));
				out.push(temp);

				if (temp)
					return true;
				else
					return false;
			}, this, function(){
				out.push(close);
			});
		}
		else
			for (var i = 0; i < this.rowsBuffer.length; i++)
				if (this.rowsBuffer[i]){
					if (this._chAttr && this.rowsBuffer[i]._locator)
						continue;
						
					var temp = this._serializeRow(this.render_row(i));
					out.push(temp);

					if (temp)
						out.push(close);
				}

		return [out.join("")];
	}

	/**
	*   @desc: serialize TR or xml node to grid formated xml (row tag)
	*   @param: r - TR or xml node (row)
	*   @retruns: string - xml representation of passed row
	*   @type: private
	*/
	this._serializeRow=function(r, i){
		var out = [];
		var ra = this.xml.row_attrs;
		var ca = this.xml.cell_attrs;

		out.push("<"+this.xml.s_row);
		out.push(" id='"+r.idd+"'");

		if ((this._sAll)&&this.selectedRows._dhx_find(r) != -1)
			out.push(" selected='1'");

		if (this._h2&&this._h2.get[r.idd].state == "minus")
			out.push(" open='1'");

		if (ra.length)
			for (var i = 0; i < ra.length; i++)out.push(" "+ra[i]+"='"+r._attrs[ra[i]]+"'");
		out.push(">");

		//userdata
		if (this._sUDa&&this.UserData[r.idd]){
			keysAr=this.UserData[r.idd].getKeys()

			for (var ii = 0;
				ii < keysAr.length;
				ii++)out.push("<userdata name='"+keysAr[ii]+"'>"+(this._asCDATA?"<![CDATA[":"")+this.UserData[r.idd].get(keysAr[ii])+(this._asCDATA?"]]>":"")+"</userdata>");
		}


		//cells
		var changeFl = false;

		for (var jj = 0; jj < this._cCount; jj++){
			if ((!this._srClmn)||(this._srClmn[jj])){
				var zx = this.cells3(r, jj);
				out.push("<cell");

				if (ca.length)
					for (var i = 0; i < ca.length; i++)out.push(" "+ca[i]+"='"+zx.cell._attrs[ca[i]]+"'");
				zxVal=zx[this._agetm]();

				if (this._asCDATA)
					zxVal="<![CDATA["+zxVal+"]]>";

				//#colspan:20092006{
				if ((this._ecspn)&&(zx.cell.colSpan)&&zx.cell.colSpan > 1)
					out.push(" colspan=\""+zx.cell.colSpan+"\" ");
				//#}

				if (this._chAttr){
					if (zx.wasChanged()){
						out.push(" changed=\"1\"");
						changeFl=true;
					}
				}

				else if ((this._onlChAttr)&&(zx.wasChanged()))
					changeFl=true;

				if (this._sAll && this.cellType[jj]=="tree")
					out.push((this._h2 ? (" image='"+this._h2.get[r.idd].image+"'") : "")+">"+zxVal+"</cell>");
				else
					out.push(">"+zxVal+"</cell>");

				//#colspan:20092006{
				if ((this._ecspn)&&(zx.cell.colSpan))
					for (var u = 0; u < zx.cell.colSpan-1; u++){
						out.push("<cell/>");
						jj++;
					}
			//#}
			}
		}

		if ((this._onlChAttr)&&(!changeFl)&&(!r._added))
			return "";

		return out.join("");
	}

	/**
	*     @desc: serialize grid configuration
	*     @type: private
	*     @topic: 0,5,7
	*/
	this._serialiseConfig=function(){
		var out = "<head>";

		for (var i = 0; i < this.hdr.rows[0].cells.length; i++){
			if (this._srClmn && !this._srClmn[i]) continue;
			var sort = this.fldSort[i];
			if (sort == "cus"){
				sort = this._customSorts[i].toString();
				sort=sort.replace(/function[\ ]*/,"").replace(/\([^\f]*/,"");
			}
			out+="<column width='"+this.getColWidth(i)+"' align='"+this.cellAlign[i]+"' type='"+this.cellType[i]
				+"' sort='"+(sort||"na")+"' color='"+this.columnColor[i]+"'"
				+(this.columnIds[i]
					? (" id='"+this.columnIds[i]+"'")
					: "")+">";
			if (this._asCDATA)
				out+="<![CDATA["+this.getHeaderCol(i)+"]]>";
			else
				out+=this.getHeaderCol(i);
			var z = this.getCombo(i);

			if (z)
				for (var j = 0; j < z.keys.length; j++)out+="<option value='"+z.keys[j]+"'>"+z.values[j]+"</option>";
			out+="</column>"
		}
		return out+="</head>";
	}
	/**
	*     @desc: get actual xml of grid. The depth of serialization can be set with setSerializationLevel method
	*     @type: public
	*     @edition: Professional
	*     @topic: 5,7
	*/
	this.serialize=function(){
		var out = '<?xml version="1.0"?><rows>';

		if (this._mathSerialization)
			this._agetm="getMathValue";
		else
			this._agetm="getValue";

		if (this._sUDa&&this.UserData["gridglobaluserdata"]){
			var keysAr = this.UserData["gridglobaluserdata"].getKeys()

			for (var i = 0;
				i < keysAr.length;
				i++)out+="<userdata name='"+keysAr[i]+"'>"+this.UserData["gridglobaluserdata"].get(keysAr[i])
				+"</userdata>";
		}

		if (this._sConfig)
			out+=this._serialiseConfig();
		out+=this._serialise();

		out+='</rows>';
		return out;
	}
//#}
//#}

	/**
	*    @desc: returns absolute left and top position of specified element
	*    @returns: array of two values: absolute Left and absolute Top positions
	*    @param: oNode - element to get position of
	*   @type: private
	*   @topic: 8
	*/
	this.getPosition=function(oNode, pNode){
		if (!pNode){
			var pos = getOffset(oNode);
			return [pos.left, pos.top];
		}
		pNode = pNode||document.body;

		var oCurrentNode = oNode;
		var iLeft = 0;
		var iTop = 0;

		while ((oCurrentNode)&&(oCurrentNode != pNode)){ //.tagName!="BODY"){
			iLeft+=oCurrentNode.offsetLeft-oCurrentNode.scrollLeft;
			iTop+=oCurrentNode.offsetTop-oCurrentNode.scrollTop;
			oCurrentNode=oCurrentNode.offsetParent;
		}

		if (pNode == document.body){
			if (_isIE){
				iTop+=document.body.offsetTop||document.documentElement.offsetTop;
				iLeft+=document.body.offsetLeft||document.documentElement.offsetLeft;
			} else if (!_isFF){
				iLeft+=document.body.offsetLeft;
				iTop+=document.body.offsetTop;
			}
		}
		return [iLeft, iTop];
	}
	/**
	*   @desc: gets nearest parent of specified type
	*   @param: obj - input object
	*   @param: tag - string. tag to find as parent
	*   @returns: object. nearest paraent object (including spec. obj) of specified type.
	*   @type: private
	*   @topic: 8
	*/
	this.getFirstParentOfType=function(obj, tag){
		while (obj&&obj.tagName != tag&&obj.tagName != "BODY"){
			obj=obj.parentNode;
		}
		return obj;
	}



	/*INTERNAL EVENT HANDLERS*/
	this.objBox.onscroll=function(){
		this.grid._doOnScroll();
	};
	this.objBox.ontouchend = function(){
		this.hdrBox.scrollLeft=this.objBox.scrollLeft;
	};
	this.hdrBox.onscroll=function(){
		if (this._try_header_sync) return;
		this._try_header_sync = true;
		if (this.grid.objBox.scrollLeft != this.scrollLeft){
			this.grid.objBox.scrollLeft = this.scrollLeft;
		}
		this._try_header_sync = false;
	}
//#column_resize:06042008{
	if ((!_isOpera)||(_OperaRv > 8.5)){
		this.hdr.onmousemove=function(e){
			this.grid.changeCursorState(e||window.event);
		};
		this.hdr.onmousedown=function(e){
			return this.grid.startColResize(e||window.event);
		};		
	}
//#}
//#tooltips:06042008{
	this.obj.onmousemove=this._drawTooltip;
//#}
	this.objBox.onclick=function(e){
		(e||event).cancelBubble=true;
	};
	this.obj.onclick=function(e){
		this.grid._doClick(e||window.event);
		if (this.grid._sclE) 
			this.grid.editCell(e||window.event); 
		else
			this.grid.editStop();
					
		(e||event).cancelBubble=true;
	};
//#context_menu:06042008{
	if (_isMacOS){
		this.entBox.oncontextmenu=function(e){
			e.cancelBubble=true;
			e.returnValue=false;
			var that = this.grid; if (that._realfake) that = that._fake;
			return that._doContClick(e||window.event);
		};
	} else {
    	this.entBox.onmousedown=function(e){
	    	return this.grid._doContClick(e||window.event);
    	};
    	this.entBox.oncontextmenu=function(e){
    		if (this.grid._ctmndx)
    			(e||event).cancelBubble=true;
    		return !this.grid._ctmndx;
		};
	}
    	
//#}		
	this.obj.ondblclick=function(e){
		if (!this.grid.wasDblClicked(e||window.event)) 
			return false; 
		if (this.grid._dclE) {
			var row = this.grid.getFirstParentOfType((_isIE?event.srcElement:e.target),"TR");
			if (row == this.grid.row)
				this.grid.editCell(e||window.event);  
		}
		(e||event).cancelBubble=true;
		if (_isOpera) return false; //block context menu for Opera 9+
	};
	this.hdr.onclick=this._onHeaderClick;
	this.sortImg.onclick=function(){
		self._onHeaderClick.apply({
			grid: self
			}, [
			null,
			self.r_fldSorted
		]);
	};

	this.hdr.ondblclick=this._onHeaderDblClick;


	if (!document.body._dhtmlxgrid_onkeydown){
		dhtmlxEvent(document, "keydown",function(e){
			if (globalActiveDHTMLGridObject) 
				return globalActiveDHTMLGridObject.doKey(e||window.event);
		});
		document.body._dhtmlxgrid_onkeydown=true;
	}

	dhtmlxEvent(document.body, "click", function(){
		if (self.editStop) self.editStop();
		if (self.isActive) self.setActive(false);
	});

	
	if (this.entBox.style.height.toString().indexOf("%") != -1)
		this._delta_y = this.entBox.style.height;
	if (this.entBox.style.width.toString().indexOf("%") != -1)
		this._delta_x = this.entBox.style.width;

	if (this._delta_x||this._delta_y)
		this._setAutoResize();
	
		
	/* deprecated names */
	this.setColHidden=this.setColumnsVisibility
	this.enableCollSpan = this.enableColSpan
	this.setMultiselect=this.enableMultiselect;
	this.setMultiLine=this.enableMultiline;
	this.deleteSelectedItem=this.deleteSelectedRows;
	this.getSelectedId=this.getSelectedRowId;
	this.getHeaderCol=this.getColumnLabel;
	this.isItemExists=this.doesRowExist;
	this.getColumnCount=this.getColumnsNum;
	this.setSelectedRow=this.selectRowById;
	this.setHeaderCol=this.setColumnLabel;
	this.preventIECashing=this.preventIECaching;
	this.enableAutoHeigth=this.enableAutoHeight;
	this.getUID=this.uid;
	
	if (dhtmlx.image_path) this.setImagePath(dhtmlx.image_path);
	if (dhtmlx.skin) this.setSkin(dhtmlx.skin);
		
	return this;
}

dhtmlXGridObject.prototype={
	getRowAttribute: function(id, name){
		return this.getRowById(id)._attrs[name];
	},
	setRowAttribute: function(id, name, value){
		this.getRowById(id)._attrs[name]=value;
	},
	/**
	*   @desc: detect is current grid is a treeGrid
	*   @type: private
	*   @topic: 2
	*/
	isTreeGrid:function(){
		return (this.cellType._dhx_find("tree") != -1);
	},
	
//#column_hidden:21092006{	
	/**
	*   @desc: hide/show row (warning! - this command doesn't affect row indexes, only visual appearance)
	*   @param: ind - column index
	*   @param: state - true/false - hide/show row
	*   @type:  public
	*/
	setRowHidden:function(id, state){
		var f = convertStringToBoolean(state);
		//var ind=this.getRowIndex(id);
		//if (id<0)
		//   return;
		var row = this.getRowById(id) //this.rowsCol[ind];
	
		if (!row)
			return;
	
		if (row.expand === "")
			this.collapseKids(row);
	
		if ((state)&&(row.style.display != "none")){
			row.style.display="none";
			var z = this.selectedRows._dhx_find(row);
	
			if (z != -1){
				row.className=row.className.replace("rowselected", "");
	
				for (var i = 0;
					i < row.childNodes.length;
					i++)row.childNodes[i].className=row.childNodes[i].className.replace(/cellselected/g, "");
				this.selectedRows._dhx_removeAt(z);
			}
			this.callEvent("onGridReconstructed", []);
		}
	
		if ((!state)&&(row.style.display == "none")){
			row.style.display="";
			this.callEvent("onGridReconstructed", []);
		}
		this.callEvent("onRowHide",[id, state]);
		this.setSizes();
	},
	
//#__pro_feature:21092006{
	/**
	*   @desc: hide/show column
	*   @param: ind - column index
	*   @param: state - true/false - hide/show column
	*   @type:  public
	*   @edition: Professional
	*/
	setColumnHidden:function(ind, state){
		if (!this.hdr.rows.length){
			if (!this._ivizcol)
				this._ivizcol=[];
			return this._ivizcol[ind]=state;
		}
	
		if ((this.fldSorted)&&(this.fldSorted.cellIndex == ind)&&(state))
			this.sortImg.style.display="none";
	
		var f = convertStringToBoolean(state);
	
		if (f){
			if (!this._hrrar)
				this._hrrar=new Array();
	
			else if (this._hrrar[ind])
				return;
			this._hrrar[ind]="display:none;";
			this._hideShowColumn(ind, "none");
		} else {
			if ((!this._hrrar)||(!this._hrrar[ind]))
				return;
			this._hrrar[ind]="";
			this._hideShowColumn(ind, "");
		}
	
		if ((this.fldSorted)&&(this.fldSorted.cellIndex == ind)&&(!state))
			this.sortImg.style.display="inline";
			
		this.setSortImgPos();
		this.callEvent("onColumnHidden",[ind,state])
	},
	
	
	/**
	*   @desc: get show/hidden status of column
	*   @param: ind - column index
	*   @type:  public
	*   @edition: Professional
	*   @returns:  if column hidden then true else false
	*/
	isColumnHidden:function(ind){
		if ((this._hrrar)&&(this._hrrar[ind]))
			return true;
	
		return false;
	},
	/**
	*   @desc: set list of visible/hidden columns
	*   @param: list - list of true/false separated by comma
	*   @type:  public
	*	@newmethod: setColumnsVisibility
	*   @edition: Professional
	*   @topic:0
	*/
	setColumnsVisibility:function(list){
		if (list)
			this._ivizcol=list.split(this.delim);
	
		if (this.hdr.rows.length&&this._ivizcol)
			for (var i = 0; i < this._ivizcol.length; i++)this.setColumnHidden(i, this._ivizcol[i]);
	},
	/**
	*   @desc: fix hidden state for column in all rows
	*   @type: private
	*/
	_fixHiddenRowsAll:function(pb, ind, prop, state, index){
		index=index||"_cellIndex";
		var z = pb.rows.length;
	
		for (var i = 0; i < z; i++){
			var x = pb.rows[i].childNodes;
	
			if (x.length != this._cCount){
				for (var j = 0; j < x.length; j++)
					if (x[j][index] == ind){
						x[j].style[prop]=state;
						break;
					}
			} else
				x[ind].style[prop]=state;
		}
	},
	/**
	*   @desc: hide column
	*   @param: ind - column index
	*   @param: state - hide/show
	*   @edition: Professional
	*   @type:  private
	*/
	_hideShowColumn:function(ind, state){
		var hind = ind;
	
		if (this.hdr.rows[1] && (this.hdr.rows[1]._childIndexes)&&(this.hdr.rows[1]._childIndexes[ind] != ind))
			hind=this.hdr.rows[1]._childIndexes[ind];
	
		if (state == "none"){
			this.hdr.rows[0].cells[ind]._oldWidth=this.hdr.rows[0].cells[ind].style.width||(this.initCellWidth[ind]+"px");
			this.hdr.rows[0].cells[ind]._oldWidthP=this.cellWidthPC[ind];
			this.obj.rows[0].cells[ind].style.width="0px";
	
			
			var t={rows:[this.obj.rows[0]]}
			this.forEachRow(function(id){
				if (this.rowsAr[id].tagName=="TR")
							t.rows.push(this.rowsAr[id])
			})
			this._fixHiddenRowsAll(t, ind, "display", "none");
	
			if (this.isTreeGrid())
				this._fixHiddenRowsAllTG(ind, "none");
	
			if ((_isOpera&&_OperaRv < 9)||_isKHTML||(_isFF)){ 
			    this._fixHiddenRowsAll(this.hdr, ind, "display", "none","_cellIndexS");
	
			}
			if (this.ftr)
				this._fixHiddenRowsAll(this.ftr.childNodes[0], ind, "display", "none");			
			this._fixHiddenRowsAll(this.hdr, ind, "whiteSpace", "nowrap","_cellIndexS");
	
			if (!this.cellWidthPX.length&&!this.cellWidthPC.length)
				this.cellWidthPX=[].concat(this.initCellWidth);
	
			if (this.cellWidthPX[ind])
				this.cellWidthPX[ind]=0;
	
			if (this.cellWidthPC[ind])
				this.cellWidthPC[ind]=0;
		} else {
			if (this.hdr.rows[0].cells[ind]._oldWidth){
				var zrow = this.hdr.rows[0].cells[ind];
	
				if (_isOpera||_isKHTML||(_isFF))
					this._fixHiddenRowsAll(this.hdr, ind, "display", "","_cellIndexS");
	
				if (this.ftr)
					this._fixHiddenRowsAll(this.ftr.childNodes[0], ind, "display", "");
	
				
				var t={rows:[this.obj.rows[0]]}
				this.forEachRow(function(id){
					if (this.rowsAr[id].tagName=="TR")
								t.rows.push(this.rowsAr[id])
				})
				this._fixHiddenRowsAll(t, ind, "display", "");
	
				if (this.isTreeGrid())
					this._fixHiddenRowsAllTG(ind, "");
	
				this._fixHiddenRowsAll(this.hdr, ind, "whiteSpace", "normal","_cellIndexS");
	
				if (zrow._oldWidthP)
					this.cellWidthPC[ind]=zrow._oldWidthP;
	
				if (zrow._oldWidth)
					this.cellWidthPX[ind]=parseInt(zrow._oldWidth);
			}
		}
		this.setSizes();
	
		if ((!_isIE)&&(!_isFF)){
			//dummy Opera/Safari fix
			this.obj.border=1;
			this.obj.border=0;
		}
	},
//#}	
//#}
//#__pro_feature:21092006{	
//#colspan:20092006{
	/**
	*   @desc: enable/disable colspan support
	*   @param: mode - true/false
	*   @type:  public
	*   @edition: Professional
	*/
	enableColSpan:function(mode){
		this._ecspn=convertStringToBoolean(mode);
	},
//#}
//#}
//#hovering:060402008{	
	/**
	*   @desc: enable/disable hovering row on mouse over
	*   @param: mode - true/false
	*   @param: cssClass - css class for hovering row
	*   @type:  public
	*/
	enableRowsHover:function(mode, cssClass){
		this._unsetRowHover(false,true);
		this._hvrCss=cssClass;
	
		if (convertStringToBoolean(mode)){
			if (!this._elmnh){
				this.obj._honmousemove=this.obj.onmousemove;
				this.obj.onmousemove=this._setRowHover;
	
				if (_isIE)
					this.obj.onmouseleave=this._unsetRowHover;
				else
					this.obj.onmouseout=this._unsetRowHover;
	
				this._elmnh=true;
			}
		} else {
			if (this._elmnh){
				this.obj.onmousemove=this.obj._honmousemove;
	
				if (_isIE)
					this.obj.onmouseleave=null;
				else
					this.obj.onmouseout=null;
	
				this._elmnh=false;
			}
		}
	},
//#}	
	/**
	*   @desc: enable/disable events which fire excell editing, mutual exclusive with enableLightMouseNavigation
	*   @param: click - true/false - enable/disable editing by single click
	*   @param: dblclick - true/false - enable/disable editing by double click
	*   @param: f2Key - enable/disable editing by pressing F2 key
	*   @type:  public
	*/
	enableEditEvents:function(click, dblclick, f2Key){
		this._sclE=convertStringToBoolean(click);
		this._dclE=convertStringToBoolean(dblclick);
		this._f2kE=convertStringToBoolean(f2Key);
	},
	
//#hovering:060402008{	
	/**
	*   @desc: enable/disable light mouse navigation mode (row selection with mouse over, editing with single click), mutual exclusive with enableEditEvents
	*   @param: mode - true/false
	*   @type:  public
	*/
	enableLightMouseNavigation:function(mode){
		if (convertStringToBoolean(mode)){
			if (!this._elmn){
				this.entBox._onclick=this.entBox.onclick;
				this.entBox.onclick=function(){
					return true;
				};
	
				this.obj._onclick=this.obj.onclick;
				this.obj.onclick=function(e){
					var c = this.grid.getFirstParentOfType(e ? e.target : event.srcElement, 'TD');
					if (!c) return;
					this.grid.editStop();
					this.grid.doClick(c);
					this.grid.editCell();
					(e||event).cancelBubble=true;
				}
	
				this.obj._onmousemove=this.obj.onmousemove;
				this.obj.onmousemove=this._autoMoveSelect;
				this._elmn=true;
			}
		} else {
			if (this._elmn){
				this.entBox.onclick=this.entBox._onclick;
				this.obj.onclick=this.obj._onclick;
				this.obj.onmousemove=this.obj._onmousemove;
				this._elmn=false;
			}
		}
	},
	
	
	/**
	*   @desc: remove hover state on row
	*   @type:  private
	*/
	_unsetRowHover:function(e, c){
		if (c)
			that=this;
		else
			that=this.grid;
	
		if ((that._lahRw)&&(that._lahRw != c)){
			for (var i = 0;
				i < that._lahRw.childNodes.length;
				i++)that._lahRw.childNodes[i].className=that._lahRw.childNodes[i].className.replace(that._hvrCss, "");
			that._lahRw=null;
		}
	},
	
	/**
	*   @desc: set hover state on row
	*   @type:  private
	*/
	_setRowHover:function(e){
		var c = this.grid.getFirstParentOfType(e ? e.target : event.srcElement, 'TD');
	
		if (c && c.parentNode!=this.grid._lahRw) {
			this.grid._unsetRowHover(0, c);
			c=c.parentNode;
	  		if (!c.idd || c.idd=="__filler__") return;
			for (var i = 0; i < c.childNodes.length; i++)c.childNodes[i].className+=" "+this.grid._hvrCss;
			this.grid._lahRw=c;
		}
		this._honmousemove(e);
	},
	
	/**
	*   @desc: onmousemove, used in light mouse navigaion mode
	*   @type:  private
	*/
	_autoMoveSelect:function(e){
		//this - grid.obj
		if (!this.grid.editor){
			var c = this.grid.getFirstParentOfType(e ? e.target : event.srcElement, 'TD');
	
			if (c.parentNode.idd)
				this.grid.doClick(c, true, 0);
		}
		this._onmousemove(e);
	},
//#}	
//#__pro_feature:21092006{
//#distrb_parsing:21092006{
	/**
	*   @desc: enable/disable distributed parsing (rows paresed portion by portion with some timeout)
	*   @param: mode - true/false
	*   @param: count - count of nodes parsed by one step (the 10 by default)
	*   @param: time - time between parsing counts in milli seconds (the 250 by default)
	*   @type:  public
	*   @edition: Professional
	*/
	enableDistributedParsing:function(mode, count, time){
		if (convertStringToBoolean(mode)){
			this._ads_count=count||10;
			this._ads_time=time||250;
		} else
			this._ads_count=0;
	},
//#}
//#}
	/**
		*     @desc: destructor, removes grid and cleans used memory
		*     @type: public
	  *     @topic: 0
		*/
	destructor:function(){
		this.editStop(true);
		//add links to current object
		if (this._sizeTime)
			this._sizeTime=window.clearTimeout(this._sizeTime);
		this.entBox.className=(this.entBox.className||"").replace(/gridbox.*/,"");
		if (this.formInputs)
			for (var i = 0; i < this.formInputs.length; i++)this.parentForm.removeChild(this.formInputs[i]);
	
		var a;
		this.xmlLoader=this.xmlLoader.destructor();
	
		for (var i = 0; i < this.rowsCol.length; i++)
			if (this.rowsCol[i])
				this.rowsCol[i].grid=null;
	
		for (i in this.rowsAr)
			if (this.rowsAr[i])
				this.rowsAr[i]=null;
	
		this.rowsCol=new dhtmlxArray();
		this.rowsAr={};
		this.entBox.innerHTML="";
		
		var dummy=function(){};
		this.entBox.onclick = this.entBox.onmousedown = this.entBox.onbeforeactivate = this.entBox.onbeforedeactivate = this.entBox.onbeforedeactivate = this.entBox.onselectstart = dummy;
		this.setSizes = this._update_srnd_view = this.callEvent = dummy;
		this.entBox.grid=this.objBox.grid=this.hdrBox.grid=this.obj.grid=this.hdr.grid=null;
		if (this._fake){
			this.globalBox.innerHTML = "";
			this._fake.setSizes = this._fake._update_srnd_view = this._fake.callEvent = dummy;
			this.globalBox.onclick = this.globalBox.onmousedown = this.globalBox.onbeforeactivate = this.globalBox.onbeforedeactivate = this.globalBox.onbeforedeactivate = this.globalBox.onselectstart = dummy;
		}
	
		for (a in this){
			if ((this[a])&&(this[a].m_obj))
				this[a].m_obj=null;
			this[a]=null;
		}
	
		if (this == globalActiveDHTMLGridObject)
			globalActiveDHTMLGridObject=null;
		//   self=null;
		return null;
	},
	
//#sorting:06042008{	
	/**
	*     @desc: get sorting state of grid
	*     @type: public
	*     @returns: array, first element is index of sortef column, second - direction of sorting ("asc" or "des").
	*     @topic: 0
	*/
	getSortingState:function(){
		var z = new Array();
	
		if (this.fldSorted){
			z[0]=this.fldSorted._cellIndex;
			z[1]=(this.sortImg.src.indexOf("sort_desc.gif") != -1) ? "des" : "asc";
		}
		return z;
	},
//#}
	
	/**
	*     @desc: enable autoheight of grid
	*     @param: mode - true/false
	*     @param: maxHeight - maximum height before scrolling appears (no limit by default)
	*     @param: countFullHeight - control the usage of maxHeight parameter - when set to true all grid height included in max height calculation, if false then only data part (no header) of grid included in calcualation (false by default)
	*     @type: public
	*     @topic: 0
	*/
	enableAutoHeight:function(mode, maxHeight, countFullHeight){
		this._ahgr=convertStringToBoolean(mode);
		this._ahgrF=convertStringToBoolean(countFullHeight);
		this._ahgrM=maxHeight||null;
		if (arguments.length == 1){
			this.objBox.style.overflowY=mode?"hidden":"auto";
		}
		if (maxHeight == "auto"){
			this._ahgrM=null;
			this._ahgrMA=true;
			this._setAutoResize();
		//   this._activeResize();
		}
	},
//#sorting:06042008{	
	enableStableSorting:function(mode){
		this._sst=convertStringToBoolean(mode);
		this.rowsCol.stablesort=function(cmp){
			var size = this.length-1;
	
			for (var i = 0; i < this.length-1; i++){
				for (var j = 0; j < size; j++)
					if (cmp(this[j], this[j+1]) > 0){
						var temp = this[j];
						this[j]=this[j+1];
						this[j+1]=temp;
					}
				size--;
			}
		}
	},
//#}
	
	/**
	*     @desc: enable/disable hot keys in grid
	*     @param: mode - true/false
	*     @type: public
	*     @topic: 0
	*/
	enableKeyboardSupport:function(mode){
		this._htkebl=!convertStringToBoolean(mode);
	},
	
//#context_menu:06042008{	
	/**
	*     @desc: enable/disable context menu
	*     @param: dhtmlxMenu object, if null - context menu will be disabled
	*     @type: public
	*     @topic: 0
	*/
	enableContextMenu:function(menu){
		this._ctmndx=menu;
	},
//#}	
	
	/*backward compatibility*/
	setScrollbarWidthCorrection:function(width){
	},
//#tooltips:06042008{	
	/**
	*     @desc: enable/disable tooltips for specified colums
	*     @param: list - list of true/false values, tooltips enabled for all columns by default
	*     @type: public
	*     @topic: 0
	*/
	enableTooltips:function(list){
		this._enbTts=list.split(",");
	
		for (var i = 0; i < this._enbTts.length; i++)this._enbTts[i]=convertStringToBoolean(this._enbTts[i]);
	},
//#}	
	
//#column_resize:06042008{
	/**
	*     @desc: enable/disable resizing for specified colums
	*     @param: list - list of true/false values, resizing enabled for all columns by default
	*     @type: public
	*     @topic: 0
	*/
	enableResizing:function(list){
		this._drsclmn=list.split(",");
	
		for (var i = 0; i < this._drsclmn.length; i++)this._drsclmn[i]=convertStringToBoolean(this._drsclmn[i]);
	},
	
	/**
	*     @desc: set minimum column width ( works only for manual resizing )
	*     @param: width - minimum column width, can be set for specified column, or as comma separated list for all columns
	*     @param: ind - column index
	*     @type: public
	*     @topic: 0
	*/
	setColumnMinWidth:function(width, ind){
		if (arguments.length == 2){
			if (!this._drsclmW)
				this._drsclmW=new Array();
			this._drsclmW[ind]=width;
		} else
			this._drsclmW=width.split(",");
	},
//#}	
	
	/**
	*     @desc: enable/disable unique id for cells (id will be automaticaly created using the following template: "c_[RowId]_[colIndex]")
	*     @param: mode - true/false - enable/disable
	*     @type: public
	*     @topic: 0
	*/
	enableCellIds:function(mode){
		this._enbCid=convertStringToBoolean(mode);
	},
	
	
//#locked_row:11052006{
	/**
	*     @desc: lock/unlock row for editing
	*     @param: rowId - id of row
	*     @param: mode - true/false - lock/unlock
	*     @type: public
	*     @topic: 0
	*/
	lockRow:function(rowId, mode){
		var z = this.getRowById(rowId);
	
		if (z){
			z._locked=convertStringToBoolean(mode);
	
			if ((this.cell)&&(this.cell.parentNode.idd == rowId))
				this.editStop();
		}
	},
//#}
	
	/**
	*   @desc:  get values of all cells in row
	*   @type:  private
	*/
	_getRowArray:function(row){
		var text = new Array();
	
		for (var ii = 0; ii < row.childNodes.length; ii++){
			var a = this.cells3(row, ii);
			text[ii]=a.getValue();
		}
	
		return text;
	},
//#__pro_feature:21092006{	
//#data_format:12052006{
	/**
	*     @desc: set mask for date formatting in cell
	*     @param: mask - date mask, d,m,y will mean day,month,year; for example "d/m/y" - 22/05/1985
	*     @type: public
	*     @edition: Professional
	*     @topic: 0
	*/
	setDateFormat:function(mask,incoming){
		this._dtmask=mask;
		this._dtmask_inc=incoming;
	},
	
	/**
	*     @desc: set mask for formatting numeric data ( works for [ed/ro]n excell only or oher cell types with suport for this method)
	*     @param: mask - numeric mask; for example 0,000.00 - 1,234.56
	*     @param: cInd - column index
	*     @param: p_sep - char used as decimalseparator ( point by default )
	*     @param: d_sep - char used as groups part separator ( comma by default )
	*     @type: public
	*     @edition: Professional
	*     @topic: 0
	*/
	setNumberFormat:function(mask, cInd, p_sep, d_sep){
		var nmask = mask.replace(/[^0\,\.]*/g, "");
		var pfix = nmask.indexOf(".");
	
		if (pfix > -1)
			pfix=nmask.length-pfix-1;
		var dfix = nmask.indexOf(",");
	
		if (dfix > -1)
			dfix=nmask.length-pfix-2-dfix;
		if (typeof p_sep != "string")
			p_sep=this.i18n.decimal_separator;
		if (typeof d_sep != "string")
			d_sep=this.i18n.group_separator;
		var pref = mask.split(nmask)[0];
		var postf = mask.split(nmask)[1];
		this._maskArr[cInd]=[
			pfix,
			dfix,
			pref,
			postf,
			p_sep,
			d_sep
		];
	},
	/**
	*   @desc:  convert formated value to original
	*   @type:  private
	*/
	_aplNFb:function(data, ind){
		var a = this._maskArr[ind];
	
		if (!a)
			return data;
	
		var ndata = parseFloat(data.toString().replace(/[^0-9]*/g, ""));
	
		if (data.toString().substr(0, 1) == "-")
			ndata=ndata*-1;
	
		if (a[0] > 0)
			ndata=ndata / Math.pow(10, a[0]);
		return ndata;
	},
	
	/**
	*   @desc:  format data with mask
	*   @type:  private
	*/
	_aplNF:function(data, ind){
		var a = this._maskArr[ind];
	
		if (!a)
			return data;
	
		var c = (parseFloat(data) < 0 ? "-" : "")+a[2];
		data=Math.abs(Math.round(parseFloat(data)*Math.pow(10, a[0] > 0 ? a[0] : 0))).toString();
		data=(data.length
			< a[0]
				? Math.pow(10, a[0]+1-data.length).toString().substr(1, a[0]+1)+data.toString()
				: data).split("").reverse();
		data[a[0]]=(data[a[0]]||"0")+a[4];
	
		if (a[1] > 0)
			for (var j = (a[0] > 0 ? 0 : 1)+a[0]+a[1]; j < data.length; j+=a[1])data[j]+=a[5];
		return c+data.reverse().join("")+a[3];
	},
//#}
//#}	
	
//#config_from_xml:20092006{
	
	/**
	*   @desc:  configure grid structure from XML
	*   @type:  private
	*/
	_launchCommands:function(arr){
		for (var i = 0; i < arr.length; i++){
			var args = new Array();
	
			for (var j = 0; j < arr[i].childNodes.length; j++)
				if (arr[i].childNodes[j].nodeType == 1)
					args[args.length]=arr[i].childNodes[j].firstChild.data;
	
			this[arr[i].getAttribute("command")].apply(this, args);
		}
	},
	
	
	/**
	*   @desc:  configure grid structure from XML
	*   @type:  private
	*/
	_parseHead:function(xmlDoc){
		var hheadCol = this.xmlLoader.doXPath("./head", xmlDoc);
	
		if (hheadCol.length){
			var headCol = this.xmlLoader.doXPath("./column", hheadCol[0]);
			var asettings = this.xmlLoader.doXPath("./settings", hheadCol[0]);
			var awidthmet = "setInitWidths";
			var split = false;
	
			if (asettings[0]){
				for (var s = 0; s < asettings[0].childNodes.length; s++)switch (asettings[0].childNodes[s].tagName){
					case "colwidth":
						if (asettings[0].childNodes[s].firstChild&&asettings[0].childNodes[s].firstChild.data == "%")
							awidthmet="setInitWidthsP";
						break;
	
					case "splitat":
						split=(asettings[0].childNodes[s].firstChild ? asettings[0].childNodes[s].firstChild.data : false);
						break;
				}
			}
			this._launchCommands(this.xmlLoader.doXPath("./beforeInit/call", hheadCol[0]));
	
			if (headCol.length > 0){
			    if (this.hdr.rows.length > 0) this.clearAll(true); //drop existing grid here, to prevent loss of initialization parameters
				var sets = [
					[],
					[],
					[],
					[],
					[],
					[],
					[],
					[],
					[]
				];
	
				var attrs = ["", "width", "type", "align", "sort", "color", "format", "hidden", "id"];
				var calls = ["", awidthmet, "setColTypes", "setColAlign", "setColSorting", "setColumnColor", "",
					"", "setColumnIds"];
	
				for (var i = 0; i < headCol.length; i++){
					for (var j = 1; j < attrs.length; j++)sets[j].push(headCol[i].getAttribute(attrs[j]));
					sets[0].push((headCol[i].firstChild
						? headCol[i].firstChild.data
						: "").replace(/^\s*((\s\S)*.+)\s*$/gi, "$1"));
				};
	
				this.setHeader(sets[0]);
				for (var i = 0; i < calls.length; i++)
					if (calls[i])
						this[calls[i]](sets[i].join(this.delim))
	
				for (var i = 0; i < headCol.length; i++){
					if ((this.cellType[i].indexOf('co') == 0)||(this.cellType[i] == "clist")){
						var optCol = this.xmlLoader.doXPath("./option", headCol[i]);
	
						if (optCol.length){
							var resAr = new Array();
	
							if (this.cellType[i] == "clist"){
								for (var j = 0;
									j < optCol.length;
									j++)resAr[resAr.length]=optCol[j].firstChild
									? optCol[j].firstChild.data
									: "";
	
								this.registerCList(i, resAr);
							} else {
								var combo = this.getCombo(i);
	
								for (var j = 0;
									j < optCol.length;
									j++)combo.put(optCol[j].getAttribute("value"),
									optCol[j].firstChild
										? optCol[j].firstChild.data
										: "");
							}
						}
					}
	
					else if (sets[6][i])
						if ((this.cellType[i].toLowerCase().indexOf("calendar")!=-1)||(this.fldSort[i] == "date"))
							this.setDateFormat(sets[6][i]);
						else
							this.setNumberFormat(sets[6][i], i);
				}
	
				this.init();
	
	            var param=sets[7].join(this.delim);
	            //preserving state of hidden columns, if not specified directly
				if (this.setColHidden && param.replace(/,/g,"")!="")
					this.setColHidden(param);
	
				if ((split)&&(this.splitAt))
					this.splitAt(split);
			}
			this._launchCommands(this.xmlLoader.doXPath("./afterInit/call", hheadCol[0]));
		}
		//global(grid) user data
		var gudCol = this.xmlLoader.doXPath("//rows/userdata", xmlDoc);
	
		if (gudCol.length > 0){
			
			if (!this.UserData["gridglobaluserdata"])
				this.UserData["gridglobaluserdata"]=new Hashtable();
	
			for (var j = 0; j < gudCol.length; j++){
				var u_record = "";
				for (var xj=0; xj < gudCol[j].childNodes.length; xj++)
					u_record += gudCol[j].childNodes[xj].nodeValue;
				this.UserData["gridglobaluserdata"].put(gudCol[j].getAttribute("name"),u_record);
			}
		}
	},
	
	
//#}
	
	
	/**
	*   @desc: get list of Ids of all rows with checked exCell in specified column
	*   @type: public
	*   @param: col_ind - column index
	*   @topic: 5
	*/
	getCheckedRows:function(col_ind){
		var d = new Array();
		this.forEachRowA(function(id){
			if (this.cells(id, col_ind).getValue() != 0)
				d.push(id);
		},true);
		return d.join(",");
	},
	/**
	*   @desc: check all checkboxes in grid
	*   @type: public
	*   @param: col_ind - column index
	*   @topic: 5
	*/	
	checkAll:function(){var mode=arguments.length?arguments[0]:1;
		 for (var cInd=0;cInd<this.getColumnsNum();cInd++){if(this.getColType(cInd)=="ch")this.setCheckedRows(cInd,mode)}},
	/**
	*   @desc: uncheck all checkboxes in grid
	*   @type: public
	*   @param: col_ind - column index
	*   @topic: 5
	*/	
	uncheckAll:function(){ this.checkAll(0); },
	/**
	*   @desc: set value for all checkboxes in specified column
	*   @type: public
	*   @param: col_ind - column index
	*   @topic: 5
	*/	
	setCheckedRows:function(cInd,v){this.forEachRowA(function(id){if(this.cells(id,cInd).isCheckbox())this.cells(id,cInd).setValue(v)})},
//#tooltips:06042008{	
	/**
	*   @desc:  grid body onmouseover function
	*   @type:  private
	*/
	_drawTooltip:function(e){
		var c = this.grid.getFirstParentOfType(e ? e.target : event.srcElement, 'TD');
	
		if (!c || ((this.grid.editor)&&(this.grid.editor.cell == c)))
			return true;
	
		var r = c.parentNode;
	
		if (!r.idd||r.idd == "__filler__")
			return;
		var el = (e ? e.target : event.srcElement);
	
		if (r.idd == window.unknown)
			return true;
	
		if (!this.grid.callEvent("onMouseOver", [
			r.idd,
			c._cellIndex,
			(e||window.event)
		]))
			return true;
	
		if ((this.grid._enbTts)&&(!this.grid._enbTts[c._cellIndex])){
			if (el.title)
				el.title='';
			return true;
		}
	
		if (c._cellIndex >= this.grid._cCount)
			return;
		var ced = this.grid.cells3(r, c._cellIndex);
		if (!ced || !ced.cell || !ced.cell._attrs) return; // fix for public release
	
		if (el._title)
			ced.cell.title="";
	
		if (!ced.cell._attrs['title'])
			el._title=true;
	
		if (ced)
			el.title=ced.cell._attrs['title']
				||(ced.getTitle
					? ced.getTitle()
					: (ced.getValue()||"").toString().replace(/<[^>]*>/gi, ""));
	
		return true;
	},
//#}	
	/**
	*   @desc:  can be used for setting correction for cell padding, while calculation setSizes
	*   @type:  private
	*/
	enableCellWidthCorrection:function(size){
		if (_isFF)
			this._wcorr=parseInt(size);
	},
	
	
	/**
	*	@desc: gets a list of all row ids in grid
	*	@param: separator - delimiter to use in list
	*	@returns: list of all row ids in grid
	*	@type: public
	*	@topic: 2,7
	*/
	getAllRowIds:function(separator){
		var ar = [];
	
		for (var i = 0; i < this.rowsBuffer.length; i++)
			if (this.rowsBuffer[i])
				ar.push(this.rowsBuffer[i].idd);
	
		return ar.join(separator||this.delim)
	},
	getAllItemIds:function(){
		return this.getAllRowIds();
	},
	
//#__pro_feature:21092006{	
//#colspan:20092006{
	
	/**
	*   @desc: dynamicaly set colspan in row starting from specified column index
	*   @param: row_id - row id
	*   @param: col_id - index of column
	*   @param: colspan - size of colspan
	*   @type: public
	*   @edition: Professional
	*   @topic: 2,9
	*/
	setColspan:function(row_id, col_ind, colspan){
		if (!this._ecspn)
			return;
	
		var r = this.getRowById(row_id);
	
		if ((r._childIndexes)&&(r.childNodes[r._childIndexes[col_ind]])){
			var j = r._childIndexes[col_ind];
			var n = r.childNodes[j];
			var m = n.colSpan;
			n.colSpan=1;
	
			if ((m)&&(m != 1))
				for (var i = 1; i < m; i++){
					var c = document.createElement("TD");
	
					if (n.nextSibling)
						r.insertBefore(c, n.nextSibling);
					else
						r.appendChild(c);
					r._childIndexes[col_ind+i]=j+i;
					c._cellIndex=col_ind+i;
					c.style.textAlign=this.cellAlign[i];
					c.style.verticalAlign=this.cellVAlign[i];
					n=c;
					this.cells3(r, col_ind+i).setValue("");
				}
	
			for (var z = col_ind*1+1*m; z < r._childIndexes.length; z++){
				r._childIndexes[z]+=(m-1)*1;
			}
		}
	
		if ((colspan)&&(colspan > 1)){
			if (r._childIndexes)
				var j = r._childIndexes[col_ind];
			else {
				var j = col_ind;
				r._childIndexes=new Array();
	
				for (var z = 0; z < r.childNodes.length; z++)r._childIndexes[z]=z;
			}
	
			r.childNodes[j].colSpan=colspan;
	
			for (var z = 1; z < colspan; z++){
				r._childIndexes[r.childNodes[j+1]._cellIndex]=j;
				r.removeChild(r.childNodes[j+1]);
			}
	
			var c1 = r.childNodes[r._childIndexes[col_ind]]._cellIndex;
	
			for (var z = c1*1+1*colspan; z < r._childIndexes.length; z++)r._childIndexes[z]-=(colspan-1);
		}
	},
	
//#}
//#}
	
	/**
	*   @desc: prevent caching in IE  by adding random values to URL string
	*   @param: mode - enable/disable random values in URLs ( disabled by default )
	*   @type: public
	*   @topic: 2,9
	*/
	preventIECaching:function(mode){
		this.no_cashe=convertStringToBoolean(mode);
		this.xmlLoader.rSeed=this.no_cashe;
	},
	enableColumnAutoSize:function(mode){
		this._eCAS=convertStringToBoolean(mode);
	},
	/**
	*   @desc: called when header was dbllicked
	*   @type: private
	*   @topic: 1,2
	*/
	_onHeaderDblClick:function(e){
		var that = this.grid;
		var el = that.getFirstParentOfType(_isIE ? event.srcElement : e.target, "TD");
	
		if (!that._eCAS)
			return false;
		that.adjustColumnSize(el._cellIndexS)
	},
	
	/**
	*   @desc: autosize column  to max content size
	*   @param: cInd - index of column
	*   @type:  public
	*/
	adjustColumnSize:function(cInd, complex){
		if (this._hrrar && this._hrrar[cInd]) return;
		this._notresize=true;
		var m = 0;
		this._setColumnSizeR(cInd, 20);
	
		for (var j = 1; j < this.hdr.rows.length; j++){
			var a = this.hdr.rows[j];
			a=a.childNodes[(a._childIndexes) ? a._childIndexes[cInd] : cInd];
	
			if ((a)&&((!a.colSpan)||(a.colSpan < 2)) && a._cellIndex==cInd){
				if ((a.childNodes[0])&&(a.childNodes[0].className == "hdrcell"))
					a=a.childNodes[0];
				m=Math.max(m, a.scrollWidth);
			}
		}
	
		var l = this.obj.rows.length;
	
		for (var i = 1; i < l; i++){
			var z = this.obj.rows[i];
			if (!this.rowsAr[z.idd]) continue;
			
			if (z._childIndexes&&z._childIndexes[cInd] != cInd || !z.childNodes[cInd])
				continue;
	
			if (_isFF||_isOpera||complex)
				z=z.childNodes[cInd].textContent.length*this.fontWidth;
			else
				z=z.childNodes[cInd].scrollWidth;
	
			if (z > m)
				m=z;
		}
		m+=20+(complex||0);
	
		this._setColumnSizeR(cInd, m);
		this._notresize=false;
		this.setSizes();
	},
	
//#header_footer:06042008{
	/**
	*   @desc: remove header line from grid (opposite to attachHeader)
	*   @param: index - index of row to be removed ( zero based )
	*	@param: hdr - header object (optional)
	*   @type:  public
	*/
	detachHeader:function(index, hdr){
		hdr=hdr||this.hdr;
		var row = hdr.rows[index+1];
	
		if (row)
			row.parentNode.removeChild(row);
		this.setSizes();
	},
	
	/**
	*   @desc: remove footer line from grid (opposite to attachFooter)
	*   @param: values - array of header titles
	*   @type:  public
	*/
	detachFooter:function(index){
		this.detachHeader(index, this.ftr);
	},
	
	/**
	*   @desc: attach additional line to header
	*   @param: values - array of header titles
	*   @param: style - array of styles, optional
	*	@param: _type - reserved
	*   @type:  public
	*/
	attachHeader:function(values, style, _type){
		if (typeof (values) == "string")
			values=this._eSplit(values);
	
		if (typeof (style) == "string")
			style=style.split(this.delim);
		_type=_type||"_aHead";
	
		if (this.hdr.rows.length){
			if (values)
				this._createHRow([
					values,
					style
				], this[(_type == "_aHead") ? "hdr" : "ftr"]);
	
			else if (this[_type])
				for (var i = 0; i < this[_type].length; i++)this.attachHeader.apply(this, this[_type][i]);
		} else {
			if (!this[_type])
				this[_type]=new Array();
			this[_type][this[_type].length]=[
				values,
				style,
				_type
			];
		}
	},
	/**
	*	@desc:
	*	@type: private
	*/
	_createHRow:function(data, parent){
		if (!parent){
			if (this.entBox.style.position!="absolute")
				this.entBox.style.position="relative";
			var z = document.createElement("DIV");
			z.className="c_ftr".substr(2);
			this.entBox.appendChild(z);
			var t = document.createElement("TABLE");
			t.cellPadding=t.cellSpacing=0;
	
			if (!_isIE || _isIE == 8){
				t.width="100%";
				t.style.paddingRight="20px";
			}
			t.style.marginRight="20px";
			t.style.tableLayout="fixed";
	
			z.appendChild(t);
			t.appendChild(document.createElement("TBODY"));
			this.ftr=parent=t;
	
			var hdrRow = t.insertRow(0);
			var thl = ((this.hdrLabels.length <= 1) ? data[0].length : this.hdrLabels.length);
	
			for (var i = 0; i < thl; i++){
				hdrRow.appendChild(document.createElement("TH"));
				hdrRow.childNodes[i]._cellIndex=i;
			}
	
			if (_isIE && _isIE<8)
				hdrRow.style.position="absolute";
			else
				hdrRow.style.height='auto';
		}
		var st1 = data[1];
		var z = document.createElement("TR");
		parent.rows[0].parentNode.appendChild(z);
	
		for (var i = 0; i < data[0].length; i++){
			if (data[0][i] == "#cspan"){
				var pz = z.cells[z.cells.length-1];
				pz.colSpan=(pz.colSpan||1)+1;
				continue;
			}
	
			if ((data[0][i] == "#rspan")&&(parent.rows.length > 1)){
				var pind = parent.rows.length-2;
				var found = false;
				var pz = null;
	
				while (!found){
					var pz = parent.rows[pind];
	
					for (var j = 0; j < pz.cells.length; j++)
						if (pz.cells[j]._cellIndex == i){
							found=j+1;
							break;
						}
					pind--;
				}
	
				pz=pz.cells[found-1];
				pz.rowSpan=(pz.rowSpan||1)+1;
				continue;
			//            data[0][i]="";
			}
	
			var w = document.createElement("TD");
			w._cellIndex=w._cellIndexS=i;
			if (this._hrrar && this._hrrar[i] && !_isIE)
				w.style.display='none';

			if (typeof data[0][i] == "object")
				w.appendChild(data[0][i]);
			else {
				if (this.forceDivInHeader)
					w.innerHTML="<div class='hdrcell'>"+(data[0][i]||"&nbsp;")+"</div>";
				else
					w.innerHTML=(data[0][i]||"&nbsp;");
		
				if ((data[0][i]||"").indexOf("#") != -1){
					var t = data[0][i].match(/(^|{)#([^}]+)(}|$)/);
		
					if (t){
						var tn = "_in_header_"+t[2];
		
						if (this[tn])
							this[tn]((this.forceDivInHeader ? w.firstChild : w), i, data[0][i].split(t[0]));
					}
				}
			}
			if (st1)
				w.style.cssText=st1[i];
	
			z.appendChild(w);
		}
		var self = parent;
	
		if (_isKHTML){
			if (parent._kTimer)
				window.clearTimeout(parent._kTimer);
			parent._kTimer=window.setTimeout(function(){
				parent.rows[1].style.display='none';
				window.setTimeout(function(){
					parent.rows[1].style.display='';
				}, 1);
			}, 500);
		}
	},
//#__pro_feature:21092006{	
	/**
	*   @desc: attach additional line to footer
	*   @param: values - array of header titles
	*   @param: style - array of styles, optional
	*   @edition: Professional
	*   @type:  public
	*/
	attachFooter:function(values, style){
		this.attachHeader(values, style, "_aFoot");
	},
//#}
//#}
//#__pro_feature:21092006{
//#dyn_cell_types:04062008{
	/**
	*   @desc: set excell type for cell in question
	*   @param: rowId - row ID
	*   @param: cellIndex - cell index
	*   @param: type - type of excell (code like "ed", "txt", "ch" etc.)
	*   @edition: Professional
	*   @type:  public
	*/
	setCellExcellType:function(rowId, cellIndex, type){
		this.changeCellType(this.getRowById(rowId), cellIndex, type);
	},
	/**
	*	@desc: 
	*	@type: private
	*/
	changeCellType:function(r, ind, type){
		type=type||this.cellType[ind];
		var z = this.cells3(r, ind);
		var v = z.getValue();
		z.cell._cellType=type;
		var z = this.cells3(r, ind);
		z.setValue(v);
	},
	/**
	*   @desc: set excell type for all cells in specified row
	*   @param: rowId - row ID
	*   @param: type - type of excell
	*   @edition: Professional
	*   @type:  public
	*/
	setRowExcellType:function(rowId, type){
		var z = this.rowsAr[rowId];
	
		for (var i = 0; i < z.childNodes.length; i++)this.changeCellType(z, i, type);
	},
	/**
	*   @desc: set excell type for all cells in specified column
	*   @param: colIndex - column index
	*   @param: type - type of excell
	*   @edition: Professional
	*   @type:  public
	*/
	setColumnExcellType:function(colIndex, type){
		for (var i = 0; i < this.rowsBuffer.length; i++)
			if (this.rowsBuffer[i] && this.rowsBuffer[i].tagName=="TR")
				this.changeCellType(this.rowsBuffer[i], colIndex, type);
		if (this.cellType[colIndex]=="math")
			this._strangeParams[i]=type;
		else
			this.cellType[colIndex]=type;
	},
	
//#}
//#}

	/**
	*   @desc: execute code for each row in a grid
	*   @param: custom_code - function which get row id as incomming argument
	*   @type:  public
	*/
	forEachRow:function(custom_code){
		for (var a in this.rowsAr)
			if (this.rowsAr[a]&&this.rowsAr[a].idd)
				custom_code.apply(this, [this.rowsAr[a].idd]);
	},
	forEachRowA:function(custom_code){
		for (var a =0; a<this.rowsBuffer.length; a++){
			if (this.rowsBuffer[a])
				custom_code.call(this, this.render_row(a).idd);
		}
	},
	/**
	*   @desc: execute code for each cell in a row
	*   @param: rowId - id of row where cell must be itterated
	*   @param: custom_code - function which get eXcell object as incomming argument
	*   @type:  public
	*/
	forEachCell:function(rowId, custom_code){
		var z = this.getRowById(rowId);
	
		if (!z)
			return;
	
		for (var i = 0; i < this._cCount; i++) custom_code(this.cells3(z, i),i);
	},
	/**
	*   @desc: changes grid's container size on the fly to fit total width of grid columns
	*   @param: mode  - truse/false - enable / disable
	*   @param: max_limit  - max allowed width, not limited by default
	*   @param: min_limit  - min allowed width, not limited by default
	*   @type:  public
	*/
	enableAutoWidth:function(mode, max_limit, min_limit){
		this._awdth=[
			convertStringToBoolean(mode),
			parseInt(max_limit||99999),
			parseInt(min_limit||0)
		];
		if (arguments.length == 1)
			this.objBox.style.overflowX=mode?"hidden":"auto";
	},
//#update_from_xml:06042008{	
	/**
	*   @desc: refresh grid from XML ( doesnt work for buffering, tree grid or rows in smart rendering mode )
	*   @param: insert_new - insert new items
	*   @param: del_missed - delete missed rows
	*   @param: afterCall - function, will be executed after refresh completted
	*   @type:  public
	*/
	
	updateFromXML:function(url, insert_new, del_missed, afterCall){
		if (typeof insert_new == "undefined")
			insert_new=true;
		this._refresh_mode=[
			true,
			insert_new,
			del_missed
		];
		this.load(url,afterCall)
	},
	_refreshFromXML:function(xml){
		if (this._f_rowsBuffer) this.filterBy(0,"");
		reset = false;
		if (window.eXcell_tree){
			eXcell_tree.prototype.setValueX=eXcell_tree.prototype.setValue;
			eXcell_tree.prototype.setValue=function(content){
				var r=this.grid._h2.get[this.cell.parentNode.idd]
				if (r && this.cell.parentNode.valTag){
					this.setLabel(content);
				} else
					this.setValueX(content);
			};
		}
	
		var tree = this.cellType._dhx_find("tree");
			xml.getXMLTopNode("rows");
		var pid = xml.doXPath("//rows")[0].getAttribute("parent")||0;
	
		var del = {
		};
	
		if (this._refresh_mode[2]){
			if (tree != -1)
				this._h2.forEachChild(pid, function(obj){
					del[obj.id]=true;
				}, this);
			else
				this.forEachRow(function(id){
					del[id]=true;
				});
		}
	
		var rows = xml.doXPath("//row");
	
		for (var i = 0; i < rows.length; i++){
			var row = rows[i];
			var id = row.getAttribute("id");
			del[id]=false;
			var pid = row.parentNode.getAttribute("id")||pid;
	
			if (this.rowsAr[id] && this.rowsAr[id].tagName!="TR"){
				if (this._h2)
					this._h2.get[id].buff.data=row;
				else
					this.rowsBuffer[this.getRowIndex(id)].data=row;
				this.rowsAr[id]=row;
			} else if (this.rowsAr[id]){
					this._process_xml_row(this.rowsAr[id], row, -1);
					this._postRowProcessing(this.rowsAr[id],true)
				} else if (this._refresh_mode[1]){
					var dadd={
						idd: id,
						data: row,
						_parser: this._process_xml_row,
						_locator: this._get_xml_data
					};
					
					var render_index = this.rowsBuffer.length;
					if (this._refresh_mode[1]=="top"){
						this.rowsBuffer.unshift(dadd);
						render_index = 0;
					} else
						this.rowsBuffer.push(dadd);
						
					if (this._h2){ 
						reset=true;
						(this._h2.add(id,(row.parentNode.getAttribute("id")||row.parentNode.getAttribute("parent")))).buff=this.rowsBuffer[this.rowsBuffer.length-1];
					}
						
					this.rowsAr[id]=row;
					row=this.render_row(render_index);
					this._insertRowAt(row,render_index?-1:0)
				}
		}
				
		if (this._refresh_mode[2])
			for (id in del){
				if (del[id]&&this.rowsAr[id])
					this.deleteRow(id);
			}
	
		this._refresh_mode=null;
		if (window.eXcell_tree)
			eXcell_tree.prototype.setValue=eXcell_tree.prototype.setValueX;
			
		if (reset) this._renderSort();
		if (this._f_rowsBuffer) {
			this._f_rowsBuffer = null;
			this.filterByAll();
		}
	},
//#}	
//#co_excell:06042008{
	/**
	*   @desc: get combobox specific for cell in question
	*   @param: id - row id
	*   @param: ind  - column index
	*   @type:  public
	*/
	getCustomCombo:function(id, ind){
		var cell = this.cells(id, ind).cell;
	
		if (!cell._combo)
			cell._combo=new dhtmlXGridComboObject();
		return cell._combo;
	},
//#}
	/**
	*   @desc: set tab order of columns
	*   @param: order - list of tab indexes (default delimiter is ",")
	*   @type:  public
	*/
	setTabOrder:function(order){
		var t = order.split(this.delim);
		this._tabOrder=[];
		var max=this._cCount||order.length;
	
		for (var i = 0; i < max; i++)t[i]={
			c: parseInt(t[i]),
			ind: i
			};
		t.sort(function(a, b){
			return (a.c > b.c ? 1 : -1);
		});
	
		for (var i = 0; i < max; i++)
			if (!t[i+1]||( typeof t[i].c == "undefined"))
				this._tabOrder[t[i].ind]=(t[0].ind+1)*-1;
			else
				this._tabOrder[t[i].ind]=t[i+1].ind;
	},
	
	i18n:{
		loading: "Loading",
		decimal_separator:".",
		group_separator:","
	},
	
	//key_ctrl_shift
	_key_events:{
		k13_1_0: function(){
			var rowInd = this.rowsCol._dhx_find(this.row)
			this.selectCell(this.rowsCol[rowInd+1], this.cell._cellIndex, true);
		},
		k13_0_1: function(){
			var rowInd = this.rowsCol._dhx_find(this.row)
			this.selectCell(this.rowsCol[rowInd-1], this.cell._cellIndex, true);
		},
		k13_0_0: function(){
			this.editStop();
			this.callEvent("onEnter", [
				(this.row ? this.row.idd : null),
				(this.cell ? this.cell._cellIndex : null)
			]);
			this._still_active=true;
		},
		k9_0_0: function(){
			this.editStop();
			if (!this.callEvent("onTab",[true])) return true;
			var z = this._getNextCell(null, 1);
		
			if (z){
				this.selectCell(z.parentNode, z._cellIndex, (this.row != z.parentNode), false, true);
				this._still_active=true;
			}
		},
		k9_0_1: function(){
			this.editStop();
			if (!this.callEvent("onTab",[false])) return false;
			var z = this._getNextCell(null, -1);
	
			if (z){
				this.selectCell(z.parentNode, z._cellIndex, (this.row != z.parentNode), false, true);
				this._still_active=true;
			}
		},
		k113_0_0: function(){
			if (this._f2kE)
				this.editCell();
		},
		k32_0_0: function(){
			var c = this.cells4(this.cell);
	
			if (!c.changeState||(c.changeState() === false))
				return false;
		},
		k27_0_0: function(){
			this.editStop(true);
		},
		k33_0_0: function(){
			if (this.pagingOn)
				this.changePage(this.currentPage-1);
			else
				this.scrollPage(-1);
		},
		k34_0_0: function(){
			if (this.pagingOn)
				this.changePage(this.currentPage+1);
			else
				this.scrollPage(1);
		},
		k37_0_0: function(){
			if (!this.editor&&this.isTreeGrid())
				this.collapseKids(this.row)
			else
				return false;
		},
		k39_0_0: function(){
			if (!this.editor&&this.isTreeGrid())
				this.expandKids(this.row)
			else
				return false;
		},
		k40_0_0: function(){
			var master = this._realfake?this._fake:this;
			if (this.editor&&this.editor.combo)
				this.editor.shiftNext();
			else {
				if (!this.row.idd) return;
				var rowInd = Math.max((master._r_select||0),this.getRowIndex(this.row.idd));
				var row = this._nextRow(rowInd, 1);
				if (row){
					master._r_select=null;
					this.selectCell(row, this.cell._cellIndex, true);
					if (master.pagingOn) master.showRow(row.idd);
				} else {
					if (!this.callEvent("onLastRow", [])) return false;
					this._key_events.k34_0_0.apply(this, []);
					if (this.pagingOn && this.rowsCol[rowInd+1])
						this.selectCell(rowInd+1, 0, true);
				}
			}
			this._still_active=true;
		},
		k38_0_0: function(){
			var master = this._realfake?this._fake:this;
			if (this.editor&&this.editor.combo)
				this.editor.shiftPrev();
			else {
				if (!this.row.idd) return;
				var rowInd = this.getRowIndex(this.row.idd)+1;
				if (rowInd != -1 && (!this.pagingOn || (rowInd!=1))){
					var nrow = this._nextRow(rowInd-1, -1);
					this.selectCell(nrow, this.cell._cellIndex, true);
					if (master.pagingOn && nrow) master.showRow(nrow.idd);
				} else {
					this._key_events.k33_0_0.apply(this, []);
					/*
					if (this.pagingOn && this.rowsCol[this.rowsBufferOutSize-1])
						this.selectCell(this.rowsBufferOutSize-1, 0, true);
						*/
				}
			}
			this._still_active=true;
		}
	},
	
	//(c)dhtmlx ltd. www.dhtmlx.com
	
	_build_master_row:function(){
		var t = document.createElement("DIV");
		var html = ["<table><tr>"];
	
		for (var i = 0; i < this._cCount; i++)html.push("<td></td>");
		html.push("</tr></table>");
		t.innerHTML=html.join("");
		this._master_row=t.firstChild.rows[0];
	},
	
	_prepareRow:function(new_id){ /*TODO: hidden columns */
		if (!this._master_row)
			this._build_master_row();
	
		var r = this._master_row.cloneNode(true);
	
		for (var i = 0; i < r.childNodes.length; i++){
			r.childNodes[i]._cellIndex=i;
	        if (this._enbCid) r.childNodes[i].id="c_"+new_id+"_"+i;
			if (this.dragAndDropOff)
				this.dragger.addDraggableItem(r.childNodes[i], this);
		}
		r.idd=new_id;
		r.grid=this;
	
		return r;
	},
	
//#non_xml_data:06042008{
	_process_jsarray_row:function(r, data){
		r._attrs={
		};
	
		for (var j = 0; j < r.childNodes.length; j++)r.childNodes[j]._attrs={
		};
	
		this._fillRow(r, (this._c_order ? this._swapColumns(data) : data));
		return r;
	},
	_get_jsarray_data:function(data, ind){
		return data[ind];
	},
	_process_json_row:function(r, data){
		data = this._c_order ? this._swapColumns(data.data) : data.data;
		return this._process_some_row(r, data);
	},
	_process_some_row:function(r,data){
		r._attrs={};
	
		for (var j = 0; j < r.childNodes.length; j++)
			r.childNodes[j]._attrs={};
	
		this._fillRow(r, data);
		return r;
	},
	_get_json_data:function(data, ind){
		return data.data[ind];
	},


	_process_js_row:function(r, data){
		var arr = [];
		for (var i=0; i<this.columnIds.length; i++){
			arr[i] = data[this.columnIds[i]];
			if (!arr[i] && arr[i]!==0)
				arr[i]="";
		}
		this._process_some_row(r,arr);

		r._attrs = data;
		return r;
	},
	_get_js_data:function(data, ind){
		return data[this.columnIds[ind]];
	},
	_process_csv_row:function(r, data){
		r._attrs={
		};
	
		for (var j = 0; j < r.childNodes.length; j++)r.childNodes[j]._attrs={
		};
	
		this._fillRow(r, (this._c_order ? this._swapColumns(data.split(this.csv.cell)) : data.split(this.csv.cell)));
		return r;
	},
	_get_csv_data:function(data, ind){
		return data.split(this.csv.cell)[ind];
	},
//#}
	_process_store_row:function(row, data){
		var result = [];
		for (var i = 0; i < this.columnIds.length; i++)
			result[i] = data[this.columnIds[i]];
		for (var j = 0; j < row.childNodes.length; j++)
		row.childNodes[j]._attrs={};

		row._attrs = data;
		this._fillRow(row, result);
	},	
//#xml_data:06042008{
	_process_xml_row:function(r, xml){		
		var cellsCol = this.xmlLoader.doXPath(this.xml.cell, xml);
		var strAr = [];
	
		r._attrs=this._xml_attrs(xml);
	
		//load userdata
		if (this._ud_enabled){
			var udCol = this.xmlLoader.doXPath("./userdata", xml);
	
			for (var i = udCol.length-1; i >= 0; i--){
				var u_record = "";
				for (var j=0; j < udCol[i].childNodes.length; j++)
					u_record += udCol[i].childNodes[j].nodeValue;

				this.setUserData(r.idd,udCol[i].getAttribute("name"), u_record);
			}
		}
	
		//load cell data
		for (var j = 0; j < cellsCol.length; j++){
			var cellVal = cellsCol[this._c_order?this._c_order[j]:j];
			if (!cellVal) continue;
			var cind = r._childIndexes?r._childIndexes[j]:j;
			var exc = cellVal.getAttribute("type");
	
			if (r.childNodes[cind]){
				if (exc)
					r.childNodes[cind]._cellType=exc;
				r.childNodes[cind]._attrs=this._xml_attrs(cellVal);
			}
	
			if (!cellVal.getAttribute("xmlcontent")){
				if (cellVal.firstChild)
				cellVal=cellVal.firstChild.data;
	
			else
				cellVal="";
			}
	
			strAr.push(cellVal);
		}
	
		for (j < cellsCol.length; j < r.childNodes.length; j++)r.childNodes[j]._attrs={
		};
	
		//treegrid
		if (r.parentNode&&r.parentNode.tagName == "row")
			r._attrs["parent"]=r.parentNode.getAttribute("idd");
	
		//back to common code
		this._fillRow(r, strAr);
		return r;
	},
	_get_xml_data:function(data, ind){ 
		data=data.firstChild;
	
		while (true){
			if (!data)
				return "";
	
			if (data.tagName == "cell")
				ind--;
	
			if (ind < 0)
				break;
			data=data.nextSibling;
		}
		return (data.firstChild ? data.firstChild.data : "");
	},
//#}	
	_fillRow:function(r, text){
		if (this.editor)
			this.editStop();
	
		for (var i = 0; i < r.childNodes.length; i++){
			if ((i < text.length)||(this.defVal[i])){
				
			    var ii=r.childNodes[i]._cellIndex;
			    var val = text[ii];
				var aeditor = this.cells4(r.childNodes[i]);
	
				if ((this.defVal[ii])&&((val == "")||( typeof (val) == "undefined")))
					val=this.defVal[ii];

				if (aeditor) aeditor.setValue(val)
			} else {
				r.childNodes[i].innerHTML="&nbsp;";
				r.childNodes[i]._clearCell=true;
			}
		}
	
		return r;
	},
	
	_postRowProcessing:function(r,donly){ 
		if (r._attrs["class"])
			r._css=r.className=r._attrs["class"];
	
		if (r._attrs.locked)
			r._locked=true;
	
		if (r._attrs.bgColor)
			r.bgColor=r._attrs.bgColor;
		var cor=0;	
		
		for (var i = 0; i < r.childNodes.length; i++){
			var c=r.childNodes[i];
			var ii=c._cellIndex;
			//style attribute
			var s = c._attrs.style||r._attrs.style;
	
			if (s)
				c.style.cssText+=";"+s;
	
			if (c._attrs["class"])
				c.className=c._attrs["class"];
			s=c._attrs.align||this.cellAlign[ii];

	
			if (s)
				c.align=s;
			c.vAlign=c._attrs.valign||this.cellVAlign[ii];
			var color = c._attrs.bgColor||this.columnColor[ii];

	
			if (color)
				c.bgColor=color;
	
			if (c._attrs["colspan"] && !donly){ 
				this.setColspan(r.idd, i+cor, c._attrs["colspan"]);
				//i+=(c._attrs["colspan"]-1);
				cor+=(c._attrs["colspan"]-1);
			}
	
			if (this._hrrar&&this._hrrar[ii]&&!donly){
				c.style.display="none";
			}
		};
		this.callEvent("onRowCreated", [
			r.idd,
			r,
			null
		]);
	},
	/**
	*   @desc: load data from external file ( xml, json, jsarray, csv )
	*   @param: url - url to external file
	*   @param: call - after loading callback function, optional, can be ommited
	*   @param: type - type of data (xml,csv,json,jsarray) , optional, xml by default
	*   @type:  public
	*/			
	load:function(url, call, type){
		this.callEvent("onXLS", [this]);
		if (arguments.length == 2 && typeof call != "function"){
			type=call;
			call=null;
		}
		type=type||"xml";
	
		if (!this.xmlFileUrl)
			this.xmlFileUrl=url;
		this._data_type=type;
		this.xmlLoader.onloadAction=function(that, b, c, d, xml){
			if (!that.callEvent) return;
			xml=that["_process_"+type](xml);
			if (!that._contextCallTimer)
			that.callEvent("onXLE", [that,0,0,xml]);
	
			if (call){
				call();
				call=null;
			}
		}
		this.xmlLoader.loadXML(url);
	},
//#__pro_feature:21092006{		
	loadXMLString:function(str, afterCall){
		var t = new dtmlXMLLoaderObject(function(){
		});

		t.loadXMLString(str);
		this.parse(t, afterCall, "xml")
	},
//#}
	loadXML:function(url, afterCall){
		this.load(url, afterCall, "xml")
	},
	/**
	*   @desc: load data from local datasource ( xml string, csv string, xml island, xml object, json objecs , javascript array )
	*   @param: data - string or object
	*   @param: type - data type (xml,json,jsarray,csv), optional, data threated as xml by default
	*   @type:  public
	*/			
	parse:function(data, call, type){
		if (arguments.length == 2 && typeof call != "function"){
			type=call;
			call=null;
		}
		type=type||"xml";
		this._data_type=type;
		data=this["_process_"+type](data);
		if (!this._contextCallTimer)
		this.callEvent("onXLE", [this,0,0,data]);
		if (call)
			call();
	},
	
	xml:{
		top: "rows",
		row: "./row",
		cell: "./cell",
		s_row: "row",
		s_cell: "cell",
		row_attrs: [],
		cell_attrs: []
	},
	
	csv:{
		row: "\n",
		cell: ","
	},
	
	_xml_attrs:function(node){
		var data = {
		};
	
		if (node.attributes.length){
			for (var i = 0; i < node.attributes.length; i++)data[node.attributes[i].name]=node.attributes[i].value;
		}
	
		return data;
	},
//#xml_data:06042008{	
	_process_xml:function(xml){ 
		if (!xml.doXPath){
			var t = new dtmlXMLLoaderObject(function(){});
			if (typeof xml == "string") 
				t.loadXMLString(xml);
			else {
				if (xml.responseXML)
					t.xmlDoc=xml;
				else
					t.xmlDoc={};
				t.xmlDoc.responseXML=xml;
			}
			xml=t;
		}
		if (this._refresh_mode) return this._refreshFromXML(xml);		
		this._parsing=true;
		var top = xml.getXMLTopNode(this.xml.top)
		if (top.tagName!=this.xml.top) return;
		var skey = top.getAttribute("dhx_security");
		if (skey)
			dhtmlx.security_key = skey;

		//#config_from_xml:20092006{
		this._parseHead(top);
		//#}
		var rows = xml.doXPath(this.xml.row, top)
		var cr = parseInt(xml.doXPath("//"+this.xml.top)[0].getAttribute("pos")||0);
		var total = parseInt(xml.doXPath("//"+this.xml.top)[0].getAttribute("total_count")||0);
		var total = Math.min(total, 32000000/this._srdh);
	
		var reset = false;
		if (total && total!=this.rowsBuffer.length){
			if (!this.rowsBuffer[total-1]){
				if (this.rowsBuffer.length)
					reset=true;
			this.rowsBuffer[total-1]=null;
			} 
			if (total<this.rowsBuffer.length){
				this.rowsBuffer.splice(total, this.rowsBuffer.length - total);
				reset = true;
			}
		}
		
			
		if (this.isTreeGrid())
			return this._process_tree_xml(xml);
			 
	
		for (var i = 0; i < rows.length; i++){
			if (this.rowsBuffer[i+cr])
				continue;
			var id = rows[i].getAttribute("id")||(i+cr+1);
			this.rowsBuffer[i+cr]={
				idd: id,
				data: rows[i],
				_parser: this._process_xml_row,
				_locator: this._get_xml_data
				};
	
			this.rowsAr[id]=rows[i];
		//this.callEvent("onRowCreated",[r.idd]);
		}

		this.callEvent("onDataReady", []);
		if (reset && this._srnd){
			var h = this.objBox.scrollTop;
			this._reset_view();
			this.objBox.scrollTop = h;
		} else {
		this.render_dataset();
		}
			
		this._parsing=false;
		return xml.xmlDoc.responseXML?xml.xmlDoc.responseXML:xml.xmlDoc;
	},
//#}
//#non_xml_data:06042008{	
	_process_jsarray:function(data){
		this._parsing=true;
	
		if (data&&data.xmlDoc){
			eval("dhtmlx.temp="+data.xmlDoc.responseText+";");
			data = dhtmlx.temp;
		}
	
		for (var i = 0; i < data.length; i++){
			var id = i+1;
			this.rowsBuffer.push({
				idd: id,
				data: data[i],
				_parser: this._process_jsarray_row,
				_locator: this._get_jsarray_data
				});
	
			this.rowsAr[id]=data[i];
		//this.callEvent("onRowCreated",[r.idd]);
		}
		this.render_dataset();
		this._parsing=false;
	},
	
	_process_csv:function(data){
		this._parsing=true;
		if (data.xmlDoc)
			data=data.xmlDoc.responseText;
		data=data.replace(/\r/g,"");
		data=data.split(this.csv.row);
	    if (this._csvHdr){
   			this.clearAll();
   			var thead=data.splice(0,1)[0].split(this.csv.cell);
   			if (!this._csvAID) thead.splice(0,1);
	   		this.setHeader(thead.join(this.delim));
	   		this.init();
   		}
	
		for (var i = 0; i < data.length; i++){
			if (!data[i] && i==data.length-1) continue; //skip new line at end of text
			if (this._csvAID){
				var id = i+1;
				this.rowsBuffer.push({
					idd: id,
					data: data[i],
					_parser: this._process_csv_row,
					_locator: this._get_csv_data
					});
			} else {
				var temp = data[i].split(this.csv.cell);
				var id = temp.splice(0,1)[0];
				this.rowsBuffer.push({
					idd: id,
					data: temp,
					_parser: this._process_jsarray_row,
					_locator: this._get_jsarray_data
					});
			}
			
	
			this.rowsAr[id]=data[i];
		//this.callEvent("onRowCreated",[r.idd]);
		}
		this.render_dataset();
		this._parsing=false;
	},
	
	_process_js:function(data){
		return this._process_json(data, "js");
	},

	_process_json:function(data, mode){
		this._parsing=true;
	
		if (data&&data.xmlDoc){
			eval("dhtmlx.temp="+data.xmlDoc.responseText+";");
			data = dhtmlx.temp;
		}
	
		if (mode == "js"){
			if (data.data)
				data = data.data;
			for (var i = 0; i < data.length; i++){
				var row = data[i];
				var id  = row.id||(i+1);
				this.rowsBuffer.push({
					idd: id,
					data: row,
					_parser: this._process_js_row,
					_locator: this._get_js_data
					});
		
				this.rowsAr[id]=data[i];
			}
		} else {
			for (var i = 0; i < data.rows.length; i++){
				var id = data.rows[i].id;
				this.rowsBuffer.push({
					idd: id,
					data: data.rows[i],
					_parser: this._process_json_row,
					_locator: this._get_json_data
					});
		
				this.rowsAr[id]=data.rows[i];
			}
		}
		if (data.dhx_security)
			dhtmlx.security_key = data.dhx_security;
		
		this.render_dataset();
		this._parsing=false;
	},
//#}	
	render_dataset:function(min, max){ 
		//normal mode - render all
		//var p=this.obj.parentNode;
		//p.removeChild(this.obj,true)
		if (this._srnd){
			if (this._fillers)
				return this._update_srnd_view();
	
			max=Math.min((this._get_view_size()+(this._srnd_pr||0)), this.rowsBuffer.length);
			
		}
	
		if (this.pagingOn){
			min=Math.max((min||0),(this.currentPage-1)*this.rowsBufferOutSize);
			max=Math.min(this.currentPage*this.rowsBufferOutSize, this.rowsBuffer.length)
		} else {
			min=min||0;
			max=max||this.rowsBuffer.length;
		}
	
		for (var i = min; i < max; i++){
			var r = this.render_row(i)
	
			if (r == -1){
				if (this.xmlFileUrl){
				    if (this.callEvent("onDynXLS",[i,(this._dpref?this._dpref:(max-i))]))
				        this.load(this.xmlFileUrl+getUrlSymbol(this.xmlFileUrl)+"posStart="+i+"&count="+(this._dpref?this._dpref:(max-i)), this._data_type);
				}
				max=i;
				break;
			}
						
			if (!r.parentNode||!r.parentNode.tagName){ 
				this._insertRowAt(r, i);
				if (r._attrs["selected"] || r._attrs["select"]){
					this.selectRow(r,r._attrs["call"]?true:false,true);
					r._attrs["selected"]=r._attrs["select"]=null;
				}
			}
			
							
			if (this._ads_count && i-min==this._ads_count){
				var that=this;
				this._context_parsing=this._context_parsing||this._parsing;
				return this._contextCallTimer=window.setTimeout(function(){
					that._contextCallTimer=null;
					that.render_dataset(i,max);
					if (!that._contextCallTimer){
						if(that._context_parsing)
					    	that.callEvent("onXLE",[])
					    else 
					    	that._fixAlterCss();
					    that.callEvent("onDistributedEnd",[]);
					    that._context_parsing=false;
				    }
				},this._ads_time)
			}
		}
	
		if (this._srnd&&!this._fillers){
			var add_count = this.rowsBuffer.length-max;
			this._fillers = [];

			while (add_count > 0){
				var add_step = (_isIE || window._FFrv)?Math.min(add_count, 50000):add_count;
				var new_filler = this._add_filler(max, add_step);
				if (new_filler)
					this._fillers.push(new_filler);
				add_count -= add_step;
				max += add_step;
			}				
		}
	
		//p.appendChild(this.obj)
		this.setSizes();
	},
	
	render_row:function(ind){
		if (!this.rowsBuffer[ind])
			return -1;
	
		if (this.rowsBuffer[ind]._parser){
			var r = this.rowsBuffer[ind];
			if (this.rowsAr[r.idd] && this.rowsAr[r.idd].tagName=="TR")
				return this.rowsBuffer[ind]=this.rowsAr[r.idd];
			var row = this._prepareRow(r.idd);
			this.rowsBuffer[ind]=row;
			this.rowsAr[r.idd]=row;
	
			r._parser.call(this, row, r.data);
			this._postRowProcessing(row);
			return row;
		}
		return this.rowsBuffer[ind];
	},
	
	
	_get_cell_value:function(row, ind, method){
		if (row._locator){
			/*if (!this._data_cache[row.idd])
				this._data_cache[row.idd]=[];
			if (this._data_cache[row.idd][ind]) 
				return this._data_cache[row.idd][ind];
			else
				 return this._data_cache[row.idd][ind]=row._locator.call(this,row.data,ind);
				 */
			if (this._c_order)
				ind=this._c_order[ind];
			return row._locator.call(this, row.data, ind);
		}
		return this.cells3(row, ind)[method ? method : "getValue"]();
	},
//#sorting:06042008{	
	/**
	*   @desc: sort grid
	*   @param: col - index of column, by which grid need to be sorted
	*   @param: type - sorting type (str,int,date), optional, by default sorting type taken from column setting
	*   @param: order - sorting order (asc,des), optional, by default sorting order based on previous sorting operation
	*   @type:  public
	*/		
	sortRows:function(col, type, order){
		//default values
		order=(order||"asc").toLowerCase();
		type=(type||this.fldSort[col]);
		col=col||0;
		
		if (this.isTreeGrid())
			this.sortTreeRows(col, type, order);
		else{
	
			var arrTS = {
			};
		
			var atype = this.cellType[col];
			var amet = "getValue";
		
			if (atype == "link")
				amet="getContent";
		
			if (atype == "dhxCalendar"||atype == "dhxCalendarA")
				amet="getDate";
		
			for (var i = 0;
				i < this.rowsBuffer.length;
				i++)arrTS[this.rowsBuffer[i].idd]=this._get_cell_value(this.rowsBuffer[i], col, amet);
		
			this._sortRows(col, type, order, arrTS);
		}
		this.callEvent("onAfterSorting", [col,type,order]);
	},
	/**
	*	@desc: 
	*	@type: private
	*/
	_sortCore:function(col, type, order, arrTS, s){
		var sort = "sort";
	
		if (this._sst){
			s["stablesort"]=this.rowsCol.stablesort;
			sort="stablesort";
		}
//#__pro_feature:21092006{	
//#custom_sort:21092006{
		if (type.length > 4)
			type=window[type];
	
		if (type == 'cus'){
			var cstr=this._customSorts[col];
			s[sort](function(a, b){
				return cstr(arrTS[a.idd], arrTS[b.idd], order, a.idd, b.idd);
			});
		}
		else if (typeof (type) == 'function'){
			s[sort](function(a, b){
				return type(arrTS[a.idd], arrTS[b.idd], order, a.idd, b.idd);
			});
		}
		else
//#}
//#}
		if (type == 'str'){
			s[sort](function(a, b){
				if (order == "asc")
					return arrTS[a.idd] > arrTS[b.idd] ? 1 : (arrTS[a.idd] < arrTS[b.idd] ? -1 : 0);
				else
					return arrTS[a.idd] < arrTS[b.idd] ? 1 : (arrTS[a.idd] > arrTS[b.idd] ? -1 : 0);
			});
		}
		else if (type == 'int'){
			s[sort](function(a, b){
				var aVal = parseFloat(arrTS[a.idd]);
				aVal=isNaN(aVal) ? -99999999999999 : aVal;
				var bVal = parseFloat(arrTS[b.idd]);
				bVal=isNaN(bVal) ? -99999999999999 : bVal;
	
				if (order == "asc")
					return aVal-bVal;
				else
					return bVal-aVal;
			});
		}
		else if (type == 'date'){
			s[sort](function(a, b){
				var aVal = Date.parse(arrTS[a.idd])||(Date.parse("01/01/1900"));
				var bVal = Date.parse(arrTS[b.idd])||(Date.parse("01/01/1900"));
	
				if (order == "asc")
					return aVal-bVal
				else
					return bVal-aVal
			});
		}
	},
	/**
	*   @desc: inner sorting routine
	*   @type: private
	*   @topic: 7
	*/
	_sortRows:function(col, type, order, arrTS){
		this._sortCore(col, type, order, arrTS, this.rowsBuffer);
		this._reset_view();
		this.callEvent("onGridReconstructed", []);
	},
//#}		
	_reset_view:function(skip){
		if (!this.obj.rows[0]) return;
		if (this._lahRw) this._unsetRowHover(0, true); //remove hovering during reset
		this.callEvent("onResetView",[]);
		var tb = this.obj.rows[0].parentNode;
		var tr = tb.removeChild(tb.childNodes[0], true)
	    if (_isKHTML) //Safari 2x
	    	for (var i = tb.parentNode.childNodes.length-1; i >= 0; i--) { if (tb.parentNode.childNodes[i].tagName=="TR") tb.parentNode.removeChild(tb.parentNode.childNodes[i],true); }
	    else if (_isIE)
			for (var i = tb.childNodes.length-1; i >= 0; i--) tb.childNodes[i].removeNode(true);
		else
			tb.innerHTML="";
		tb.appendChild(tr)
		this.rowsCol=dhtmlxArray();
		if (this._sst)
			this.enableStableSorting(true);
		this._fillers=this.undefined;
		if (!skip){
		    if (_isIE && this._srnd){
		        // var p=this._get_view_size;
		        // this._get_view_size=function(){ return 1; }
    		    this.render_dataset();
    		    // this._get_view_size=p;
    		}
    	    else
    	        this.render_dataset();
	    }
		
		
	},
	
	/**
	*   @desc: delete row from the grid
	*   @param: row_id - row ID
	*   @type:  public
	*/		
	deleteRow:function(row_id, node){
		if (!node)
			node=this.getRowById(row_id)
	
		if (!node)
			return;
	
		this.editStop();
		if (!this._realfake)
			if (this.callEvent("onBeforeRowDeleted", [row_id]) == false)
				return false;
		
		var pid=0;
		if (this.cellType._dhx_find("tree") != -1 && !this._realfake){
			pid=this._h2.get[row_id].parent.id;
			this._removeTrGrRow(node);
		}
		else {
			if (node.parentNode)
				node.parentNode.removeChild(node);
	
			var ind = this.rowsCol._dhx_find(node);
	
			if (ind != -1)
				this.rowsCol._dhx_removeAt(ind);
	
			for (var i = 0; i < this.rowsBuffer.length; i++)
				if (this.rowsBuffer[i]&&this.rowsBuffer[i].idd == row_id){
					this.rowsBuffer._dhx_removeAt(i);
					ind=i;
					break;
				}
		}
		this.rowsAr[row_id]=null;
	
		for (var i = 0; i < this.selectedRows.length; i++)
			if (this.selectedRows[i].idd == row_id)
				this.selectedRows._dhx_removeAt(i);
	
		if (this._srnd){
			for (var i = 0; i < this._fillers.length; i++){
				var f = this._fillers[i]
	            if (!f) continue; //can be null	
	            
	            this._update_fillers(i, (f[1] >= ind ? -1 : 0), (f[0] >= ind ? -1 : 0));
			};
	
			this._update_srnd_view();
		}
	
		if (this.pagingOn)
			this.changePage();
		if (!this._realfake)  this.callEvent("onAfterRowDeleted", [row_id,pid]);
		this.callEvent("onGridReconstructed", []);
		if (this._ahgr) this.setSizes();
		return true;
	},
	
	_addRow:function(new_id, text, ind){
		if (ind == -1|| typeof ind == "undefined")
			ind=this.rowsBuffer.length;
		if (typeof text == "string") text=text.split(this.delim);
		var row = this._prepareRow(new_id);
		row._attrs={
		};
	
		for (var j = 0; j < row.childNodes.length; j++)row.childNodes[j]._attrs={
		};
	
	
		this.rowsAr[row.idd]=row;
		if (this._h2) this._h2.get[row.idd].buff=row;	//treegrid specific
		this._fillRow(row, text);
		this._postRowProcessing(row);
		if (this._skipInsert){
			this._skipInsert=false;
			return this.rowsAr[row.idd]=row;
		}
	
		if (this.pagingOn){
			this.rowsBuffer._dhx_insertAt(ind,row);
			this.rowsAr[row.idd]=row;
			return row;
		}
	
		if (this._fillers){ 
			this.rowsCol._dhx_insertAt(ind, null);
			this.rowsBuffer._dhx_insertAt(ind,row);
			if (this._fake) this._fake.rowsCol._dhx_insertAt(ind, null);
			this.rowsAr[row.idd]=row;
			var found = false;
	
			for (var i = 0; i < this._fillers.length; i++){
				var f = this._fillers[i];
	
				if (f&&f[0] <= ind&&(f[0]+f[1]) >= ind){
					f[1]=f[1]+1;
					var nh = f[2].firstChild.style.height=parseInt(f[2].firstChild.style.height)+this._srdh+"px";
					found=true;
					if (this._fake){
						this._fake._fillers[i][1]++;
						this._fake._fillers[i][2].firstChild.style.height = nh;
					}
				}
	
				if (f&&f[0] > ind){
					f[0]=f[0]+1
					if (this._fake) this._fake._fillers[i][0]++;
				}
			}
	
			if (!found)
				this._fillers.push(this._add_filler(ind, 1, (ind == 0 ? {
					parentNode: this.obj.rows[0].parentNode,
					nextSibling: (this.rowsCol[1])
					} : this.rowsCol[ind-1])));
	
			return row;
		}
		this.rowsBuffer._dhx_insertAt(ind,row);
		return this._insertRowAt(row, ind);
	},
	
	/**
	*   @desc: add row to the grid
	*   @param: new_id - row ID, must be unique
	*   @param: text - row values, may be a comma separated list or an array
	*   @param: ind - index of new row, optional, row added to the last position by default
	*   @type:  public
	*/	
	addRow:function(new_id, text, ind){
		var r = this._addRow(new_id, text, ind);
	
		if (!this.dragContext)
			this.callEvent("onRowAdded", [new_id]);
	
		if (this.pagingOn)
			this.changePage(this.currentPage)
	
		if (this._srnd)
			this._update_srnd_view();
	
		r._added=true;
	
		if (this._ahgr)
			this.setSizes();
		this.callEvent("onGridReconstructed", []);
		return r;
	},
	
	_insertRowAt:function(r, ind, skip){
		this.rowsAr[r.idd]=r;
	
		if (this._skipInsert){
			this._skipInsert=false;
			return r;
		}
	
		if ((ind < 0)||((!ind)&&(parseInt(ind) !== 0)))
			ind=this.rowsCol.length;
		else {
			if (ind > this.rowsCol.length)
				ind=this.rowsCol.length;
		}
	
		if (this._cssEven){
			var css = r.className.replace(this._cssUnEven, "");
			if ((this._cssSP ? this.getLevel(r.idd) : ind)%2 == 1)
				r.className+=css+" "+this._cssUnEven+(this._cssSU ? (" "+this._cssUnEven+"_"+this.getLevel(r.idd)) : "");
			else
				r.className+=css+" "+this._cssEven+(this._cssSU ? (" "+this._cssEven+"_"+this.getLevel(r.idd)) : "");
		}
		/*
		if (r._skipInsert) {                
			this.rowsAr[r.idd] = r;
			return r;
		}*/
		if (!skip)
			if ((ind == (this.obj.rows.length-1))||(!this.rowsCol[ind]))
				if (_isKHTML)
					this.obj.appendChild(r);
				else {
					this.obj.firstChild.appendChild(r);
				}
			else {
				this.rowsCol[ind].parentNode.insertBefore(r, this.rowsCol[ind]);
			}
	
		this.rowsCol._dhx_insertAt(ind, r);
		this.callEvent("onRowInserted",[r, ind]);
		return r;
	},
	
	getRowById:function(id){
		var row = this.rowsAr[id];
	
		if (row){
			if (row.tagName != "TR"){
				for (var i = 0; i < this.rowsBuffer.length; i++)
					if (this.rowsBuffer[i] && this.rowsBuffer[i].idd == id)
						return this.render_row(i);
				if (this._h2) return this.render_row(null,row.idd);
			}
			return row;
		}
		return null;
	},
	
/**
*   @desc: gets dhtmlXGridCellObject object (if no arguments then gets dhtmlXGridCellObject object of currently selected cell)
*   @param: row_id -  row id
*   @param: col -  column index
*   @returns: dhtmlXGridCellObject object (see its methods below)
*   @type: public
*   @topic: 4
*/
	cellById:function(row_id, col){
		return this.cells(row_id, col);
	},
/**
*   @desc: gets dhtmlXGridCellObject object (if no arguments then gets dhtmlXGridCellObject object of currently selected cell)
*   @param: row_id -  row id
*   @param: col -  column index
*   @returns: dhtmlXGridCellObject object (use it to get/set value to cell etc.)
*   @type: public
*   @topic: 4
*/
	cells:function(row_id, col){
		if (arguments.length == 0)
			return this.cells4(this.cell);
		else
			var c = this.getRowById(row_id);
		var cell = (c._childIndexes ? c.childNodes[c._childIndexes[col]] : c.childNodes[col]);
		if (!cell && c._childIndexes)
			cell = c.firstChild || {};
		return this.cells4(cell);
	},
	/**
	*   @desc: gets dhtmlXGridCellObject object
	*   @param: row_index -  row index
	*   @param: col -  column index
	*   @returns: dhtmlXGridCellObject object (see its methods below)
	*   @type: public
	*   @topic: 4
	*/
	cellByIndex:function(row_index, col){
		return this.cells2(row_index, col);
	},
	/**
	*   @desc: gets dhtmlXGridCellObject object
	*   @param: row_index -  row index
	*   @param: col -  column index
	*   @returns: dhtmlXGridCellObject object (see its methods below)
	*   @type: public
	*   @topic: 4
	*/
	cells2:function(row_index, col){
		var c = this.render_row(row_index);
		var cell = (c._childIndexes ? c.childNodes[c._childIndexes[col]] : c.childNodes[col]);
		if (!cell && c._childIndexes)
			cell = c.firstChild || {};
		return this.cells4(cell);
	},
	/**
	*   @desc: gets exCell editor for row  object and column id
	*   @type: private
	*   @topic: 4
	*/
	cells3:function(row, col){
		var cell = (row._childIndexes ? row.childNodes[row._childIndexes[col]] : row.childNodes[col]);
		return this.cells4(cell);
	},
	/**
	*   @desc: gets exCell editor for cell  object
	*   @type: private
	*   @topic: 4
	*/
	cells4:function(cell){
		var type = window["eXcell_"+(cell._cellType||this.cellType[cell._cellIndex])];

		if (type)
			return new type(cell);
	},	
	cells5:function(cell, type){ 
		var type = type||(cell._cellType||this.cellType[cell._cellIndex]);
	
		if (!this._ecache[type]){
			if (!window["eXcell_"+type])
				var tex = eXcell_ro;
			else
				var tex = window["eXcell_"+type];
	
			this._ecache[type]=new tex(cell);
		}
		this._ecache[type].cell=cell;
		return this._ecache[type];
	},
	dma:function(mode){
		if (!this._ecache)
			this._ecache={
			};
	
		if (mode&&!this._dma){
			this._dma=this.cells4;
			this.cells4=this.cells5;
		} else if (!mode&&this._dma){
			this.cells4=this._dma;
			this._dma=null;
		}
	},
	
	/**
	*   @desc: returns count of row in grid ( in case of dynamic mode it will return expected count of rows )
	*   @type:  public
	*	@returns: count of rows in grid
	*/	
	getRowsNum:function(){
		return this.rowsBuffer.length;
	},
	
	
	/**
	*   @desc: enables/disables mode when readonly cell is not available with tab 
	*   @param: mode - (boolean) true/false
	*   @type:  public
	*/
	enableEditTabOnly:function(mode){
		if (arguments.length > 0)
			this.smartTabOrder=convertStringToBoolean(mode);
		else
			this.smartTabOrder=true;
	},
	/**
	*   @desc: sets elements which get focus when tab is pressed in the last or first (tab+shift) cell 
	*   @param: start - html object or its id - gets focus when tab+shift are pressed in the first cell  
	*   @param: end - html object or its id - gets focus when tab is pressed in the last cell  
	*   @type:  public
	*/
	setExternalTabOrder:function(start, end){
		var grid = this;
		this.tabStart=( typeof (start) == "object") ? start : document.getElementById(start);

		var oldkeydown_start = this.tabStart.onkeydown;
		this.tabStart.onkeydown=function(e){
			if (oldkeydown_start)
				oldkeydown_start.call(this, e);

			var ev = (e||window.event);
			if (ev.keyCode == 9 && !ev.shiftKey){
				
				ev.cancelBubble=true;		
				grid.selectCell(0, 0, 0, 0, 1);
	
				if (grid.smartTabOrder && grid.cells2(0, 0).isDisabled()){
					grid._key_events["k9_0_0"].call(grid);
				}
				this.blur();
				return false;
			}
		};
		if(_isOpera) this.tabStart.onkeypress = this.tabStart.onkeydown;
		this.tabEnd=( typeof (end) == "object") ? end : document.getElementById(end);

		var oldkeydown_end= this.tabEnd.onkeydown;
		this.tabEnd.onkeydown=this.tabEnd.onkeypress=function(e){
			if (oldkeydown_end)
				oldkeydown_end.call(this, e);

			var ev = (e||window.event);
			if (ev.keyCode == 9 && ev.shiftKey){
				ev.cancelBubble=true;
				grid.selectCell((grid.getRowsNum()-1), (grid.getColumnCount()-1), 0, 0, 1);
	
				if (grid.smartTabOrder && grid.cells2((grid.getRowsNum()-1), (grid.getColumnCount()-1)).isDisabled()){
					grid._key_events["k9_0_1"].call(grid);
				}
				this.blur();
				return false;
			}
		};
		if(_isOpera) this.tabEnd.onkeypress = this.tabEnd.onkeydown;
	},
	/**
	*   @desc: returns unique ID
	*   @type:  public
	*/	
	uid:function(){
		if (!this._ui_seed) this._ui_seed=(new Date()).valueOf();
		return this._ui_seed++;
	},
	/**
	*   @desc: clears existing grid state and load new XML
	*   @type:  public
	*/
	clearAndLoad:function(){
		var t=this._pgn_skin; this._pgn_skin=null;
		this.clearAll();
		this._pgn_skin=t;
		this.load.apply(this,arguments);
	},
	/**
	*   @desc: returns details about current grid state
	*   @type:  public
	*/
	getStateOfView:function(){
		if (this.pagingOn){
			var start = (this.currentPage-1)*this.rowsBufferOutSize;
			return [this.currentPage, start, Math.min(start+this.rowsBufferOutSize,this.rowsBuffer.length), this.rowsBuffer.length ];
		}
 		return [
            Math.floor(this.objBox.scrollTop/this._srdh),
			Math.ceil(parseInt(this.objBox.offsetHeight)/this._srdh),
			this.rowsBuffer.length
			];
	}
};

//grid
(function(){
	//local helpers
	function direct_set(name,value){ this[name]=value; 	}
	function direct_call(name,value){ this[name].call(this,value); 	}
	function joined_call(name,value){ this[name].call(this,value.join(this.delim));  }
	function set_options(name,value){
		for (var i=0; i < value.length; i++) 
			if (typeof value[i] == "object"){
				var combo = this.getCombo(i);
				for (var key in value[i])
					combo.put(key, value[i][key]);
			}
	}
	function header_set(name,value,obj){
		//make a matrix
		var rows = 1;
		var header = [];
		function add(i,j,value){
			if (!header[j]) header[j]=[];
			if (typeof value == "object") value.toString=function(){ return this.text; }
			header[j][i]=value;
		}
		
		for (var i=0; i<value.length; i++) {
			if (typeof(value[i])=="object" && value[i].length){
				for (var j=0; j < value[i].length; j++)
					add(i,j,value[i][j]);		
			} else
				add(i,0,value[i]);		
		}
		for (var i=0; i<header.length; i++)
			for (var j=0; j<header[0].length; j++){
				var h=header[i][j];
				header[i][j]=(h||"").toString()||"&nbsp;";
				if (h&&h.colspan)
					for (var k=1; k < h.colspan; k++) add(j+k,i,"#cspan");
				if (h&&h.rowspan)
					for (var k=1; k < h.rowspan; k++) add(j,i+k,"#rspan");
			}
				
		this.setHeader(header[0]);
		for (var i=1; i < header.length; i++) 
			this.attachHeader(header[i]);
	}
	
	//defenitions
	var columns_map=[
		{name:"label", 	def:"&nbsp;", 	operation:"setHeader",		type:header_set		},
		{name:"id", 	def:"", 		operation:"columnIds",		type:direct_set		},
		{name:"width", 	def:"*", 		operation:"setInitWidths", 	type:joined_call	},
		{name:"align", 	def:"left", 	operation:"cellAlign",		type:direct_set		},
		{name:"valign", def:"middle", 	operation:"cellVAlign",		type:direct_set		},
		{name:"sort", 	def:"na", 		operation:"fldSort",		type:direct_set		},
		{name:"type", 	def:"ro", 		operation:"setColTypes",	type:joined_call	},
		{name:"options",def:"", 		operation:"",				type:set_options	}
	];
	
	//extending	
	dhtmlx.extend_api("dhtmlXGridObject",{
		_init:function(obj){
			return [obj.parent];
		},
		image_path:"setImagePath",
		columns:"columns",
		rows:"rows",
		headers:"headers",
		skin:"setSkin",
		smart_rendering:"enableSmartRendering",
		css:"enableAlterCss",
		auto_height:"enableAutoHeight",
		save_hidden:"enableAutoHiddenColumnsSaving",
		save_cookie:"enableAutoSaving",
		save_size:"enableAutoSizeSaving",
		auto_width:"enableAutoWidth",
		block_selection:"enableBlockSelection",
		csv_id:"enableCSVAutoID",
		csv_header:"enableCSVHeader",
		cell_ids:"enableCellIds",
		colspan:"enableColSpan",
		column_move:"enableColumnMove",
		context_menu:"enableContextMenu",
		distributed:"enableDistributedParsing",
		drag:"enableDragAndDrop",
		drag_order:"enableDragOrder",
		tabulation:"enableEditTabOnly",
		header_images:"enableHeaderImages",
		header_menu:"enableHeaderMenu",
		keymap:"enableKeyboardSupport",
		mouse_navigation:"enableLightMouseNavigation",
		markers:"enableMarkedCells",
		math_editing:"enableMathEditing",
		math_serialization:"enableMathSerialization",
		drag_copy:"enableMercyDrag",
		multiline:"enableMultiline",
		multiselect:"enableMultiselect",
		save_column_order:"enableOrderSaving",
		hover:"enableRowsHover",
		rowspan:"enableRowspan",
		smart:"enableSmartRendering",
		save_sorting:"enableSortingSaving",
		stable_sorting:"enableStableSorting",
		undo:"enableUndoRedo",
		csv_cell:"setCSVDelimiter",
		date_format:"setDateFormat",
		drag_behavior:"setDragBehavior",
		editable:"setEditable",
		without_header:"setNoHeader",
		submit_changed:"submitOnlyChanged",
		submit_serialization:"submitSerialization",
		submit_selected:"submitOnlySelected",
		submit_id:"submitOnlyRowID",		
		xml:"load"
	},{
		columns:function(obj){
			for (var j=0; j<columns_map.length; j++){
				var settings = [];
				for (var i=0; i<obj.length; i++)
					settings[i]=obj[i][columns_map[j].name]||columns_map[j].def;
			var type=columns_map[j].type||direct_call;
				type.call(this,columns_map[j].operation,settings,obj);
			}
			this.init();
		},
		rows:function(obj){
			
		},
		headers:function(obj){
			for (var i=0; i < obj.length; i++) 
				this.attachHeader(obj[i]);
		}
	});

})();


dhtmlXGridObject.prototype._dp_init=function(dp){
	dp.attachEvent("insertCallback", function(upd, id) {
		if (this.obj._h2)
			this.obj.addRow(id, row, null, parent);
		else
			this.obj.addRow(id, [], 0);
			
		var row = this.obj.getRowById(id);
		if (row){
			this.obj._process_xml_row(row, upd.firstChild);
			this.obj._postRowProcessing(row);	
		}
	});
	dp.attachEvent("updateCallback", function(upd, id) {
		var row = this.obj.getRowById(id);
		if (row){
			this.obj._process_xml_row(row, upd.firstChild);
			this.obj._postRowProcessing(row);	
		}
	});
	dp.attachEvent("deleteCallback", function(upd, id) {
		this.obj.setUserData(id, this.action_param, "true_deleted");
		this.obj.deleteRow(id);
	});
	

	dp._methods=["setRowTextStyle","setCellTextStyle","changeRowId","deleteRow"];
	this.attachEvent("onEditCell",function(state,id,index){
		if (dp._columns && !dp._columns[index]) return true;
		var cell = this.cells(id,index)
		if (state==1){
			if(cell.isCheckbox()){
				dp.setUpdated(id,true)
			}
		} else if (state==2){
			if(cell.wasChanged()){
				dp.setUpdated(id,true)
			}
		}
    	return true;
	});
	this.attachEvent("onRowPaste",function(id){
		dp.setUpdated(id,true)
	});
	this.attachEvent("onUndo",function(id){
		dp.setUpdated(id,true)
	});
	this.attachEvent("onRowIdChange",function(id,newid){
		var ind=dp.findRow(id);
		if (ind<dp.updatedRows.length)
			dp.updatedRows[ind]=newid;
	});
	this.attachEvent("onSelectStateChanged",function(rowId){
		if(dp.updateMode=="row")
			dp.sendData();
        return true;
	});
	this.attachEvent("onEnter",function(rowId,celInd){
		if(dp.updateMode=="row")
			dp.sendData();
        return true;
	});
	this.attachEvent("onBeforeRowDeleted",function(rowId){
		if (!this.rowsAr[rowId]) return true;
		if (this.dragContext && dp.dnd) {
			window.setTimeout(function(){
				dp.setUpdated(rowId,true);
			},1);
			return true;
		}
    	var z=dp.getState(rowId);
		if (this._h2){
			this._h2.forEachChild(rowId,function(el){
				dp.setUpdated(el.id,false);
				dp.markRow(el.id,true,"deleted");
			},this);
		}
		if (z=="inserted") {  dp.set_invalid(rowId,false); dp.setUpdated(rowId,false);		return true; }
		if (z=="deleted")  return false;
		if (z=="true_deleted")  { dp.setUpdated(rowId,false); return true; }

		dp.setUpdated(rowId,true,"deleted");
		return false;
	});
	this.attachEvent("onBindUpdate", function(id){
		if (typeof id == "object")
			id = id.id;
		dp.setUpdated(id,true);
	});
	this.attachEvent("onRowAdded",function(rowId){
		if (this.dragContext && dp.dnd) return true;
		dp.setUpdated(rowId,true,"inserted")
    	return true;
	});
	dp._getRowData=function(rowId,pref){
		var data = [];
		
		data["gr_id"]=rowId;
		if (this.obj.isTreeGrid())
			data["gr_pid"]=this.obj.getParentId(rowId);
		
		var r=this.obj.getRowById(rowId);
		for (var i=0; i<this.obj._cCount; i++){
		   if (this.obj._c_order)
		   		var i_c=this.obj._c_order[i];
		   else
			   	var i_c=i;
		
		   var c=this.obj.cells(r.idd,i);
		   if (this._changed && !c.wasChanged()) continue;
		   if (this._endnm)
		       data[this.obj.getColumnId(i)]=c.getValue();
		   else
		       data["c"+i_c]=c.getValue();
		}
		   
		var udata=this.obj.UserData[rowId];
		if (udata){
			for (var j=0; j<udata.keys.length; j++)
				if (udata.keys[j] && udata.keys[j].indexOf("__")!=0)
					data[udata.keys[j]]=udata.values[j];
		}
		var udata=this.obj.UserData["gridglobaluserdata"];
		if (udata){
		   for (var j=0; j<udata.keys.length; j++)
		       data[udata.keys[j]]=udata.values[j];
		}
		return data;
	};
	dp._clearUpdateFlag=function(rowId){
		var row=this.obj.getRowById(rowId);
		if (row)
		for (var j=0; j<this.obj._cCount; j++)
			this.obj.cells(rowId,j).cell.wasChanged=false;	//using cells because of split
	};
	dp.checkBeforeUpdate=function(rowId){ 
		var valid=true; var c_invalid=[];
		for (var i=0; i<this.obj._cCount; i++)
			if (this.mandatoryFields[i]){
				var res=this.mandatoryFields[i].call(this.obj,this.obj.cells(rowId,i).getValue(),rowId,i);
				if (typeof res == "string"){
					this.messages.push(res);
					valid = false;
				} else {
					valid&=res;
					c_invalid[i]=!res;
				}
			}
		if (!valid){
			this.set_invalid(rowId,"invalid",c_invalid);
			this.setUpdated(rowId,false);
		}
		return valid;
	};	
};

//(c)dhtmlx ltd. www.dhtmlx.com

//v.3.6 build 131108

/*
Copyright DHTMLX LTD. http://www.dhtmlx.com
To use this component please contact sales@dhtmlx.com to obtain license
*/
/**
*	@desc: dhtmlxGrid cell object constructor (shouldn't be accesed directly. Use cells and cells2 methods of the grid instead)
*	@type: cell
*	@returns: dhtmlxGrid cell
*/
function dhtmlXGridCellObject(obj){
	/**
	*	@desc: desctructor, clean used memory
	*	@type: public
	*/
	this.destructor=function(){
		this.cell.obj=null;
		this.cell=null;
		this.grid=null;
		this.base=null;
		return null;
	}
	this.cell=obj;
	/**
	*	@desc: gets Value of cell
	*	@type: public
	*/
	this.getValue=function(){
		if ((this.cell.firstChild)&&(this.cell.firstChild.tagName == "TEXTAREA"))
			return this.cell.firstChild.value;
		else
			return this.cell.innerHTML._dhx_trim(); //innerText;
	}

	/**
	*	@desc: gets math formula of cell if any
	*	@type: public
	*/
	this.getMathValue=function(){
		if (this.cell.original)
			return this.cell.original; //innerText;
		else
			return this.getValue();
	}
	
//#excell_methods:04062008{
	/**
	*	@desc: determ. font style if it was set
	*	@returns: font name only if it was set for the cell
	*	@type: public
	*/
	this.getFont=function(){
		arOut=new Array(3);

		if (this.cell.style.fontFamily)
			arOut[0]=this.cell.style.fontFamily

		if (this.cell.style.fontWeight == 'bold'||this.cell.parentNode.style.fontWeight == 'bold')
			arOut[1]='bold';

		if (this.cell.style.fontStyle == 'italic'||this.cell.parentNode.style.fontWeight == 'italic')
			arOut[1]+='italic';

		if (this.cell.style.fontSize)
			arOut[2]=this.cell.style.fontSize
		else
			arOut[2]="";
		return arOut.join("-")
	}
	/**
	*	@desc: determ. cell's text color
	*	@returns: cell's text color
	*	@type: public
	*/
	this.getTextColor=function(){
		if (this.cell.style.color)
			return this.cell.style.color
		else
			return "#000000";
	}
	/**
	*	@desc: determ. cell's background color
	*	@returns: cell's background color
	*	@type: public
	*/
	this.getBgColor=function(){
		if (this.cell.bgColor)
			return this.cell.bgColor
		else
			return "#FFFFFF";
	}
	/**
	*	@desc: determines horisontal align od the cell
	*	@returns: horisontal align of cell content
	*	@type: public
	*/
	this.getHorAlign=function(){
		if (this.cell.style.textAlign)
			return this.cell.style.textAlign;

		else if (this.cell.style.textAlign)
			return this.cell.style.textAlign;

		else
			return "left";
	}
	/**
	*	@desc: gets width of the cell in pixel
	*	@returns: width of the cell in pixels
	*	@type: public
	*/
	this.getWidth=function(){
		return this.cell.scrollWidth;
	}

	/**
	*	@desc: sets font family to the cell
	*	@param: val - string in format: Arial-bold(italic,bolditalic,underline)-12px
	*	@type: public
	*/
	this.setFont=function(val){
		fntAr=val.split("-");
		this.cell.style.fontFamily=fntAr[0];
		this.cell.style.fontSize=fntAr[fntAr.length-1]

		if (fntAr.length == 3){
			if (/bold/.test(fntAr[1]))
				this.cell.style.fontWeight="bold";

			if (/italic/.test(fntAr[1]))
				this.cell.style.fontStyle="italic";

			if (/underline/.test(fntAr[1]))
				this.cell.style.textDecoration="underline";
		}
	}
	/**
	*	@desc: sets text color to the cell
	*	@param: val - color value (name or hex)
	*	@type: public
	*/
	this.setTextColor=function(val){
		this.cell.style.color=val;
	}
	/**
	*	@desc: sets background color to the cell
	*	@param: val - color value (name or hex)
	*	@type: public
	*/
	this.setBgColor=function(val){
		if (val == "")
			val=null;
		this.cell.bgColor=val;
	}
	/**
	*	@desc: sets horisontal align to the cell
	*	@param: val - value in single-letter or full format(exmp: r or right)
	*	@type: public
	*/
	this.setHorAlign=function(val){
		if (val.length == 1){
			if (val == 'c')
				this.cell.style.textAlign='center'

			else if (val == 'l')
				this.cell.style.textAlign='left';

			else
				this.cell.style.textAlign='right';
		} else
			this.cell.style.textAlign=val
	}
//#}
	/**
	*	@desc: determines whether cell value was changed
	*	@returns: true if cell value was changed, otherwise - false
	*	@type: public
	*/
	this.wasChanged=function(){
		if (this.cell.wasChanged)
			return true;
		else
			return false;
	}
	/**
	*	@desc: determines whether first child of the cell is checkbox or radio
	*	@returns: true if first child of the cell is input element of type radio or checkbox
	*	@type: deprecated
	*/
	this.isCheckbox=function(){
		var ch = this.cell.firstChild;

		if (ch&&ch.tagName == 'INPUT'){
			type=ch.type;

			if (type == 'radio'||type == 'checkbox')
				return true;
			else
				return false;
		} else
			return false;
	}
	/**
	*	@desc: determines whether radio or checkbox inside is checked
	*	@returns: true if first child of the cell is checked
	*	@type: public
	*/
	this.isChecked=function(){
		if (this.isCheckbox()){
			return this.cell.firstChild.checked;
		}
	}
	/**
	*	@desc: determines whether cell content (radio,checkbox) is disabled
	*	@returns: true if first child of the cell is disabled
	*	@type: public
	*/
	this.isDisabled=function(){
		return this.cell._disabled;
	}
	/**
	*	@desc: checks checkbox or radion
	*	@param: fl - true or false
	*	@type: public
	*/
	this.setChecked=function(fl){
		if (this.isCheckbox()){
			if (fl != 'true'&&fl != 1)
				fl=false;
			this.cell.firstChild.checked=fl;
		}
	}
	/**
	*	@desc: disables radio or checkbox
	*	@param: fl - true or false
	*	@type: public
	*/
	this.setDisabled=function(fl){
		if (fl != 'true'&&fl != 1)
			fl=false;

		if (this.isCheckbox()){
			this.cell.firstChild.disabled=fl;

			if (this.disabledF)
				this.disabledF(fl);
		}
		this.cell._disabled=fl;
	}
}

dhtmlXGridCellObject.prototype={
	getAttribute: function(name){
		return this.cell._attrs[name];
	},
	setAttribute: function(name, value){
		this.cell._attrs[name]=value;
	},
	getInput:function(){
		if (this.obj && (this.obj.tagName=="INPUT" || this.obj.tagName=="TEXTAREA")) return this.obj;
		
		var inps=(this.obj||this.cell).getElementsByTagName("TEXTAREA");
		if (!inps.length)
			inps=(this.obj||this.cell).getElementsByTagName("INPUT");
		return inps[0];
	}
}

/**
*	@desc: sets value to the cell
*	@param: val - new value
*	@type: public
*/
dhtmlXGridCellObject.prototype.setValue=function(val){
	if (( typeof (val) != "number")&&(!val||val.toString()._dhx_trim() == "")){
		val="&nbsp;"
		this.cell._clearCell=true;
	} else
		this.cell._clearCell=false;
	this.setCValue(val);
}
/**
*	@desc: sets value to the cell
*	@param: val - new value
*	@param: val2
*	@type: private
*/
dhtmlXGridCellObject.prototype.getTitle=function(){
	return (_isIE ? this.cell.innerText : this.cell.textContent);
}

dhtmlXGridCellObject.prototype.setCValue=function(val, val2){
	this.cell.innerHTML=val;
//#__pro_feature:21092006{
//#on_cell_changed:23102006{
	this.grid.callEvent("onCellChanged", [
		this.cell.parentNode.idd,
		this.cell._cellIndex,
		(arguments.length > 1 ? val2 : val)
	]);
//#}
//#}
}

dhtmlXGridCellObject.prototype.setCTxtValue=function(val){
	this.cell.innerHTML="";
	this.cell.appendChild(document.createTextNode(val));
//#__pro_feature:21092006{	
//#on_cell_changed:23102006{
	this.grid.callEvent("onCellChanged", [
		this.cell.parentNode.idd,
		this.cell._cellIndex,
		val
	]);
//#}
//#}
}

/**
*	@desc: sets text representation of cell which contains math formula ( setLabel doesn't triger math calculations as setValue do)
*	@param: val - new value
*	@type: public
*/
dhtmlXGridCellObject.prototype.setLabel=function(val){
	this.cell.innerHTML=val;
}

/**
*	@desc: get formula of ExCell ( actual only for math based exCells )
*	@type: public
*/
dhtmlXGridCellObject.prototype.getMath=function(){
	if (this._val)
		return this.val;
	else
		return this.getValue();
}

/**
*	@desc: dhtmlxGrid cell editor constructor (base for all eXcells). Shouldn't be accessed directly
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell(){
	this.obj=null; //editor
	//this.cell = null//cell to get value from
	this.val=null; //current value (before edit)
	/**
	*	@desc: occures on space for example 
	*	@type: private
	*/
	this.changeState=function(){
		return false
	}
	/**
	*	@desc: opens editor
	*	@type: private
	*/
	this.edit=function(){
		this.val=this.getValue()
	} //
	/**
	*	@desc: return value to cell, closes editor
	*	@returns: if cell's value was changed (true) or not
	*	@type: private
	*/
	this.detach=function(){
		return false
	} //
	/**
	*	@desc: gets position (left-right) of element
	*	@param: oNode - element to get position of
	*	@type: private
	*	@topic: 8
	*/
	this.getPosition=function(oNode){
		var oCurrentNode = oNode;
		var iLeft = 0;
		var iTop = 0;

		while (oCurrentNode.tagName != "BODY"){
			iLeft+=oCurrentNode.offsetLeft;
			iTop+=oCurrentNode.offsetTop;
			oCurrentNode=oCurrentNode.offsetParent;
		}
		return new Array(iLeft, iTop);
	}
}
eXcell.prototype=new dhtmlXGridCellObject;


/**
*	@desc: simple text editor
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_ed(cell){
	if (cell){
		this.cell=cell;
		this.grid=this.cell.parentNode.grid;
	}
	this.edit=function(){
		this.cell.atag=((!this.grid.multiLine)&&(_isKHTML||_isMacOS||_isFF)) ? "INPUT" : "TEXTAREA";
		this.val=this.getValue();
		this.obj=document.createElement(this.cell.atag);
		this.obj.setAttribute("autocomplete", "off");
		this.obj.style.height=(this.cell.offsetHeight-(_isIE ? 4 : 4))+"px";
		this.obj.className="dhx_combo_edit";
		this.obj.wrap="soft";
		this.obj.style.textAlign=this.cell.style.textAlign;
		this.obj.onclick=function(e){
			(e||event).cancelBubble=true
		}
		this.obj.onmousedown=function(e){
			(e||event).cancelBubble=true
		}
		this.obj.value=this.val
		this.cell.innerHTML="";
		this.cell.appendChild(this.obj);

		this.obj.onselectstart=function(e){
			if (!e)
				e=event;
			e.cancelBubble=true;
			return true;
		};
		if (_isIE){
		    this.obj.focus();
			this.obj.blur();
		}
		this.obj.focus();
	}
	this.getValue=function(){
		if ((this.cell.firstChild)&&((this.cell.atag)&&(this.cell.firstChild.tagName == this.cell.atag)))
			return this.cell.firstChild.value;

		if (this.cell._clearCell)
			return "";

		return this.cell.innerHTML.toString()._dhx_trim();
	}

	this.detach=function(){
		this.setValue(this.obj.value);
		return this.val != this.getValue();
	}
}
eXcell_ed.prototype=new eXcell;

/**
*	@desc: pure text editor ( HTML not supported )
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_edtxt(cell){
	if (cell){
		this.cell=cell;
		this.grid=this.cell.parentNode.grid;
	}
	this.getValue=function(){
		if ((this.cell.firstChild)&&((this.cell.atag)&&(this.cell.firstChild.tagName == this.cell.atag)))
			return this.cell.firstChild.value;

		if (this.cell._clearCell)
			return "";

		return (_isIE ? this.cell.innerText : this.cell.textContent);
	}
	this.setValue=function(val){
		if (!val||val.toString()._dhx_trim() == ""){
			val=" ";
			this.cell._clearCell=true;
		} else
			this.cell._clearCell=false;
		this.setCTxtValue(val);
	}
}
eXcell_edtxt.prototype=new eXcell_ed;
//#__pro_feature:21092006{
/**
*	@desc: simple numeric text editor
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*	@edition: professional
*/
function eXcell_edn(cell){
	if (cell){
		this.cell=cell;
		this.grid=this.cell.parentNode.grid;
	}
	this.getValue=function(){
		//this.grid.editStop();
		if ((this.cell.firstChild)&&(this.cell.firstChild.tagName == "TEXTAREA"))
			return this.cell.firstChild.value;

		if (this.cell._clearCell)
			return "";

		return this.cell._orig_value||this.grid._aplNFb(this.cell.innerHTML.toString()._dhx_trim(), this.cell._cellIndex);
	}

	this.detach=function(){
		var tv = this.obj.value;
		this.setValue(tv);
		return this.val != this.getValue();
	}
}
eXcell_edn.prototype=new eXcell_ed;
eXcell_edn.prototype.setValue=function(val){ 
	if (!val||val.toString()._dhx_trim() == ""){
		this.cell._clearCell=true;
		return this.setCValue("&nbsp;",0);
	} else {
		this.cell._clearCell=false;
		this.cell._orig_value = val;
	}
	this.setCValue(this.grid._aplNF(val, this.cell._cellIndex), val);
}
//#}

//#ch_excell:04062008{
/**
*	@desc: checkbox editor
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_ch(cell){
	if (cell){
		this.cell=cell;
		this.grid=this.cell.parentNode.grid;
	}

	this.disabledF=function(fl){
		if ((fl == true)||(fl == 1))
			this.cell.innerHTML=this.cell.innerHTML.replace("item_chk0.", "item_chk0_dis.").replace("item_chk1.",
				"item_chk1_dis.");
		else
			this.cell.innerHTML=this.cell.innerHTML.replace("item_chk0_dis.", "item_chk0.").replace("item_chk1_dis.",
				"item_chk1.");
	}

	this.changeState=function(fromClick){
		//nb:
		if (fromClick===true && !this.grid.isActive) {
			if (window.globalActiveDHTMLGridObject != null && window.globalActiveDHTMLGridObject != this.grid && window.globalActiveDHTMLGridObject.isActive) window.globalActiveDHTMLGridObject.setActive(false);
			this.grid.setActive(true);
		}
		if ((!this.grid.isEditable)||(this.cell.parentNode._locked)||(this.isDisabled()))
			return;

		if (this.grid.callEvent("onEditCell", [
			0,
			this.cell.parentNode.idd,
			this.cell._cellIndex
		])){
			this.val=this.getValue()

			if (this.val == "1")
				this.setValue("0")
			else
				this.setValue("1")

			this.cell.wasChanged=true;
			//nb:
			this.grid.callEvent("onEditCell", [
				1,
				this.cell.parentNode.idd,
				this.cell._cellIndex
			]);

			this.grid.callEvent("onCheckbox", [
				this.cell.parentNode.idd,
				this.cell._cellIndex,
				(this.val != '1')
			]);

			this.grid.callEvent("onCheck", [
				this.cell.parentNode.idd,
				this.cell._cellIndex,
				(this.val != '1')
			]);
		} else { //preserve editing (not tested thoroughly for this editor)
			this.editor=null;
		}
	}
	this.getValue=function(){
		return this.cell.chstate ? this.cell.chstate.toString() : "0";
	}

	this.isCheckbox=function(){
		return true;
	}
	this.isChecked=function(){
		if (this.getValue() == "1")
			return true;
		else
			return false;
	}

	this.setChecked=function(fl){
		this.setValue(fl.toString())
	}
	this.detach=function(){
		return this.val != this.getValue();
	}
	this.edit=null;
}
eXcell_ch.prototype=new eXcell;
eXcell_ch.prototype.setValue=function(val){
	this.cell.style.verticalAlign="middle"; //nb:to center checkbox in line
	//val can be int
	if (val){
		val=val.toString()._dhx_trim();

		if ((val == "false")||(val == "0"))
			val="";
	}

	if (val){
		val="1";
		this.cell.chstate="1";
	} else {
		val="0";
		this.cell.chstate="0"
	}
	var obj = this;
	this.setCValue("<img src='"+this.grid.imgURL+"item_chk"+val
		+".gif' onclick='new eXcell_ch(this.parentNode).changeState(true); (arguments[0]||event).cancelBubble=true; '>",
		this.cell.chstate);
}
//#}
//#ra_excell:04062008{
/**
*	@desc: radio editor
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_ra(cell){
	this.base=eXcell_ch;
	this.base(cell)
	this.grid=cell.parentNode.grid;

	this.disabledF=function(fl){
		if ((fl == true)||(fl == 1))
			this.cell.innerHTML=this.cell.innerHTML.replace("radio_chk0.", "radio_chk0_dis.").replace("radio_chk1.",
				"radio_chk1_dis.");
		else
			this.cell.innerHTML=this.cell.innerHTML.replace("radio_chk0_dis.", "radio_chk0.").replace("radio_chk1_dis.",
				"radio_chk1.");
	}

	this.changeState=function(mode){
		if (mode===false && this.getValue()==1) return;
		if ((!this.grid.isEditable)||(this.cell.parentNode._locked))
			return;

		if (this.grid.callEvent("onEditCell", [
			0,
			this.cell.parentNode.idd,
			this.cell._cellIndex
		]) != false){
			this.val=this.getValue()

			if (this.val == "1")
				this.setValue("0")
			else
				this.setValue("1")
			this.cell.wasChanged=true;
			//nb:
			this.grid.callEvent("onEditCell", [
				1,
				this.cell.parentNode.idd,
				this.cell._cellIndex
			]);

			this.grid.callEvent("onCheckbox", [
				this.cell.parentNode.idd,
				this.cell._cellIndex,
				(this.val != '1')
			]);

			this.grid.callEvent("onCheck", [
				this.cell.parentNode.idd,
				this.cell._cellIndex,
				(this.val != '1')
			]);
		} else { //preserve editing (not tested thoroughly for this editor)
			this.editor=null;
		}
	}
	this.edit=null;
}
eXcell_ra.prototype=new eXcell_ch;
eXcell_ra.prototype.setValue=function(val){
	this.cell.style.verticalAlign="middle"; //nb:to center checkbox in line

	if (val){
		val=val.toString()._dhx_trim();

		if ((val == "false")||(val == "0"))
			val="";
	}

	if (val){
		if (!this.grid._RaSeCol)
			this.grid._RaSeCol=[];

		if (this.grid._RaSeCol[this.cell._cellIndex]){
			var z = this.grid.cells4(this.grid._RaSeCol[this.cell._cellIndex]);
			z.setValue("0")
			if (this.grid.rowsAr[z.cell.parentNode.idd])
			this.grid.callEvent("onEditCell", [
				1,
				z.cell.parentNode.idd,
				z.cell._cellIndex
			]);
		}

		this.grid._RaSeCol[this.cell._cellIndex]=this.cell;

		val="1";
		this.cell.chstate="1";
	} else {
		val="0";
		this.cell.chstate="0"
	}
	this.setCValue("<img src='"+this.grid.imgURL+"radio_chk"+val+".gif' onclick='new eXcell_ra(this.parentNode).changeState(false);'>",
		this.cell.chstate);
}
//#}
//#txt_excell:04062008{
/**
*	@desc: multilene popup editor
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_txt(cell){
	if (cell){
		this.cell=cell;
		this.grid=this.cell.parentNode.grid;
	}
	this.edit=function(){
		this.val=this.getValue()
		this.obj=document.createElement("TEXTAREA");
		this.obj.className="dhx_textarea";

		this.obj.onclick=function(e){
			(e||event).cancelBubble=true
		}
		var arPos = this.grid.getPosition(this.cell); //,this.grid.objBox

		this.obj.value=this.val;

		this.obj.style.display="";
		this.obj.style.textAlign=this.cell.style.textAlign;

		if (_isFF){
			var z_ff = document.createElement("DIV");
			z_ff.appendChild(this.obj);
			z_ff.style.overflow="auto";
			z_ff.className="dhx_textarea";
			this.obj.style.margin="0px 0px 0px 0px";
			this.obj.style.border="0px";
			this.obj=z_ff;
		}
		document.body.appendChild(this.obj); //nb:
		if(_isOpera) this.obj.onkeypress=function(ev){ if (ev.keyCode == 9) return false; }
		this.obj.onkeydown=function(e){
			var ev = (e||event);

			if (ev.keyCode == 9){
				globalActiveDHTMLGridObject.entBox.focus();
				globalActiveDHTMLGridObject.doKey({
					keyCode: ev.keyCode,
					shiftKey: ev.shiftKey,
					srcElement: "0"
					});

				return false;
			}
		}

		this.obj.style.left=arPos[0]+"px";
		this.obj.style.top=arPos[1]+this.cell.offsetHeight+"px";

		if (this.cell.offsetWidth < 200)
			var pw = 200;
		else
			var pw = this.cell.offsetWidth;
		this.obj.style.width=pw+(_isFF ? 18 : 16)+"px"

		if (_isFF){
			this.obj.firstChild.style.width=parseInt(this.obj.style.width)+"px";
			this.obj.firstChild.style.height=this.obj.offsetHeight-3+"px";
		}

        if (_isIE) { this.obj.select(); this.obj.value=this.obj.value; }//dzen of IE
		if (_isFF)
			this.obj.firstChild.focus();
		else {
			this.obj.focus()
		}
	}
	this.detach=function(){
		var a_val = "";

		if (_isFF)
			a_val=this.obj.firstChild.value;
		else
			a_val=this.obj.value;

		if (a_val == ""){
			this.cell._clearCell=true;
		}
		else
			this.cell._clearCell=false;
		this.setValue(a_val);
		document.body.removeChild(this.obj);
		this.obj=null;
		return this.val != this.getValue();
	}
	this.getValue=function(){
		if (this.obj){
			if (_isFF)
				return this.obj.firstChild.value;
			else
				return this.obj.value;
		}
				
		if (this.cell._clearCell)
			return "";

		if (typeof this.cell._brval != "undefined") return this.cell._brval;

		if ((!this.grid.multiLine))
			return this.cell._brval||this.cell.innerHTML;
		else
			return this.cell._brval||this.cell.innerHTML.replace(/<br[^>]*>/gi, "\n")._dhx_trim(); //innerText;
	}
}

eXcell_txt.prototype=new eXcell;

/**
*	@desc: multiline text editor without HTML support
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_txttxt(cell){
	if (cell){
		this.cell=cell;
		this.grid=this.cell.parentNode.grid;
	}
	this.getValue=function(){
		if ((this.cell.firstChild)&&(this.cell.firstChild.tagName == "TEXTAREA"))
			return this.cell.firstChild.value;

		if (this.cell._clearCell)
			return "";

		if ((!this.grid.multiLine)&&this.cell._brval)
			return this.cell._brval;

		return (_isIE ? this.cell.innerText : this.cell.textContent);
	}
	this.setValue=function(val){
		this.cell._brval=val;

		if (!val||val.toString()._dhx_trim() == ""){
			val=" ";
			this.cell._clearCell=true;
		} else
			this.cell._clearCell=false;
		this.setCTxtValue(val);
	}
}

eXcell_txttxt.prototype=new eXcell_txt;

eXcell_txt.prototype.setValue=function(val){
	this.cell._brval=val;

	if (!val||val.toString()._dhx_trim() == ""){
		val="&nbsp;"
		this.cell._clearCell=true;
	} else
		this.cell._clearCell=false;

	if ((!this.grid.multiLine) || this.cell._clearCell)
		this.setCValue(val, this.cell._brval);
	else
		this.setCValue(val.replace(/\n/g, "<br/>"), val);
}
//#}
//#co_excell:04062008{
/**
*	@desc: combobox editor
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_co(cell){
	if (cell){
		this.cell=cell;
		this.grid=this.cell.parentNode.grid;
		this.combo=(this.cell._combo||this.grid.getCombo(this.cell._cellIndex));
		this.editable=true
	}
	this.shiftNext=function(){
		var z = this.list.options[this.list.selectedIndex+1];

		if (z)
			z.selected=true;
		this.obj.value=this.list.options[this.list.selectedIndex].text;

		return true;
	}
	this.shiftPrev=function(){
		if (this.list.selectedIndex != 0){
			var z = this.list.options[this.list.selectedIndex-1];

			if (z)
				z.selected=true;
			this.obj.value=this.list.options[this.list.selectedIndex].text;
		}

		return true;
	}

	this.edit=function(){
		this.val=this.getValue();
		this.text=this.getText()._dhx_trim();
		var arPos = this.grid.getPosition(this.cell) //,this.grid.objBox)

		this.obj=document.createElement("TEXTAREA");
		this.obj.className="dhx_combo_edit";
		this.obj.style.height=(this.cell.offsetHeight-4)+"px";

		this.obj.wrap="soft";
		this.obj.style.textAlign=this.cell.style.textAlign;
		this.obj.onclick=function(e){
			(e||event).cancelBubble=true
		}
		this.obj.onmousedown=function(e){
			(e||event).cancelBubble=true
		}
		this.obj.value=this.text
		this.obj.onselectstart=function(e){
			if (!e)
				e=event;
			e.cancelBubble=true;
			return true;
		};
		var editor_obj = this;
		this.obj.onkeyup=function(e){
			var key=(e||event).keyCode;
			if (key==38 || key==40 || key==9) return;
			var val = this.readonly ? String.fromCharCode(key) : this.value;
			
			var c = editor_obj.list.options;

			for (var i = 0; i < c.length; i++)
				if (c[i].text.indexOf(val) == 0)
					return c[i].selected=true;
		}
		this.list=document.createElement("SELECT");

		this.list.className='dhx_combo_select';
		this.list.style.width=this.cell.offsetWidth+"px";
		this.list.style.left=arPos[0]+"px";                       //arPos[0]
		this.list.style.top=arPos[1]+this.cell.offsetHeight+"px"; //arPos[1]+this.cell.offsetHeight;
		this.list.onclick=function(e){
			var ev = e||window.event;
			var cell = ev.target||ev.srcElement

			//tbl.editor_obj.val=cell.combo_val;
			if (cell.tagName == "OPTION")
				cell=cell.parentNode;
			//editor_obj.list.value = cell.value;
			editor_obj.editable=false;
			editor_obj.grid.editStop();
			ev.cancelBubble = true;
		}
		var comboKeys = this.combo.getKeys();
		var fl = false
		var selOptId = 0;

		for (var i = 0; i < comboKeys.length; i++){
			var val = this.combo.get(comboKeys[i])
			this.list.options[this.list.options.length]=new Option(val, comboKeys[i]);

			if (comboKeys[i] == this.val){
				selOptId=this.list.options.length-1;
				fl=true;
			}
		}

		if (fl == false){ //if no such value in combo list
			this.list.options[this.list.options.length]=new Option(this.text, this.val === null ? "" : this.val);
			selOptId=this.list.options.length-1;
		}
		document.body.appendChild(this.list) //nb:this.grid.objBox.appendChild(this.listBox);
		this.list.size="6";
		this.cstate=1;

		if (this.editable){
			this.cell.innerHTML="";
		}
		else {
			this.obj.style.width="1px";
			this.obj.style.height="1px";
		}
		this.cell.appendChild(this.obj);
		this.list.options[selOptId].selected=true;

		//fix for coro - FF scrolls grid in incorrect position
		if ((!_isFF)||(this.editable)){
			this.obj.focus();
			this.obj.focus();
		}

		if (!this.editable){
			this.obj.style.visibility="hidden";
			this.list.focus();
			this.list.onkeydown=function(e){
				e=e||window.event;
				editor_obj.grid.setActive(true)

				if (e.keyCode < 30)
					return editor_obj.grid.doKey({
						target: editor_obj.cell,
						keyCode: e.keyCode,
						shiftKey: e.shiftKey,
						ctrlKey: e.ctrlKey
						})
			}
		}
	}

	this.getValue=function(){
		return ((this.cell.combo_value == window.undefined) ? "" : this.cell.combo_value);
	}
	this.detach=function(){
		if (this.val != this.getValue()){
			this.cell.wasChanged=true;
		}

		if (this.list.parentNode != null){
			if (this.editable){
					var ind = this.list.options[this.list.selectedIndex]
					if (ind&&ind.text == this.obj.value)
						this.setValue(this.list.value)
					else{
						var combo=(this.cell._combo||this.grid.getCombo(this.cell._cellIndex));
						var val=combo.values._dhx_find(this.obj.value);
						if (val!=-1) this.setValue(combo.keys[val]);
						else this.setCValue(this.cell.combo_value=this.obj.value);
					}
			}
			else
				this.setValue(this.list.value)
		}

		if (this.list.parentNode)
			this.list.parentNode.removeChild(this.list);

		if (this.obj.parentNode)
			this.obj.parentNode.removeChild(this.obj);

		return this.val != this.getValue();
	}
}
eXcell_co.prototype=new eXcell;
eXcell_co.prototype.getText=function(){
	return this.cell.innerHTML;
}
eXcell_co.prototype.setValue=function(val){
	if (typeof (val) == "object"){
		var optCol = this.grid.xmlLoader.doXPath("./option", val);

		if (optCol.length)
			this.cell._combo=new dhtmlXGridComboObject();

		for (var j = 0;
			j < optCol.length;
			j++)this.cell._combo.put(optCol[j].getAttribute("value"),
			optCol[j].firstChild
				? optCol[j].firstChild.data
				: "");
		val=val.firstChild.data;
	}

	if ((val||"").toString()._dhx_trim() == "")
		val=null
	this.cell.combo_value=val;
	
	if (val !== null){
		var label = (this.cell._combo||this.grid.getCombo(this.cell._cellIndex)).get(val);
		this.setCValue(label===null?val:label, val);
	}else
		this.setCValue("&nbsp;", val);

	
}
/**
*	@desc: selectbox editor
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_coro(cell){
	this.base=eXcell_co;
	this.base(cell)
	this.editable=false;
}
eXcell_coro.prototype=new eXcell_co;

function eXcell_cotxt(cell){
	this.base=eXcell_co;
	this.base(cell)
}
eXcell_cotxt.prototype=new eXcell_co;
eXcell_cotxt.prototype.getText=function(){
	return (_isIE ? this.cell.innerText : this.cell.textContent);
}
eXcell_cotxt.prototype.setValue=function(val){
	if (typeof (val) == "object"){
		var optCol = this.grid.xmlLoader.doXPath("./option", val);

		if (optCol.length)
			this.cell._combo=new dhtmlXGridComboObject();

		for (var j = 0;
			j < optCol.length;
			j++)this.cell._combo.put(optCol[j].getAttribute("value"),
			optCol[j].firstChild
				? optCol[j].firstChild.data
				: "");
		val=val.firstChild.data;
	}

	if ((val||"").toString()._dhx_trim() == "")
		val=null

	if (val !== null)
		this.setCTxtValue((this.cell._combo||this.grid.getCombo(this.cell._cellIndex)).get(val)||val, val);
	else
		this.setCTxtValue(" ", val);

	this.cell.combo_value=val;
}

function eXcell_corotxt(cell){
	this.base=eXcell_co;
	this.base(cell)
	this.editable=false;
}
eXcell_corotxt.prototype=new eXcell_cotxt;
//#}

//#cp_excell:04062008{
/**
*	@desc: color picker editor
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_cp(cell){
	try{
		this.cell=cell;
		this.grid=this.cell.parentNode.grid;
	}
	catch (er){}
	this.edit=function(){
		this.val=this.getValue()
		this.obj=document.createElement("SPAN");
		this.obj.style.border="1px solid black";
		this.obj.style.position="absolute";
		var arPos = this.grid.getPosition(this.cell); //,this.grid.objBox
		this.colorPanel(4, this.obj)
		document.body.appendChild(this.obj);          //this.grid.objBox.appendChild(this.obj);
		this.obj.style.left=arPos[0]+"px";
		this.obj.style.zIndex=1000;
		this.obj.style.top=arPos[1]+this.cell.offsetHeight+"px";
	}
	this.toolDNum=function(value){
		if (value.length == 1)
			value='0'+value;
		return value;
	}
	this.colorPanel=function(index, parent){
		var tbl = document.createElement("TABLE");
		parent.appendChild(tbl)
		tbl.cellSpacing=0;
		tbl.editor_obj=this;
		tbl.style.cursor="default";
		tbl.onclick=function(e){
			var ev = e||window.event
			var cell = ev.target||ev.srcElement;
			var ed = cell.parentNode.parentNode.parentNode.editor_obj
			ed.setValue(cell._bg)
			ed.grid.editStop();
		}
		var cnt = 256 / index;
		for (var j = 0; j <= (256 / cnt); j++){
			var r = tbl.insertRow(j);

			for (var i = 0; i <= (256 / cnt); i++){
				for (var n = 0; n <= (256 / cnt); n++){
					R=new Number(cnt*j)-(j == 0 ? 0 : 1)
					G=new Number(cnt*i)-(i == 0 ? 0 : 1)
					B=new Number(cnt*n)-(n == 0 ? 0 : 1)
					var rgb =
						this.toolDNum(R.toString(16))+""+this.toolDNum(G.toString(16))+""+this.toolDNum(B.toString(16));
					var c = r.insertCell(i);
					c.width="10px";
					c.innerHTML="&nbsp;"; //R+":"+G+":"+B;//
					c.title=rgb.toUpperCase()
					c.style.backgroundColor="#"+rgb
					c._bg="#"+rgb;

					if (this.val != null&&"#"+rgb.toUpperCase() == this.val.toUpperCase()){
						c.style.border="2px solid white"
					}
				}
			}
		}
	}
	this.getValue=function(){
		return this.cell.firstChild._bg||""; //this.getBgColor()
	}
	this.getRed=function(){
		return Number(parseInt(this.getValue().substr(1, 2), 16))
	}
	this.getGreen=function(){
		return Number(parseInt(this.getValue().substr(3, 2), 16))
	}
	this.getBlue=function(){
		return Number(parseInt(this.getValue().substr(5, 2), 16))
	}
	this.detach=function(){
		if (this.obj.offsetParent != null)
			document.body.removeChild(this.obj);
		//this.obj.removeNode(true)
		return this.val != this.getValue();
	}
}
eXcell_cp.prototype=new eXcell;
eXcell_cp.prototype.setValue=function(val){
	this.setCValue("<div style='width:100%;height:"+((this.grid.multiLine?this.cell.offsetHeight-2:16))+";background-color:"+(val||"")
		+";border:0px;'>&nbsp;</div>",
		val);
	this.cell.firstChild._bg=val;
}
//#}

//#img_excell:04062008{
/**
*	@desc: image editor
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
/*
	The corresponding  cell value in XML should be a "^" delimited list of following values:
	1st - image src
	2nd - image alt text (optional)
	3rd - link (optional)
	4rd - target (optional, default is _self)
*/
function eXcell_img(cell){
	try{
		this.cell=cell;
		this.grid=this.cell.parentNode.grid;
	}
	catch (er){}
	this.getValue=function(){
		if (this.cell.firstChild.tagName == "IMG")
			return this.cell.firstChild.src+(this.cell.titFl != null
				? "^"+this.cell._brval
				: "");
			else if (this.cell.firstChild.tagName == "A"){
			var out = this.cell.firstChild.firstChild.src+(this.cell.titFl != null ? "^"+this.cell._brval : "");
			out+="^"+this.cell.lnk;

			if (this.cell.trg)
				out+="^"+this.cell.trg
			return out;
		}
	}
	this.isDisabled=function(){
		return true;
	}
}
eXcell_img.prototype=new eXcell;
eXcell_img.prototype.getTitle=function(){
	return this.cell._brval
}
eXcell_img.prototype.setValue=function(val){
	var title = val;

	if (val.indexOf("^") != -1){
		var ar = val.split("^");
		val=ar[0]
		title=this.cell._attrs.title||ar[1];

		//link
		if (ar.length > 2){
			this.cell.lnk=ar[2]

			if (ar[3])
				this.cell.trg=ar[3]
		}
		this.cell.titFl="1";
	}
	this.setCValue("<img src='"+this.grid.iconURL+(val||"")._dhx_trim()+"' border='0'>", val);

	if (this.cell.lnk){
		this.cell.innerHTML="<a href='"+this.cell.lnk+"' target='"+this.cell.trg+"'>"+this.cell.innerHTML+"</a>"
	}
	this.cell._brval=title;
}
//#}

//#price_excell:04062008{
/**
*	@desc: text editor with price (USD) formatting
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_price(cell){
	this.base=eXcell_ed;
	this.base(cell)
	this.getValue=function(){
		if (this.cell.childNodes.length > 1)
			return this.cell.childNodes[1].innerHTML.toString()._dhx_trim()
		else
			return "0";
	}
}

eXcell_price.prototype=new eXcell_ed;
eXcell_price.prototype.setValue=function(val){
	if (isNaN(parseFloat(val))){
		val=this.val||0;
	}
	var color = "green";

	if (val < 0)
		color="red";

	this.setCValue("<span>$</span><span style='padding-right:2px;color:"+color+";'>"+val+"</span>", val);
}
//#}

//#dyn_excells:04062008{
/**
*	@desc: text editor with additional formatting for positive and negative numbers (arrow down/up and color)
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_dyn(cell){
	this.base=eXcell_ed;
	this.base(cell)
	this.getValue=function(){
		return this.cell.firstChild.childNodes[1].innerHTML.toString()._dhx_trim()
	}
}

eXcell_dyn.prototype=new eXcell_ed;
eXcell_dyn.prototype.setValue=function(val){
	if (!val||isNaN(Number(val))){
		if (val!=="")
			val=0;
	}

	if (val > 0){
		var color = "green";
		var img = "dyn_up.gif";
	} else if (val == 0){
		var color = "black";
		var img = "dyn_.gif";
	} else {
		var color = "red";
		var img = "dyn_down.gif";
	}
	this.setCValue("<div style='position:relative;padding-right:2px; width:100%;overflow:hidden; white-space:nowrap;'><img src='"+this.grid.imgURL+""+img
		+"' height='15' style='position:absolute;top:0px;left:0px;'><span style=' padding-left:20px; width:100%;color:"+color+";'>"+val
		+"</span></div>",
		val);
}
//#}

/**
*	@desc: readonly editor
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_ro(cell){
	if (cell){
		this.cell=cell;
		this.grid=this.cell.parentNode.grid;
	}
	this.edit=function(){
	}

	this.isDisabled=function(){
		return true;
	}
	this.getValue=function(){
		return this.cell._clearCell?"":this.cell.innerHTML.toString()._dhx_trim();
	}
}
eXcell_ro.prototype=new eXcell;

function eXcell_ron(cell){
	this.cell=cell;
	this.grid=this.cell.parentNode.grid;
	this.edit=function(){
	}

	this.isDisabled=function(){
		return true;
	}
	this.getValue=function(){
		return this.cell._clearCell?"":this.grid._aplNFb(this.cell.innerHTML.toString()._dhx_trim(), this.cell._cellIndex).toString();
	}
}
eXcell_ron.prototype=new eXcell;
eXcell_ron.prototype.setValue=function(val){ 
	if (val === 0){}
	else if (!val||val.toString()._dhx_trim() == ""){
		this.setCValue("&nbsp;");
		return this.cell._clearCell=true;
	}
	this.cell._clearCell=false;
	this.setCValue(val?this.grid._aplNF(val, this.cell._cellIndex):"0");
}


/**
*	@desc: readonly pure text editor (without HTML support)
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_rotxt(cell){
	this.cell=cell;
	this.grid=this.cell.parentNode.grid;
	this.edit=function(){
	}

	this.isDisabled=function(){
		return true;
	}
	this.setValue=function(val){
		if (!val){
			val=" ";
			this.cell._clearCell = true;
		}
		else
			this.cell._clearCell = false;
			
		this.setCTxtValue(val);
	}
	this.getValue=function(){
		if (this.cell._clearCell)
			return "";
	    return (_isIE ? this.cell.innerText : this.cell.textContent);
	}	
}
eXcell_rotxt.prototype=new eXcell;

/**
	*	@desc: combobox object constructor (shouldn't be accessed directly - instead please use getCombo(...) method of the grid)
	*	@type: private
	*	@returns: combobox for dhtmlxGrid
	*/
function dhtmlXGridComboObject(){
	this.keys=new dhtmlxArray();
	this.values=new dhtmlxArray();
	/**
	*	@desc: puts new combination of key and value into combobox
	*	@type: public
	*	@param: key - object to use as a key (should be a string in the case of combobox)
	*	@param: value - object value of combobox line
	*/
	this.put=function(key, value){
		for (var i = 0; i < this.keys.length; i++){
			if (this.keys[i] == key){
				this.values[i]=value;
				return true;
			}
		}
		this.values[this.values.length]=value;
		this.keys[this.keys.length]=key;
	}
	/**
	*	@desc: gets value corresponding to the given key
	*	@type: public
	*	@param: key - object to use as a key (should be a string in the case of combobox)
	*	@returns: value correspond. to given key or null if no such key
	*/
	this.get=function(key){
		for (var i = 0; i < this.keys.length; i++){
			if (this.keys[i] == key){
				return this.values[i];
			}
		}
		return null;
	}
	/**
	*	@desc: clears combobox
	*	@type: public
	*/
	this.clear=function(){
		/*for(var i=0;i<this.keys.length;i++){
				this.keys._dhx_removeAt(i);
				this.values._dhx_removeAt(i);
		}*/
		this.keys=new dhtmlxArray();
		this.values=new dhtmlxArray();
	}
	/**
	*	@desc: remove pair of key-value from combobox with given key 
	*	@type: public
	*	@param: key - object to use as a key
	*/
	this.remove=function(key){
		for (var i = 0; i < this.keys.length; i++){
			if (this.keys[i] == key){
				this.keys._dhx_removeAt(i);
				this.values._dhx_removeAt(i);
				return true;
			}
		}
	}
	/**
	*	@desc: gets the size of combobox 
	*	@type: public
	*	@returns: current size of combobox
	*/
	this.size=function(){
		var j = 0;

		for (var i = 0; i < this.keys.length; i++){
			if (this.keys[i] != null)
				j++;
		}
		return j;
	}
	/**
	*	@desc: gets array of all available keys present in combobox
	*	@type: public
	*	@returns: array of all available keys
	*/
	this.getKeys=function(){
		var keyAr = new Array(0);

		for (var i = 0; i < this.keys.length; i++){
			if (this.keys[i] != null)
				keyAr[keyAr.length]=this.keys[i];
		}
		return keyAr;
	}

	/**
	*	@desc: save curent state
	*	@type: public
	*/
	this.save=function(){
		this._save=new Array();

		for (var i = 0; i < this.keys.length; i++)this._save[i]=[
			this.keys[i],
			this.values[i]
		];
	}


	/**
	*	@desc: restore saved state
	*	@type: public
	*/
	this.restore=function(){
		if (this._save){
			this.keys[i]=new Array();
			this.values[i]=new Array();

			for (var i = 0; i < this._save.length; i++){
				this.keys[i]=this._save[i][0];
				this.values[i]=this._save[i][1];
			}
		}
	}
	return this;
}

function Hashtable(){
	this.keys=new dhtmlxArray();
	this.values=new dhtmlxArray();
	return this;
}
Hashtable.prototype=new dhtmlXGridComboObject;

//(c)dhtmlx ltd. www.dhtmlx.com
//v.3.6 build 131108

/*
Copyright DHTMLX LTD. http://www.dhtmlx.com
To use this component please contact sales@dhtmlx.com to obtain license
*/
dhtmlXGridObject.prototype._process_json_row=function(r, data){
	r._attrs=data;
	for (var j = 0; j < r.childNodes.length; j++)r.childNodes[j]._attrs={
	};
	if (data.userdata)
		for (var a in data.userdata)
			this.setUserData(r.idd,a,data.userdata[a]);
			
	data = this._c_order?this._swapColumns(data.data):data.data;

	for (var i=0; i<data.length; i++)
		if (typeof data[i] == "object" && data[i] != null){
			r.childNodes[i]._attrs=data[i];
			if (data[i].type) r.childNodes[i]._cellType=data[i].type;
			data[i]=data[i].value;
		}
	this._fillRow(r, data);
	return r;
};


dhtmlXGridObject.prototype._process_js_row=function(r, data){
	r._attrs=data;
	for (var j = 0; j < r.childNodes.length; j++)
		r.childNodes[j]._attrs={};

	if (data.userdata)
		for (var a in data.userdata)
			this.setUserData(r.idd,a,data.userdata[a]);
			
	var arr = [];
	for (var i=0; i<this.columnIds.length; i++){
		arr[i] = data[this.columnIds[i]];
		if (typeof arr[i] == "object" && arr[i] != null){
			r.childNodes[i]._attrs=arr[i];
			if (arr[i].type) r.childNodes[i]._cellType=arr[i].type;
			arr[i]=arr[i].value;
		}
		if (!arr[i] && arr[i]!==0)
			arr[i]="";
	}

	this._fillRow(r, arr);
	return r;
};

dhtmlXGridObject.prototype.updateFromJSON = function(url, insert_new, del_missed, afterCall){
	if (typeof insert_new == "undefined")
		insert_new=true;
	this._refresh_mode=[
		true,
		insert_new,
		del_missed
	];
	
	this.load(url,afterCall,"json");
},
dhtmlXGridObject.prototype._refreshFromJSON = function(data){
		if (this._f_rowsBuffer) this.filterBy(0,"");
		reset = false;
		if (window.eXcell_tree){
			eXcell_tree.prototype.setValueX=eXcell_tree.prototype.setValue;
			eXcell_tree.prototype.setValue=function(content){
				var r=this.grid._h2.get[this.cell.parentNode.idd]
				if (r && this.cell.parentNode.valTag){
					this.setLabel(content);
				} else
					this.setValueX(content);
			};
		}
	
		var tree = this.cellType._dhx_find("tree");
		var pid = data.parent||0;
	
		var del = {
		};
	
		if (this._refresh_mode[2]){
			if (tree != -1)
				this._h2.forEachChild(pid, function(obj){
					del[obj.id]=true;
				}, this);
			else
				this.forEachRow(function(id){
					del[id]=true;
				});
		}
	
		var rows = data.rows;
	
		for (var i = 0; i < rows.length; i++){
			var row = rows[i];
			var id = row.id;
			del[id]=false;
	
			if (this.rowsAr[id] && this.rowsAr[id].tagName!="TR"){
				if (this._h2)
					this._h2.get[id].buff.data=row;
				else
					this.rowsBuffer[this.getRowIndex(id)].data=row;
				this.rowsAr[id]=row;
			} else if (this.rowsAr[id]){
					this._process_json_row(this.rowsAr[id], row, -1);
					this._postRowProcessing(this.rowsAr[id],true)
				} else if (this._refresh_mode[1]){
					var dadd={
						idd: id,
						data: row,
						_parser: this._process_json_row,
						_locator: this._get_json_data
					};
					
					var render_index = this.rowsBuffer.length;
					if (this._refresh_mode[1]=="top"){
						this.rowsBuffer.unshift(dadd);
						render_index = 0;
					} else
						this.rowsBuffer.push(dadd);
						
					if (this._h2){ 
						reset=true;
						(this._h2.add(id,pid)).buff=this.rowsBuffer[this.rowsBuffer.length-1];
					}
						
					this.rowsAr[id]=row;
					row=this.render_row(render_index);
					this._insertRowAt(row,render_index?-1:0)
				}
		}
				
		if (this._refresh_mode[2])
			for (id in del){
				if (del[id]&&this.rowsAr[id])
					this.deleteRow(id);
			}
	
		this._refresh_mode=null;
		if (window.eXcell_tree)
			eXcell_tree.prototype.setValue=eXcell_tree.prototype.setValueX;
			
		if (reset) this._renderSort();
		if (this._f_rowsBuffer) {
			this._f_rowsBuffer = null;
			this.filterByAll();
		}
	},

	dhtmlXGridObject.prototype._process_js=function(data){
		return this._process_json(data, "js");
	},

	dhtmlXGridObject.prototype._process_json=function(data, mode){
		this._parsing=true;
		try {
			if (data&&data.xmlDoc){
				eval("dhtmlx.temp="+data.xmlDoc.responseText+";");
				data = dhtmlx.temp;
			} else if (typeof data == "string"){
				eval("dhtmlx.temp="+data+";");
				data = dhtmlx.temp;
			}
		} catch(e){
				dhtmlxError.throwError("LoadXML", "Incorrect JSON", [
					(data.xmlDoc||data),
					this
				]);
				data = {rows:[]};
		}
			
		if (this._refresh_mode) return this._refreshFromJSON(data);				

		var cr = parseInt(data.pos||0);
		var total = parseInt(data.total_count||0);
		
		var reset = false;
		if (total){
			if (!this.rowsBuffer[total-1]){
				if (this.rowsBuffer.length)
					reset=true;
			this.rowsBuffer[total-1]=null;
			} 
			if (total<this.rowsBuffer.length){
				this.rowsBuffer.splice(total, this.rowsBuffer.length - total);
				reset = true;
			}
		}
			
		for (var key in data){
			if (key!="rows")
				this.setUserData("",key, data[key]);
		}

		if (mode == "js" && data.collections){
			for (var colkey in data.collections){
				var index = this.getColIndexById(colkey);
				var colrecs = data.collections[colkey];
				if (index !== window.undefined){
					if (this.cellType[index] == "clist"){
						colplaindata=[];
						for (var j=0; j<colrecs.length; j++)
							colplaindata.push(colrecs[j].label);
						this.registerCList(index, colplaindata);
					} else {
						var combo = this.getCombo(index);
						for (var j = 0; j < colrecs.length; j++)
							combo.put(colrecs[j].value, colrecs[j].label);
					}
				}
			}
		}
		
		if (this.isTreeGrid())
			return this._process_tree_json(data, null, null, mode);
			
		if (mode == "js"){
			if (data.data)
				data = data.data;
			for (var i = 0; i < data.length; i++){
				if (this.rowsBuffer[i+cr])
					continue;

				var row = data[i];
				var id  = row.id||(i+1);
				this.rowsBuffer[i+cr]={
					idd: id,
					data: row,
					_parser: this._process_js_row,
					_locator: this._get_js_data
				};

				this.rowsAr[id]=data[i];
			}
		} else {
			for (var i = 0; i < data.rows.length; i++){
				if (this.rowsBuffer[i+cr])
					continue;
				var id = data.rows[i].id;
				this.rowsBuffer[i+cr]={
					idd: id,
					data: data.rows[i],
					_parser: this._process_json_row,
					_locator: this._get_json_data
				};
	
				this.rowsAr[id]=data.rows[i];
			}
		}
		
		if (reset && this._srnd){
			var h = this.objBox.scrollTop;
			this._reset_view();
			this.objBox.scrollTop = h;
		} else {
			this.render_dataset();
		}
		
		this._parsing=false;
}

dhtmlXGridObject.prototype._get_json_data=function(data, ind){
	if (typeof data.data[ind] == "object")
		return data.data[ind].value;
	else
		return data.data[ind];
};

dhtmlXGridObject.prototype._process_tree_json=function(data,top,pid,mode){
	this._parsing=true;
	var main=false;
	if (!top){
		this.render_row=this.render_row_tree;
		main=true;
		top=data;
		pid=top.parent||0;
		if (pid=="0") pid=0;
		if (!this._h2)	 this._h2=new dhtmlxHierarchy();
		if (this._fake) this._fake._h2=this._h2;
	} 
	
	if (mode == "js"){
		if (top.data && !pid) 
			data = top.data;
		if (top.rows)
			top = top.rows;
		for (var i = 0; i < top.length; i++){
			var id = top[i].id;
			var row=this._h2.add(id,pid);
			row.buff={ idd:id, data:top[i], _parser: this._process_js_row, _locator:this._get_js_data };

			if (top[i].open)
			    row.state="minus";
				
			this.rowsAr[id]=row.buff;
		    this._process_tree_json(top[i],top[i],id,mode);
		}
	} else {
		if (top.rows) {
			for (var i = 0; i < top.rows.length; i++){
					var id = top.rows[i].id;
					var row=this._h2.add(id,pid);
					row.buff={ idd:id, data:top.rows[i], _parser: this._process_json_row, _locator:this._get_json_data };
					if (top.rows[i].open)
					    row.state="minus";
					
					this.rowsAr[id]=row.buff;
				    this._process_tree_json(top.rows[i],top.rows[i],id,mode);
			}
		}
	}
		
	if (main){ 
		
		if (pid!=0) this._h2.change(pid,"state","minus")
		this._updateTGRState(this._h2.get[pid]);
		this._h2_to_buff();
		
		if (pid!=0 && (this._srnd || this.pagingOn))
			this._renderSort();
		else
			this.render_dataset();
		
		
	
		if (this._slowParse===false){
			this.forEachRow(function(id){
				this.render_row_tree(0,id)
			})
		}
		this._parsing=false;
	}
	
}	

//v.3.6 build 131108

/*
Copyright DHTMLX LTD. http://www.dhtmlx.com
To use this component please contact sales@dhtmlx.com to obtain license
*/
//please beware that function started from _in_header_ must not be obfuscated



/**
*   @desc: filter grid by mask
*   @type: public
*   @param: column - {number} zero based index of column
*   @param: value - {string} filtering mask
*   @param: preserve - {bool} filter current or initial state ( false by default )
*	@edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.filterBy=function(column, value, preserve){
	if (this.isTreeGrid()) return this.filterTreeBy(column, value, preserve);
	if (this._f_rowsBuffer){
		if (!preserve){
			this.rowsBuffer=dhtmlxArray([].concat(this._f_rowsBuffer));
			if (this._fake) this._fake.rowsBuffer=this.rowsBuffer;
		}
	} else
		this._f_rowsBuffer=[].concat(this.rowsBuffer);	//backup copy
	
		
	if (!this.rowsBuffer.length) return;
	var d=true;
	this.dma(true)
	if (typeof(column)=="object")
		for (var j=0; j<value.length; j++)
			this._filterA(column[j],value[j]);
	else
			this._filterA(column,value);
	this.dma(false)
	if (this.pagingOn && this.rowsBuffer.length/this.rowsBufferOutSize < (this.currentPage-1)) this.changePage(0);
	this._reset_view();
	this.callEvent("onGridReconstructed",[])
}
dhtmlXGridObject.prototype._filterA=function(column,value){ 
	if (value=="") return;
	var d=true;
	if (typeof(value)=="function") d=false;
	else value=(value||"").toString().toLowerCase();
	if (!this.rowsBuffer.length) return;
	
	for (var i=this.rowsBuffer.length-1; i>=0; i--)
		if (d?(this._get_cell_value(this.rowsBuffer[i],column).toString().toLowerCase().indexOf(value)==-1):(!value.call(this, this._get_cell_value(this.rowsBuffer[i],column),this.rowsBuffer[i].idd)))
			this.rowsBuffer.splice(i,1);//filter row
}

dhtmlXGridObject.prototype.getFilterElement=function(index){
	if (!this.filters) return;
	for (var i=0; i < this.filters.length; i++) {
		if (this.filters[i][1]==index)
			return (this.filters[i][0].combo||this.filters[i][0]);
	};
	return null;
}

/**
*   @desc: get all possible values in column
*   @type: public
*   @param: column - {number} zero based index of column
*   @returns: {array} array of all possible values in column
*	@edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.collectValues=function(column){
	var value=this.callEvent("onCollectValues",[column]);
	if (value!==true) return value;
	
	if (this.isTreeGrid()) return this.collectTreeValues(column);
	this.dma(true)
	this._build_m_order();
	column=this._m_order?this._m_order[column]:column;
	var c={}; var f=[];
	var col=this._f_rowsBuffer||this.rowsBuffer;
	for (var i=0; i<col.length; i++){
		var val=this._get_cell_value(col[i],column);
		if (val && (!col[i]._childIndexes || col[i]._childIndexes[column]!=col[i]._childIndexes[column-1])) c[val]=true;
	}
	this.dma(false);
	var vals= (this.combos[column]||(this._col_combos?this._col_combos[column]:false));
	for (var d in c) 
		if (c[d]===true){
           if(vals){
               if(vals.get&&vals.get(d)){
                   d = vals.get(d);
               }
               else if(vals.getOption&&vals.getOption(d)){
                   d = vals.getOption(d).text;
               }

           }
           f.push(d);
        }
	
	return f.sort();			
}

dhtmlXGridObject.prototype._build_m_order=function(){
	if (this._c_order){
		this._m_order=[]
		for (var i=0; i < this._c_order.length; i++) {
			this._m_order[this._c_order[i]]=i;
		};
	}
}
/**
*   @desc: force grid filtering by registered inputs ( created by # starting shortcuts, or by makeFilter function )
*   @type: public
*	@edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.filterByAll=function(){
	var a=[];
	var b=[];
	this._build_m_order();

	for (var i=0; i<this.filters.length; i++){
		if (i >= this._cCount) continue;
		var ind=this._m_order?this._m_order[this.filters[i][1]]:this.filters[i][1];
		b.push(ind);

		var val=this.filters[i][0].old_value=this.filters[i][0].value;
		if (this.filters[i][0]._filter)
			val = this.filters[i][0]._filter();
		
		var vals;
		if (typeof val != "function" && (vals=(this.combos[ind]||(this._col_combos?this._col_combos[ind]:false)))){
            if(vals.values){
                ind=vals.values._dhx_find(val);
			    val=(ind==-1)?val:vals.keys[ind];
            }
			else if(vals.getOptionByLabel){
                val=(vals.getOptionByLabel(val)?vals.getOptionByLabel(val).value:val);
            }
		}
		a.push(val);
		
	}
	if (!this.callEvent("onFilterStart",[b,a])) return;
	this.filterBy(b,a);
	if (this._cssEven) this._fixAlterCss();
	this.callEvent("onFilterEnd",[this.filters]);

	if (this._f_rowsBuffer && this.rowsBuffer.length == this._f_rowsBuffer.length)
		this._f_rowsBuffer = null;
}

/**
*   @desc: create a filter from any input element (text filter), select (dropdown) or DIV (combobox based on dhtmlxCombo)
*   @type: public
*   @param: id - {string|object} input id or input html object
*   @param: column - {number} index of column
*   @param: preserve - {bool} filter current state or initial one ( false by default )
*	@edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.makeFilter=function(id,column,preserve){
	if (!this.filters) this.filters=[];
	if (typeof(id)!="object")
		id=document.getElementById(id);
	if(!id) return;
	var self=this;
	
	if (!id.style.width) id.style.width = "90%";
		
	if (id.tagName=='SELECT'){
		this.filters.push([id,column]);
		this._loadSelectOptins(id,column);
		id.onchange=function(){
			self.filterByAll();
		}
		if(_isIE)
			id.style.marginTop="1px";
			
		this.attachEvent("onEditCell",function(stage,a,ind){ 
			this._build_m_order();
			if (stage==2 && this.filters && ( this._m_order?(ind==this._m_order[column]):(ind==column) ))
				this._loadSelectOptins(id,column);
			return true;
		});
	} 
	else if (id.tagName=='INPUT'){
		this.filters.push([id,column]);
		id.old_value = id.value='';
		id.onkeydown=function(){
			if (this._timer) window.clearTimeout(this._timer);
			this._timer=window.setTimeout(function(){
				if (id.value != id.old_value){
					self.filterByAll();
					id.old_value=id.value;
				}
			},500);
		};
	}
	else if (id.tagName=='DIV' && id.className=="combo"){
		this.filters.push([id,column]);
		id.style.padding="0px";id.style.margin="0px";
		if (!window.dhx_globalImgPath) window.dhx_globalImgPath=this.imgURL;
		var z=new dhtmlXCombo(id,"_filter","90%");
		z.filterSelfA=z.filterSelf;
		z.filterSelf=function(){
			if (this.getSelectedIndex()==0) this.setComboText("");
			this.filterSelfA.apply(this,arguments);
			this.optionsArr[0].hide(false);	
		}
         
         
		z.enableFilteringMode(true);
		id.combo=z;
		id.value="";
		
		this._loadComboOptins(id,column);
		z.attachEvent("onChange",function(){
			id.value=z.getSelectedValue();
			if (id.value === null) id.value = "";
			self.filterByAll();
		});
	}
	if (id.parentNode)
		id.parentNode.className+=" filter";
	
	this._filters_ready(); //set event handlers
}
	/**
	*   @desc: find cell in grid by value
	*   @param: value - search string
	*   @param: c_ind - index of column to search in (optional. if not specified, then search everywhere)
	*   @param: count - count of results to return
	*   @edition: Professional
	*   @returns: array each member of which contains array with row ID  and cell index
	*   @type:  public
	*/
	dhtmlXGridObject.prototype.findCell=function(value, c_ind, count, compare){ 
		var compare = compare || (function(master, check){
			return check.toString().toLowerCase().indexOf(master) != -1;
		});
		if (compare === true)
			compare = function(master, check){ return check.toString().toLowerCase() == master; };

		var res = new Array();
		value=value.toString().toLowerCase();
		if (typeof count != "number") count = count?1:0;
	
		if (!this.rowsBuffer.length)
			return res;
	
		for (var i = (c_ind||0); i < this._cCount; i++){
			if (this._h2)
				this._h2.forEachChild(0,function(el){
					if (count && res.length==count) return res;
					if (compare(value, this._get_cell_value(el.buff,i))){
						res.push([el.id,i]);
					}
				},this)
			else
				for (var j=0; j < this.rowsBuffer.length; j++) 
					if (compare(value, this._get_cell_value(this.rowsBuffer[j],i))){
						res.push([this.rowsBuffer[j].idd,i]);
						if (count && res.length==count) return res;
					}
						
			
		
			if (typeof (c_ind) != "undefined")
				return res;
		}
	
		return res;
	}
	
/**
*   @desc: create a search box (set selection to the row with found value) from any input
*   @type: public
*   @param: id - {string|object} input id or input html object
*   @param: column - {number} index of column
*	@edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.makeSearch=function(id,column,strict){
	if (typeof(id)!="object")
		id=document.getElementById(id);
	if(!id) return;
	var self=this;
		
	if (id.tagName=='INPUT'){
		id.onkeypress=function(){
			if (this._timer) window.clearTimeout(this._timer);
			this._timer=window.setTimeout(function(){
				if (id.value=="") return;
				var z=self.findCell(id.value,column,true,strict);
				if (z.length){
					if (self._h2)
						self.openItem(z[0][0]);
					self.selectCell(self.getRowIndex(z[0][0]),(column||0))
				}
			},500);
		};
	}
	if (id.parentNode)
		id.parentNode.className+=" filter";
}
	
dhtmlXGridObject.prototype._loadSelectOptins=function(t,c){ 
		var l=this.collectValues(c);
		var v=t.value;
		t.innerHTML="";
		t.options[0]=new Option("","");
		var f=this._filter_tr?this._filter_tr[c]:null;
		for (var i=0; i<l.length; i++)
			t.options[t.options.length]=new Option(f?f(l[i]):l[i],l[i]);
		t.value=v;
}
dhtmlXGridObject.prototype.setSelectFilterLabel=function(ind,fun){ 
		if (!this._filter_tr) this._filter_tr=[];
		this._filter_tr[ind]=fun;
}

dhtmlXGridObject.prototype._loadComboOptins=function(t,c){
	if (!t.combo) return; // prevent calls from refreshFilters
	var l=this.collectValues(c);
	t.combo.clearAll();
	t.combo.render(false);
	var opts = [["","&nbsp;"]];
	for (var i=0; i<l.length; i++) opts.push([l[i],l[i]]);
	t.combo.addOption(opts);
	t.combo.render(true);
}

/**
*   @desc: refresh filtering ( can be used if data in grid changed and filters need to be updated )
*   @type: public
*	@edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.refreshFilters=function(){
        if(!this.filters) return;
	for (var i=0; i<this.filters.length; i++){
		switch(this.filters[i][0].tagName.toLowerCase()){
			case "input":
				break;
			case "select":
				this._loadSelectOptins.apply(this,this.filters[i]);
				break;
			case "div":
				this._loadComboOptins.apply(this,this.filters[i]);
				break;
		}
	}
}

dhtmlXGridObject.prototype._filters_ready=function(fl,code){
	this.attachEvent("onXLE",this.refreshFilters);
	this.attachEvent("onRowCreated",function(id,r){
		if (this._f_rowsBuffer)
			for (var i=0; i<this._f_rowsBuffer.length; i++)
				if (this._f_rowsBuffer[i].idd == id)
					return this._f_rowsBuffer[i]=r;
	})
	this.attachEvent("onClearAll",function(){ 
	    this._f_rowsBuffer=null; 
		if (!this.hdr.rows.length)
			this.filters=[];
	});
	if (window.dhtmlXCombo)
		this.attachEvent("onScroll",dhtmlXCombo.prototype.closeAll);
	
	this._filters_ready=function(){};
}

dhtmlXGridObject.prototype._in_header_text_filter=function(t,i){
	t.innerHTML="<input type='text'>";
	t.onclick=t.onmousedown = function(e){ (e||event).cancelBubble=true; return true; }
	t.onselectstart=function(){ return (event.cancelBubble=true); }
	this.makeFilter(t.firstChild,i);
}

dhtmlXGridObject.prototype._in_header_text_filter_inc=function(t,i){
	t.innerHTML="<input type='text'>";
	t.onclick=t.onmousedown = function(e){ (e||event).cancelBubble=true; return true; }
	t.onselectstart=function(){ return (event.cancelBubble=true); }
	this.makeFilter(t.firstChild,i);
	t.firstChild._filter=function(){ 
		if (t.firstChild.value=="") return "";
		return function(val){
			return (val.toString().toLowerCase().indexOf(t.firstChild.value.toLowerCase())==0); 
		}
	}
	this._filters_ready();
}

dhtmlXGridObject.prototype._in_header_select_filter=function(t,i){
	t.innerHTML="<select></select>";
	t.onclick=function(e){ (e||event).cancelBubble=true; return false; }
	this.makeFilter(t.firstChild,i);
}

dhtmlXGridObject.prototype._in_header_select_filter_strict=function(t,i){
	t.innerHTML="<select style='width:90%; font-size:8pt; font-family:Tahoma;'></select>";
	t.onclick=function(e){ (e||event).cancelBubble=true; return false; }
	this.makeFilter(t.firstChild,i);
	var combos = this.combos;
	t.firstChild._filter=function(){ 
		var value = t.firstChild.value;
		if (!value) return "";
		if (combos[i])
            value = combos[i].keys[combos[i].values._dhx_find(value)];
       	value = value.toLowerCase();
            
		return function(val){
			return (val.toString().toLowerCase()==value); 
		};
	};
	this._filters_ready();
}

dhtmlXGridObject.prototype._in_header_combo_filter=function(t,i){
	t.innerHTML="<div style='width:100%; padding-left:2px; overflow:hidden; ' class='combo'></div>";
	t.onselectstart=function(){ return (event.cancelBubble=true); }
	t.onclick=t.onmousedown=function(e){ (e||event).cancelBubble=true; return true; }
	this.makeFilter(t.firstChild,i);
}

dhtmlXGridObject.prototype._search_common=function(t, i){
	t.innerHTML="<input type='text' style='width:90%; '>";
	t.onclick= t.onmousedown = function(e){ (e||event).cancelBubble=true; return true; }
	t.onselectstart=function(){ return (event.cancelBubble=true); }
}
dhtmlXGridObject.prototype._in_header_text_search=function(t,i, strict){
	this._search_common(t, i);
	this.makeSearch(t.firstChild,i);
}
dhtmlXGridObject.prototype._in_header_text_search_strict=function(t,i){
	this._search_common(t, i);
	this.makeSearch(t.firstChild,i, true);
}

dhtmlXGridObject.prototype._in_header_numeric_filter=function(t,i){
	this._in_header_text_filter.call(this,t,i);
	t.firstChild._filter=function(){
		var v=this.value;
		
		var r; var op="=="; var num=parseFloat(v.replace("=","")); var num2=null;
		
		if (v){
			if (v.indexOf("..")!=-1){
				v=v.split("..");
				num=parseFloat(v[0]);
				num2=parseFloat(v[1]);
				return function(v){
					if (v>=num && v<=num2) return true;
					return false;
					}
			}
			r=v.match(/>=|<=|>|</)
			if (r) {
				op=r[0];
				num=parseFloat(v.replace(op,""));
			}
			return Function("v"," if (v "+op+" "+num+" ) return true; return false;");
		}
		return "";
	};
}

dhtmlXGridObject.prototype._in_header_master_checkbox=function(t,i,c){
	t.innerHTML=c[0]+"<input type='checkbox' />"+c[1];
	var self=this;
	t.getElementsByTagName("input")[0].onclick=function(e){
		self._build_m_order();
		var j=self._m_order?self._m_order[i]:i;
		var val=this.checked?1:0;
		self.forEachRowA(function(id){
			var c=this.cells(id,j);
			if (c.isCheckbox()) {
				c.setValue(val);
				c.cell.wasChanged = true;
			}
			this.callEvent("onEditCell",[1,id,j,val]);
			this.callEvent("onCheckbox", [id, j, val]);
		});
		(e||event).cancelBubble=true;
	}
}

dhtmlXGridObject.prototype._in_header_stat_total=function(t,i,c){
	var calck=function(){
		var summ=0;
		this._build_m_order();
		var ii = this._m_order?this._m_order[i]:i;
		for (var j=0; j<this.rowsBuffer.length; j++){
			var v=parseFloat(this._get_cell_value(this.rowsBuffer[j],ii));
			summ+=isNaN(v)?0:v;
		}
		
		return this._maskArr[ii]?this._aplNF(summ,ii):(Math.round(summ*100)/100);
	}
	this._stat_in_header(t,calck,i,c,c);
}
dhtmlXGridObject.prototype._in_header_stat_multi_total=function(t,i,c){
	var cols=c[1].split(":"); c[1]="";
	for(var k = 0; k < cols.length;k++){
		cols[k]=parseInt(cols[k]);
	}
	var calck=function(){
		var summ=0;
		for (var j=0; j<this.rowsBuffer.length; j++){
			var v = 1;
			for(var k = 0; k < cols.length;k++){
				v *= parseFloat(this._get_cell_value(this.rowsBuffer[j],cols[k]))
			}
			summ+=isNaN(v)?0:v;
		}
		return this._maskArr[i]?this._aplNF(summ,i):(Math.round(summ*100)/100);
	}
	var track=[];
	for(var ind = 0; ind < cols.length;ind++){
		track[cols[ind]]=true;
	}
	this._stat_in_header(t,calck,track,c,c);
}
dhtmlXGridObject.prototype._in_header_stat_max=function(t,i,c){
	var calck=function(){
		this._build_m_order();
		var ii = this._m_order?this._m_order[i]:i;
		
		var summ=-999999999;
		if (this.getRowsNum()==0) return "&nbsp;";
		for (var j=0; j<this.rowsBuffer.length; j++)
			summ=Math.max(summ,parseFloat(this._get_cell_value(this.rowsBuffer[j],ii)));
		
		return this._maskArr[i]?this._aplNF(summ,i):summ;
	}
	this._stat_in_header(t,calck,i,c);
}
dhtmlXGridObject.prototype._in_header_stat_min=function(t,i,c){
	var calck=function(){
		this._build_m_order();
		var ii = this._m_order?this._m_order[i]:i;
		
		var summ=999999999;
		if (this.getRowsNum()==0) return "&nbsp;";
		for (var j=0; j<this.rowsBuffer.length; j++)
			summ=Math.min(summ,parseFloat(this._get_cell_value(this.rowsBuffer[j],ii)));
		return this._maskArr[i]?this._aplNF(summ,i):summ;
	}
	this._stat_in_header(t,calck,i,c);
}
dhtmlXGridObject.prototype._in_header_stat_average=function(t,i,c){
	var calck=function(){
		this._build_m_order();
		var ii = this._m_order?this._m_order[i]:i;
		
		var summ=0; var count=0;
		if (this.getRowsNum()==0) return "&nbsp;";
		for (var j=0; j<this.rowsBuffer.length; j++){
			var v=parseFloat(this._get_cell_value(this.rowsBuffer[j],ii));
			summ+=isNaN(v)?0:v;
			count++;
		}
		return this._maskArr[i]?this._aplNF(summ/count,i):(Math.round(summ/count*100)/100);
	}
	this._stat_in_header(t,calck,i,c);
}
dhtmlXGridObject.prototype._in_header_stat_count=function(t,i,c){
	var calck=function(){
		return this.getRowsNum();
	}
	this._stat_in_header(t,calck,i,c);
}

dhtmlXGridObject.prototype._stat_in_header=function(t,calck,i,c){
	var that=this;
	var f=function(){
		this.dma(true)
		t.innerHTML=(c[0]?c[0]:"")+calck.call(this)+(c[1]?c[1]:"");
		this.dma(false)
		this.callEvent("onStatReady",[])
	}
	if (!this._stat_events) {
		this._stat_events=[];
		this.attachEvent("onClearAll",function(){ 
			if (!this.hdr.rows[1]){
				for (var i=0; i<this._stat_events.length; i++)
					for (var j=0; j < 4; j++) 
						this.detachEvent(this._stat_events[i][j]);
				this._stat_events=[];	
			}
		})
	}
	
	this._stat_events.push([
	this.attachEvent("onGridReconstructed",f),
	this.attachEvent("onXLE",f),
	this.attachEvent("onFilterEnd",f),
	this.attachEvent("onEditCell",function(stage,id,ind){
		if (stage==2 && ( ind==i || ( i && i[ind]) ) ) f.call(this);
		return true;
		})]);
	t.innerHTML="";
}



//(c)dhtmlx ltd. www.dhtmlx.com
//v.3.6 build 131108

/*
Copyright DHTMLX LTD. http://www.dhtmlx.com
To use this component please contact sales@dhtmlx.com to obtain license
*/
dhtmlXGridObject.prototype.unGroup=function(){ 
	if (!this._groups) return;
	this._dndProblematic=false;
	
	delete this._groups;
	delete this._gIndex;	
	if (this._fake)	this._mirror_rowsCol();
	this.forEachRow(function(id){
		this.rowsAr[id].style.display='';
	})
	this._reset_view();
	this.callEvent("onGridReconstructed",[])
	this.callEvent("onUnGroup",[]);
}

dhtmlXGridObject.prototype._mirror_rowsCol=function(){ 
	this._fake._groups=this._groups;
	this._fake._gIndex=this._gIndex;
	this.rowsBuffer=dhtmlxArray(); 
	for (var i=0; i<this.rowsCol.length; i++)
		if (!this.rowsCol[i]._cntr)
			this.rowsBuffer.push(this.rowsCol[i]);
	this._fake.rowsBuffer=dhtmlxArray(); 
	for (var i=0; i<this._fake.rowsCol.length; i++)
		if (!this._fake.rowsCol[i]._cntr)
			this._fake.rowsBuffer.push(this._fake.rowsCol[i]);
	
}
/**
*	@desc: group grid content by values of specified column
*	@param: ind - column index to group by
*	@edition: Professional
*	@type: public
*/
dhtmlXGridObject.prototype.groupBy=function(ind,mask){
		
	if (this._groups) this.unGroup();
	this._dndProblematic=true;
	this._groups={};
	if (!mask) {
		mask=["#title"];
		for (var i=1; i<this._cCount; i++) mask.push("#cspan");
	}
	this._gmask=document.createElement("TR");
	this._gmask.origin = mask;
	var ltd,rindex=0;
	for (var i=0; i<mask.length; i++){
		if (mask[i]=="#cspan") 
			ltd.colSpan=(parseInt(ltd.colSpan)||1)+1
		else {
			ltd=document.createElement("TD");
			ltd._cellIndex=i;
			if (this._hrrar[i]) ltd.style.display="none";
			ltd.className="group_row";
			ltd.innerHTML="&nbsp;";
			if (mask[i]=="#title") this._gmask._title=rindex;
			else ltd.align=this.cellAlign[i]||"left";
			this._gmask.appendChild(ltd);
			if (mask[i].indexOf("#stat")==0){
				this._gmask._math=true;
				ltd._counter=[this["_g_"+mask[i].replace("#","")],i,rindex];
			}
			rindex++;
		}
	}
	for (var a in this._groups) this._groups[a]=this.undefined;
	this._gIndex=ind;
	
	if (this._fake &&!this._realfake){
		this._fake._groups=[];
		this._fake._gIndex=this._gIndex;
	}
	
	//keyboard commands
	this._nextRow=function(ind,dir){
		var r=this.rowsCol[ind+dir];
		if (r && ( r.style.display=="none" || r._cntr)) return this._nextRow(ind+dir,dir);
		return r;	
	}
	
	if (!this.__sortRowsBG){
		this._key_events=dhtmlXHeir({},this._key_events)
		this._key_events.k38_0_0=function(){
			if (this.editor && this.editor.combo)
				this.editor.shiftPrev();
			else{
				var rowInd = this.row.rowIndex;
				if (!rowInd) return;
				var nrow=this._nextRow(rowInd-1,-1);
				if (nrow)
	        		this.selectCell(nrow,this.cell._cellIndex,true);
			}
		}
		this._key_events.k13_1_0=this._key_events.k13_0_1=function(){};
	this._key_events.k40_0_0=function(){
		if (this.editor && this.editor.combo)
			this.editor.shiftNext();
		else{
			var rowInd = this.row.rowIndex;
			if (!rowInd) return;
			var nrow=this._nextRow(rowInd-1,1);
			if (nrow)
        		this.selectCell(nrow,this.cell._cellIndex,true);
		}
	}	
	
		this.attachEvent("onFilterStart",function(){
			if (this._groups) this._groups=this.undefined;
			return true;
		});
		this.attachEvent("onFilterEnd",function(){
			if (typeof this._gIndex != "undefined") this.groupBy(this._gIndex,this._gmask.origin);
		});
		this.sortRows_bg=this.sortRows;
		this.sortRows=function(ind,type,dir){
			if (typeof(this._groups)=="undefined") return this.sortRows_bg.apply(this,arguments);
			this.callEvent("onBeforeSorting",[ind,(type||"str"),(dir||"asc")]);
		}
		this.attachEvent("onBeforeSorting",function(ind,type,dir){
			if (typeof(this._groups)=="undefined") return true;
			if (ind==this._gIndex) this._sortByGroup(ind,type,dir);
			else this._sortInGroup(ind,type,dir);
			this.setSortImgState(true,ind,dir)
			if (this._fake){ 
				this._mirror_rowsCol();
				this._fake._groups=[];
				this._fake._reset_view();
			}
			this.setSortImgState(true,ind,dir);
			this.callEvent("onAfterSorting",[ind,type,dir]);
			return false;
		});
		this.attachEvent("onClearAll",function(){ this.unGroup(); });
		this.attachEvent("onBeforeRowDeleted",function(id){ 
			if (!this._groups) return true;
			if (!this.rowsAr[id]) return true;
			var val=this.cells(id,this._gIndex).getValue();
			if (val==="") val=" ";
			var z=this._groups[val];
			this._dec_group(z);
			return true;
			});
		this.attachEvent("onAfterRowDeleted",function(id){ 
			this.updateGroups();
			});			
		this.attachEvent("onCheckbox",function(id,index,value){
			this.callEvent("onEditCell",[2,id,index,(value?1:0),(value?0:1)]);
		});
		this.attachEvent("onXLE",this.updateGroups);
		this.attachEvent("onColumnHidden",this.hideGroupColumn);
		this.attachEvent("onEditCell",function(stage,id,ind,val,oldval){
			if (!this._groups) return true;
			if (stage==2 && val!=oldval && ind==this._gIndex){
				if (oldval==="") oldval=" ";
				this._dec_group(this._groups[oldval]);
				var r=this.rowsAr[id];
				var i=this.rowsCol._dhx_find(r)
				var ni=this._inc_group(val);
				var n=this.rowsCol[ni];
				if (r==n) n=n.nextSibling;
					
				
				var p=r.parentNode;
				var o=r.rowIndex;
				
				p.removeChild(r);
				if (n)
					p.insertBefore(r,n);
				else
					p.appendChild(r);
				this.rowsCol._dhx_insertAt(ni,r);
				if (ni<i) i++;
				this.rowsCol._dhx_removeAt(i,r);
				this._fixAlterCss();
			} else if (stage==2 && val!=oldval) {
				this.updateGroups();
				this._updateGroupView(this._groups[this.cells(id,this._gIndex).getValue()||" "]);
				}
			return true;
			})
		this.__sortRowsBG=true;
	}
	
	
	this._groupExisting();	
	if (this._hrrar)
		for (var i=0; i<this._hrrar.length; i++)
			if (this._hrrar[i])
				this.hideGroupColumn(i,true);
	this.callEvent("onGroup",[]);
	if (this._ahgr || this._awdth) this.setSizes();
}
dhtmlXGridObject.prototype._sortInGroup=function(col,type,order){
	var b=this._groups_get();
	b.reverse();

	for (var i=0; i<b.length; i++){
		var c=b[i]._cntr._childs; var a={};
		for (var j=0; j<c.length; j++){
			var cell = this.cells3(c[j],col);
			a[c[j].idd]=cell.getDate?cell.getDate():cell.getValue();
		}
			
		this._sortCore(col,type,order,a,c);
	}
	//add|delete|edit|ungroup
	this._groups_put(b);
	this.setSizes();
	this.callEvent("onGridReconstructed",[])
}

dhtmlXGridObject.prototype._sortByGroup=function(col,type,order){ 
	var b=this._groups_get();
	var a=[];
	for (var i=0; i<b.length; i++){
		b[i].idd="_sort_"+i;
		a["_sort_"+i]=b[i]._cntr.text;
	}
		
	this._sortCore(col,type,order,a,b);
	//add|delete|edit|ungroup
	this._groups_put(b);
	this.callEvent("onGridReconstructed",[])
	this.setSizes();
}
dhtmlXGridObject.prototype._inc_group=function(val,hidden,skip){
	if (val==="") val=" ";
	if (!this._groups[val]){ 
		this._groups[val]={text:val,row:this._addPseudoRow(),count:0,state:hidden?"plus":"minus"}; }
	var z=this._groups[val];
	//this._fixAlterCss();
	z.row._cntr=z;
		
	 
	var ind=this.rowsCol._dhx_find(z.row)+z.count+1;
	z.count++;
	
	if (!skip) {
	this._updateGroupView(z);
		this.updateGroups();
	}
	return ind;
}
dhtmlXGridObject.prototype._dec_group=function(z){
	if (!z) return;
	z.count--;
	if (z.count==0){
		z.row.parentNode.removeChild(z.row);
		this.rowsCol._dhx_removeAt(this.rowsCol._dhx_find(z.row));
		delete this._groups[z.text];
	}
	else
		this._updateGroupView(z);
	if (this._fake && !this._realfake)
		this._fake._dec_group(this._fake._groups[z.text]);
	this.updateGroups();
	return true;	
	}
dhtmlXGridObject.prototype._insertRowAt_gA=dhtmlXGridObject.prototype._insertRowAt;
dhtmlXGridObject.prototype._insertRowAt=function(r,ind,skip){
	if (typeof(this._groups)!="undefined"){
		if (this._realfake)
			var val=this._fake._bfs_cells(r.idd,this._gIndex).getValue();
		else
			if (this._bfs_cells3)
				var val=this._bfs_cells3(r,this._gIndex).getValue();
			else
				var val=this.cells3(r,this._gIndex).getValue();
			if (!val) val=" ";
			ind=this._inc_group(val,r.style.display=="none");		
	}
	var res=this._insertRowAt_gA(r,ind,skip);
	if (typeof(this._groups)!="undefined"){	
		this.expandGroup(val);
		this._updateGroupView(this._groups[val]);
		this.updateGroups();
	}
	return res;
}

dhtmlXGridObject.prototype._updateGroupView=function(z){ 
	if (this._fake && !this._realfake) return z.row.firstChild.innerHTML="&nbsp;";
	var mask = this._gmask||this._fake._gmask;
	var html="<img style='margin-bottom:-4px' src='"+this.imgURL+z.state+".gif'> ";
	if (this.customGroupFormat) html+=this.customGroupFormat(z.text,z.count);
	else html+=z.text+" ( "+z.count+" ) ";
	z.row.childNodes[mask._title].innerHTML=html;
}
dhtmlXGridObject.prototype._addPseudoRow=function(skip){
	
	var mask = this._gmask||this._fake._gmask;
	var r=mask.cloneNode(true)
	//cloneNode ignores custom attributes
	for (var i=0; i<r.childNodes.length; i++) {
		r.childNodes[i]._cellIndex=mask.childNodes[i]._cellIndex;
		if (this._realfake) r.childNodes[i].style.display="";
	}
	var that=this;
	
	r.onclick=function(e){ 
		if (!that.callEvent("onGroupClick",[this._cntr.text]))
			return;

		if (that._fake && that._realfake) 
			that._fake._switchGroupState(that._fake._groups[this._cntr.text].row); 
		else
			that._switchGroupState(this);
		(e||event).cancelBubble="true"; }
	r.ondblclick=function(e){ (e||event).cancelBubble="true"; }
	
	if (!skip){
		if (_isKHTML)
			this.obj.appendChild(r)
		else
			this.obj.firstChild.appendChild(r)
		this.rowsCol.push(r);
	}
	return r;
}

dhtmlXGridObject.prototype._groups_get=function(){
	var b=[];
	this._temp_par=this.obj.parentNode;
	this._temp_par.removeChild(this.obj);
	var a=[];
	for (var i=this.rowsCol.length-1; i>=0; i--){
		if (this.rowsCol[i]._cntr){
			this.rowsCol[i]._cntr._childs=a;
			a=[];
			b.push(this.rowsCol[i]);
		} else a.push(this.rowsCol[i]);
		this.rowsCol[i].parentNode.removeChild(this.rowsCol[i]);
	}
  return b;
}

dhtmlXGridObject.prototype._groups_put=function(b){ 
	var sts = this.rowsCol.stablesort;
	this.rowsCol=new dhtmlxArray(0);
	this.rowsCol.stablesort = sts;
	
	for (var i=0; i<b.length; i++){
		var gr=b[i]._cntr;
		this.obj.firstChild.appendChild(gr.row);
		this.rowsCol.push(gr.row)
		gr.row.idd=null;
		for (var j=0; j<gr._childs.length; j++){
			this.obj.firstChild.appendChild(gr._childs[j]);
			this.rowsCol.push(gr._childs[j])
		}
		delete gr._childs;
	}
	this._temp_par.appendChild(this.obj);
}
dhtmlXGridObject.prototype._groupExisting=function(b){ 
	if (!this.getRowsNum()) return;
	var b=[];
	this._temp_par=this.obj.parentNode;
	this._temp_par.removeChild(this.obj);
	var a=[];
	
	var mlen=this.rowsCol.length;
	for (var i=0; i<mlen; i++){
		var val=this.cells4(this.rowsCol[i].childNodes[this._gIndex]).getValue();
		this.rowsCol[i].style.display = "";
		if (!val) val=" ";
		
		if (!this._groups[val]){
			this._groups[val]={text:val,row:this._addPseudoRow(true),count:0,state:"minus"};
			var z=this._groups[val];
			z.row._cntr=z;
			this._groups[val]._childs=[];
			b.push(z.row)
		}
		
		this._groups[val].count++;
		this._groups[val]._childs.push(this.rowsCol[i]);
		this.rowsCol[i].parentNode.removeChild(this.rowsCol[i]);
	}
  for (var i=0; i<b.length; i++)
 	this._updateGroupView(b[i]._cntr)
  this._groups_put(b);
  if (this._fake && !this._realfake) {
  	this._mirror_rowsCol();
  	this._fake._groups=[];
  	this._fake._reset_view();
  }
  this.callEvent("onGridReconstructed",[])
  this.updateGroups();
}

dhtmlXGridObject.prototype._switchGroupState=function(row){
	var z=row._cntr;
	if (this._fake && !this._realfake) {
		z.state=this._fake._groups[row._cntr.text].row._cntr.state;
		this._fake._switchGroupState(this._fake._groups[row._cntr.text].row)
	}
	
	var ind=this.rowsCol._dhx_find(z.row)+1;
	z.state=z.state=="minus"?"plus":"minus";
	var st=z.state=="plus"?"none":"";
	
	while(this.rowsCol[ind] && !this.rowsCol[ind]._cntr){
		this.rowsCol[ind].style.display=st;
		ind++;
	}

	this._updateGroupView(z);
	this.callEvent("onGroupStateChanged",[z.text, (z.state=="minus")]);
	this.setSizes();
}
/**
*	@desc: expand group of rows
*	@param: val - value to use to determine what group to expand (in other words this should be value common for all of them)
*	@edition: Professional
*	@type: public
*/
dhtmlXGridObject.prototype.expandGroup=function(val){
	if (this._groups[val].state=="plus")
		this._switchGroupState(this._groups[val].row);
}
/**
*	@desc: collapse group of rows
*	@param: val - value to use to determine what group to collapse (in other words this should be value common for all of them)
*	@edition: Professional
*	@type: public
*/
dhtmlXGridObject.prototype.collapseGroup=function(val){
	if (this._groups[val].state=="minus")
		this._switchGroupState(this._groups[val].row);
}
/**
*	@desc: expand all groups
*	@edition: Professional
*	@type: public
*/
dhtmlXGridObject.prototype.expandAllGroups=function(){
	for(var i in this._groups)
		if (this._groups[i] && this._groups[i].state=="plus")
			this._switchGroupState(this._groups[i].row);
}
/**
*	@desc: collapse all groups
*	@edition: Professional
*	@type: public
*/
dhtmlXGridObject.prototype.collapseAllGroups=function(){
	for(var i in this._groups)
		if (this._groups[i] && this._groups[i].state=="minus")
			this._switchGroupState(this._groups[i].row);
}

dhtmlXGridObject.prototype.hideGroupColumn=function(ind,state){
	if (this._fake) return;
	var rind=-1;
	var row = this._gmask.childNodes;
	for (var i=0; i<row.length; i++)
		if (row[i]._cellIndex==ind) {
			rind = i;
			break;
	}
	if (rind == -1) return;
	for (var a in this._groups)
		this._groups[a].row.childNodes[rind].style.display=state?"none":"";
};
dhtmlXGridObject.prototype.groupStat=function(name,ind,math){
	math = this["_g_"+(math||"stat_total")];
	var summ=0; var index=0;
	this.forEachRowInGroup(name,function(id){
		summ=math(summ,this.cells(id,ind).getValue()*1,index)
		index++;
	})
	return summ;
}
dhtmlXGridObject.prototype.forEachRowInGroup=function(name,code){
	var row=this._groups[name].row.nextSibling;
	if (row){
		while (row && !row._cntr) {
			code.call(this,row.idd);
			row=row.nextSibling;
		}
	} else {
		var cs=this._groups[name]._childs;
		if (cs)
			for (var i=0; i<cs.length; i++)
				code.call(this,cs[i].idd);
	}
};
dhtmlXGridObject.prototype.updateGroups=function(){
	if (!this._gmask || !this._gmask._math || this._parsing) return;
	var r=this._gmask.childNodes;
	for (var i=0; i<r.length; i++)
		if (r[i]._counter) this._b_processing.apply(this,r[i]._counter)
}
dhtmlXGridObject.prototype._b_processing=function(a,ind,rind){
	var c=0,j=0; 
	//put editor in cache, so it can be used for custom html containers - can be moved in cells5(?)
	if (!this._ecache[this.cellType[ind]]) this.cells5({parentNode:{grid:this}},this.cellType[ind]);
	for (var i=this.rowsCol.length-1; i>=0; i--){
		if (!this.rowsCol[i]._cntr){
			c=a(c,this.cells3(this.rowsCol[i],ind).getValue()*1,j);
			j++;
		} else {
			this.cells5(this.rowsCol[i].childNodes[rind],this.cellType[ind]).setValue(c);
			j=c=0;
		}
	}
}

dhtmlXGridObject.prototype._g_stat_total=function(c,n,i){
	return c+n;
}
dhtmlXGridObject.prototype._g_stat_min=function(c,n,i){
	if (!i) c=Infinity;
	return Math.min(c,n);
}
dhtmlXGridObject.prototype._g_stat_max=function(c,n,i){
	if (!i) c=-Infinity;
	return Math.max(c,n);
}
dhtmlXGridObject.prototype._g_stat_average=function(c,n,i){
	return (c*i+n)/(i+1);
}
dhtmlXGridObject.prototype._g_stat_count=function(c,n,i){
	return c++;
}
	
//(c)dhtmlx ltd. www.dhtmlx.com

//v.3.6 build 131108

/*
Copyright DHTMLX LTD. http://www.dhtmlx.com
To use this component please contact sales@dhtmlx.com to obtain license
*/
/**
*     @desc: enable/disable drag-and-drop
*     @type: public
*     @param: mode - enabled/disabled [ can be true/false/temporary_disabled - last value mean that tree can be D-n-D can be switched to true later ]
*     @topic: 0
*/
   dhtmlXGridObject.prototype.enableDragAndDrop=function(mode){
        if  (mode=="temporary_disabled"){
            this.dADTempOff=false;
            mode=true;                  }
        else
            this.dADTempOff=true;

		this.dragAndDropOff=convertStringToBoolean(mode);
		this._drag_validate=true;
		if (mode)
			this.objBox.ondragstart = function (e) {
				(e||event).cancelBubble = true;
				return false;
			}
       };

/**
*     @desc: set Drag-And-Drop behavior (child - drop as chils, sibling - drop as sibling
*     @type: public
*     @param: mode - behavior name (child,sibling,complex)
*     @topic: 0
*/
dhtmlXGridObject.prototype.setDragBehavior=function(mode){
        this.dadmodec=this.dadmodefix=0;
      switch (mode) {
         case "child": this.dadmode=0; this._sbmod=false;  break;
         case "sibling": this.dadmode=1; this._sbmod=false;  break;
         case "sibling-next": this.dadmode=1; this._sbmod=true; break;
         case "complex": this.dadmode=2; this._sbmod=false;  break;
         case "complex-next": this.dadmode=2; this._sbmod=true;  break;
      }    };


/**
*     @desc: switch to mode when draged item, droped in target location in same order as they was in source grid
*     @type: public
*     @param: mode - true/false to enable/disable mode
*     @topic: 0
*/
dhtmlXGridObject.prototype.enableDragOrder=function(mode){
        this._dndorder=convertStringToBoolean(mode);
};


dhtmlXGridObject.prototype._checkParent=function(row,ids){
	var z=this._h2.get[row.idd].parent;
	if (!z.parent) return;
	for (var i=0; i<ids.length; i++) 
		if (ids[i]==z.id) return true;
		
	return this._checkParent(this.rowsAr[z.id],ids);
}

/**
*     @desc: create html element for dragging
*     @type: private
*     @param: htmlObject - html node object
*     @topic: 1
*/
dhtmlXGridObject.prototype._createDragNode=function(htmlObject,e){
	  this.editStop();
	  if (window.dhtmlDragAndDrop.dragNode) return null;
      if (!this.dADTempOff) return null;
      htmlObject.parentObject=new Object();
      htmlObject.parentObject.treeNod=this;

	var text=this.callEvent("onBeforeDrag",[htmlObject.parentNode.idd,htmlObject._cellIndex, e]);
	if (!text) return null;

      var z=new Array();
//#__pro_feature:21092006{
      z=this.getSelectedId();
	  z=(((z)&&(z!=""))?z.split(this.delim):[]);
      var exst=false;
      for (var i=0; i<z.length; i++)
        if (z[i]==htmlObject.parentNode.idd)  exst=true;
      if (!exst){
      	this.selectRow(this.rowsAr[htmlObject.parentNode.idd],false,e.ctrlKey,false);
      	if (!e.ctrlKey) {
      		z=[];
  		}
//#}
          z[this.selMultiRows?z.length:0]=htmlObject.parentNode.idd;
//#__pro_feature:21092006{
    }
//#}

	//remove child in case of treeGrid
	if (this.isTreeGrid()){
		for (var i=z.length-1; i>=0; i--) 
			if (this._checkParent(this.rowsAr[z[i]],z)) z.splice(i,1);
				
	}
	

	var self=this;
	if (z.length && this._dndorder)
		z.sort(function(a,b){ return (self.rowsAr[a].rowIndex>self.rowsAr[b].rowIndex?1:-1); });

     var el = this.getFirstParentOfType(_isIE?e.srcElement:e.target,"TD");
     if (el) this._dndExtra=el._cellIndex;
      this._dragged=new Array();
      for (var i=0; i<z.length; i++)
          if (this.rowsAr[z[i]]){
          this._dragged[this._dragged.length]=this.rowsAr[z[i]];
          this.rowsAr[z[i]].treeNod=this;
          }

      htmlObject.parentObject.parentNode=htmlObject.parentNode;

   var dragSpan=document.createElement('div');
   dragSpan.innerHTML=(text!==true?text:this.rowToDragElement(htmlObject.parentNode.idd));
   dragSpan.style.position="absolute";
   dragSpan.className="dragSpanDiv";
   return dragSpan;
}



/**
*   @desc:  create a drag visual marker
*   @type:  private
*/
dhtmlXGridObject.prototype._createSdrgc=function(){
    this._sdrgc=document.createElement("DIV");
    this._sdrgc.innerHTML="&nbsp;";
    this._sdrgc.className="gridDragLine";
    this.objBox.appendChild(this._sdrgc);
}











/**
*   @desc:  create a drag context object
*   @type:  private
*/
function dragContext(a,b,c,d,e,f,j,h,k,l){
    this.source=a||"grid";
    this.target=b||"grid";
    this.mode=c||"move";
    this.dropmode=d||"child";
    this.sid=e||0;
    this.tid=f;
    this.sobj=j||null;
    this.tobj=h||null;
   this.sExtra=k||null;
   this.tExtra=l||null;
    return this;
}
/**
*   @desc:  check is operation possible
*   @type:  private
*/
dragContext.prototype.valid=function(){
   if (this.sobj!=this.tobj) return true;
   if (this.sid==this.tid) return false;
   if (this.target=="treeGrid"){
      var z=this.tid
      while (z = this.tobj.getParentId(z) ){
         if (this.sid==z) return false;
         }
   }
   return true;
}
/**
*   @desc:  close context
*   @type:  private
*/
dragContext.prototype.close=function(){
    this.sobj=null;
    this.tobj=null;
}
/**
*   @desc:  return copy of context
*   @type:  private
*/
dragContext.prototype.copy=function(){
    return new dragContext(this.source,this.target,this.mode,this.dropmode,this.sid,this.tid,this.sobj,this.tobj,this.sExtra,this.tExtra);
}
/**
*   @desc:  set a lue of context attribute
*   @type:  private
*/
dragContext.prototype.set=function(a,b){
    this[a]=b;
    return this;
}
/**
*   @desc:  generate an Id for new node
*   @type:  private
*/
dragContext.prototype.uid=function(a,b){
    this.nid=this.sid;
    while (this.tobj.rowsAr[this.nid])
        this.nid=this.nid+((new Date()).valueOf());

    return this;
}
/**
*   @desc:  get data array for grid row
*   @type:  private
*/
dragContext.prototype.data=function(){
    if (this.sobj==this.tobj)
        return this.sobj._getRowArray(this.sobj.rowsAr[this.sid]);
    if (this.source=="tree")
        return this.tobj.treeToGridElement(this.sobj,this.sid,this.tid);
    else
        return this.tobj.gridToGrid(this.sid,this.sobj,this.tobj);
}
dragContext.prototype.attrs=function(){
    if (this.source=="tree")
        return {};
    else
        return this.sobj.rowsAr[this.sid]._attrs;
}
dragContext.prototype.childs=function(){
    if (this.source=="treeGrid")
		return this.sobj._h2.get[this.sid]._xml_await?this.sobj._h2.get[this.sid].has_kids:null;
	return null;
}

/**
*   @desc:  return parent id for row in context
*   @type:  private
*/
dragContext.prototype.pid=function(){
    if (!this.tid) return 0;
	if (!this.tobj._h2) return 0;
    if (this.target=="treeGrid")
        if (this.dropmode=="child")
            return this.tid;
        else{
			var z=this.tobj.rowsAr[this.tid];
			var apid=this.tobj._h2.get[z.idd].parent.id;
			if ((this.alfa)&&(this.tobj._sbmod)&&(z.nextSibling)){
				var zpid=this.tobj._h2.get[z.nextSibling.idd].parent.id;
				if (zpid==this.tid)
            		return this.tid;
				if (zpid!=apid)
            		return zpid;
			}
	        return apid;
	   }
}
/**
*   @desc:  get index of target position
*   @type:  private
*/
dragContext.prototype.ind=function(){ 
    if (this.tid==window.unknown) return this.tobj.rowsBuffer.length;
    if (this.target=="treeGrid"){
      if (this.dropmode=="child")
            this.tobj.openItem(this.tid);
      else
         this.tobj.openItem(this.tobj.getParentId(this.tid));
   }
    var ind=this.tobj.rowsBuffer._dhx_find(this.tobj.rowsAr[this.tid]);
	if ((this.alfa)&&(this.tobj._sbmod)&&(this.dropmode=="sibling")){
		var z=this.tobj.rowsAr[this.tid];
		if ((z.nextSibling)&&(this._h2.get[z.nextSibling.idd].parent.id==this.tid))
			return ind+1;
	}

    return (ind+1+((this.target=="treeGrid" && ind>=0 && this.tobj._h2.get[this.tobj.rowsBuffer[ind].idd].state=="minus")?this.tobj._getOpenLenght(this.tobj.rowsBuffer[ind].idd,0):0));
}
/**
*   @desc:  get row related image
*   @type:  private
*/
dragContext.prototype.img=function(){
    if ((this.target!="grid")&&(this.sobj._h2))
      return this.sobj.getItemImage(this.sid);
   else return null;
}

/**
*   @desc:  return list of rows in context
*   @type:  private
*/
dragContext.prototype.slist=function(){
    var res=new Array();
    for (var i=0; i<this.sid.length; i++)
        res[res.length]=this.sid[i][(this.source=="tree")?"id":"idd"];

    return res.join(",");
}


/**
*   @desc:  drag entry point
*   @type:  private
*/
dhtmlXGridObject.prototype._drag=function(sourceHtmlObject,dhtmlObject,targetHtmlObject,lastLanding){
   if (this._realfake) return this._fake._drag()	
   
   var z=(this.lastLanding)
    //close unfinished tasks
    if  (this._autoOpenTimer) window.clearTimeout(this._autoOpenTimer);

    //detect details
    var r1=targetHtmlObject.parentNode;
    var r2=sourceHtmlObject.parentObject;
    //drop on header
    if (!r1.idd) { r1.grid=this;    this.dadmodefix=0; }

    var c=new dragContext(0,0,0,((r1.grid.dadmode==1 || r1.grid.dadmodec)?"sibling":"child"));


    if (r2 && r2.childNodes)
        c.set("source","tree").set("sobj",r2.treeNod).set("sid",c.sobj._dragged);
    else{
    	if (!r2) return true;
        if (r2.treeNod.isTreeGrid && r2.treeNod.isTreeGrid())
        	c.set("source","treeGrid");
        c.set("sobj",r2.treeNod).set("sid",c.sobj._dragged);
        }

    if (r1.grid.isTreeGrid())
        c.set("target","treeGrid");
	else
		c.set("dropmode","sibling");
    c.set("tobj",r1.grid).set("tid",r1.idd);

//#__pro_feature:21092006{
    //complex drag mode - adjust tartget element
    if (((c.tobj.dadmode==2)&&(c.tobj.dadmodec==1))&&(c.tobj.dadmodefix<0))
       if (c.tobj.obj.rows[1].idd!=c.tid) c.tid=r1.previousSibling.idd;
       else c.tid=0;
//#}

   var el = this.getFirstParentOfType(lastLanding,"TD")
   if (el) c.set("tExtra",el._cellIndex);
   if (el) c.set("sExtra",c.sobj._dndExtra);

    if (c.sobj.dpcpy) c.set("mode","copy");
    
    if (c.tobj._realfake) c.tobj=c.tobj._fake;
    if (c.sobj._realfake) c.sobj=c.sobj._fake;
    
    c.tobj._clearMove();
    
	if (r2 && r2.treeNod && r2.treeNod._nonTrivialRow)
		r2.treeNod._nonTrivialRow(this,c.tid,c.dropmode,r2);
	else {
		c.tobj.dragContext=c;
	    if (!c.tobj.callEvent("onDrag",[c.slist(),c.tid,c.sobj,c.tobj,c.sExtra,c.tExtra]))  return  c.tobj.dragContext=null;
	
	   //all ready, start mantras
	   var result=new Array();
	   if (typeof(c.sid)=="object"){
	        var nc=c.copy();
	        for (var i=0; i<c.sid.length; i++){
	         if (!nc.set("alfa",(!i)).set("sid",c.sid[i][(c.source=="tree"?"id":"idd")]).valid()) continue;
	            nc.tobj._dragRoutine(nc);
	            if (nc.target=="treeGrid" && nc.dropmode == "child") nc.tobj.openItem(nc.tid);
	            result[result.length]=nc.nid;
	         nc.set("dropmode","sibling").set("tid",nc.nid);
	            }
	        nc.close();
	        }
	    else
	       c.tobj._dragRoutine(c);		

	   //finish math if any awaiting
	   if (c.tobj.laterLink) c.tobj.laterLink();
	   //destroy context
		c.tobj.callEvent("onDrop",[c.slist(),c.tid,result.join(","),c.sobj,c.tobj,c.sExtra,c.tExtra]);
	}

   c.tobj.dragContext=null;
   c.close();
}


/**
*   @desc:  context drag routine
*   @type:  private
*/
dhtmlXGridObject.prototype._dragRoutine=function(c){
      if ((c.sobj==c.tobj)&&(c.source=="grid")&&(c.mode=="move")&&!this._fake){
         //special case for moving rows in same grid
         if (c.sobj._dndProblematic) return;
         var fr=c.sobj.rowsAr[c.sid];
         var bind=c.sobj.rowsCol._dhx_find(fr);
         c.sobj.rowsCol._dhx_removeAt(c.sobj.rowsCol._dhx_find(fr));
         c.sobj.rowsBuffer._dhx_removeAt(c.sobj.rowsBuffer._dhx_find(fr));
         c.sobj.rowsBuffer._dhx_insertAt(c.ind(),fr);
         if (c.tobj._fake){
         	c.tobj._fake.rowsCol._dhx_removeAt(bind);
         	var tr=c.tobj._fake.rowsAr[c.sid];
         	tr.parentNode.removeChild(tr);
     	 }         
         c.sobj._insertRowAt(fr,c.ind());

         c.nid=c.sid;
         c.sobj.callEvent("onGridReconstructed",[]);
         return;
      }
      var new_row;
		if (this._h2 && typeof c.tid !="undefined" && c.dropmode=="sibling" && (this._sbmod || c.tid)){
			if (c.alfa && this._sbmod && this._h2.get[c.tid].childs.length){
				this.openItem(c.tid)
				new_row=c.uid().tobj.addRowBefore(c.nid,c.data(),this._h2.get[c.tid].childs[0].id,c.img(),c.childs());
			}
			else
			new_row=c.uid().tobj.addRowAfter(c.nid,c.data(),c.tid,c.img(),c.childs());
			}
		else
        	new_row=c.uid().tobj.addRow(c.nid,c.data(),c.ind(),c.pid(),c.img(),c.childs());

          new_row._attrs = c.attrs();
		
		
        if (c.source=="tree"){
        	this.callEvent("onRowAdded",[c.nid]);            
            var sn=c.sobj._globalIdStorageFind(c.sid);
            if (sn.childsCount){
                var nc=c.copy().set("tid",c.nid).set("dropmode",c.target=="grid"?"sibling":"child");
              for(var j=0;j<sn.childsCount;j++){
                    c.tobj._dragRoutine(nc.set("sid",sn.childNodes[j].id));
                    if (c.mode=="move") j--;
                    }
                nc.close();
                }
        }
        else{
            c.tobj._copyUserData(c);
			this.callEvent("onRowAdded",[c.nid]);            
			
            if ((c.source=="treeGrid")){
            	
            	if (c.sobj==c.tobj) new_row._xml=c.sobj.rowsAr[c.sid]._xml;
                var snc=c.sobj._h2.get[c.sid];
                if ((snc)&&(snc.childs.length)){
                    var nc=c.copy().set("tid",c.nid);
                    if(c.target=="grid")
                        nc.set("dropmode","sibling");
                    else {
                    	nc.tobj.openItem(c.tid);
                        nc.set("dropmode","child");
                        }
					var l=snc.childs.length;
                    for(var j=0;j<l;j++){
                    	c.sobj.render_row_tree(null,snc.childs[j].id);
                        c.tobj._dragRoutine(nc.set("sid",snc.childs[j].id));
                        if (l!=snc.childs.length) {  j--; l=snc.childs.length; }
                        }
                    nc.close();
                    }
            }
        }

        if (c.mode=="move"){
           c.sobj[(c.source=="tree")?"deleteItem":"deleteRow"](c.sid);
           if ((c.sobj==c.tobj)&&(!c.tobj.rowsAr[c.sid])) {
               c.tobj.changeRowId(c.nid,c.sid);
            c.nid=c.sid;
         }
      }
}


/**
*   @desc: redefine this method in your code to define how grid row values should be used in another grid
*   @param: rowId - id of draged row
*   @param: sgrid - source grid object
*   @param: tgrid - target grid object
*   @returns: array of values for cells in target grid row
*   @type: public
*   @topic: 7
*/
dhtmlXGridObject.prototype.gridToGrid = function(rowId,sgrid,tgrid){
    var z=new Array();
    for (var i=0; i<sgrid.hdr.rows[0].cells.length; i++)
        z[i]=sgrid.cells(rowId,i).getValue();
   return z;
}

/**
*   @desc:  check if d-n-d is in allowed rules
*   @type:  private
*/
dhtmlXGridObject.prototype.checkParentLine=function(node,id){
    if ((!this._h2)||(!id)||(!node)) return false;
    if (node.id==id) return true;
    else return this.checkParentLine(node.parent,id);
}

/**
*   @desc:  called when drag moved over landing
*   @type:  private
*/
dhtmlXGridObject.prototype._dragIn=function(htmlObject,shtmlObject,x,y){
                    if (!this.dADTempOff) return 0;
                    var tree=this.isTreeGrid();
                    var obj=shtmlObject.parentNode.idd?shtmlObject.parentNode:shtmlObject.parentObject;
                    
					if (this._drag_validate){
                    	if(htmlObject.parentNode==shtmlObject.parentNode)
                        	return 0;
                        	
	                    if ((tree)&&(this==obj.grid)&&((this.checkParentLine(this._h2.get[htmlObject.parentNode.idd],shtmlObject.parentNode.idd))))
    	                    return 0;
    	            }
                    if (!this.callEvent("onDragIn",[obj.idd||obj.id,htmlObject.parentNode.idd,obj.grid||obj.treeNod,(htmlObject.grid||htmlObject.parentNode.grid)]))
                        return this._setMove(htmlObject,x,y,true);

                    this._setMove(htmlObject,x,y);

                  if ((tree)&&(htmlObject.parentNode.expand!="")){
                     this._autoOpenTimer=window.setTimeout(new callerFunction(this._autoOpenItem,this),1000);
                   this._autoOpenId=htmlObject.parentNode.idd;
                        }
                  else
                    if  (this._autoOpenTimer) window.clearTimeout(this._autoOpenTimer);

                    return htmlObject;
}
/**
*   @desc:  open item on timeout
*   @type:  private
*/
dhtmlXGridObject.prototype._autoOpenItem=function(e,gridObject){
	   gridObject.openItem(gridObject._autoOpenId);
}

/**
*   @desc:  called on onmouseout event , when drag out landing zone
*   @type:  private
*/
dhtmlXGridObject.prototype._dragOut=function(htmlObject){
                    this._clearMove();
                    var obj=htmlObject.parentNode.parentObject?htmlObject.parentObject.id:htmlObject.parentNode.idd;
                    this.callEvent("onDragOut",[obj]);
                    if  (this._autoOpenTimer) window.clearTimeout(this._autoOpenTimer);
}
/**
*   @desc:  set visual effect for moving row over landing
*   @type:  private
*/
dhtmlXGridObject.prototype._setMove=function(htmlObject,x,y,skip){
   if (!htmlObject.parentNode.idd) return;
   var a1=getAbsoluteTop(htmlObject);
   var a2=getAbsoluteTop(this.objBox);
   

   //scroll down
   if ( (a1-a2)>(parseInt(this.objBox.offsetHeight)-50) )
      this.objBox.scrollTop=parseInt(this.objBox.scrollTop)+20;
   //scroll top
   if ( (a1-a2+parseInt(this.objBox.scrollTop))<(parseInt(this.objBox.scrollTop)+30) )
      this.objBox.scrollTop=parseInt(this.objBox.scrollTop)-20;
      
   if (skip) return 0;
   
    if (this.dadmode==2)
    {

        var z=y-a1+(document.body.scrollTop||document.documentElement.scrollTop)-2-htmlObject.offsetHeight/2;
        if ((Math.abs(z)-htmlObject.offsetHeight/6)>0)
        {
        this.dadmodec=1;
      //sibbling zone
        if (z<0)  this.dadmodefix=-1; else   this.dadmodefix=1;
        }
        else this.dadmodec=0;
    }
    else
        this.dadmodec=this.dadmode;




    if (this.dadmodec){
      if (!this._sdrgc) this._createSdrgc();
      this._sdrgc.style.display="block";
      this._sdrgc.style.top=a1-a2+parseInt(this.objBox.scrollTop)+((this.dadmodefix>=0)?htmlObject.offsetHeight:0)+"px";
    }
    else{
      this._llSelD=htmlObject;
      if (htmlObject.parentNode.tagName=="TR")
      for (var i=0; i<htmlObject.parentNode.childNodes.length; i++)
      {
      var z= htmlObject.parentNode.childNodes[i];
	  z._bgCol=z.style.backgroundColor;
      z.style.backgroundColor="#FFCCCC";
      }
    }
}
/**
*   @desc:  remove all visual effects
*   @type:  private
*/
dhtmlXGridObject.prototype._clearMove=function(){
    if (this._sdrgc) this._sdrgc.style.display="none";
    if ((this._llSelD)&&(this._llSelD.parentNode.tagName=="TR")){
    	var coll = this._llSelD.parentNode.childNodes;
        for (var i=0; i<coll.length; i++)
           coll[i].style.backgroundColor=coll[i]._bgCol;
	}       

    this._llSelD=null;
}


/**
*   @desc: redefine this method in your code to define how grid row values should be displaied while draging
*   @param: gridRowId - id of grid row
*   @returns: html string representing dragging row 
*   @type: public
*   @topic: 7
*/
dhtmlXGridObject.prototype.rowToDragElement=function(gridRowId){
    var out=this.cells(gridRowId,0).getValue();
    return out;
}








/**
*   @desc:  copy user data for row
*   @type:  private
*/
dhtmlXGridObject.prototype._copyUserData = function(c){
			if(!c.tobj.UserData[c.nid] || c.tobj!=c.sobj)
            	c.tobj.UserData[c.nid] = new Hashtable();
            else return;

            var z1 = c.sobj.UserData[c.sid];
            var z2 = c.tobj.UserData[c.nid];
            if (z1) {
                z2.keys = z2.keys.concat(z1.keys);
                z2.values = z2.values.concat(z1.values);
            }
    }



/**
*     @desc: move row
*     @type:  public
*     @param: rowId - source row Id
*     @param: mode - moving mode (up,down,row_sibling)
*     @param: targetId - target row  in row_sibling mode
*     @param: targetGrid - used for moving between grids (optional)
*     @edition: Professional
*     @topic: 2
*/
dhtmlXGridObject.prototype.moveRow=function(rowId,mode,targetId,targetGrid){
      switch(mode){
      case "row_sibling":
                    this.moveRowTo(rowId,targetId,"move","sibling",this,targetGrid);
         break;
      case "up":
               this.moveRowUp(rowId);
         break;
      case "down":
               this.moveRowDown(rowId);
          break;
      }
}





//#__pro_feature:21092006{

/**
*   @desc: move rows from grid to tree
*   @param: tree - object of tree
*   @param: targetObject - target node of tree
*   @param: beforeNode - anchor node of tree
*   @param: itemObject - dragged node
*   @param: z2 - flag of recursion
*   @type:  private
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype._nonTrivialNode=function(tree,targetObject,beforeNode,itemObject,z2)
{
    if ((tree.callEvent)&&(!z2))
          if (!tree.callEvent("onDrag",[itemObject.idd,targetObject.id,(beforeNode?beforeNode.id:null),this,tree])) return false;

    var gridRowId = itemObject.idd;
    var treeNodeId = gridRowId;
    while (tree._idpull[treeNodeId]) treeNodeId+=(new Date()).getMilliseconds().toString();

   var img=(this.isTreeGrid()?this.getItemImage(gridRowId):"")
	if (beforeNode){
		for (i=0; i<targetObject.childsCount; i++)
		    if (targetObject.childNodes[i]==beforeNode) break;
		
		if (i!=0)
		    beforeNode=targetObject.childNodes[i-1];
		else{
		    st="TOP";
		    beforeNode="";
		    }
	}   
   var newone=tree._attachChildNode(targetObject,treeNodeId,this.gridToTreeElement(tree,treeNodeId,gridRowId),"",img,img,img,"","",beforeNode);
    if (this._h2){
      var akids=this._h2.get[gridRowId];
      if (akids.childs.length)
      for (var i=0; i<akids.childs.length; i++){
          this._nonTrivialNode(tree,newone,0,this.rowsAr[akids.childs[i].id],1);
          if (!this.dpcpy) i--;
      }
    }

    if (!this.dpcpy) this.deleteRow(gridRowId);

    if ((tree.callEvent)&&(!z2))
       tree.callEvent("onDrop",[treeNodeId,targetObject.id,(beforeNode?beforeNode.id:null),this,tree]);
}

/**
*   @desc: redefine this method in your code to define how grid row values should be used in tree (using input parameters you can change id of new tree node, set label, set userdata blocks etc.).
*   @param: treeObj - object of tree
*   @param: treeNodeId - id of node created in tree
*   @param: gridRowId - id of grid row
*   @returns: if true, then grid row will be moved to tree, else - copied
*   @type: public
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype.gridToTreeElement = function(treeObj,treeNodeId,gridRowId){
   return this.cells(gridRowId,0).getValue();
}

/**
*   @desc: redefine this method in your code to define how tree node values should be used in grid (using input parameters you can change id of new row, values for cells, userdata blocks etc.).
*   @param: treeObj - object of tree
*   @param: treeNodeId - id of node created in tree
*   @param: gridRowId - id of grid row
*   @returns: if true, then tree node should be moved to grid, else - copied
*   @type: public
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype.treeToGridElement = function(treeObj,treeNodeId,gridRowId){
    var w=new Array();
    var z=this.cellType._dhx_find("tree");
   if (z==-1) z=0;
   for(var i=0;i<this.getColumnCount();i++)
        w[w.length]=(i!=z)?(treeObj.getUserData(treeNodeId,this.getColumnId(i))||""):treeObj.getItemText(treeNodeId);
   return w;
}

/**
*     @desc: move row
*     @type:  public
*     @param: srowId - source row Id
*     @param: trowId - target row Id
*     @param: mode - move or copy
*     @param: dropmode - sibling or child
*     @param: sourceGrid - target row  in row_sibling mode
*     @param: targetGrid - used for moving between grids (optional)
*     @returns: moved item ID
*     @edition: Professional
*     @topic: 2
*/
dhtmlXGridObject.prototype.moveRowTo=function(srowId,trowId,mode,dropmode,sourceGrid,targetGrid){
    var c=new dragContext((sourceGrid||this).isTreeGrid()?"treeGrid":"grid",(targetGrid||this).isTreeGrid()?"treeGrid":"grid",mode,dropmode||"sibling",srowId,trowId,sourceGrid||this,targetGrid||this);
    c.tobj._dragRoutine(c);
    c.close();
    return c.nid;
}

/**
*     @desc: enable drag without removing (copy instead of move)
*     @beforeInit: 1
*     @param: mode - 1 - on, 0 - off;
*     @type: public
*     @edition:Professional
*     @topic: 0
*/
dhtmlXGridObject.prototype.enableMercyDrag=function(mode){ this.dpcpy=convertStringToBoolean(mode); };
//#}
//(c)dhtmlx ltd. www.dhtmlx.com

//v.3.6 build 131108

/*
Copyright DHTMLX LTD. http://www.dhtmlx.com
To use this component please contact sales@dhtmlx.com to obtain license
*/
dhtmlXGridObject.prototype._process_xmlA=function(xml){ 
    if (!xml.doXPath){
			var t = new dtmlXMLLoaderObject(function(){});
			if (typeof xml == "string") 
				t.loadXMLString(xml);
			else {
				if (xml.responseXML)
					t.xmlDoc=xml;
				else
					t.xmlDoc={};
				t.xmlDoc.responseXML=xml;
			}
			xml=t;
		}
		
	this._parsing=true;
	var top=xml.getXMLTopNode(this.xml.top)
	//#config_from_xml:20092006{
	this._parseHead(top);
	//#}
	var rows=xml.doXPath(this.xml.row,top)
	var cr=parseInt(xml.doXPath("//"+this.xml.top)[0].getAttribute("pos")||0);
	var total=parseInt(xml.doXPath("//"+this.xml.top)[0].getAttribute("total_count")||0);
	if (total && !this.rowsBuffer[total-1]) this.rowsBuffer[total-1]=null;
	
	if (this.isTreeGrid()){
		this._get_xml_data = this._get_xml_dataA;
		this._process_xml_row = this._process_xml_rowA;
		return this._process_tree_xml(xml);
	}
	
	for (var i=0; i < rows.length; i++) {
		if (this.rowsBuffer[i+cr]) continue;
		var id=rows[i].getAttribute("id")||this.uid();
		this.rowsBuffer[i+cr]={ idd:id, data:rows[i], _parser: this._process_xml_rowA, _locator:this._get_xml_dataA };
		this.rowsAr[id]=rows[i];
		//this.callEvent("onRowCreated",[r.idd]);
	}
	this.render_dataset();
	this._parsing=false;
	return xml.xmlDoc.responseXML?xml.xmlDoc.responseXML:xml.xmlDoc;
}

dhtmlXGridObject.prototype._process_xmlB=function(xml){
    if (!xml.doXPath){
			var t = new dtmlXMLLoaderObject(function(){});
			if (typeof xml == "string") 
				t.loadXMLString(xml);
			else {
				if (xml.responseXML)
					t.xmlDoc=xml;
				else
					t.xmlDoc={};
				t.xmlDoc.responseXML=xml;
			}
			xml=t;
		}
		
	this._parsing=true;
	var top=xml.getXMLTopNode(this.xml.top)
	//#config_from_xml:20092006{
	this._parseHead(top);
	//#}
	var rows=xml.doXPath(this.xml.row,top)
	var cr=parseInt(xml.doXPath("//"+this.xml.top)[0].getAttribute("pos")||0);
	var total=parseInt(xml.doXPath("//"+this.xml.top)[0].getAttribute("total_count")||0);
	if (total && !this.rowsBuffer[total-1]) this.rowsBuffer[total-1]=null;
	
	if (this.isTreeGrid()){
		this._get_xml_data = this._get_xml_dataB;
		this._process_xml_row = this._process_xml_rowB;
		return this._process_tree_xml(xml);
	}
			
	for (var i=0; i < rows.length; i++) {
		if (this.rowsBuffer[i+cr]) continue;
		var id=rows[i].getAttribute("id")||this.uid();
		this.rowsBuffer[i+cr]={ idd:id, data:rows[i], _parser: this._process_xml_rowB, _locator:this._get_xml_dataB };
		this.rowsAr[id]=rows[i];
		//this.callEvent("onRowCreated",[r.idd]);
	}
	this.render_dataset();
	this._parsing=false;
	return xml.xmlDoc.responseXML?xml.xmlDoc.responseXML:xml.xmlDoc;
}

dhtmlXGridObject.prototype._process_xml_rowA=function(r,xml){
	var strAr = [];
	r._attrs=this._xml_attrs(xml);
	
	//load cell data
    for(var j=0;j<this.columnIds.length;j++){
    	var cid=this.columnIds[j];
    	var cellVal=r._attrs[cid]||"";
        if (r.childNodes[j])
       		r.childNodes[j]._attrs={};
   		
		strAr.push(cellVal);
	}
	    
    //back to common code
	this._fillRow(r,(this._c_order?this._swapColumns(strAr):strAr));
    return r;
}
dhtmlXGridObject.prototype._get_xml_dataA=function(data,ind){
	return data.getAttribute(this.getColumnId(ind));
}

dhtmlXGridObject.prototype._process_xml_rowB=function(r,xml){
	var strAr = [];
	r._attrs=this._xml_attrs(xml);
	
	//load userdata
	if (this._ud_enabled){	
		var udCol = this.xmlLoader.doXPath("./userdata",xml);
    	for (var i = udCol.length - 1; i >= 0; i--)
    		this.setUserData(udCol[i].getAttribute("name"),udCol[i].firstChild?udCol[i].firstChild.data:"");
	}
	
	//load cell data
	
	for (var jx=0; jx < xml.childNodes.length; jx++) {
		var cellVal=xml.childNodes[jx];
    	if (!cellVal.tagName) continue;
    	var j=this.getColIndexById(cellVal.tagName);
    	if (isNaN(j)) continue;
    		
        var exc=cellVal.getAttribute("type");
        if (exc)
        	r.childNodes[j]._cellType=exc;
       	r.childNodes[j]._attrs=this._xml_attrs(cellVal);
   		
		if (cellVal.getAttribute("xmlcontent"))
		{}
		else if (cellVal.firstChild)
			cellVal=cellVal.firstChild.data;
		else cellVal="";
        
		strAr[j]=cellVal;
	}
	for (var i=0; i < r.childNodes.length; i++) {
		if (!r.childNodes[i]._attrs) r.childNodes[i]._attrs={};
	};
            
    //back to common code
	this._fillRow(r,(this._c_order?this._swapColumns(strAr):strAr));
    return r;
}
dhtmlXGridObject.prototype._get_xml_dataB=function(data,ind){
	var id=this.getColumnId(ind);
	data=data.firstChild;
	while (true){
		if (!data) return "";
		if (data.tagName==id) return (data.firstChild?data.firstChild.data:"")
		data=data.nextSibling;
	}
  return "";
}
//v.3.6 build 131108

/*
Copyright DHTMLX LTD. http://www.dhtmlx.com
To use this component please contact sales@dhtmlx.com to obtain license
*/
dhtmlXGridObject.prototype.attachHeaderA=dhtmlXGridObject.prototype.attachHeader;
dhtmlXGridObject.prototype.attachHeader=function()
{
	this.attachHeaderA.apply(this,arguments);
	if (this._realfake) return true;
	this.formAutoSubmit();
	if (typeof(this.FormSubmitOnlyChanged)=="undefined")
		this.submitOnlyChanged(true);
		
	if (typeof(this._submitAR)=="undefined")
		this.submitAddedRows(true);
		
	var that=this;
	
	this._added_rows=[];
	this._deleted_rows=[];
	
	this.attachEvent("onRowAdded",function(id){ 
		that._added_rows.push(id);
		that.forEachCell(id,function(a){ a.cell.wasChanged=true; })
		return true;
	});
	this.attachEvent("onBeforeRowDeleted",function(id){
		that._deleted_rows.push(id);
		return true;
	});
	
	this.attachHeader=this.attachHeaderA;
}

dhtmlXGridObject.prototype.formAutoSubmit = function()
{
	this.parentForm = this.detectParentFormPresent();
	if (this.parentForm === false) {
		return false;
	}
	if (this.formEventAttached)
		return;
    this.formInputs = new Array();
	var self = this;
	dhtmlxEvent(this.parentForm, 'submit', function() {if (self.entBox) self.parentFormOnSubmit();});
	this.formEventAttached = true;
}

dhtmlXGridObject.prototype.parentFormOnSubmit = function()
{
	this.formCreateInputCollection();
	if (!this.callEvent("onBeforeFormSubmit",[])) return false;
}

/**
*   @desc: include only changed rows in form submit
*   @type: public
*   @param: mode - {boolean}  enable|disable mode
*   @topic: 0
*/
dhtmlXGridObject.prototype.submitOnlyChanged = function(mode)
{
	this.FormSubmitOnlyChanged = convertStringToBoolean(mode);
}

dhtmlXGridObject.prototype.submitColumns=function(names){
	if (typeof names == "string") names=names.split(this.delim);
	this._submit_cols=names;	
}

/**
*   @desc: allows to define input name which will be used for data sending, name may contain next auto-replaced elements - GRID_ID - ID of grids container, ROW_ID - ID of row, ROW_INDEX - index of row, COLUMN_ID - id of column, COLUMN_INDEX - index of column
*   @type: public
*   @param: name - input name mask
*   @topic: 0
*/
dhtmlXGridObject.prototype.setFieldName=function(mask){
	mask=mask.replace(/\{GRID_ID\}/g,"'+a1+'");
	mask=mask.replace(/\{ROW_ID\}/g,"'+a2+'");
	mask=mask.replace(/\{ROW_INDEX\}/g,"'+this.getRowIndex(a2)+'");
	mask=mask.replace(/\{COLUMN_INDEX\}/g,"'+a3+'");
	mask=mask.replace(/\{COLUMN_ID\}/g,"'+this.getColumnId(a3)+'");
	this._input_mask=Function("a1","a2","a3","return '"+mask+"';");
}
 
   
/**
*   @desc: include serialized grid as part of form submit
*   @type: public
*   @param: mode - {boolean}  enable|disable mode
*   @topic: 0
*/
dhtmlXGridObject.prototype.submitSerialization = function(mode)
{
	this.FormSubmitSerialization = convertStringToBoolean(mode);
}

/**
*   @desc: include additional data with info about which rows was added and which deleted, enabled by default
*   @type: public
*   @param: mode - {boolean}  enable|disable mode
*   @topic: 0
*/
dhtmlXGridObject.prototype.submitAddedRows = function(mode)
{
	this._submitAR = convertStringToBoolean(mode);
}




/**
*   @desc: include only selected rows in form submit
*   @type: public
*   @param: mode - {boolean}  enable|disable mode
*   @topic: 0
*/
dhtmlXGridObject.prototype.submitOnlySelected = function(mode)
{
	this.FormSubmitOnlySelected = convertStringToBoolean(mode);
}


/**
*   @desc: include only  row's IDS in form submit
*   @type: public
*   @param: mode - {boolean}  enable|disable mode
*   @topic: 0
*/
dhtmlXGridObject.prototype.submitOnlyRowID = function(mode)
{
	this.FormSubmitOnlyRowID = convertStringToBoolean(mode);
}


dhtmlXGridObject.prototype.createFormInput = function(name,value){
    var input = document.createElement('input');
    input.type = 'hidden';
    if (this._input_mask && (typeof name != "string"))
    	input.name=this._input_mask.apply(this,name);
    else
    	input.name =((this.globalBox||this.entBox).id||'dhtmlXGrid')+'_'+name;
    input.value = value;
    this.parentForm.appendChild(input);
    this.formInputs.push(input);
}

dhtmlXGridObject.prototype.createFormInputRow = function(r){ 
	var id=(this.globalBox||this.entBox).id;
	for (var j=0; j<this._cCount; j++){
		var foo_cell = this.cells3(r, j);
		if (((!this.FormSubmitOnlyChanged) || foo_cell.wasChanged()) && (!this._submit_cols || this._submit_cols[j]))
			this.createFormInput(this._input_mask?[id,r.idd,j]:(r.idd+'_'+j),foo_cell.getValue());
	}
}


dhtmlXGridObject.prototype.formCreateInputCollection = function()
{
	if (this.parentForm == false) {
		return false;
	}
	for (var i=0; i<this.formInputs.length; i++) {
		this.parentForm.removeChild(this.formInputs[i]);
	}
    this.formInputs = new Array();
    
    if (this.FormSubmitSerialization){
    	this.createFormInput("serialized",this.serialize());
    } else if (this.FormSubmitOnlySelected){
    	//submit selected
    	if (this.FormSubmitOnlyRowID)
    		this.createFormInput("selected",this.getSelectedId());
    	else
    		for(var i=0;i<this.selectedRows.length;i++)
    			this.createFormInputRow(this.selectedRows[i]);
    	}
    else{
    	//submit all
    		if (this._submitAR){
    			if (this._added_rows.length)
    				this.createFormInput("rowsadded",this._added_rows.join(","));
    			if (this._deleted_rows.length)
    				this.createFormInput("rowsdeleted",this._deleted_rows.join(","));
	    		}
    		this.forEachRow(function(id){
    			this.getRowById(id);
    			this.createFormInputRow(this.rowsAr[id]);
			})
    		
    	}
}

dhtmlXGridObject.prototype.detectParentFormPresent = function()
{
	var parentForm = false;
	var parent = this.entBox;
	while(parent && parent.tagName && parent != document.body) {
		if (parent.tagName.toLowerCase() == 'form') {
			parentForm = parent;
			break;
		} else {
        	parent = parent.parentNode;
		}
	}
	return parentForm;
}
//(c)dhtmlx ltd. www.dhtmlx.com

//v.3.6 build 131108

/*
Copyright DHTMLX LTD. http://www.dhtmlx.com
To use this component please contact sales@dhtmlx.com to obtain license
*/
/**
*	@desc: enable pop up menu which allows hidding/showing columns
*	@edition: Professional
*	@type: public
*/
dhtmlXGridObject.prototype.enableHeaderMenu=function(columns)
{
	if (typeof columns == "string")
		columns = columns.split(",");
	this._hm_config = columns;
	var that=this;
	this.attachEvent("onInit",function(){
    	this.hdr.oncontextmenu = function(e){ return that._doHContClick(e||window.event); };   
		{
			this.startColResizeA=this.startColResize;
			this.startColResize=function(e){
					if (e.button==2 || (_isMacOS&&e.ctrlKey))
						return this._doHContClick(e)
					return this.startColResizeA(e);
			}
		}
		this._chm_ooc=this.obj.onclick;
		this._chm_hoc=this.hdr.onclick;
		this.hdr.onclick=function(e){
			if (e && ( e.button==2  || (_isMacOS&&e.ctrlKey))) return false;
			that._showHContext(false);	
			return that._chm_hoc.apply(this,arguments)
		}
		this.obj.onclick=function(){
			that._showHContext(false);	
			return that._chm_ooc.apply(this,arguments)
		}
	    	
	});
	dhtmlxEvent(document.body,"click",function(){
		if (that._hContext)
			that._showHContext(false);
	})
	if (this.hdr.rows.length) this.callEvent("onInit",[]);
	this.enableHeaderMenu=function(){};
}

dhtmlXGridObject.prototype._doHContClick=function(ev)
{
		function mouseCoords(ev){
            if(ev.pageX || ev.pageY){
                return {x:ev.pageX, y:ev.pageY};
            }
            var d  =  ((_isIE)&&(document.compatMode != "BackCompat"))?document.documentElement:document.body;
            return {
                x:ev.clientX + d.scrollLeft - d.clientLeft,
                y:ev.clientY + d.scrollTop  - d.clientTop
            };
        }

		this._createHContext();
		var coords = mouseCoords(ev);
		this._showHContext(true,coords.x,coords.y);
        ev[_isIE?"srcElement":"target"].oncontextmenu = function(e){ (e||event).cancelBubble=true; return false; };
		
		ev.cancelBubble=true;
		if (ev.preventDefault) ev.preventDefault();
    	return false;
}

dhtmlXGridObject.prototype._createHContext=function()
{
	if (this._hContext) return this._hContext;
	var d = document.createElement("DIV");
	d.oncontextmenu = function(e){ (e||event).cancelBubble=true; return false; };
	d.onclick=function(e){
		(e||event).cancelBubble=true;
		return true;
		}
	d.className="dhx_header_cmenu";
	d.style.width=d.style.height="5px";
	d.style.display="none";
	var a=[];
	var i=0;
	if (this._fake)
		i=this._fake._cCount;	
	
	var true_ind=i;
	
	for (var i; i<this.hdr.rows[1].cells.length; i++){
		var c=this.hdr.rows[1].cells[i];
		if (!this._hm_config || (this._hm_config[i] &&  this._hm_config[i] != "false")){
			if (c.firstChild && c.firstChild.tagName=="DIV") var val=c.firstChild.innerHTML;
			else var val = c.innerHTML;
			val = val.replace(/<[^>]*>/gi,"");
			a.push("<div class='dhx_header_cmenu_item'><input type='checkbox' column='"+true_ind+"' len='"+(c.colSpan||1)+"' checked='true' />"+val+"</div>");			
		}
		true_ind+=(c.colSpan||1);
	}
	d.innerHTML=a.join("");

	var that=this;	
	var f=function(){
    	var c=this.getAttribute("column");
    	if (!this.checked && !that._checkLast(c)) return this.checked=true;
    	if (that._realfake) that=that._fake;
    	for (var i=0; i<this.getAttribute("len"); i++)
			that.setColumnHidden((c*1+i*1),!this.checked);
		if(this.checked && that.getColWidth(c)==0) 
			that.adjustColumnSize(c);
	}
	for (var i=0; i<d.childNodes.length; i++)
		d.childNodes[i].firstChild.onclick=f;
	
	document.body.insertBefore(d,document.body.firstChild);
	this._hContext=d;
	
	d.style.position="absolute";
	d.style.zIndex=999;
	d.style.width='auto'
	d.style.height='auto'
	d.style.display='block';
}
dhtmlXGridObject.prototype._checkLast=function(ind){
	for (var i=0; i < this._cCount; i++)
		if ((!this._hrrar || !this._hrrar[i])&&(i!=ind))
			return true;
	return false;
}
dhtmlXGridObject.prototype._updateHContext=function()
{
	for (var i=0; i<this._hContext.childNodes.length; i++){
		var c=this._hContext.childNodes[i].firstChild;
		var col=c.getAttribute("column");
		if (this.isColumnHidden(col) || (this.getColWidth(col)==0))
			c.checked=false;
	}
}

dhtmlXGridObject.prototype._showHContext=function(mode,x,y)
{
	if (mode && this.enableColumnMove) {
		 this._hContext.parentNode.removeChild(this._hContext);
		 this._hContext=null;
	}
    this._createHContext();
	this._hContext.style.display=(mode?'block':'none');
	if (mode){
		this._updateHContext(true);
		this._hContext.style.left=x+"px";
		this._hContext.style.top=y+"px";
	}
	
}
//(c)dhtmlx ltd. www.dhtmlx.com

//v.3.6 build 131108

/*
Copyright DHTMLX LTD. http://www.dhtmlx.com
To use this component please contact sales@dhtmlx.com to obtain license
*/
/**
*	@desc: cell with support for math formulas
*	@param: cell - cell object
*	@type:  private
*   @edition: Professional
*/
function eXcell_math(cell){
	if (cell){
		this.cell = cell;
    	this.grid = this.cell.parentNode.grid;
	}
	this.edit = function(){
		this.grid.editor = new eXcell_ed(this.cell);
		this.grid.editor.fix_self=true;
		this.grid.editor.getValue=this.cell.original?(function(){ return this.cell.original}):this.getValue;
		this.grid.editor.setValue=this.setValue;
		this.grid.editor.edit();
	}
	this.isDisabled = function(){ return !this.grid._mathEdit; }
	this.setValue = function(val){
				val=this.grid._compileSCL(val,this.cell,this.fix_self);
                if (this.grid._strangeParams[this.cell._cellIndex])
    				this.grid.cells5(this.cell,this.grid._strangeParams[this.cell._cellIndex]).setValue(val);
                else{
                    this.setCValue(val);
    	            this.cell._clearCell=false;
	            }
    }
    this.getValue = function(){
        if (this.grid._strangeParams[this.cell._cellIndex])
			return this.grid.cells5(this.cell,this.grid._strangeParams[this.cell._cellIndex]).getValue();
        
        return this.cell.innerHTML;
    }
}
eXcell_math.prototype = new eXcell;

dhtmlXGridObject.prototype._init_point_bm=dhtmlXGridObject.prototype._init_point;
dhtmlXGridObject.prototype._init_point = function(){
	this._mat_links={};
	this._aggregators=[];
	this.attachEvent("onClearAll",function(){
		this._mat_links={};
		this._aggregators=[];
	})
	this.attachEvent("onCellChanged",function(id,ind){
		if (this._mat_links[id]){ 
			var cell=this._mat_links[id][ind];
			if (cell){ 
				for (var i=0; i<cell.length; i++)
          if (cell[i].parentNode)
            this.cells5(cell[i]).setValue(this._calcSCL(cell[i]));
			}
		}
		if (!this._parsing && this._aggregators[ind]){
			var pid=this._h2.get[id].parent.id;
			if (pid!=0){
				var ed=this.cells(pid,ind);
				ed.setValue(this._calcSCL(ed.cell));
			}
		}
	})
	this.attachEvent("onAfterRowDeleted",function(id,pid){ //will be called for each delete operation, may be optimized
		if (pid!=0)
			if (!this._parsing && this._aggregators.length){
				for (var ind=0; ind < this._aggregators.length; ind++) {
					if (this._aggregators[ind]){
							var ed=this.cells(pid,ind);
							ed.setValue(this._calcSCL(ed.cell));
					}
				};
			}
		return true;
	})
	this.attachEvent("onXLE",function(){
		for (var i=0; i < this._aggregators.length; i++) {
			if (this._aggregators[i])
				this._h2.forEachChild(0,function(el){
					if (el.childs.length!=0){
						var ed=this.cells(el.id,i);
						ed.setValue(this._calcSCL(ed.cell));
					}
				},this);
		};
	})
	this._init_point=this._init_point_bm;
	if (this._init_point) this._init_point();
}

/**
*	@desc: enable/disable serialization of math formulas
*	@param: status - true/false
*	@type:  public
*   @edition: Professional
*/
dhtmlXGridObject.prototype.enableMathSerialization=function(status){
    this._mathSerialization=convertStringToBoolean(status);
}
/**
*	@desc: enable/disable rounding while math calculations
*	@param: digits - set hom many digits must be rounded, set 0 for disabling
*	@type:  public
*   @edition: Professional
*/
dhtmlXGridObject.prototype.setMathRound=function(digits){
	this._roundDl=digits;
    this._roundD=Math.pow(10,digits);
}
/**
*	@desc: enable/disable editing of math cells
*	@param: status - true/false
*	@type:  public
*   @edition: Professional
*/
dhtmlXGridObject.prototype.enableMathEditing=function(status){
    this._mathEdit=convertStringToBoolean(status);
}

/**
*	@desc: calculate value of math cell
*	@param: cell - math cell
*	@returns: cell value
*	@type:  private
*   @edition: Professional
*/
dhtmlXGridObject.prototype._calcSCL=function(cell){ 
    if (!cell._code) return this.cells5(cell).getValue();
    try{
    	dhtmlx.agrid=this;
    	var z=eval(cell._code);
    } catch(e){ return ("#SCL"); }
    if (this._roundD)
        { 
        	var pre=Math.abs(z)<1?"0":"";
         	if (z<0) pre="-"+pre;
            z=Math.round(Math.abs(z)*this._roundD).toString();
            if (z==0) return 0;
            if (this._roundDl>0){
            	var n=z.length-this._roundDl;
            	if (n<0) {
            		z=("000000000"+z).substring(9+n);
            		n=0;
            	}
            	return (pre+z.substring(0,n)+"."+z.substring(n,z.length));
            }
          return pre+z;
      }
    return z;      
}

dhtmlXGridObject.prototype._countTotal=function(row,cell){ 
	var b=0;
	var z=this._h2.get[row];
	for (var i=0; i<z.childs.length; i++){
		if (!z.childs[i].buff) return b;	// dnd of item with childs, item inserted in hierarchy but not fully processed
		if (z.childs[i].buff._parser){
			this._h2.forEachChild(row,function(el){
				if (el.childs.length==0)
					b+=parseFloat(this._get_cell_value(el.buff,cell),10);
			},this)
			return b;
		}
		b+=parseFloat(this._get_cell_value(z.childs[i].buff,cell),10);
	}
	return b;
}

/**
*	@desc: compile pseudo code to correct javascript
*	@param: code - pseudo code
*	@param: cell - math cell
*	@returns: valid js code
*	@type:  private
*   @edition: Professional
*/
dhtmlXGridObject.prototype._compileSCL=function(code,cell,fix){ 
		if (code === null || code === window.undefined) return code;
        code=code.toString();
        if (code.indexOf("=")!=0) {
        	this._reLink([],cell);
        	if (fix) cell._code = cell.original = null;
            return code;
        }
        cell.original=code;
        
        var linked=null;
        code=code.replace("=","");
        if (code.indexOf("sum")!=-1){ 
            code=code.replace("sum","(dhtmlx.agrid._countTotal('"+cell.parentNode.idd+"',"+cell._cellIndex+"))");
            if (!this._aggregators) this._aggregators=[];
            this._aggregators[cell._cellIndex]="sum";
            cell._code=code;
        	return  this._parsing?"":this._calcSCL(cell);
        }
        if (code.indexOf("[[")!=-1){
          var test = /(\[\[([^\,]*)\,([^\]]*)]\])/g;
          dhtmlx.agrid=this;
          linked=linked||(new Array());
          code=code.replace(test,
              function ($0,$1,$2,$3){
                  if ($2=="-")
                      $2=cell.parentNode.idd;
                  if ($2.indexOf("#")==0)
                      $2=dhtmlx.agrid.getRowId($2.replace("#",""));
                      linked[linked.length]=[$2,$3];
                  return "(parseFloat(dhtmlx.agrid.cells(\""+$2+"\","+$3+").getValue(),10))";
              }
          );
        }
        
        if (code.indexOf(":")!=-1){ 
          var test = /:(\w+)/g;
          dhtmlx.agrid=this;
          var id=cell.parentNode.idd;
          linked=linked||(new Array());
          code=code.replace(test,
              function ($0,$1,$2,$3){
                  linked[linked.length]=[id,dhtmlx.agrid.getColIndexById($1)];
                  return '(parseFloat(dhtmlx.agrid.cells("'+id+'",dhtmlx.agrid.getColIndexById("'+$1+'")).getValue(),10))';
              }
          );
        }
        else{
          var test = /c([0-9]+)/g;
          dhtmlx.agrid=this;
          var id=cell.parentNode.idd;
          linked=linked||(new Array());
          code=code.replace(test,
              function ($0,$1,$2,$3){
                  linked[linked.length]=[id,$1];
                  return "(parseFloat(dhtmlx.agrid.cells(\""+id+"\","+$1+").getValue(),10))";
              }
          );
        }
        
        this._reLink(linked,cell);
        cell._code=code;
        return this._calcSCL(cell);
    }

/**
*	@desc: link math cells to it source cells
*	@param: ar - array of nodes for linking
*	@param: cell - math cell
*	@type:  private
*   @edition: Professional
*/
dhtmlXGridObject.prototype._reLink=function(ar,cell){
		if (!ar.length) return; // basically it would be good to clear unused math links, but it will require a symetric structure 
		for (var i=0; i<ar.length; i++){ 
			if (!this._mat_links[ar[i][0]]) this._mat_links[ar[i][0]]={};
			var t=this._mat_links[ar[i][0]];
			if (!t[ar[i][1]]) t[ar[i][1]]=[];
			t[ar[i][1]].push(cell);
		}
}

if (_isKHTML){
// replace callback support for safari.
 (function(){
   var default_replace = String.prototype.replace;
   String.prototype.replace = function(search,replace){
 // replace is not function
 if(typeof replace != "function"){
 return default_replace.apply(this,arguments)
 }
 var str = "" + this;
 var callback = replace;
 // search string is not RegExp
 if(!(search instanceof RegExp)){
 var idx = str.indexOf(search);
 return (
 idx == -1 ? str :
 default_replace.apply(str,[search,callback(search, idx, str)])
 )
 }
 var reg = search;
 var result = [];
 var lastidx = reg.lastIndex;
 var re;
 while((re = reg.exec(str)) != null){
 var idx  = re.index;
 var args = re.concat(idx, str);
 result.push(
 str.slice(lastidx,idx),
 callback.apply(null,args).toString()
 );
 if(!reg.global){
 lastidx += RegExp.lastMatch.length;
 break
 }else{
 lastidx = reg.lastIndex;
 }
 }
 result.push(str.slice(lastidx));
 return result.join("")
   }
 })();
 }
//(c)dhtmlx ltd. www.dhtmlx.com
//v.3.6 build 131108

/*
Copyright DHTMLX LTD. http://www.dhtmlx.com
To use this component please contact sales@dhtmlx.com to obtain license
*/
/**
*   @desc: add new column to the grid. Can be used after grid was initialized. At least one column should be in grid
*   @param: ind - index of column
*   @param: header - header content of column
*   @param: type - type of column
*   @param: width - width of column
*   @param: sort - sort type of column
*   @param: align - align of column
*   @param: valign - vertical align of column
*   @param: reserved - not used for now
*   @param: columnColor - background color of column
*   @type: public
*   @edition: Professional
*   @topic: 3
*/
dhtmlXGridObject.prototype.insertColumn=function(ind,header,type,width,sort,align,valign,reserved,columnColor){
	ind=parseInt(ind);
	if (ind>this._cCount) ind=this._cCount;
	if (!this._cMod) this._cMod=this._cCount;
	this._processAllArrays(this._cCount,ind-1,[(header||"&nbsp;"),(width||100),(type||"ed"),(align||"left"),(valign||""),(sort||"na"),(columnColor||""),"",this._cMod,(width||100)]);
	this._processAllRows("_addColInRow",ind);

	if (typeof(header)=="object")
		for (var i=1; i < this.hdr.rows.length; i++) {
			if (header[i-1]=="#rspan"){
         		var pind=i-1;
         		var found=false;
         		var pz=null;
         		while(!found){
            		var pz=this.hdr.rows[pind];
            		for (var j=0; j<pz.cells.length; j++)
               			if (pz.cells[j]._cellIndex==ind) {
                  			found=j;
                  			break;
		      		}
            		pind--;
	        	}
	        this.hdr.rows[pind+1].cells[j].rowSpan=(this.hdr.rows[pind].cells[j].rowSpan||1)+1;
			}
			else				
			this.setHeaderCol(ind,(header[i-1]||"&nbsp;"),i);
		}
	else
		this.setHeaderCol(ind,(header||"&nbsp;"));
	this.hdr.rows[0].cells[ind]
	this._cCount++;
	this._cMod++;
	this._master_row=null;
	this.setSizes();
}
/**
*   @desc: delete column
*   @param: ind - index of column
*   @type: public
*   @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.deleteColumn=function(ind){
	ind=parseInt(ind);
	if (this._cCount==0) return;
	if (!this._cMod) this._cMod=this._cCount;
	if (ind>=this._cCount) return;
	this._processAllArrays(ind,this._cCount-1,[null,null,null,null,null,null,null,null,null,null,null]);
	this._processAllRows("_deleteColInRow",ind);
	this._cCount--;
	this._master_row=null;
	this.setSizes();

}

/**
*   @desc: call method for all rows in all collections
*   @type: private
*   @topic: 0
*/
dhtmlXGridObject.prototype._processAllRows = function(method,oldInd,newInd){
	this[method](this.obj.rows[0],oldInd,newInd,0);

	var z=this.hdr.rows.length;
    for (var i=0; i<z; i++)
		this[method](this.hdr.rows[i],oldInd,newInd,i);
		
	if (this.ftr){
		var z=this.ftr.firstChild.rows.length;
	    for (var i=0; i<z; i++)
			this[method](this.ftr.firstChild.rows[i],oldInd,newInd,i);
	}

	this.forEachRow(function(id){
		if (this.rowsAr[id] && this.rowsAr[id].tagName=="TR")
			this[method](this.rowsAr[id],oldInd,newInd,-1);
	});			
	
}

/**
*   @desc: shift data in all arrays
*   @type: private
*   @topic: 0
*/
dhtmlXGridObject.prototype._processAllArrays = function(oldInd,newInd,vals){
	var ars=["hdrLabels","initCellWidth","cellType","cellAlign","cellVAlign","fldSort","columnColor","_hrrar","_c_order"];
	if (this.cellWidthPX.length) ars.push("cellWidthPX");
	if (this.cellWidthPC.length) ars.push("cellWidthPC");
	if (this._col_combos) ars.push("_col_combos");
    if (this._mCols) ars[ars.length]="_mCols";
    if (this.columnIds) ars[ars.length]="columnIds";
    if (this._maskArr) ars.push("_maskArr");
    if (this._drsclmW) ars.push("_drsclmW");
    if (this._RaSeCol) ars.push("_RaSeCol");
    
    if (this.clists) ars.push("clists");
    if (this._validators && this._validators.data) ars.push(this._validators.data);
    
    ars.push("combos");
    if (this._customSorts) ars.push("_customSorts");
    if (this._aggregators)  ars.push("_aggregators");
    var mode=(oldInd<=newInd);

	if (!this._c_order) {
		this._c_order=new Array();
		var l=this._cCount;
		for (var i=0; i<l; i++)
			this._c_order[i]=i;
	}

	for (var i=0; i<ars.length; i++)
		{
			var t=this[ars[i]]||ars[i];
			if (t){
				if (mode){
					var val=t[oldInd];
					for (var j=oldInd; j<newInd; j++)
						t[j]=t[j+1];
					t[newInd]=val;
				} else {
					var val=t[oldInd];
					for (var j=oldInd; j>(newInd+1); j--)
						t[j]=t[j-1];
					t[newInd+1]=val;
				}
				if (vals)
					t[newInd+(mode?0:1)]=vals[i];
			}
		}
}


/**
*   @desc: moves column of specified index to new position
*   @param: oldInd - current index of column
*   @param: newInd - new index of column
*   @type: public
*   @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.moveColumn = function(oldInd,newInd){
	newInd--;
    oldInd=parseInt(oldInd); newInd=parseInt(newInd);
	if (newInd<oldInd) var tInd=newInd+1;
	else var tInd=newInd;
	

	if (!this.callEvent("onBeforeCMove",[oldInd,tInd]))  return false;
	if (oldInd==tInd) return;

	
	//replace data
	this.editStop();
    this._processAllRows("_moveColInRow",oldInd,newInd);
    this._processAllArrays(oldInd,newInd);

	//sorting image
	if (this.fldSorted)
		this.setSortImgPos(this.fldSorted._cellIndex);

  /*	for (var i=0; i<this.hdrLabels.length; i++)
		this._c_revers[this._c_order[i]]=i;*/
	this.callEvent("onAfterCMove",[oldInd,tInd]);
};


/**
*   @desc: swap columns in collection
*   @param: cols - collection of collumns
*   @type: private
*   @topic: 0
*/
dhtmlXGridObject.prototype._swapColumns = function(cols){
	var z=new Array();
	for (var i=0; i<this._cCount; i++){
		var n=cols[this._c_order[i]];
		if (typeof(n)=="undefined") n="";
		z[i]=n;
		}
	return z;
}

/**
*   @desc: move data in the row
*   @param: row - row object
*   @param: oldInd - current index of column
*   @param: newInd - new index of column
*   @type: private
*   @topic: 0
*/
dhtmlXGridObject.prototype._moveColInRow = function(row,oldInd,newInd){


	var c=row.childNodes[oldInd];
	var ci=row.childNodes[newInd+1];
	if (!c) return;
	if (ci)
		row.insertBefore(c,ci);
	else
		row.appendChild(c);

	for (var i=0; i<row.childNodes.length; i++)
		row.childNodes[i]._cellIndex=row.childNodes[i]._cellIndexS=i;

};
/**
*   @desc: add column in row
*   @param: row - row object
*   @param: ind - current index of column
*   @type: private
*   @topic: 0
*/
dhtmlXGridObject.prototype._addColInRow = function(row,ind,old,mod){
	var cind=ind;
	if (row._childIndexes){
		if (row._childIndexes[ind-1]==row._childIndexes[ind] || !row.childNodes[row._childIndexes[ind-1]]){
			for (var i=row._childIndexes.length; i>=ind; i--)
			row._childIndexes[i]=i?(row._childIndexes[i-1]+1):0;
			row._childIndexes[ind]--;
			}
		else
		for (var i = row._childIndexes.length; i >= ind; i--)
			row._childIndexes[i]=i?(row._childIndexes[i-1]+1):0;
		var cind=row._childIndexes[ind];
	}
	var c=row.childNodes[cind];
	var z=document.createElement((mod)?"TD":"TH");
	if (mod) { z._attrs={}; } //necessary for code compressor
	else z.style.width=(parseInt(this.cellWidthPX[ind])||"100")+"px";
	if (c)
		row.insertBefore(z,c);
	else
		row.appendChild(z);

	if (this.dragAndDropOff && row.idd) this.dragger.addDraggableItem(row.childNodes[cind],this);
	
	for (var i=cind+1; i<row.childNodes.length; i++){
		row.childNodes[i]._cellIndex=row.childNodes[i]._cellIndexS=row.childNodes[i]._cellIndex+1;
	}
		
	if (row.childNodes[cind]) row.childNodes[cind]._cellIndex=row.childNodes[cind]._cellIndexS=ind;

	if (row.idd || typeof(row.idd)!="undefined"){
		this.cells3(row,ind).setValue("");
		z.align=this.cellAlign[ind];
		z.style.verticalAlign=this.cellVAlign[ind];
		z.bgColor=this.columnColor[ind];
		}
	else if (z.tagName=="TD"){
		if (!row.idd && this.forceDivInHeader) z.innerHTML="<div class='hdrcell'>&nbsp;</div>";
		else	z.innerHTML="&nbsp;";
	} 
};
/**
*   @desc: delete columns from row
*   @param: row - row object
*   @param: ind - current index of column
*   @type: private
*   @topic: 0
*/
dhtmlXGridObject.prototype._deleteColInRow = function(row,ind){
	
	if (row._childIndexes) ind=row._childIndexes[ind];
	var c=row.childNodes[ind];
	if (!c) return;
	if (c.colSpan && c.colSpan>1 && c.parentNode.idd){
		var t=c.colSpan-1;
		var v=this.cells4(c).getValue();
		this.setColspan(c.parentNode.idd,c._cellIndex,1)
		if (t>1){
			var cind=c._cellIndex*1;
			this.setColspan(c.parentNode.idd,cind+1,t)
			this.cells(c.parentNode.idd,c._cellIndex*1+1).setValue(v)
			row._childIndexes.splice(cind,1)
			for (var i=cind; i < row._childIndexes.length; i++) 
				row._childIndexes[i]-=1;
				
		}
	} else if (row._childIndexes){
	    row._childIndexes.splice(ind,1);
	    for (var i=ind; i<row._childIndexes.length; i++) row._childIndexes[i]--;
	}
	if (c)
		row.removeChild(c);

	for (var i=ind; i<row.childNodes.length; i++)
		row.childNodes[i]._cellIndex=row.childNodes[i]._cellIndexS=row.childNodes[i]._cellIndex-1;
};


/**
*   @desc: enable move column functionality
*   @param: mode - true/false
*   @param: columns - list of true/false values, optional
*   @type: public
*   @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.enableColumnMove = function(mode,columns){
	this._mCol=convertStringToBoolean(mode);
	if (typeof(columns)!="undefined")
		this._mCols=columns.split(",");
	if (!this._mmevTrue){
		dhtmlxEvent(this.hdr,"mousedown",this._startColumnMove);
		dhtmlxEvent(document.body,"mousemove",this._onColumnMove);
		dhtmlxEvent(document.body,"mouseup",this._stopColumnMove);
		this._mmevTrue=true;
	}
};

dhtmlXGridObject.prototype._startColumnMove = function(e){
	e=e||event;
	var el = e.target||e.srcElement;
//	var grid=globalActiveDHTMLGridObject;
	   	var zel=el;
	   	while(zel.tagName!="TABLE") zel=zel.parentNode;
		var grid=zel.grid;
		if (!grid) return; //somehow grid not found
		grid.setActive();
	if (!grid._mCol || e.button==2) return;
	
	el = grid.getFirstParentOfType(el,"TD")
    if(el.style.cursor!="default") return true;
	if ((grid)&&(!grid._colInMove)){
		grid.resized = null;
		if ((!grid._mCols)||(grid._mCols[el._cellIndex]=="true"))
	    	grid._colInMove=el._cellIndex+1;
	}
	return true;
};
dhtmlXGridObject.prototype._onColumnMove = function(e){
	e=e||event;
	var grid=window.globalActiveDHTMLGridObject;
	if ((grid)&&(grid._colInMove)){
		if (grid._showHContext) grid._showHContext(false)
    	if (typeof(grid._colInMove)!="object"){
        	var z=document.createElement("DIV");
			z._aIndex=(grid._colInMove-1);
			z._bIndex=null;
			z.innerHTML=grid.getHeaderCol(z._aIndex);
			z.className="dhx_dragColDiv";
			z.style.position="absolute";
			document.body.appendChild(z);
            grid._colInMove=z;
		}
		
		var cor=[];
		cor[0]=(document.body.scrollLeft||document.documentElement.scrollLeft);
		cor[1]=(document.body.scrollTop||document.documentElement.scrollTop);
		
		
		grid._colInMove.style.left=e.clientX+cor[0]+8+"px";
		grid._colInMove.style.top=e.clientY+cor[1]+8+"px";
		
        var el = e.target||e.srcElement;
		while ((el)&&(typeof(el._cellIndexS)=="undefined"))
			el=el.parentNode;

		if (grid._colInMove._oldHe){
			grid._colInMove._oldHe.className=grid._colInMove._oldHe.className.replace(/columnTarget(L|R)/g,"");
			grid._colInMove._oldHe=null;
			grid._colInMove._bIndex=null;
			}
		if (el) {
			if (grid.hdr.rows[1]._childIndexes)
				var he=grid.hdr.rows[1].cells[grid.hdr.rows[1]._childIndexes[el._cellIndexS]];
			else
				var he=grid.hdr.rows[1].cells[el._cellIndexS];
			var z=e.clientX-(getAbsoluteLeft(he)-grid.hdrBox.scrollLeft);
            if (z/he.offsetWidth>0.5){
				he.className+=" columnTargetR";
				grid._colInMove._bIndex=el._cellIndexS;
				}
			else {
				he.className+=" columnTargetL";
				grid._colInMove._bIndex=el._cellIndexS-1;
			}
			if (he.offsetLeft<(grid.objBox.scrollLeft+20))
				grid.objBox.scrollLeft=Math.max(0,he.offsetLeft-20);

			if ((he.offsetLeft+he.offsetWidth-grid.objBox.scrollLeft)>(grid.objBox.offsetWidth-20))
				grid.objBox.scrollLeft=Math.min(grid.objBox.scrollLeft+he.offsetWidth+20,grid.objBox.scrollWidth-grid.objBox.offsetWidth);	
				
            grid._colInMove._oldHe=he;
		}
		//prevent selection, or other similar reactions while column draged
		e.cancelBubble = true;  
        return false;  
	}
	return true;
};
dhtmlXGridObject.prototype._stopColumnMove = function(e){
	e=e||event;
	var grid=window.globalActiveDHTMLGridObject;
	if ((grid)&&(grid._colInMove)){
		if (typeof(grid._colInMove)=="object"){
			grid._colInMove.parentNode.removeChild(grid._colInMove);
			if (grid._colInMove._bIndex!=null)
				grid.moveColumn(grid._colInMove._aIndex,grid._colInMove._bIndex+1);

			if (grid._colInMove._oldHe)
				grid._colInMove._oldHe.className=grid._colInMove._oldHe.className.replace(/columnTarget(L|R)/g,"");
			grid._colInMove._oldHe=null;
			grid._colInMove.grid=null;
			grid.resized = true;
			}
        grid._colInMove=0;
	}
	return true;
};



//(c)dhtmlx ltd. www.dhtmlx.com


//v.3.6 build 131108

/*
Copyright DHTMLX LTD. http://www.dhtmlx.com
To use this component please contact sales@dhtmlx.com to obtain license
*/
/**
*   @desc: load grid from CSV file
*   @param: path - path to file
*   @param: afterCall - function which will be called after xml loading
*   @type: public
*     @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.loadCSVFile = function(path,afterCall){
    this.load(path,afterCall,"csv")
}

/**
*   @desc: enable mode, where ID for rows loaded from CSV autogenerated
*   @param: mode - true/false
*   @type: public
*   @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.enableCSVAutoID = function(mode){
   this._csvAID=convertStringToBoolean(mode);
}
/**
*   @desc: enable recognizing first row in CSV as header
*   @param: mode - true/false
*   @type: public
*   @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.enableCSVHeader = function(mode){
   this._csvHdr=convertStringToBoolean(mode);
}

/**
*   @desc: load grid from CSV string
*   @param: str - delimer used in CSV operations, comma by default ( only single char delimeters allowed )
*   @type: public
*     @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.setCSVDelimiter = function(str){
   this.csv.cell=str;
}
dhtmlXGridObject.prototype._csvAID = true;

/**
*   @desc: load grid from CSV string
*   @param: str - CSV  string
*   @type: public
*     @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.loadCSVString = function(str){
   this.parse(str,"csv")
}

/**
*   @desc: serialize to CSV string
*   @type: public
*	@param: text only - force serialization of text values ( skip HTML elements ) )
*     @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.serializeToCSV = function(textmode){ 
    this.editStop()
    if (this._mathSerialization)
         this._agetm="getMathValue";
    else if (this._strictText || textmode)
    	this._agetm="getTitle";
    else this._agetm="getValue";

	var out=[];
	if (this._csvHdr){
		for (var j=1; j < this.hdr.rows.length; j++) {
			var a=[]; 
			for (var i=0; i<this._cCount; i++)
				if ((!this._srClmn)||(this._srClmn[i]))
					a.push(this.getColumnLabel(i,j-1));
    		out.push(this.csvParser.str(a,this.csv.cell, this.csv.row));
    	}
    }

    
    //rows collection
    var i=0;
    var leni=this.rowsBuffer.length;

   for(i; i<leni; i++){
		var temp=this._serializeRowToCVS(null,i)      	
		if (temp!="") out.push(temp);
  }

   return this.csvParser.block(out,this.csv.row);
}

/**
*   @desc: serialize TR to CSV
*   @param: r - TR or xml node (row)
*   @retruns: string - CSV representation of passed row
*   @type: private
*/
dhtmlXGridObject.prototype._serializeRowToCVS = function(r,i,start,end){
    var out = new Array();
    if (!r){
	    r=this.render_row(i)
	    if (this._fake && !this._fake.rowsAr[r.idd]) this._fake.render_row(i);
	}
    

    if (!this._csvAID)
       out[out.length]=r.idd;

	start = start||0;
	
    end = end||this._cCount;
    //cells
    var changeFl=false;
    var ind=start;
    //rowspans before block selection
    while (r.childNodes[start]._cellIndex>ind && start) start--; 
    
    
    for(var jj=start;ind<end;jj++){
    	if (!r.childNodes[jj]) break;
    	var real_ind=r.childNodes[jj]._cellIndex;
        if (((!this._srClmn)||(this._srClmn[real_ind])) && (!this._serialize_visible || !this._hrrar[real_ind])){
            var cvx=r.childNodes[jj];

            var zx=this.cells(r.idd,real_ind);
            while (ind!=real_ind){
            	ind++;
            	out.push("")
            	if (ind>=end) break;
            }
            if (ind>=end) break;
            ind++;
        /*	if (zx.getText)
        		zxVal=zx.getText();
        	else*/
            if (zx.cell)
				zxVal=zx[this._agetm]();
			else zxVal="";


		if ((this._chAttr)&&(zx.wasChanged()))
			changeFl=true;

            out[out.length]=((zxVal===null)?"":zxVal)
//#colspan:20092006{
            if ( this._ecspn && cvx.colSpan && cvx.colSpan >1 ){
                cvx=cvx.colSpan-1;
                for (var u=0; u<cvx; u++){
	                out[out.length] = "";
	                ind++;
                }
            }
//#}

 } else ind++;
    }
     if ((this._onlChAttr)&&(!changeFl)) return "";
      return this.csvParser.str(out,this.csv.cell, this.csv.row);
}

dhtmlXGridObject.prototype.toClipBoard=function(val){
    if (window.clipboardData)
      window.clipboardData.setData("Text",val);
   else
      (new Clipboard()).copy(val);

}
dhtmlXGridObject.prototype.fromClipBoard=function(){
   if (window.clipboardData)
      return window.clipboardData.getData("Text");
   else
      return (new Clipboard()).paste();
}

/**
*   @desc: copy value of cell to clipboard
*   @type: public
*   @param: rowId - id of row (optional, use selected row by default)
*   @param: cellInd - column index(optional, use selected cell by default)
*     @edition: Professional
*   @topic: 5
*/
dhtmlXGridObject.prototype.cellToClipboard = function(rowId,cellInd){
    if ((!rowId)||(!cellInd)){
       if (!this.selectedRows[0]) return;
       rowId=this.selectedRows[0].idd;
       cellInd=this.cell._cellIndex;
   }
   
   	var ed=this.cells(rowId,cellInd);
    this.toClipBoard(((ed.getLabel?ed.getLabel():ed.getValue())||"").toString());
}

/**
*   @desc: set value of cell from clipboard
*   @type: public
*     @edition: Professional
*   @param: rowId - id of row (optional, use selected row by default)
*   @param: cellInd - column index(optional, use selected cell by default)
*   @topic: 5
*/
dhtmlXGridObject.prototype.updateCellFromClipboard = function(rowId,cellInd){
    if ((!rowId)||(!cellInd)){
       if (!this.selectedRows[0]) return;
       rowId=this.selectedRows[0].idd;
       cellInd=this.cell._cellIndex;
   }
   	var ed=this.cells(rowId,cellInd);
    ed[ed.setImage?"setLabel":"setValue"](this.fromClipBoard());
}

/**
*   @desc: copy value of row to clipboard
*   @type: public
*     @edition: Professional
*   @param: rowId - id of row (optional, use selected row by default)
*   @topic: 5
*/
dhtmlXGridObject.prototype.rowToClipboard = function(rowId){
	var out="";
	if (this._mathSerialization)
		this._agetm="getMathValue";
	else if (this._strictText)
		this._agetm="getTitle";
	else 
		this._agetm="getValue";
    
	if (rowId)
		out=this._serializeRowToCVS(this.getRowById(rowId));
	else {
   		var data = [];
		for (var i=0; i<this.selectedRows.length; i++){
			data[data.length] = this._serializeRowToCVS(this.selectedRows[i]);
			out = this.csvParser.block(data, this.csv.row);
		}
	}
	this.toClipBoard(out);
}

/**
*   @desc: set value of row from clipboard
*   @type: public
*     @edition: Professional
*   @param: rowId - id of row (optional, use selected row by default)
*   @topic: 5
*/
dhtmlXGridObject.prototype.updateRowFromClipboard = function(rowId){
	var csv=this.fromClipBoard();
	if (!csv) return;
	if (rowId)
		var r=this.getRowById(rowId);
	else
		var r=this.selectedRows[0];
	if (!r) return;
	
	var parser = this.csvParser;
	csv=parser.unblock(csv,this.csv.cell, this.csv.row)[0];
	if (!this._csvAID) csv.splice(0,1);
	for (var i=0; i<csv.length; i++){
		var ed=this.cells3(r,i);
		ed[ed.setImage?"setLabel":"setValue"](csv[i]);
	}
}

dhtmlXGridObject.prototype.csvParser={
	block:function(data,row){
		return data.join(row);
	},
	unblock:function(str,cell,row){
		var data = (str||"").split(row);	
		for (var i=0; i < data.length; i++)
			data[i]=(data[i]||"").split(cell);
    var last = data.length-1;
    if (data[last].length == 1 && data[last][0]=="")
      data.splice(last,1);
		return data;
	},
	str:function(data,cell,row){
		return data.join(cell);
	}
};
dhtmlXGridObject.prototype.csvExtParser={
	_quote:RegExp('"',"g"),
	_quote_esc:RegExp("\\\\\"","g"),
	block:function(data,row){
		return data.join(row);
	},
	unblock:function(str,cell,row){ 
		var out = [[]];
		var ind = 0;
		if (!str) return out;

		var quote_start = /^[ ]*"/;
		var quote_end   = /"[ ]*$/;
		var row_exp  = new RegExp(".*"+row+".*$");
		
		var data = str.split(cell);
		for (var i=0; i<data.length; i++){
			if (data[i].match(quote_start)){
				var buff = data[i].replace(quote_start, "");
				while (!data[i].match(quote_end)) {
					i++;
					buff+=data[i];
				}
				out[ind].push(buff.replace(quote_end, "").replace(this._quote_esc,'"'));
			} else if (data[i].match(row_exp)){
        var row_pos = data[i].indexOf(row);
				out[ind].push(data[i].substr(0, row_pos));
				ind++;
				out[ind] = [];
				data[i]=data[i].substr(row_pos+1); i--;
			} else {
				if (data[i] || i!=data.length-1)
					out[ind].push(data[i]);
			}
		}

    var last = out.length-1;
    if (last>0 && !out[last].length)
      out.splice(last,1);
    
		return out;	
	},
	str:function(data,cell,row){
		for (var i=0; i < data.length; i++)
			data[i] = '"'+data[i].replace(this._quote, "\\\"")+'"';
		return data.join(cell);
	}
};

/**
*   @desc: add new row from clipboard
*   @type: public
*     @edition: Professional
*   @topic: 5
*/
dhtmlXGridObject.prototype.addRowFromClipboard = function(){
   var csv=this.fromClipBoard();
   if (!csv) return;
   var z=this.csvParser.unblock(csv, this.csv.cell, this.csv.row);
   for (var i=0; i<z.length; i++)
      if (z[i]){
         csv=z[i];
         if (!csv.length) continue;
         if (this._csvAID)
         	this.addRow(this.getRowsNum()+2,csv);
         else{
         	if (this.rowsAr[csv[0]])
         		csv[0]=this.uid();
         	this.addRow(csv[0],csv.slice(1));
     		}
      }
}

/**
*   @desc: copy grid in CSV to clipboard
*   @type: public
*     @edition: Professional
*   @topic: 5
*/
dhtmlXGridObject.prototype.gridToClipboard = function(){
   this.toClipBoard(this.serializeToCSV());
}

/**
*   @desc: init grid from CSV stored in clipboard
*   @type: public
*     @edition: Professional
*   @topic: 5
*/
dhtmlXGridObject.prototype.gridFromClipboard = function(){
   var csv=this.fromClipBoard();
   if (!csv) return;
   this.loadCSVString(csv);
}

/**
*   @desc: get grid as XML - php required
*   @param: path - path to server side code,optional
*   @type: private
*   @edition: Professional
*   @topic: 5
*/
dhtmlXGridObject.prototype.getXLS = function(path){
   if (!this.xslform){
      this.xslform=document.createElement("FORM");
      this.xslform.action=(path||"")+"xls.php";
      this.xslform.method="post";
      this.xslform.target=(_isIE?"_blank":"");
      document.body.appendChild(this.xslform);
      var i1=document.createElement("INPUT");
      i1.type="hidden";
      i1.name="csv";
      this.xslform.appendChild(i1);
      var i2=document.createElement("INPUT");
      i2.type="hidden";
      i2.name="csv_header";
      this.xslform.appendChild(i2);
   }
      var cvs = this.serializeToCSV();
      this.xslform.childNodes[0].value = cvs;
        var cvs_header = [];
        var l = this._cCount;
        for (var i=0; i<l; i++) {
         cvs_header.push(this.getHeaderCol(i));
        }
      cvs_header = cvs_header.join(',');
      this.xslform.childNodes[1].value = cvs_header;
       this.xslform.submit();
}

/**
*   @desc: generate print friendly view
*   @type: public
*   @edition: Professional
*   @topic: 5
*/
dhtmlXGridObject.prototype.printView = function(before,after){
	  var html="<style>TD { font-family:Arial; text-align:center; padding-left:2px;padding-right:2px; } \n td.filter input, td.filter select { display:none; }	\n  </style>";
	  var st_hr=null;
	  if (this._fake) {
	  	st_hr=[].concat(this._hrrar); 
	  	for (var i=0; i<this._fake._cCount; i++)
	  		this._hrrar[i]=null;
	  }
	   html+="<base  href='"+document.location.href+"'></base>";
	   if (!this.parentGrid) html+=(before||"");
       html += '<table width="100%" border="2px" cellpadding="0" cellspacing="0">';
       var row_length = Math.max(this.rowsBuffer.length,this.rowsCol.length); //paging and smartrendering
       var col_length = this._cCount;
      var width = this._printWidth();
      html += '<tr class="header_row_1">';
        for (var i=0; i<col_length; i++){
        	if (this._hrrar && this._hrrar[i]) continue;
         var hcell=this.hdr.rows[1].cells[this.hdr.rows[1]._childIndexes?this.hdr.rows[1]._childIndexes[parseInt(i)]:i];
         var colspan=(hcell.colSpan||1);
         var rowspan=(hcell.rowSpan||1);
         
         for (var j=1; j<colspan; j++)
         	width[i]+=width[j];
    	html += '<td rowspan="'+rowspan+'" width="'+width[i]+'%" style="background-color:lightgrey;" colspan="'+colspan+'">'+this.getHeaderCol(i)+'</td>';
         i+=colspan-1;
        }
      html += '</tr>';

	  	for (var i=2; i<this.hdr.rows.length; i++){
	  		if (_isIE){
	  			html+="<tr style='background-color:lightgrey' class='header_row_"+i+"'>";
	  			var cells=this.hdr.rows[i].childNodes;
	  			for (var j=0; j < cells.length; j++) 
	  				if (!this._hrrar || !this._hrrar[cells[j]._cellIndex]){
	  					html+=cells[j].outerHTML;
	  				}
	  			html+="</tr>";
	  			}
	  		else
				html+="<tr class='header_row_"+i+"' style='background-color:lightgrey'>"+(this._fake?this._fake.hdr.rows[i].innerHTML:"")+this.hdr.rows[i].innerHTML+"</tr>";
		}

       for (var i=0; i<row_length; i++) {
         html += '<tr>';
           if (this.rowsCol[i] && this.rowsCol[i]._cntr){
           	  html+=this.rowsCol[i].innerHTML.replace(/<img[^>]*>/gi,"")+'</tr>';
           	  continue;
           }
           if (this.rowsCol[i] && this.rowsCol[i].style.display=="none") continue;
           
           var row_id
           if (this.rowsCol[i])
           		row_id=this.rowsCol[i].idd;
           	else if (this.rowsBuffer[i]) 
           		row_id=this.rowsBuffer[i].idd;
           	else continue; //dyn loading 
           	
           for (var j=0; j<col_length; j++) {
           	   if (this._hrrar && this._hrrar[j]) continue;
           	   if(this.rowsAr[row_id] && this.rowsAr[row_id].tagName=="TR") {
	           	   var c=this.cells(row_id, j);
	           	   if (c._setState) var value="";
	           	   else if (c.getContent) value = c.getContent();
	           	   else if (c.getImage || c.combo) var value=c.cell.innerHTML;
	           	   else var value = c.getValue();
           	   } else 
	           	  var value=this._get_cell_value(this.rowsBuffer[i],j);
               var color = this.columnColor[j]?'background-color:'+this.columnColor[j]+';':'';
            var align = this.cellAlign[j]?'text-align:'+this.cellAlign[j]+';':'';
            var cspan =  c.getAttribute("colspan");
            html += '<td style="'+color+align+'" '+(cspan?'colSpan="'+cspan+'"':'')+'>'+(value===""?"&nbsp;":value)+'</td>';
            if (cspan) j+=cspan-1;
           }
         html += '</tr>';
         if (this.rowsCol[i] && this.rowsCol[i]._expanded){
         	 var sub=this.cells4(this.rowsCol[i]._expanded.ctrl);
         	 if (sub.getSubGrid)
         	 	html += '<tr><td colspan="'+col_length+'">'+sub.getSubGrid().printView()+'</td></tr>';
         	 else
         	 	html += '<tr><td colspan="'+col_length+'">'+this.rowsCol[i]._expanded.innerHTML+'</td></tr>';
         }
       }

	   if (this.ftr)
	  	for (var i=1; i<this.ftr.childNodes[0].rows.length; i++)
	  		html+="<tr style='background-color:lightgrey'>"+((this._fake)?this._fake.ftr.childNodes[0].rows[i].innerHTML:"")+this.ftr.childNodes[0].rows[i].innerHTML+"</tr>";
        		

      html += '</table>';
      if (this.parentGrid) return html;
      
      html+=(after||"");
      var d = window.open('', '_blank');
      d.document.write(html);
      d.document.write("<script>window.onerror=function(){return true;}</script>");
      d.document.close();
      if (this._fake) {
	  	this._hrrar=st_hr;
	  }
}
dhtmlXGridObject.prototype._printWidth=function(){
      var width = [];
      var total_width = 0;
      for (var i=0; i<this._cCount; i++) {
         var w = this.getColWidth(i);
         width.push(w);
         total_width += w;
      }
      var percent_width = [];
      var total_percent_width = 0;
      for (var i=0; i<width.length; i++) {
         var p = Math.floor((width[i]/total_width)*100);
         total_percent_width += p;
            percent_width.push(p);
      }
      percent_width[percent_width.length-1] += 100-total_percent_width;
      return percent_width;
   }
/**
*   @desc: load grid from javascript object
*   @param: obj - object
*   @type: notImplemented
*   @topic: 0
*/
dhtmlXGridObject.prototype.loadObject = function(obj){
}


/**
*   @desc: load grid from JSON file
*   @param: path - path to file
*   @type: notImplemented
*   @topic: 0
*/
dhtmlXGridObject.prototype.loadJSONFile = function(path){
}


/**
*   @desc: serialize to JSON object
*   @type: notImplemented
*   @topic: 0
*/
dhtmlXGridObject.prototype.serializeToObject = function(){
}

/**
*   @desc: serialize to JSON string
*   @type: notImplemented
*   @topic: 0
*/
dhtmlXGridObject.prototype.serializeToJSON = function(){
}

/*
user_pref("signed.applets.codebase_principal_support", true);
*/
if (!window.clipboardData)
window.clipboardData={
	_make:function(){
	   
	   var clip = Components.classes['@mozilla.org/widget/clipboard;1'].createInstance(Components.interfaces.nsIClipboard);
	   if (!clip) return null;
		
	   var trans = Components.classes['@mozilla.org/widget/transferable;1'].createInstance(Components.interfaces.nsITransferable);
	   if (!trans) return null;
	   		
	   trans.addDataFlavor('text/unicode');


	   var str = Components.classes["@mozilla.org/supports-string;1"].createInstance(Components.interfaces.nsISupportsString);
	   		
	   this._p=[clip,trans,str];
	   		
	   return true;
	},
	setData:function(type,text){
		try{
		netscape.security.PrivilegeManager.enablePrivilege('UniversalXPConnect');
		} catch(e){ dhtmlxError.throwError("Clipboard","Access to clipboard denied",[type,text]); return ""; }
		if (!this._make()) return false;
		
   this._p[2].data=text;
   this._p[1].setTransferData("text/unicode",this._p[2],text.length*2);
   var clipid=Components.interfaces.nsIClipboard;
   this._p[0].setData(this._p[1],null,clipid.kGlobalClipboard);

	},
	getData:function(type){ 
		try{
		netscape.security.PrivilegeManager.enablePrivilege('UniversalXPConnect');		
		} catch(e){ dhtmlxError.throwError("Clipboard","Access to clipboard denied",[type]); return ""; }
		if (!this._make()) return false;


   this._p[0].getData(this._p[1],this._p[0].kGlobalClipboard);
   var strLength = new Object();
   var str = new Object();
   try{
   	this._p[1].getTransferData("text/unicode",str,strLength);
   } catch(e){
   	//empty clipboard in FF 
   	return "";
   }

	if (str) str = str.value.QueryInterface(Components.interfaces.nsISupportsString);
	if (str) return str.data.substring(0,strLength.value / 2);

	return "";

	}
}
//(c)dhtmlx ltd. www.dhtmlx.com


//v.3.6 build 131108

/*
Copyright DHTMLX LTD. http://www.dhtmlx.com
To use this component please contact sales@dhtmlx.com to obtain license
*/
/**
*     @desc: enables block selection mode in grid
*     @type: public
*     @topic: 0
*/
dhtmlXGridObject.prototype.enableBlockSelection = function(mode)
{
	if (typeof this._bs_mode == "undefined"){
		var self = this;
		this.obj.onmousedown = function(e) {
			if (self._bs_mode) self._OnSelectionStart((e||event),this); return true;
		}
		this._CSVRowDelimiter = this.csv.row;
		this.attachEvent("onResize", function() {self._HideSelection(); return true;});
		this.attachEvent("onGridReconstructed", function() {self._HideSelection(); return true;});
		this.attachEvent("onFilterEnd",this._HideSelection);
	}
	if (mode===false){
		this._bs_mode=false;
		return this._HideSelection();
	} else this._bs_mode=true;
}
/**
*     @desc:  affect block selection, so it will copy|paste only visible text , not values behind
*	  @param: mode - true/false
*     @type: public
*     @topic: 0
*/
dhtmlXGridObject.prototype.forceLabelSelection = function(mode)
{
	this._strictText = convertStringToBoolean(mode)
}


dhtmlXGridObject.prototype.disableBlockSelection = function()
{
	this.obj.onmousedown = null;
}
	
dhtmlXGridObject.prototype._OnSelectionStart = function(event, obj)
{

	var self = this;
	if (event.button == 2) return;
	var src = event.srcElement || event.target;
	if (this.editor){
		if (src.tagName && (src.tagName=="INPUT" || src.tagName=="TEXTAREA"))   return;
		this.editStop();
	}
	
	self.setActive(true);
	var pos = this.getPosition(this.obj);
	var x = event.clientX - pos[0] + (document.body.scrollLeft||(document.documentElement?document.documentElement.scrollLeft:0));
	var y = event.clientY - pos[1] + (document.body.scrollTop||(document.documentElement?document.documentElement.scrollTop:0));
	this._CreateSelection(x-4, y-4);

	if (src == this._selectionObj) {
		this._HideSelection();
		this._startSelectionCell = null;
	} else {
	    while (src.tagName.toLowerCase() != 'td')
	        src = src.parentNode;
	    this._startSelectionCell = src;
	}
	
	if (this._startSelectionCell){
		if (!this.callEvent("onBeforeBlockSelected",[this._startSelectionCell.parentNode.idd, this._startSelectionCell._cellIndex]))
			return this._startSelectionCell = null;
	}
	
	    //this._ShowSelection();
	    this.obj.onmousedown = null;
		this.obj[_isIE?"onmouseleave":"onmouseout"] = function(e){ if (self._blsTimer) window.clearTimeout(self._blsTimer); };	    
		this.obj.onmmold=this.obj.onmousemove;
		this._init_pos=[x,y];
	    this._selectionObj.onmousemove = this.obj.onmousemove = function(e) {e = e||event; e.returnValue = false;  self._OnSelectionMove(e);}
	    
	    
	    this._oldDMP=document.body.onmouseup;
	    document.body.onmouseup = function(e) {e = e||event; self._OnSelectionStop(e, this); return true; }
	this.callEvent("onBeforeBlockSelection",[]);
	document.body.onselectstart = function(){return false};//avoid text select	    
}

dhtmlXGridObject.prototype._getCellByPos = function(x,y){
	x=x;//+this.objBox.scrollLeft;
	if (this._fake)
		x+=this._fake.objBox.scrollHeight;
	y=y;//+this.objBox.scrollTop;
	var _x=0;
	for (var i=0; i < this.obj.rows.length; i++) {
		y-=this.obj.rows[i].offsetHeight;
		if (y<=0) {
			_x=this.obj.rows[i];
			break;
		}
	}
	if (!_x || !_x.idd) return null;
	for (var i=0; i < this._cCount; i++) {
		x-=this.getColWidth(i);
		if (x<=0) {
			while(true){
				if (_x._childIndexes && _x._childIndexes[i+1]==_x._childIndexes[i])
					_x=_x.previousSibling;
				else {
					return this.cells(_x.idd,i).cell;
				}
				
			}
		}
	}
	return null;
}

dhtmlXGridObject.prototype._OnSelectionMove = function(event)
{ 
	
	var self=this;
	this._ShowSelection();
	var pos = this.getPosition(this.obj);
	var X = event.clientX - pos[0] + (document.body.scrollLeft||(document.documentElement?document.documentElement.scrollLeft:0));
	var Y = event.clientY - pos[1] + (document.body.scrollTop||(document.documentElement?document.documentElement.scrollTop:0));

	if ((Math.abs(this._init_pos[0]-X)<5) && (Math.abs(this._init_pos[1]-Y)<5)) return this._HideSelection();
	
	var temp = this._endSelectionCell;
	if(this._startSelectionCell==null)
 		this._endSelectionCell  = this._startSelectionCell = this.getFirstParentOfType(event.srcElement || event.target,"TD");		
	else
		if (event.srcElement || event.target) {
			if ((event.srcElement || event.target).className == "dhtmlxGrid_selection")
				this._endSelectionCell=(this._getCellByPos(X,Y)||this._endSelectionCell);
			else {
				var t = this.getFirstParentOfType(event.srcElement || event.target,"TD");
				if (t.parentNode.idd) this._endSelectionCell = t;
			}
		}
		
	if (this._endSelectionCell){
		if (!this.callEvent("onBeforeBlockSelected",[this._endSelectionCell.parentNode.idd, this._endSelectionCell._cellIndex]))
			this._endSelectionCell = temp;
	}
	
		/*
	//window.status = pos[0]+'+'+pos[1];
	var prevX = this._selectionObj.startX;
	var prevY = this._selectionObj.startY;
	var diffX = X - prevX;
	var diffY = Y - prevY;
	
	if (diffX < 0) {
        this._selectionObj.style.left = this._selectionObj.startX + diffX + 1+"px";
        diffX = 0 - diffX;
	} else {
		this._selectionObj.style.left = this._selectionObj.startX - 3+"px";
	}
	if (diffY < 0) {
		this._selectionObj.style.top = this._selectionObj.startY + diffY + 1+"px";
        diffY = 0 - diffY;
	} else {
		this._selectionObj.style.top = this._selectionObj.startY - 3+"px";
	}
    this._selectionObj.style.width = (diffX>4?diffX-4:0) + 'px';
    this._selectionObj.style.height = (diffY>4?diffY-4:0) + 'px';


/* AUTO SCROLL */
	var BottomRightX = this.objBox.scrollLeft + this.objBox.clientWidth;
	var BottomRightY = this.objBox.scrollTop + this.objBox.clientHeight;
	var TopLeftX = this.objBox.scrollLeft;
	var TopLeftY = this.objBox.scrollTop;

	var nextCall=false;
	if (this._blsTimer) window.clearTimeout(this._blsTimer);	
	
	if (X+20 >= BottomRightX) {
		this.objBox.scrollLeft = this.objBox.scrollLeft+20;
		nextCall=true;
	} else if (X-20 < TopLeftX) {
		this.objBox.scrollLeft = this.objBox.scrollLeft-20;
		nextCall=true;
	}
	if (Y+20 >= BottomRightY && !this._realfake) {
		this.objBox.scrollTop = this.objBox.scrollTop+20;
		nextCall=true;
	} else if (Y-20 < TopLeftY && !this._realfake) {
		this.objBox.scrollTop = this.objBox.scrollTop-20;
		nextCall=true;		
	}
	this._selectionArea = this._RedrawSelectionPos(this._startSelectionCell, this._endSelectionCell);
	

	if (nextCall){ 
		var a=event.clientX;
		var b=event.clientY;
		this._blsTimer=window.setTimeout(function(){self._OnSelectionMove({clientX:a,clientY:b})},100);
	}
	
}

dhtmlXGridObject.prototype._OnSelectionStop = function(event)
{
	var self = this;
	if (this._blsTimer) window.clearTimeout(this._blsTimer);	
	this.obj.onmousedown = function(e) {if (self._bs_mode)  self._OnSelectionStart((e||event), this); return true;}
	this.obj.onmousemove = this.obj.onmmold||null;
	this._selectionObj.onmousemove = null;
	document.body.onmouseup = this._oldDMP||null;
	if ( parseInt( this._selectionObj.style.width ) < 2 && parseInt( this._selectionObj.style.height ) < 2) {
		this._HideSelection();
	} else {
	    var src = this.getFirstParentOfType(event.srcElement || event.target,"TD");
	    if ((!src) || (!src.parentNode.idd)){
	    	src=this._endSelectionCell;
    		}
    	if (!src) return this._HideSelection();
	    while (src.tagName.toLowerCase() != 'td')
	        src = src.parentNode;
	    this._stopSelectionCell = src;
	    this._selectionArea = this._RedrawSelectionPos(this._startSelectionCell, this._stopSelectionCell);
		this.callEvent("onBlockSelected",[]);
	}
	document.body.onselectstart = function(){};//avoid text select
}

dhtmlXGridObject.prototype._RedrawSelectionPos = function(LeftTop, RightBottom)
{

//	td._cellIndex
//
//	getRowIndex
	var pos = {};
	pos.LeftTopCol = LeftTop._cellIndex;
	pos.LeftTopRow = this.getRowIndex( LeftTop.parentNode.idd );
	pos.RightBottomCol = RightBottom._cellIndex;
	pos.RightBottomRow = this.getRowIndex( RightBottom.parentNode.idd );

	var LeftTop_width = LeftTop.offsetWidth;
	var LeftTop_height = LeftTop.offsetHeight;
	LeftTop = this.getPosition(LeftTop, this.obj);

	var RightBottom_width = RightBottom.offsetWidth;
	var RightBottom_height = RightBottom.offsetHeight;
	RightBottom = this.getPosition(RightBottom, this.obj);

    if (LeftTop[0] < RightBottom[0]) {
		var Left = LeftTop[0];
		var Right = RightBottom[0] + RightBottom_width;
    } else {
    	var foo = pos.RightBottomCol;
        pos.RightBottomCol = pos.LeftTopCol;
        pos.LeftTopCol = foo;
		var Left = RightBottom[0];
		var Right = LeftTop[0] + LeftTop_width;
    }

    if (LeftTop[1] < RightBottom[1]) {
		var Top = LeftTop[1];
		var Bottom = RightBottom[1] + RightBottom_height;
    } else {
    	var foo = pos.RightBottomRow;
        pos.RightBottomRow = pos.LeftTopRow;
        pos.LeftTopRow = foo;
		var Top = RightBottom[1];
		var Bottom = LeftTop[1] + LeftTop_height;
    }

    var Width = Right - Left;
    var Height = Bottom - Top;

	this._selectionObj.style.left = Left + 'px';
	this._selectionObj.style.top = Top + 'px';
	this._selectionObj.style.width =  Width  + 'px';
	this._selectionObj.style.height = Height + 'px';
	return pos;
}

dhtmlXGridObject.prototype._CreateSelection = function(x, y)
{
	if (this._selectionObj == null) {
		var div = document.createElement('div');
		div.style.position = 'absolute';
        div.style.display = 'none';
        div.className = 'dhtmlxGrid_selection';
		this._selectionObj = div;
		this._selectionObj.onmousedown = function(e){
			e=e||event;
			if (e.button==2 || (_isMacOS&&e.ctrlKey))
				return this.parentNode.grid.callEvent("onBlockRightClick", ["BLOCK",e]);
		}
		this._selectionObj.oncontextmenu=function(e){(e||event).cancelBubble=true;return false;}
		this.objBox.appendChild(this._selectionObj);
	}
    //this._selectionObj.style.border = '1px solid #83abeb';
    this._selectionObj.style.width = '0px';
    this._selectionObj.style.height = '0px';
    //this._selectionObj.style.border = '0px';
	this._selectionObj.style.left = x + 'px';
	this._selectionObj.style.top  = y + 'px';
    this._selectionObj.startX = x;
    this._selectionObj.startY = y;
}

dhtmlXGridObject.prototype._ShowSelection = function()
{
	if (this._selectionObj)
	    this._selectionObj.style.display = '';
}

dhtmlXGridObject.prototype._HideSelection = function()
{
	
	if (this._selectionObj)
	    this._selectionObj.style.display = 'none';
    this._selectionArea = null;
}
/**
*     @desc: copy content of block selection into clipboard in csv format (delimiter as set for csv serialization)
*     @type: public
*     @topic: 0
*/
dhtmlXGridObject.prototype.copyBlockToClipboard = function()
{
	if ( this._selectionArea != null ) {
		var serialized = new Array();
	if (this._mathSerialization)
         this._agetm="getMathValue";
    else if (this._strictText)
    	this._agetm="getTitle";
    else this._agetm="getValue";

    this._serialize_visible = true;

		for (var i=this._selectionArea.LeftTopRow; i<=this._selectionArea.RightBottomRow; i++) {
			var data = this._serializeRowToCVS(this.rowsBuffer[i], null,  this._selectionArea.LeftTopCol, this._selectionArea.RightBottomCol+1);
			if (!this._csvAID)
				serialized[serialized.length] = data.substr( data.indexOf( this.csv.cell ) + 1 );	//remove row ID and add to array
			else
				serialized[serialized.length] = data;
		}
		serialized = serialized.join(this._CSVRowDelimiter);
		this.toClipBoard(serialized);

	this._serialize_visible = false;
	}
}
/**
*     @desc: paste content of clipboard into block selection of grid
*     @type: public
*     @topic: 0
*/
dhtmlXGridObject.prototype.pasteBlockFromClipboard = function()
{
	var serialized = this.fromClipBoard();
    if (this._selectionArea != null) {
        var startRow = this._selectionArea.LeftTopRow;
        var startCol = this._selectionArea.LeftTopCol;
    } else if (this.cell != null && !this.editor) {
        var startRow = this.getRowIndex( this.cell.parentNode.idd );
        var startCol = this.cell._cellIndex;
    } else {
        return false;
    }

	serialized = this.csvParser.unblock(serialized, this.csv.cell, this.csv.row);
   // if ((serialized.length >1)&&(serialized[serialized.length-1]==""))
   // serialized.splice(serialized.length-1,1);
     
   //	if (serialized[serialized.length-1]=="") serialized.pop();
 /*   for (var i=0; i<serialized.length; i++) {
        serialized[i] = serialized[i].split(this.csv.cell);
    }*/
    var endRow = startRow+serialized.length;
    var endCol = startCol+serialized[0].length;
    if (endCol > this._cCount)
		endCol = this._cCount;
    var k = 0;
    for (var i=startRow; i<endRow; i++) {
        var row = this.render_row(i);
        if (row==-1) continue;
        var l = 0;
        for (var j=startCol; j<endCol; j++) {
        	if (this._hrrar[j]){
        		endCol = Math.max(endCol+1, this._cCount);
        		continue;
        	}
        	var ed = this.cells3(row, j);
        	if (ed.isDisabled()) {
        	    l++;
        	    continue;
        	}
        	if (this._onEditUndoRedo)
        		this._onEditUndoRedo(2, row.idd, j, serialized[ k ][ l ], ed.getValue());
        	if (ed.combo){
				var comboVa = ed.combo.values;
				for(var n=0; n<comboVa.length; n++)
					if (serialized[ k ][ l ] == comboVa[n]){
						ed.setValue( ed.combo.keys[ n ]);
						comboVa=null;
						break;
					}
				if (comboVa!=null && ed.editable) ed.setValue( serialized[ k ][ l++ ] );
				else l++;
        	}else
        		ed[ ed.setImage ? "setLabel" : "setValue" ]( serialized[ k ][ l++ ] );
        	ed.cell.wasChanged=true;
        }
        this.callEvent("onRowPaste",[row.idd])
        k++;
    }
}

dhtmlXGridObject.prototype.getSelectedBlock = function() {
	// if block selection exists
	if (this._selectionArea)
		return this._selectionArea;
	else if (this.getSelectedRowId() !== null){
		// if one cell is selected
			return {
				LeftTopRow: this.getSelectedRowId(),
				LeftTopCol: this.getSelectedCellIndex(),
				RightBottomRow: this.getSelectedRowId(),
				RightBottomCol: this.getSelectedCellIndex()
			};
		} else
			return null;
};
//(c)dhtmlx ltd. www.dhtmlx.com

//v.3.6 build 131108

/*
Copyright DHTMLX LTD. http://www.dhtmlx.com
To use this component please contact sales@dhtmlx.com to obtain license
*/
/**
*   @desc: enable smart paging mode
*   @type: public
*   @param: fl - true|false - enable|disable mode
*   @param: pageSize - count of rows per page
*   @param: pagesInGrp - count of visible page selectors
*   @param: parentObj - ID or container which will be used for showing paging controls
*   @param: showRecInfo - true|false - enable|disable showing of additional info about paging state
*   @param: recInfoParentObj - ID or container which will be used for showing paging state
*   @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.enablePaging = function(fl,pageSize,pagesInGrp,parentObj,showRecInfo,recInfoParentObj){
 		this._pgn_parentObj = typeof(parentObj)=="string" ? document.getElementById(parentObj) : parentObj;
		this._pgn_recInfoParentObj = typeof(recInfoParentObj)=="string" ? document.getElementById(recInfoParentObj) : recInfoParentObj;
		
		this.pagingOn = fl;
		this.showRecInfo = showRecInfo;
		this.rowsBufferOutSize = parseInt(pageSize);
		this.currentPage = 1;
		this.pagesInGroup = parseInt(pagesInGrp);
		this._init_pgn_events()
		this.setPagingSkin("default");
}
/**
*   @desc: allow to configure settings of dynamical paging
*   @type: public
*   @param: filePath - path which will be used for requesting data ( parth from load command used by default )
*   @param: buffer -  count of rows requrested from server by single operation, optional
*   @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.setXMLAutoLoading = function(filePath,bufferSize){
      this.xmlFileUrl = filePath;
      this._dpref = bufferSize;
}
/**
*   @desc: change current page in grid
*   @type: public
*   @param: ind - correction ( -1,1,2  etc) to current active page
*   @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.changePageRelative = function(ind){ 
	this.changePage(this.currentPage+ind);
}
/**
*   @desc: change current page in grid
*   @type: public
*   @param: pageNum -  new active page
*   @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.changePage = function(pageNum){ 
	if (arguments.length==0) pageNum=this.currentPage||0;
	pageNum=parseInt(pageNum);
	pageNum=Math.max(1,Math.min(pageNum,Math.ceil(this.rowsBuffer.length/this.rowsBufferOutSize)));
	
	if(!this.callEvent("onBeforePageChanged",[this.currentPage,pageNum]))
		return;
		
	this.currentPage = parseInt(pageNum);
	this._reset_view();
	this._fixAlterCss();			
	this.callEvent("onPageChanged",this.getStateOfView());
}
/**
	*   @desc: allows to set custom paging skin
	*	@param: name - skin name (default,toolbar,bricks)
	*   @type:  public
*/
dhtmlXGridObject.prototype.setPagingSkin = function(name){
	this._pgn_skin=this["_pgn_"+name];
	if (name=="toolbar") this._pgn_skin_tlb=arguments[1];
}
/**
	*   @desc: allows to set paging templates for default skin
	*	@param: a - template for zone A
	*	@param: b - template for zone B
	*   @type:  public
*/
dhtmlXGridObject.prototype.setPagingTemplates = function(a,b){
	this._pgn_templateA=this._pgn_template_compile(a);
	this._pgn_templateB=this._pgn_template_compile(b);
	this._page_skin_update();
}
dhtmlXGridObject.prototype._page_skin_update = function(name){
	if (!this.pagesInGroup) this.pagesInGroup=Math.ceil(Math.min(5,this.rowsBuffer.length/this.rowsBufferOutSize));
	var totalPages=Math.ceil(this.rowsBuffer.length/this.rowsBufferOutSize);
	if (totalPages && totalPages<this.currentPage)
		return this.changePage(totalPages);
	if (this.pagingOn && this._pgn_skin) this._pgn_skin.apply(this,this.getStateOfView());
}
dhtmlXGridObject.prototype._init_pgn_events = function(name){
	this.attachEvent("onXLE",this._page_skin_update)
	this.attachEvent("onClearAll",this._page_skin_update)
	this.attachEvent("onPageChanged",this._page_skin_update)
	this.attachEvent("onGridReconstructed",this._page_skin_update)
	
	this._init_pgn_events=function(){};
}

// default paging
dhtmlXGridObject.prototype._pgn_default=function(page,start,end){
	if (!this.pagingBlock){
		this.pagingBlock = document.createElement("DIV");
		this.pagingBlock.className = "pagingBlock";
		this.recordInfoBlock = document.createElement("SPAN");
		this.recordInfoBlock.className = "recordsInfoBlock";
		if (!this._pgn_parentObj) return;
			this._pgn_parentObj.appendChild(this.pagingBlock)
		if(this._pgn_recInfoParentObj && this.showRecInfo)
			this._pgn_recInfoParentObj.appendChild(this.recordInfoBlock)
		
		//this._pgn_template="{prev:} {current:-1},{current},{current:+1} {next:>}"
		if (!this._pgn_templateA){
			this._pgn_templateA=this._pgn_template_compile("[prevpages:&lt;:&nbsp;] [currentpages:,&nbsp;] [nextpages:&gt;:&nbsp;]");
			this._pgn_templateB=this._pgn_template_compile("Results <b>[from]-[to]</b> of <b>[total]</b>");
		}
	}
	
	var details=this.getStateOfView();
	this.pagingBlock.innerHTML = this._pgn_templateA.apply(this,details);
	this.recordInfoBlock.innerHTML = this._pgn_templateB.apply(this,details);
	this._pgn_template_active(this.pagingBlock);
	this._pgn_template_active(this.recordInfoBlock);
	
	this.callEvent("onPaging",[]);
}

dhtmlXGridObject.prototype._pgn_block=function(sep){ 
	var start=Math.floor((this.currentPage-1)/this.pagesInGroup)*this.pagesInGroup;
	var max=Math.min(Math.ceil(this.rowsBuffer.length/this.rowsBufferOutSize),start+this.pagesInGroup);
	var str=[];
	for (var i=start+1; i<=max; i++)
		if (i==this.currentPage)
			str.push("<a class='dhx_not_active'><b>"+i+"</b></a>");
		else
			str.push("<a onclick='this.grid.changePage("+i+"); return false;'>"+i+"</a>");
	return str.join(sep);
}
dhtmlXGridObject.prototype._pgn_link=function(mode,ac,ds){
	if (mode=="prevpages" || mode=="prev"){
		if (this.currentPage==1) return ds;
		return '<a onclick=\'this.grid.changePageRelative(-1*'+(mode=="prev"?'1':'this.grid.pagesInGroup')+'); return false;\'>'+ac+'</a>'
	}
	
	if (mode=="nextpages" || mode=="next"){
		if (this.rowsBuffer.length/this.rowsBufferOutSize <= this.currentPage ) return ds;
		if (this.rowsBuffer.length/(this.rowsBufferOutSize*(mode=="next"?'1':this.pagesInGroup)) <= 1 ) return ds;
		return '<a onclick=\'this.grid.changePageRelative('+(mode=="next"?'1':'this.grid.pagesInGroup')+'); return false;\'>'+ac+'</a>'
	}
	
	if (mode=="current"){
		var i=this.currentPage+(ac?parseInt(ac):0);
		if (i<1 || Math.ceil(this.rowsBuffer.length/this.rowsBufferOutSize) < i ) return ds;
		return '<a '+(i==this.currentPage?"class='dhx_active_page_link' ":"")+'onclick=\'this.grid.changePage('+i+'); return false;\'>'+i+'</a>'
	}
	return ac;
}

dhtmlXGridObject.prototype._pgn_template_active=function(block){
	var tags=block.getElementsByTagName("A");
	if (tags)
		for (var i=0; i < tags.length; i++) {
			tags[i].grid=this;
		};
}
dhtmlXGridObject.prototype._pgn_template_compile=function(template){
	/*
		[prev],[next]
		[currentpages]
		[from],[to],[total]
	*/
	template=template.replace(/\[([^\]]*)\]/g,function(a,b){
		b=b.split(":");
		switch (b[0]){
			case "from": 
				return '"+(arguments[1]*1+(arguments[2]*1?1:0))+"';
			case "total":
				return '"+arguments[3]+"';
			case "to":
				return '"+arguments[2]+"';
			case "current":
			case "prev":
			case "next":
			case "prevpages":
			case "nextpages":
				return '"+this._pgn_link(\''+b[0]+'\',\''+b[1]+'\',\''+b[2]+'\')+"'
			case "currentpages":
				return '"+this._pgn_block(\''+b[1]+'\')+"'
		}
		//do it here
	})
	return new Function('return "'+template+'";')
}

dhtmlXGridObject.prototype.i18n.paging={
	results:"Results",
	records:"Records from ",
	to:" to ",
	page:"Page ",
	perpage:"rows per page",
	first:"To first Page",
	previous:"Previous Page",
	found:"Found records",
	next:"Next Page",
	last:"To last Page",
	of:" of ",
	notfound:"No Records Found"
}
/**
*	@desc: configure paging with toolbar mode ( must be called BEFORE enablePaging)
*	@param: navButtons - enable/disable navigation buttons
*	@param: navLabel - enable/disable navigation label
*	@param: pageSelect - enable/disable page selector
*	@param: perPageSelect - an array of "per page" select options ([5,10,15,20,25,30] by default)
*	@type: public
*   @edition: Professional
*/
dhtmlXGridObject.prototype.setPagingWTMode = function(navButtons,navLabel,pageSelect,perPageSelect){
	this._WTDef=[navButtons,navLabel,pageSelect,perPageSelect];
}
/**
*	@desc: Bricks skin for paging
*/
dhtmlXGridObject.prototype._pgn_bricks = function(page, start, end){
		//set class names depending on grid skin
		var tmp = (this.skin_name||"").split("_")[1];
		var sfx="";
		if(tmp=="light" || tmp=="modern" || tmp=="skyblue")
			sfx = "_"+tmp;
		
		this.pagerElAr = new Array();
		this.pagerElAr["pagerCont"] = document.createElement("DIV");
		this.pagerElAr["pagerBord"] = document.createElement("DIV");
		this.pagerElAr["pagerLine"] = document.createElement("DIV");
		this.pagerElAr["pagerBox"] = document.createElement("DIV");
		this.pagerElAr["pagerInfo"] = document.createElement("DIV");
		this.pagerElAr["pagerInfoBox"] = document.createElement("DIV");
		var se = (this.globalBox||this.objBox);
		this.pagerElAr["pagerCont"].style.width = se.clientWidth+"px";
		this.pagerElAr["pagerCont"].style.overflow = "hidden";
		this.pagerElAr["pagerCont"].style.clear = "both";
		this.pagerElAr["pagerBord"].className = "dhx_pbox"+sfx;
		this.pagerElAr["pagerLine"].className = "dhx_pline"+sfx;
		this.pagerElAr["pagerBox"].style.clear = "both";
		this.pagerElAr["pagerInfo"].className = "dhx_pager_info"+sfx;
		
		//create structure
		this.pagerElAr["pagerCont"].appendChild(this.pagerElAr["pagerBord"]);
		this.pagerElAr["pagerCont"].appendChild(this.pagerElAr["pagerLine"]);
		this.pagerElAr["pagerCont"].appendChild(this.pagerElAr["pagerInfo"]);
		this.pagerElAr["pagerLine"].appendChild(this.pagerElAr["pagerBox"]);
		this.pagerElAr["pagerInfo"].appendChild(this.pagerElAr["pagerInfoBox"]);
		this._pgn_parentObj.innerHTML = "";
		this._pgn_parentObj.appendChild(this.pagerElAr["pagerCont"]);
			
				
			
		
		if(this.rowsBuffer.length>0){
			var lineWidth = 20;
			var lineWidthInc = 22;
			
			//create left arrow if needed
			if(page>this.pagesInGroup){
				var pageCont = document.createElement("DIV");
				var pageBox = document.createElement("DIV");
				pageCont.className = "dhx_page"+sfx;
				pageBox.innerHTML = "&larr;";
				pageCont.appendChild(pageBox);
				this.pagerElAr["pagerBox"].appendChild(pageCont);
				var self = this;
				pageCont.pgnum = (Math.ceil(page/this.pagesInGroup)-1)*this.pagesInGroup;
				pageCont.onclick = function(){
					self.changePage(this.pgnum);
				}
				lineWidth +=lineWidthInc;
			}
			//create pages
			for(var i=1;i<=this.pagesInGroup;i++){
				var pageCont = document.createElement("DIV");
				var pageBox = document.createElement("DIV");
				pageCont.className = "dhx_page"+sfx;
				pageNumber = ((Math.ceil(page/this.pagesInGroup)-1)*this.pagesInGroup)+i;
				if(pageNumber>Math.ceil(this.rowsBuffer.length/this.rowsBufferOutSize))
					break;
				pageBox.innerHTML = pageNumber;
				pageCont.appendChild(pageBox);
				if(page==pageNumber){
					pageCont.className += " dhx_page_active"+sfx;
					pageBox.className = "dhx_page_active"+sfx;
				}else{
					var self = this;
					pageCont.pgnum = pageNumber;
					pageCont.onclick = function(){
						self.changePage(this.pgnum);
					}
				}
				lineWidth +=(parseInt(lineWidthInc/3)*pageNumber.toString().length)+15;
				pageBox.style.width = (parseInt(lineWidthInc/3)*pageNumber.toString().length)+8+"px";
				this.pagerElAr["pagerBox"].appendChild(pageCont);
			}
			//create right arrow if needed
			if(Math.ceil(page/this.pagesInGroup)*this.pagesInGroup<Math.ceil(this.rowsBuffer.length/this.rowsBufferOutSize)){
				var pageCont = document.createElement("DIV");
				var pageBox = document.createElement("DIV");
				pageCont.className = "dhx_page"+sfx;
				pageBox.innerHTML = "&rarr;";
				pageCont.appendChild(pageBox);
				this.pagerElAr["pagerBox"].appendChild(pageCont);
				var self = this;
				pageCont.pgnum = (Math.ceil(page/this.pagesInGroup)*this.pagesInGroup)+1;
				pageCont.onclick = function(){
					self.changePage(this.pgnum);
				}
				lineWidth +=lineWidthInc;
			}
			
			this.pagerElAr["pagerLine"].style.width = lineWidth+"px";
		}
		
		//create page info
		if(this.rowsBuffer.length>0 && this.showRecInfo)
			this.pagerElAr["pagerInfoBox"].innerHTML = this.i18n.paging.records+(start+1)+this.i18n.paging.to+end+this.i18n.paging.of+this.rowsBuffer.length;
		else if(this.rowsBuffer.length==0){
			this.pagerElAr["pagerLine"].parentNode.removeChild(this.pagerElAr["pagerLine"]);
			this.pagerElAr["pagerInfoBox"].innerHTML = this.i18n.paging.notfound;
		}
		//add whitespaces where necessary
		this.pagerElAr["pagerBox"].appendChild(document.createElement("SPAN")).innerHTML = "&nbsp;";
		this.pagerElAr["pagerBord"].appendChild(document.createElement("SPAN")).innerHTML = "&nbsp;";
		this.pagerElAr["pagerCont"].appendChild(document.createElement("SPAN")).innerHTML = "&nbsp;";
		this.callEvent("onPaging",[]);			
	}


/**
*	@desc: web toolbar skin for paging
*/
dhtmlXGridObject.prototype._pgn_toolbar = function(page, start, end){
	if (!this.aToolBar) this.aToolBar=this._pgn_createToolBar();
		var totalPages=Math.ceil(this.rowsBuffer.length/this.rowsBufferOutSize);
		
	
		if (this._WTDef[0]){
			this.aToolBar.enableItem("right");
			this.aToolBar.enableItem("rightabs");
			this.aToolBar.enableItem("left");
			this.aToolBar.enableItem("leftabs");
			if(this.currentPage>=totalPages){
				this.aToolBar.disableItem("right");
				this.aToolBar.disableItem("rightabs");
			}
			if(this.currentPage==1){
				this.aToolBar.disableItem("left");
				this.aToolBar.disableItem("leftabs");
			}
		}
		if (this._WTDef[2]){
			var that=this;
			this.aToolBar.forEachListOption("pages", function(id){
			    that.aToolBar.removeListOption("pages",id);
			});
			for(var i=0;i<totalPages;i++){
				this.aToolBar.addListOption('pages', 'pages_'+(i+1), NaN, "button", this.i18n.paging.page+(i+1));
			}
			this.aToolBar.setItemText("pages","<div style='width:100%; text-align:right'>"+this.i18n.paging.page+page+"</div>");
		}
//		pButton.setSelected(page.toString())
	
	
	if (this._WTDef[1]){
		if (!this.getRowsNum())
			this.aToolBar.setItemText('results',this.i18n.paging.notfound);
		else
			this.aToolBar.setItemText('results',"<div style='width:100%; text-align:center'>"+this.i18n.paging.records+(start+1)+this.i18n.paging.to+end+"</div>");
	}
    if (this._WTDef[3])
    	this.aToolBar.setItemText("perpagenum","<div style='width:100%; text-align:right'>"+this.rowsBufferOutSize.toString()+" "+this.i18n.paging.perpage+"</div>");
		
	this.callEvent("onPaging",[]);		
}
dhtmlXGridObject.prototype._pgn_createToolBar = function(){
	this.aToolBar = new dhtmlXToolbarObject(this._pgn_parentObj,(this._pgn_skin_tlb||"dhx_blue"));
	if (!this._WTDef) this.setPagingWTMode(true,true,true,true);
	var self=this;
	this.aToolBar.attachEvent("onClick",function(val){ 
		val=val.split("_")
		switch (val[0]){
			case "leftabs":
				self.changePage(1);
				break;
			case "left":
				self.changePage(self.currentPage-1);
				break;
			case "rightabs":
			    self.changePage(99999);
				break;
			case "right":
				self.changePage(self.currentPage+1);
				break;
			case "perpagenum":
				if (val[1]===this.undefined) return;
			    self.rowsBufferOutSize = parseInt(val[1]);
				self.changePage();
				self.aToolBar.setItemText("perpagenum","<div style='width:100%; text-align:right'>"+val[1]+" "+self.i18n.paging.perpage+"</div>");
				break;
			case "pages":
				if (val[1]===this.undefined) return;
				self.changePage(val[1]);
				self.aToolBar.setItemText("pages","<div style='width:100%; text-align:right'>"+self.i18n.paging.page+val[1]+"</div>");
				break;
			}
	})
	//add buttons
	if (this._WTDef[0]){
		this.aToolBar.addButton("leftabs", NaN,  "", this.imgURL+'ar_left_abs.gif', this.imgURL+'ar_left_abs_dis.gif');
		this.aToolBar.setWidth("leftabs","20")
		this.aToolBar.addButton("left", NaN,  "", this.imgURL+'ar_left.gif', this.imgURL+'ar_left_dis.gif');
		this.aToolBar.setWidth("left","20")
	}
	if (this._WTDef[1]){
		this.aToolBar.addText("results",NaN,this.i18n.paging.results)
		this.aToolBar.setWidth("results","150");
		this.aToolBar.disableItem("results");
	}
	if (this._WTDef[0]){
		this.aToolBar.addButton("right", NaN,  "", this.imgURL+'ar_right.gif', this.imgURL+'ar_right_dis.gif');
		this.aToolBar.setWidth("right","20")
		this.aToolBar.addButton("rightabs", NaN,  "", this.imgURL+'ar_right_abs.gif', this.imgURL+'ar_right_abs_dis.gif');
		this.aToolBar.setWidth("rightabs","20")
	}
	if (this._WTDef[2]){
		this.aToolBar.addButtonSelect("pages", NaN, "select page", [], null, null, true, true);
		this.aToolBar.setWidth("pages","75")
	}
	var arr;
	if (arr = this._WTDef[3]){
		this.aToolBar.addButtonSelect("perpagenum", NaN, "select size", [], null, null, true, true);
		if(typeof arr != "object")  arr = [5,10,15,20,25,30];
		for (var k=0; k<arr.length; k++)
			this.aToolBar.addListOption('perpagenum', 'perpagenum_'+arr[k], NaN, "button", arr[k]+" "+this.i18n.paging.perpage);
		this.aToolBar.setWidth("perpagenum","135");
	}
	
	//var td = document.createElement("TD"); td.width = "5"; this.aToolBar.tr.appendChild(td);
	//var td = document.createElement("TD"); td.width = "100%"; this.aToolBar.tr.appendChild(td);
		
	return this.aToolBar;
}
//v.3.6 build 131108

/*
Copyright DHTMLX LTD. http://www.dhtmlx.com
To use this component please contact sales@dhtmlx.com to obtain license
*/
/**
*   @desc: hide pivot table related to grid, if any exists, switch grid back to normal mode
*   @type: public
*   @topic: 0
*/ 

dhtmlXGridObject.prototype.hidePivot=function(cont){ 
	if (this._pgridCont){
		if (this._pgrid) this._pgrid.destructor();
		var c=this._pgridCont.parentNode;
		c.innerHTML="";
		if (c.parentNode==this.entBox) 
			this.entBox.removeChild(c);
		this._pgrid=this._pgridSelect=this._pUNI=this._pgridCont=null;
		
	}
}
/**
*   @desc: show pivot table based on grid
*   @type: public
*	@param: cont - html container in which pivot rendered, but default pivot will be rendered over existing grid
*	details: collection of settings; details.column_list - list of columns used in pivot selects; details.readonly - created pivot with fixed configuration, details.action, details.value, action.x, action.y - default values for 4 pivot's selects 
*   @topic: 0
*/ 
dhtmlXGridObject.prototype.makePivot=function(cont,details){
	details=details||{};
	this.hidePivot();
	
	if (!cont){
			var cont=document.createElement("DIV");
			cont.style.cssText="position:absolute; top:0px; left:0px;background-color:white;";
			cont.style.height=this.entBox.offsetHeight+"px";
			cont.style.width=this.entBox.offsetWidth+"px";
			if (this.entBox.style.position!="absolute")
				this.entBox.style.position="relative";
			this.entBox.appendChild(cont);
	}
	
	if (typeof(cont)!="object") cont=document.getElementById(cont)
   
    if (details.column_list)
    	this._column_list=details.column_list;
    else{
		this._column_list=[];
		for (var i=0; i<this.hdr.rows[1].cells.length; i++)
   			this._column_list.push(this.hdr.rows[1].cells[i][_isIE?"innerText":"textContent"])
   	}
   		
   	var that = this;
	cont.innerHTML="<table cellspacing='0' cellpadding='0'><tr><td style='width:160px' align='center'></td><td>&nbsp;&nbsp;&nbsp;</td><td></td></tr></table><div></div>";
	var z1=this.makePivotSelect(this._column_list);
		z1.style.width="80px";
		z1.onchange=function(){
			if (this.value!=-1)
				that._pivotS.value=this.value;
			else that._pivotS.value="";
			
			that._reFillPivotLists();
			that._renderPivot2();
		}		
	var z2=this.makePivotSelect(this._column_list);
		z2.onchange=function(){
			if (this.value!=-1)
				that._pivotS.x=this.value;
			else that._pivotS.x="";
			that._reFillPivotLists();
			that._renderPivot()
		}		
	var z3=this.makePivotSelect(this._column_list);
		z3.onchange=function(){
			if (this.value!=-1)
				that._pivotS.y=this.value;
			else that._pivotS.y="";
			that._reFillPivotLists();
			that._renderPivot()
		}
	var z4=this.makePivotSelect(["Sum","Min","Max","Average","Count"],-1);
		z4.style.width="70px";
		z4.onchange=function(){
			if (this.value!=-1)
				that._pivotS.action=this.value;
			else that._pivotS.action=null;
			
			that._renderPivot2();
		}
		
	if (details.readonly)
		z1.disabled=z2.disabled=z3.disabled=z4.disabled=true;
	
	cont.firstChild.rows[0].cells[0].appendChild(z4);
	cont.firstChild.rows[0].cells[0].appendChild(z1);
	cont.firstChild.rows[0].cells[2].appendChild(z2);
	
	var gr=cont.childNodes[1];
	gr.style.width=cont.offsetWidth+"px";
	gr.style.height=cont.offsetHeight-20+"px";
	gr.style.overflow="hidden";
	this._pgridCont=gr;
	this._pgridSelect=[z1,z2,z3,z4];
	
	this._pData=this._fetchPivotData();
	this._pUNI=[];
	this._pivotS={ action:(details.action||"0"), value:(typeof details.value != "undefined" ? (details.value||"0") : null), x:(typeof details.x != "undefined" ? (details.x||"0") : null), y:(typeof details.y != "undefined" ? (details.y||"0") : null) };
	
	z1.value=this._pivotS.value;
	z2.value=this._pivotS.x;
	z3.value=this._pivotS.y;
	z4.value=this._pivotS.action;
	
	that._reFillPivotLists();
	this._renderPivot();
}

dhtmlXGridObject.prototype._fetchPivotData=function(){ 
	var z=[];
	for (var i=0; i<this._cCount; i++) {
		var d=[];
		for (var j=0; j<this.rowsCol.length; j++) {
			if (this.rowsCol[j]._cntr) continue;
			d.push(this.cells2(j,i).getValue());	//TODO : excell caching 
		}
		z.push(d)
	}
	return z;
}

dhtmlXGridObject.prototype._renderPivot=function(){ 
	if (_isIE) this._pgridSelect[2].removeNode(true)
	if (this._pgrid)  
		this._pgrid.destructor();
	
	this._pgrid=new dhtmlXGridObject(this._pgridCont);
	this._pgrid.setImagePath(this.imgURL);
	this._pgrid.attachEvent("onBeforeSelect",function(){return false;});
	if (this._pivotS.x){
		var l=this._getUniList(this._pivotS.x);
		var s=[160];
		for (var i=0; i < l.length; i++) 
			s.push(100);
		l=[""].concat(l)
		this._pgrid.setHeader(l);
		this._pgrid.setInitWidths(s.join(","));
	} else {
		this._pgrid.setHeader("");
		this._pgrid.setInitWidths("160");
	}
		
	this._pgrid.init();
	this._pgrid.setEditable(false);
	this._pgrid.setSkin(this.entBox.className.replace("gridbox gridbox_",""));

	var t=this._pgrid.hdr.rows[1].cells[0];
	if (t.firstChild && t.firstChild.tagName=="DIV") t=t.firstChild;
	t.appendChild(this._pgridSelect[2]);
	this._pgrid.setSizes();
	
	if (this._pivotS.y){
		var l=this._getUniList(this._pivotS.y);
		for (var i=0; i < l.length; i++) {
			this._pgrid.addRow(this._pgrid.uid(),[l[i]],-1);
		};
	} else {
		this._pgrid.addRow(1,"not ready",1);
	}	
	this._renderPivot2();
}
dhtmlXGridObject.prototype._pivot_action_0=function(a,b,c,av,bv,data){ 
	var ret=0;
	var resA=data[a];
	var resB=data[b];
	var resC=data[c];
	for (var i = resA.length - 1; i >= 0; i--)
		if (resA[i]==av && resB[i]==bv) 
			ret+=this.parseFloat(resC[i]);
	return ret;
}
dhtmlXGridObject.prototype._pivot_action_1=function(a,b,c,av,bv,data){ 
	ret=9999999999;
	var resA=data[a];
	var resB=data[b];
	var resC=data[c];
	
	for (var i = resA.length - 1; i >= 0; i--)
		if (resA[i]==av && resB[i]==bv) 
			ret=Math.min(this.parseFloat(resC[i]),ret);
	if (ret==9999999999) ret="";
	return ret;
}
dhtmlXGridObject.prototype._pivot_action_2=function(a,b,c,av,bv,data){ 
	
	ret=-9999999999;
	var resA=data[a];
	var resB=data[b];
	var resC=data[c];
	for (var i = resA.length - 1; i >= 0; i--)
		if (resA[i]==av && resB[i]==bv) 
			ret=Math.max(this.parseFloat(resC[i]),ret);
	if (ret==-9999999999) ret="";
	return ret;
}
dhtmlXGridObject.prototype._pivot_action_3=function(a,b,c,av,bv,data){ 
	var ret=0;
	var count=0;
	var resA=data[a];
	var resB=data[b];
	var resC=data[c];
	for (var i = resA.length - 1; i >= 0; i--)
		if (resA[i]==av && resB[i]==bv) {
			ret+=this.parseFloat(resC[i]);
			count++;
		}
	return count?ret/count:"";
}
dhtmlXGridObject.prototype._pivot_action_4=function(a,b,c,av,bv,data){ 
	var ret=0;
	var count=0;
	var resA=data[a];
	var resB=data[b];
	var resC=data[c];
	for (var i = resA.length - 1; i >= 0; i--)
		if (resA[i]==av && resB[i]==bv) {
			ret++;
		}
	return ret;
}
dhtmlXGridObject.prototype.parseFloat = function(val){
	val = parseFloat(val);
	if (isNaN(val)) return 0;
	return val;
}
	
dhtmlXGridObject.prototype._renderPivot2=function(){ 
	if (!(this._pivotS.x && this._pivotS.y && this._pivotS.value && this._pivotS.action)) return;

	var action=this["_pivot_action_"+this._pivotS.action];
	var x=this._getUniList(this._pivotS.x);
	var y=this._getUniList(this._pivotS.y);
	
	for (var i=0; i < x.length; i++) {
		for (var j=0; j < y.length; j++) {
			this._pgrid.cells2(j,i+1).setValue(Math.round(action(this._pivotS.x,this._pivotS.y,this._pivotS.value,x[i],y[j],this._pData)*100)/100);
		};
		
	};
}


dhtmlXGridObject.prototype._getUniList=function(col){ 
    if (!this._pUNI[col]){
    	var t={};
    	var a=[];
    	for (var i = this._pData[col].length - 1; i >= 0; i--){
    		t[this._pData[col][i]]=true;
    	}
    	for (var n in t) 
      		if (t[n]===true) a.push(n);
      	this._pUNI[col]=a.sort();
   	}
   	
   	return this._pUNI[col];
}

dhtmlXGridObject.prototype._fillPivotList=function(z,list,miss,v){ 
	if (!miss){
		miss={};
		v=-1;
	}
	z.innerHTML="";
	z.options[z.options.length]=new Option("-select-",-1);
	for (var i=0; i<list.length; i++){
		if (miss[i] || list[i]===null) continue;
		z.options[z.options.length]=new Option(list[i],i);
	}	
	z.value=parseInt(v);
}

dhtmlXGridObject.prototype._reFillPivotLists=function(){ 
	var s=[]; 	var v=[];
	for (var i=0; i<3; i++){
		s.push(this._pgridSelect[i]);
		v.push(s[i].value);
	}
	
	
	var t=this._reFfillPivotLists;
	var m={}; m[v[1]]=m[v[2]]=true;
	this._fillPivotList(s[0],this._column_list,m,v[0]);
	m={}; m[v[0]]=m[v[2]]=true;
	this._fillPivotList(s[1],this._column_list,m,v[1]);
	m={}; m[v[1]]=m[v[0]]=true;
	this._fillPivotList(s[2],this._column_list,m,v[2]);
	
	this._reFfillPivotLists=t;
	
}


dhtmlXGridObject.prototype.makePivotSelect=function(list,miss){ 
	var z=document.createElement("SELECT");
	this._fillPivotList(z,list,miss);
	z.style.cssText="width:150px; height:20px; font-family:Tahoma; font-size:8pt; font-weight:normal;";
	
	
	return z;
}
//(c)dhtmlx ltd. www.dhtmlx.com

//v.3.6 build 131108

/*
Copyright DHTMLX LTD. http://www.dhtmlx.com
To use this component please contact sales@dhtmlx.com to obtain license
*/
/**
*   @desc: set rowspan with specified length starting from specified cell
*   @param: rowID - row Id
*	@param: colInd - column index
*	@param: length - length of rowspan
*	@edition: professional
*   @type:  public
*/
dhtmlXGridObject.prototype.setRowspan=function(rowID,colInd,length){
    var c=this[this._bfs_cells?"_bfs_cells":"cells"](rowID,colInd).cell;    
   var r=this.rowsAr[rowID];

   if (c.rowSpan && c.rowSpan!=1){
		var ur=r.nextSibling;   
		for (var i=1; i<c.rowSpan; i++){
			var tc=ur.childNodes[ur._childIndexes[c._cellIndex+1]]
			var ti=document.createElement("TD"); 
			ti.innerHTML="&nbsp;"; 
			ti._cellIndex=c._cellIndex;
			ti._clearCell=true;
			if (tc)
				tc.parentNode.insertBefore(ti,tc);
			else
				ur.parentNode.appendChild(ti);
			this._shiftIndexes(ur,c._cellIndex,-1);
	    	ur=ur.nextSibling;
	    }
    }

    c.rowSpan=length;
    if (!this._h2)
		r=r.nextSibling||this.rowsCol[this.rowsCol._dhx_find(r)+1];
	else
		r=this.rowsAr[ this._h2.get[r.idd].parent.childs[this._h2.get[r.idd].index+1].id ];
		
	var kids=[];
	for (var i=1; i<length; i++){
	    var ct=null;
		if (this._fake && !this._realfake)
		    ct=this._bfs_cells3(r,colInd).cell;
		else
		    ct=this.cells3(r,colInd).cell;
		
		

		this._shiftIndexes(r,c._cellIndex,1);
		if (ct)
    	ct.parentNode.removeChild(ct);
    	kids.push(r);
    	
    	if (!this._h2)
			r=r.nextSibling||this.rowsCol[this.rowsCol._dhx_find(r)+1];
		else { 
			var r=this._h2.get[r.idd].parent.childs[this._h2.get[r.idd].index+1];
			if (r) r=this.rowsAr[ r.id ];
		}
    }
    
    this.rowsAr[rowID]._rowSpan=this.rowsAr[rowID]._rowSpan||{};
    this.rowsAr[rowID]._rowSpan[colInd]=kids;
    if (this._fake && !this._realfake && colInd<this._fake._cCount) 
        this._fake.setRowspan(rowID,colInd,length)
}


dhtmlXGridObject.prototype._shiftIndexes=function(r,pos,ind){
		if (!r._childIndexes){
    	r._childIndexes=new Array();
        for (var z=0; z<r.childNodes.length; z++)
            r._childIndexes[z]=z;
		}
		
		for (var z=0; z<r._childIndexes.length; z++)
			if (z>pos)
            	r._childIndexes[z]=r._childIndexes[z]-ind;
				
}

/**
*   @desc: enable rowspan in grid
*   @type:  public
*	@edition: professional
*/
dhtmlXGridObject.prototype.enableRowspan=function(){
    this._erspan=true;
	this.enableRowspan=function(){};
	this.attachEvent("onAfterSorting",function(){
		if (this._dload) return; //can't be helped
		for (var i=1; i<this.obj.rows.length; i++)	
		  if (this.obj.rows[i]._rowSpan){
		  	var master=this.obj.rows[i];
		  	for (var kname in master._rowSpan){
			  	var row=master;
				var kids=row._rowSpan[kname];
			  	for (var j=0; j < kids.length; j++) {
			  		if(row.nextSibling)
			  			row.parentNode.insertBefore(kids[j],row.nextSibling);
			  		else 
			  			row.parentNode.appendChild(kids[j]);
			  		if (this._fake){ // split mode
			  		    var frow=this._fake.rowsAr[row.idd];
			  		    var fkid=this._fake.rowsAr[kids[j].idd];
			  		    if(frow.nextSibling)
			  		  	    frow.parentNode.insertBefore(fkid,frow.nextSibling);
			  		    else 
			  			  frow.parentNode.appendChild(fkid);
			  			 this._correctRowHeight(row.idd);
			  		}
			 		row=row.nextSibling;
			  	}
		    }
	  }
	  var t = this.rowsCol.stablesort;
	  this.rowsCol=new dhtmlxArray();
	  this.rowsCol.stablesort=t;
	  
	  for (var i=1; i<this.obj.rows.length; i++)	
	  	this.rowsCol.push(this.obj.rows[i]);
	  
	}) 
	
	this.attachEvent("onXLE",function(a,b,c,xml){
		for (var i=0; i<this.rowsBuffer.length; i++){
			var row = this.render_row(i);
			var childs = row.childNodes;
			for (var j=0; j<childs.length; j++){
				if (childs[j]._attrs["rowspan"]){
					this.setRowspan(row.idd,j,childs[j]._attrs["rowspan"]);
				}
			}
		}
	});
}

//v.3.6 build 131108

/*
Copyright DHTMLX LTD. http://www.dhtmlx.com
To use this component please contact sales@dhtmlx.com to obtain license
*/
/*
    Limitation:
        a) Width of column in px
        b) Grid not autoresizable
        c) Initialize grid in visible state
*/

dhtmlXGridObject.prototype._init_point_bspl=dhtmlXGridObject.prototype._init_point;
dhtmlXGridObject.prototype._init_point = function(){
    if (this._split_later)
        this.splitAt(this._split_later);
   this._init_point=this._init_point_bspl;
   if (this._init_point) this._init_point();
}


/**
*   @desc:  split grid in two parts, with separate scrolling
*   @param:  ind - index of column to split after
*   @edition: Professional
*   @type:  public$
*/
dhtmlXGridObject.prototype.splitAt=function(ind){
    if (!this.obj.rows[0]) return this._split_later=ind;
    ind=parseInt(ind);
    
    var leftBox=document.createElement("DIV");
    this.entBox.appendChild(leftBox);
    var rightBox=document.createElement("DIV");
    this.entBox.appendChild(rightBox);
    
    for (var i=this.entBox.childNodes.length-3; i>=0; i--)
    	rightBox.insertBefore(this.entBox.childNodes[i],rightBox.firstChild);
    
    this.entBox.style.position="relative";	
    this.globalBox=this.entBox;
    this.entBox=rightBox; rightBox.grid=this;
    

    leftBox.style.cssText+="border:0px solid red !important;";
    rightBox.style.cssText+="border:0px solid red !important;";
    
	rightBox.style.top="0px";
    rightBox.style.position="absolute";
        
    leftBox.style.position="absolute";
    leftBox.style.top="0px";
    leftBox.style.left="0px";
    leftBox.style.zIndex=11;
        
    rightBox.style.height=leftBox.style.height=this.globalBox.clientHeight;
    
    
    this._fake=new dhtmlXGridObject(leftBox);
    this._fake.setSkin("not_existing_skin");
    
    this.globalBox=this._fake.globalBox=this.globalBox;
    this._fake._fake=this;
    this._fake._realfake=true;
    
	//copy properties    
    this._treeC=this.cellType._dhx_find("tree");
    this._fake.delim=this.delim;
    this._fake.customGroupFormat=this.customGroupFormat;
    
    this._fake.imgURL=this.imgURL;
    this._fake._customSorts=this._customSorts;
	this._fake.noHeader=this.noHeader;
	this._fake._enbTts=this._enbTts;
	this._fake._htkebl = this._htkebl;
	this._fake.clists = this.clists;
    this._fake.fldSort=new Array();
    this._fake.selMultiRows=this.selMultiRows;
    this._fake.multiLine=this.multiLine;
    
    if (this.multiLine || this._erspan){
    	this.attachEvent("onCellChanged",this._correctRowHeight);
    	this.attachEvent("onRowAdded",this._correctRowHeight);
    	var corrector=function(){
    		this.forEachRow(function(id){
    			this._correctRowHeight(id);
			})
		};
		this.attachEvent("onPageChanged",corrector);
    	this.attachEvent("onXLE",corrector);
    	this.attachEvent("onResizeEnd",corrector);
    	if (!this._ads_count) //in case of distribute parsing - use special event instead
    		this.attachEvent("onAfterSorting",corrector);
    	this.attachEvent("onDistributedEnd",corrector);
		
    	//this._fake.attachEvent("onCellChanged",this._correctRowHeight);
    	}
    this.attachEvent("onGridReconstructed",function(){
    	this._fake.objBox.scrollTop = this.objBox.scrollTop;
	})
    
	this._fake.loadedKidsHash=this.loadedKidsHash;
	if (this._h2) this._fake._h2=this._h2;
	this._fake._dInc=this._dInc;
	
	//collect grid configuraton
    var b_ha=[[],[],[],[],[],[],[]];
    var b_ar=["hdrLabels","initCellWidth","cellType","cellAlign","cellVAlign","fldSort","columnColor"];
    var b_fu=["setHeader","setInitWidths","setColTypes","setColAlign","setColVAlign","setColSorting","setColumnColor"];

    this._fake.callEvent=function(){
    	this._fake._split_event=true;
    	if (arguments[0]=="onGridReconstructed")
    		this._fake.callEvent.apply(this,arguments);
    		return this._fake.callEvent.apply(this._fake,arguments);
    	this._fake._split_event=false;	
    }
    	
    if (this._elmn)
		this._fake.enableLightMouseNavigation(true);

    if (this.__cssEven||this._cssUnEven)
        this._fake.attachEvent("onGridReconstructed",function(){
            this._fixAlterCss();
        });

	this._fake._cssEven=this._cssEven;
	this._fake._cssUnEven=this._cssUnEven;
	this._fake._cssSP=this._cssSP;
	this._fake.isEditable=this.isEditable;
	this._fake._edtc=this._edtc;
	if (this._sst) this._fake.enableStableSorting(true);

	this._fake._sclE=this._sclE;
	this._fake._dclE=this._dclE;
	this._fake._f2kE=this._f2kE;
	this._fake._maskArr=this._maskArr;
	this._fake._dtmask=this._dtmask;
	this._fake.combos=this.combos;

    var width=0;

	var m_w=this.globalBox.offsetWidth;
    for (var i=0; i<ind; i++){
        for (var j=0; j<b_ar.length; j++){
            if (this[b_ar[j]])
                b_ha[j][i]=this[b_ar[j]][i];
            if (typeof b_ha[j][i] == "string") b_ha[j][i]=b_ha[j][i].replace(new RegExp("\\"+this.delim,"g"),"\\"+this.delim);
        }
        if (_isFF) b_ha[1][i]=b_ha[1][i]*1;
		if ( this.cellWidthType == "%"){
			b_ha[1][i]=Math.round(parseInt(this[b_ar[1]][i])*m_w/100);
			width+=b_ha[1][i];
		} else
	        width+=parseInt(this[b_ar[1]][i]);
        this.setColumnHidden(i,true);
        }


    for (var j=0; j<b_ar.length; j++){
        var str=b_ha[j].join(this.delim);
       
	if (b_fu[j]!="setHeader"){
		if (str!="")
    		this._fake[b_fu[j]](str);
	} else
	    this._fake[b_fu[j]](str,null,this._hstyles);
    }


	this._fake._strangeParams=this._strangeParams;
    this._fake._drsclmn=this._drsclmn;

	width = Math.min(this.globalBox.offsetWidth, width);
    rightBox.style.left=width+"px";    leftBox.style.width=width+"px";
    rightBox.style.width=Math.max(this.globalBox.offsetWidth-width,0);

    if (this._ecspn) this._fake._ecspn=true;

//    this._fake.setNoHeader(true);
    this._fake.init();
    if (this.dragAndDropOff)
		this.dragger.addDragLanding(this._fake.entBox, this);
		
    this._fake.objBox.style.overflow="hidden";
    this._fake.objBox.style.overflowX="scroll";
    
   	this._fake._srdh=this._srdh||20;
   	this._fake._srnd=this._srnd;


   	var selfmaster = this;
	function _on_wheel(e){
		var dir  = e.wheelDelta/-40;
		if (e.wheelDelta === window.undefined)
			dir = e.detail;
		var cont = selfmaster.objBox;
		cont.scrollTop += dir*40;
		if (e.preventDefault)
			e.preventDefault();
	}
	dhtmlxEvent(this._fake.objBox,"mousewheel",_on_wheel);
	dhtmlxEvent(this._fake.objBox,"DOMMouseScroll",_on_wheel);


//inner methods

	
		function change_td(a,b){ 
			b.style.whiteSpace="";
			var c=b.nextSibling;
			var cp=b.parentNode;
			a.parentNode.insertBefore(b,a);
			if (!c)
				cp.appendChild(a);
			else
				cp.insertBefore(a,c);
			var z=a.style.display;
			a.style.display=b.style.display;
			b.style.display=z;
				}
		function proc_hf(i,rows,mode,frows){
			var temp_header=(new Array(ind)).join(this.delim);
			var temp_rspan=[];
			if (i==2)
				for (var k=0; k<ind; k++){
					var r=rows[i-1].cells[rows[i-1]._childIndexes?rows[i-1]._childIndexes[k]:k];
					if (r.rowSpan && r.rowSpan>1){
						temp_rspan[r._cellIndex]=r.rowSpan-1;
						frows[i-1].cells[frows[i-1]._childIndexes?frows[i-1]._childIndexes[k]:k].rowSpan=r.rowSpan;
						r.rowSpan=1;
					}
				}
				
				for (i; i<rows.length; i++){
					this._fake.attachHeader(temp_header,null,mode);
					frows=frows||this._fake.ftr.childNodes[0].rows;
					var max_ind=ind;
					var r_cor=0;
					for (var j=0; j<max_ind; j++){
						
						if (temp_rspan[j]) { 
							temp_rspan[j]=temp_rspan[j]-1;
							if (_isIE || (_isFF && _FFrv >= 1.9 ) || _isOpera) {
								var td=document.createElement("TD");
								if (_isFF) td.style.display="none";
								rows[i].insertBefore(td,rows[i].cells[0])
							}
							
							r_cor++;
							continue;
						}

						var a=frows[i].cells[j-r_cor];
						var b=rows[i].cells[j-(_isIE?0:r_cor)];
						var t=b.rowSpan;
						
						change_td(a,b);
						if (t>1){ 
							temp_rspan[j]=t-1;
							b.rowSpan=t;
						}
						if (frows[i].cells[j].colSpan>1){
							rows[i].cells[j].colSpan=frows[i].cells[j].colSpan;
							max_ind-=frows[i].cells[j].colSpan-1;
							for (var k=1; k < frows[i].cells[j].colSpan; k++) 
								frows[i].removeChild(frows[i].cells[j+1]);
				}
		}
	}
		}
		
		if (this.hdr.rows.length>2)
			proc_hf.call(this,2,this.hdr.rows,"_aHead",this._fake.hdr.rows);
		if (this.ftr){
			proc_hf.call(this,1,this.ftr.childNodes[0].rows,"_aFoot");
			this._fake.ftr.parentNode.style.bottom=(_isFF?2:1)+"px";
		}
		

        if (this.saveSizeToCookie){
		   this.saveSizeToCookie=function(name,cookie_param){
		   		if (this._realfake)
					return this._fake.saveSizeToCookie.apply(this._fake,arguments);

				if (!name) name=this.entBox.id;
				var z=new Array();
				var n="cellWidthPX";
		
				for (var i=0; i<this[n].length; i++)
					if (i<ind)
						z[i]=this._fake[n][i];
					else
						z[i]=this[n][i];
				z=z.join(",")
				this.setCookie(name,cookie_param,0,z);
				var z=(this.initCellWidth||(new  Array)).join(",");
				this.setCookie(name,cookie_param,1,z);

			    return true;
			}
		this.loadSizeFromCookie=function(name){
			if (!name) name=this.entBox.id;
			var z=this._getCookie(name,1);

			if (!z) return
			this.initCellWidth=z.split(",");
			var z=this._getCookie(name,0);
			var n="cellWidthPX";
			this.cellWidthType="px";
			
            var summ2=0;
			if ((z)&&(z.length)){
				z=z.split(",");
				for (var i=0; i<z.length; i++)
					if (i<ind){
					   this._fake[n][i]=z[i];
					   summ2+=z[i]*1;
					   }
					else
					   this[n][i]=z[i];
			}

    		this._fake.entBox.style.width=summ2+"px";
    		this._fake.objBox.style.width=summ2+"px";
   			var pa=this.globalBox.childNodes[1];
			    pa.style.left=summ2-(_isFF?0:0)+"px";
			if (this.ftr)
	    		this.ftr.style.left=summ2-(_isFF?0:0)+"px";
    			pa.style.width=this.globalBox.offsetWidth-summ2+"px";

			this.setSizes();
		    return true;
		}
		   	this._fake.onRSE=this.onRSE;
		}


			this.setCellTextStyleA=this.setCellTextStyle;
			this.setCellTextStyle=function(row_id,i,styleString){
				if  (i<ind) this._fake.setCellTextStyle(row_id,i,styleString);
				this.setCellTextStyleA(row_id,i,styleString);
			}
			this.setRowTextBoldA=this.setRowTextBold;
   			this.setRowTextBold = function(row_id){
				this.setRowTextBoldA(row_id);
				this._fake.setRowTextBold(row_id);
            }
            
            this.setRowColorA=this.setRowColor;
   			this.setRowColor = function(row_id,color){
				this.setRowColorA(row_id,color);
				this._fake.setRowColor(row_id,color);
            } 
                       
			this.setRowHiddenA=this.setRowHidden;
   			this.setRowHidden = function(id,state){
				this.setRowHiddenA(id,state);
				this._fake.setRowHidden(id,state);
            }

			this.setRowTextNormalA=this.setRowTextNormal;
   			this.setRowTextNormal = function(row_id){
				this.setRowTextNormalA(row_id);
				this._fake.setRowTextNormal(row_id);
            }


			this.getChangedRows = function(and_added){
				var res = new Array();
				function test(row){
						for (var j = 0; j < row.childNodes.length; j++) 
							if (row.childNodes[j].wasChanged)
								return res[res.length]=row.idd;
				}
				this.forEachRow(function(id){
					var row = this.rowsAr[id];
					var frow = this._fake.rowsAr[id];
					if (row.tagName!="TR" || frow.tagName!="TR") return; 
					if (and_added && row._added)
						res[res.length]=row.idd;
					else{
						if (!test(row)) test(frow);
					}
				});
				return res.join(this.delim);
			};
			this.setRowTextStyleA=this.setRowTextStyle;
   			this.setRowTextStyle = function(row_id,styleString){
				this.setRowTextStyleA(row_id,styleString);
				if (this._fake.rowsAr[row_id])
				this._fake.setRowTextStyle(row_id,styleString);
            }

			this.lockRowA = this.lockRow;
			this.lockRow = function(id,mode){ this.lockRowA(id,mode); this._fake.lockRow(id,mode); }
			
			this.getColWidth = function(i){
				if  (i<ind) return parseInt(this._fake.cellWidthPX[i]);
				else return parseInt(this.cellWidthPX[i]);
            };
            this.getColumnLabel = function(i){
            	return this._fake.getColumnLabel.apply(((i<ind)?this._fake:this) ,arguments);
            };
			this.setColWidthA=this._fake.setColWidthA=this.setColWidth;
			this.setColWidth = function(i,value){
				i=i*1;
				if  (i<ind) this._fake.setColWidthA(i,value);
				else this.setColWidthA(i,value);
				if ((i+1)<=ind) this._fake._correctSplit(Math.min(this._fake.objBox.offsetWidth,this._fake.obj.offsetWidth));
            }
			this.adjustColumnSizeA=this.adjustColumnSize;
			this.setColumnLabelA=this.setColumnLabel;
			this.setColumnLabel=function(a,b,c,d){
				var that  = this;
				if (a<ind) that = this._fake;
				return this.setColumnLabelA.apply(that,[a,b,c,d]);
			}
			this.adjustColumnSize=function(aind,c){
				if  (aind<ind) {
					if (_isIE) this._fake.obj.style.tableLayout="";
					this._fake.adjustColumnSize(aind,c);
					if (_isIE) this._fake.obj.style.tableLayout="fixed";
				    this._fake._correctSplit();
					}
				else return this.adjustColumnSizeA(aind,c);
			}

            var zname="cells";
            this._bfs_cells=this[zname];
            this[zname]=function(){
                    if (arguments[1]<ind){
                        return this._fake.cells.apply(this._fake,arguments);
                    } else
                        return this._bfs_cells.apply(this,arguments);
                    }
            
            this._bfs_isColumnHidden=this.isColumnHidden;        
            this.isColumnHidden=function(){
				if (parseInt(arguments[0])<ind)
					return this._fake.isColumnHidden.apply(this._fake,arguments);
				else
					return this._bfs_isColumnHidden.apply(this,arguments);
            }                    


            this._bfs_setColumnHidden=this.setColumnHidden;        
            this.setColumnHidden=function(){
                    if (parseInt(arguments[0])<ind){
                        this._fake.setColumnHidden.apply(this._fake,arguments);
                        return this._fake._correctSplit();
            		}
                    else
                        return this._bfs_setColumnHidden.apply(this,arguments);
                    }                    

            var zname="cells2";
            this._bfs_cells2=this[zname];
            this[zname]=function(){
                    if (arguments[1]<ind)
                        return this._fake.cells2.apply(this._fake,arguments);
                    else
                        return this._bfs_cells2.apply(this,arguments);
                    }

            var zname="cells3";
            this._bfs_cells3=this[zname];
            this[zname]=function(a,b){
                    if (arguments[1]<ind && this._fake.rowsAr[arguments[0].idd]){
                        //fall back for totally rowspanned row
                        if (this._fake.rowsAr[a.idd] && this._fake.rowsAr[a.idd].childNodes.length==0)  return this._bfs_cells3.apply(this,arguments);
                        arguments[0]=arguments[0].idd;
                        return this._fake.cells.apply(this._fake,arguments);
                        }
                    else
                        return this._bfs_cells3.apply(this,arguments);
                    }

            var zname="changeRowId";
            this._bfs_changeRowId=this[zname];
            this[zname]=function(){
                this._bfs_changeRowId.apply(this,arguments);
                if (this._fake.rowsAr[arguments[0]])
                	this._fake.changeRowId.apply(this._fake,arguments);
            }
            this._fake.getRowById=function(id){
            	var row = this.rowsAr[id];
            	if (!row && this._fake.rowsAr[id]) row=this._fake.getRowById(id);
				
			
				if (row){
					if (row.tagName != "TR"){
						for (var i = 0; i < this.rowsBuffer.length; i++)
							if (this.rowsBuffer[i] && this.rowsBuffer[i].idd == id)
								return this.render_row(i);
						if (this._h2) return this.render_row(null,row.idd);
					}
					return row;
				}
				return null;
			}

            if (this.collapseKids){
				//tree grid
	            this._fake["_bfs_collapseKids"]=this.collapseKids;
				this._fake["collapseKids"]=function(){
					return this._fake["collapseKids"].apply(this._fake,[this._fake.rowsAr[arguments[0].idd]]);
				}
				
	            this["_bfs_collapseKids"]=this.collapseKids;
				this["collapseKids"]=function(){
					var z=this["_bfs_collapseKids"].apply(this,arguments);
					this._fake._h2syncModel();
					if (!this._cssSP) this._fake._fixAlterCss();
				}				
				
				
	            this._fake["_bfs_expandKids"]=this.expandKids;
				this._fake["expandKids"]=function(){
					this._fake["expandKids"].apply(this._fake,[this._fake.rowsAr[arguments[0].idd]]);
					if (!this._cssSP) this._fake._fixAlterCss();
				}
				

				this["_bfs_expandAll"]=this.expandAll;
				this["expandAll"]=function(){
					this._bfs_expandAll();
					this._fake._h2syncModel();
					if (!this._cssSP) this._fake._fixAlterCss();
				}

				this["_bfs_collapseAll"]=this.collapseAll;
				this["collapseAll"]=function(){
					this._bfs_collapseAll();
					this._fake._h2syncModel();
					if (!this._cssSP) this._fake._fixAlterCss();
				}								
				
	            this["_bfs_expandKids"]=this.expandKids;
				this["expandKids"]=function(){
					var z=this["_bfs_expandKids"].apply(this,arguments);
					this._fake._h2syncModel();
					if (!this._cssSP) this._fake._fixAlterCss();
				}				
				
				this._fake._h2syncModel=function(){
					if (this._fake.pagingOn) this._fake._renderSort();
					else this._renderSort();
				}
				this._updateTGRState=function(a){
					return this._fake._updateTGRState(a);
				}
			}



				//split


      if (this._elmnh){
			this._setRowHoverA=this._fake._setRowHoverA=this._setRowHover;
			this._unsetRowHoverA=this._fake._unsetRowHoverA=this._unsetRowHover;
			this._setRowHover=this._fake._setRowHover=function(){
				var that=this.grid;
				that._setRowHoverA.apply(this,arguments);
				var z=(_isIE?event.srcElement:arguments[0].target);
				z=that._fake.rowsAr[that.getFirstParentOfType(z,'TD').parentNode.idd];
				if (z){
					that._fake._setRowHoverA.apply(that._fake.obj,[{target:z.childNodes[0]},arguments[1]]);
				   	}
			};
			this._unsetRowHover=this._fake._unsetRowHover=function(){
				if (arguments[1]) var that=this;
				else	var that=this.grid;
				that._unsetRowHoverA.apply(this,arguments);
				that._fake._unsetRowHoverA.apply(that._fake.obj,arguments);
			};
		  		this._fake.enableRowsHover(true,this._hvrCss);
		  		this.enableRowsHover(false);
		  		this.enableRowsHover(true,this._fake._hvrCss);
			}

			this._updateTGRState=function(z){ 
				if (!z.update || z.id==0) return;
				if (this.rowsAr[z.id].imgTag)
					this.rowsAr[z.id].imgTag.src=this.imgURL+z.state+".gif";
				if (this._fake.rowsAr[z.id] && this._fake.rowsAr[z.id].imgTag)
					this._fake.rowsAr[z.id].imgTag.src=this.imgURL+z.state+".gif";
				z.update=false;
			}
			this.copy_row=function(row){
				    var x=row.cloneNode(true);
                    x._skipInsert=row._skipInsert;
                    var r_ind=ind;
                    x._attrs={};
                    x._css = row._css;
                    
                    if (this._ecspn){
                    	r_ind=0;
                    	for (var i=0; (r_ind<x.childNodes.length && i<ind); i+=(x.childNodes[r_ind].colSpan||1))
                    		r_ind++;
                    }
                                
                    while (x.childNodes.length>r_ind)
                        x.removeChild(x.childNodes[x.childNodes.length-1]);
                        var zm=r_ind;
                    for (var i=0; i<zm; i++){
                    	
						if (this.dragAndDropOff)
							this.dragger.addDraggableItem(x.childNodes[i], this);                        
                        x.childNodes[i].style.display=(this._fake._hrrar?(this._fake._hrrar[i]?"none":""):"");
                        x.childNodes[i]._cellIndex=i;
                        //TODO - more universal solution
                        x.childNodes[i].combo_value=arguments[0].childNodes[i].combo_value;
                        x.childNodes[i]._clearCell=arguments[0].childNodes[i]._clearCell;
                        x.childNodes[i]._cellType=arguments[0].childNodes[i]._cellType;
						x.childNodes[i]._brval=arguments[0].childNodes[i]._brval;                        
						x.childNodes[i]._attrs=arguments[0].childNodes[i]._attrs;
						x.childNodes[i].chstate=arguments[0].childNodes[i].chstate;
						if (row._attrs['style']) x.childNodes[i].style.cssText+=";"+row._attrs['style'];
						

                        if(x.childNodes[i].colSpan>1) 
                            this._childIndexes=this._fake._childIndexes;
                            }
                    
                    if (this._h2 && this._treeC < ind){
						var trow=this._h2.get[arguments[0].idd];
                		x.imgTag=x.childNodes[this._treeC].childNodes[0].childNodes[trow.level];
						x.valTag=x.childNodes[this._treeC].childNodes[0].childNodes[trow.level+2];
                        }

					
                        x.idd=row.idd;
                        x.grid=this._fake;
                        
                	return x;
                        	}
                    	
            var zname="_insertRowAt";
            this._bfs_insertRowAt=this[zname];
            this[zname]=function(){ 
                        var r=this["_bfs_insertRowAt"].apply(this,arguments);
                        arguments[0]=this.copy_row(arguments[0]);

                        var r2=this._fake["_insertRowAt"].apply(this._fake,arguments);
                        if (r._fhd){
							r2.parentNode.removeChild(r2);
                            this._fake.rowsCol._dhx_removeAt(this._fake.rowsCol._dhx_find(r2));
							r._fhd=false;
						}

						return r;
            }
            /*
var quirks = (_isIE && document.compatMode=="BackCompat");
		
		var isVScroll = this.parentGrid?false:(this.objBox.scrollHeight > this.objBox.offsetHeight);
		var isHScroll = this.parentGrid?false:(this.objBox.scrollWidth > this.objBox.offsetWidth); 
		var scrfix = _isFF?20:18;
		
		var outerBorder=(this.entBox.offsetWidth-this.entBox.clientWidth)/2;
				
		var gridWidth=this.entBox.clientWidth;
		var gridHeight=this.entBox.clientHeight;
		*/
            this._bfs_setSizes=this.setSizes;
            this.setSizes=function(){
            		if (this._notresize) return;
                	this._bfs_setSizes(this,arguments);
                	
					this.sync_headers()
					if (this.sync_scroll() && this._ahgr) this.setSizes(); //if scrolls was removed - check once more to correct auto-height
					
                    this._fake.entBox.style.height=this.entBox.style.height;
                    this._fake.objBox.style.height=this.objBox.style.height;
                    this._fake.hdrBox.style.height=this.hdrBox.style.height;
                    
                    this._fake.objBox.scrollTop=this.objBox.scrollTop;
                    
                    this._fake.setColumnSizes(this._fake.entBox.clientWidth);
                    
                    this.globalBox.style.width=parseInt(this.entBox.style.width)+parseInt(this._fake.entBox.style.width);
                    this.globalBox.style.height=this.entBox.style.height;
                    
            }
            
            this.sync_scroll=this._fake.sync_scroll=function(end){
            		var old=this.objBox.style.overflowX;
            	    if (this.obj.offsetWidth<=this.objBox.offsetWidth)
                    {
                    	if (!end) return this._fake.sync_scroll(true);
                        this.objBox.style.overflowX="hidden";
                        this._fake.objBox.style.overflowX="hidden";
                    }
                    else{
                        this.objBox.style.overflowX="scroll";
                        this._fake.objBox.style.overflowX="scroll";
                    }
                    return old!=this.objBox.style.overflowX;
        	}
            this.sync_headers=this._fake.sync_headers=function(){
            	if (this.noHeader || (this._fake.hdr.scrollHeight==this.hdr.offsetHeight)) return;
            //	if (this.hdr.rows.length!=2){
            		for (var i=1; i<this.hdr.rows.length; i++){
						var ha=this.hdr.rows[i].scrollHeight; var hb=this._fake.hdr.rows[i].scrollHeight;
						if (ha!=hb)
							this._fake.hdr.rows[i].style.height=this.hdr.rows[i].style.height=Math.max(ha,hb)+"px";
						if (window._KHTMLrv) 
							this._fake.hdr.rows[i].childNodes[0].style.height=this.hdr.rows[i].childNodes[ind].style.height=Math.max(ha,hb)+"px";
					}
					this._fake.sync_headers;
			//	} else this._fake.hdr.style.height=this.hdr.offsetHeight+"px";
        	}
        	this._fake._bfs_setSizes=this._fake.setSizes;
            this._fake.setSizes=function(){
            		if (this._fake._notresize) return;
            		this._fake.setSizes();
            }

            var zname="_doOnScroll";
            this._bfs__doOnScroll=this[zname];
            this[zname]=function(){
                    this._bfs__doOnScroll.apply(this,arguments);
                    this._fake.objBox.scrollTop=this.objBox.scrollTop;
                    this._fake["_doOnScroll"].apply(this._fake,arguments);
            }
            
            var zname="selectAll";
            this._bfs__selectAll=this[zname];
            this[zname]=function(){
                    this._bfs__selectAll.apply(this,arguments);
                    this._bfs__selectAll.apply(this._fake,arguments);
            }
            
            



            var zname="doClick";
            this._bfs_doClick=this[zname];
            this[zname]=function(){
                    this["_bfs_doClick"].apply(this,arguments);
                        if (arguments[0].tagName=="TD"){
                            var fl=(arguments[0]._cellIndex>=ind);
							if (!arguments[0].parentNode.idd) return;
							if (!fl)
                            	arguments[0].className=arguments[0].className.replace(/cellselected/g,"");
                            //item selected but it left part not rendered yet
							if (!this._fake.rowsAr[arguments[0].parentNode.idd])
								this._fake.render_row(this.getRowIndex(arguments[0].parentNode.idd));
                            arguments[0]=this._fake.cells(arguments[0].parentNode.idd,(fl?0:arguments[0]._cellIndex)).cell;
                            if (fl) this._fake.cell=null;
                            this._fake["_bfs_doClick"].apply(this._fake,arguments);
                            if (fl) this._fake.cell=this.cell;
                            else this.cell=this._fake.cell;
                            if (this._fake.onRowSelectTime) clearTimeout(this._fake.onRowSelectTime)
                            if (fl) {
                                arguments[0].className=arguments[0].className.replace(/cellselected/g,"");
                                globalActiveDHTMLGridObject=this;
                                this._fake.cell=this.cell;                                
                                }
                            else{
                                this.objBox.scrollTop=this._fake.objBox.scrollTop;
	                            }
                        }
            }
            this._fake._bfs_doClick=this._fake[zname];
            this._fake[zname]=function(){
                    this["_bfs_doClick"].apply(this,arguments);
                        if (arguments[0].tagName=="TD"){
                            var fl=(arguments[0]._cellIndex<ind);
							if (!arguments[0].parentNode.idd) return;
                            arguments[0]=this._fake._bfs_cells(arguments[0].parentNode.idd,(fl?ind:arguments[0]._cellIndex)).cell;
                            this._fake.cell=null;
this._fake["_bfs_doClick"].apply(this._fake,arguments);
							this._fake.cell=this.cell;
                            if (this._fake.onRowSelectTime) clearTimeout(this._fake.onRowSelectTime)
                            if (fl) {
                                arguments[0].className=arguments[0].className.replace(/cellselected/g,"");
                                globalActiveDHTMLGridObject=this;
								this._fake.cell=this.cell;                                
								this._fake.objBox.scrollTop=this.objBox.scrollTop;
                                }
                        }
            }


this.clearSelectionA = this.clearSelection;
this.clearSelection = function(mode){
    if (mode) this._fake.clearSelection();
    this.clearSelectionA();
}


this.moveRowUpA = this.moveRowUp;
this.moveRowUp = function(row_id){
	if (!this._h2)
    	this._fake.moveRowUp(row_id);
    this.moveRowUpA(row_id);
    if (this._h2) this._fake._h2syncModel();
}
this.moveRowDownA = this.moveRowDown;
this.moveRowDown = function(row_id){
	if (!this._h2)
    	this._fake.moveRowDown(row_id);
    this.moveRowDownA(row_id);
    if (this._h2) this._fake._h2syncModel();
}



this._fake.getUserData=function(){	return this._fake.getUserData.apply(this._fake,arguments); }
this._fake.setUserData=function(){	return this._fake.setUserData.apply(this._fake,arguments); }

this.getSortingStateA=this.getSortingState;
this.getSortingState = function(){
	var z=this.getSortingStateA();
	if (z.length!=0) return z;
	return this._fake.getSortingState();
}

this.setSortImgStateA=this._fake.setSortImgStateA=this.setSortImgState;
this.setSortImgState = function(a,b,c,d){
	this.setSortImgStateA(a,b,c,d);
	if (b*1<ind) {
		this._fake.setSortImgStateA(a,b,c,d);
		this.setSortImgStateA(false);
	} else 
		this._fake.setSortImgStateA(false);
}


this._fake.doColResizeA = this._fake.doColResize;
this._fake.doColResize = function(ev,el,startW,x,tabW){ 
    var a=-1;
    var z=0;
    if (arguments[1]._cellIndex==(ind-1)){
            a = this._initalSplR + (ev.clientX-x);
            if (!this._initalSplF) this._initalSplF=arguments[3]+this.objBox.scrollWidth-this.objBox.offsetWidth;
            if (this.objBox.scrollWidth==this.objBox.offsetWidth && (this._fake.alter_split_resize || (ev.clientX-x)>0 )){
            	arguments[3]=(this._initalSplF||arguments[3]);
            	z=this.doColResizeA.apply(this,arguments);
            } 
            else
            	z=this.doColResizeA.apply(this,arguments);
    }
    else{
        if (this.obj.offsetWidth<this.entBox.offsetWidth)
    		a=this.obj.offsetWidth;
    	z=this.doColResizeA.apply(this,arguments);
	}
	
	this._correctSplit(a);
	this.resized=this._fake.resized=1;
    return z;
}

		this._fake.changeCursorState = function(ev){
                     var el = ev.target||ev.srcElement;
                     if(el.tagName!="TD")
                           el = this.getFirstParentOfType(el,"TD")
                           if ((el.tagName=="TD")&&(this._drsclmn)&&(!this._drsclmn[el._cellIndex])) return;
                           var check = (ev.layerX||0)+(((!_isIE)&&(ev.target.tagName=="DIV"))?el.offsetLeft:0);
                           var pos = parseInt(this.getPosition(el,this.hdrBox)); 
                           
                           if(((el.offsetWidth - (ev.offsetX||(pos-check)*-1))<(_isOpera?20:10))||((this.entBox.offsetWidth - (ev.offsetX?(ev.offsetX+el.offsetLeft):check) + this.objBox.scrollLeft - 0)<(_isOpera?20:10))){
                              el.style.cursor = "E-resize";
                           }else
                              el.style.cursor = "default";
                       if (_isOpera) this.hdrBox.scrollLeft = this.objBox.scrollLeft;
                        }
			
		this._fake.startColResizeA = this._fake.startColResize;
		this._fake.startColResize = function(ev){
                                    var z=this.startColResizeA(ev);
                                    this._initalSplR=this.entBox.offsetWidth;
                                    this._initalSplF=null;
                                    if (this.entBox.onmousemove){
                                        var m=this.entBox.parentNode;   
                                        if (m._aggrid) return z;
										m._aggrid=m.grid;   m.grid=this;
                                        this.entBox.parentNode.onmousemove=this.entBox.onmousemove;
                                        this.entBox.onmousemove=null;
                                        }
                                    return z;
								}

		this._fake.stopColResizeA = this._fake.stopColResize;
		this._fake.stopColResize = function(ev){
                                    if (this.entBox.parentNode.onmousemove){
                                        var m=this.entBox.parentNode;   m.grid=m._aggrid;   m._aggrid=null;
                                        this.entBox.onmousemove=this.entBox.parentNode.onmousemove;
                                        this.entBox.parentNode.onmousemove=null;
                                        if (this.obj.offsetWidth<this.entBox.offsetWidth)
                                        	this._correctSplit(this.obj.offsetWidth);
                                        }
                                    return this.stopColResizeA(ev);
								}



this.doKeyA = this.doKey;
this._fake.doKeyA = this._fake.doKey;
this._fake.doKey=this.doKey=function(ev){
                            if (!ev) return true;
                            if (this._htkebl) return true;
		if ((ev.target||ev.srcElement).value !== window.undefined){
			var zx = (ev.target||ev.srcElement);

			if ((!zx.parentNode)||(zx.parentNode.className.indexOf("editable") == -1))
				return true;
		}
		                            
    switch (ev.keyCode){
        case 9:
            if (!ev.shiftKey){
                if (this._realfake){
                    if ((this.cell)&&(this.cell._cellIndex==(ind-1))){
                        if (ev.preventDefault)
					       ev.preventDefault();
					   var ind_t=ind;
					   while (this._fake._hrrar && this._fake._hrrar[ind_t]) ind_t++;
                       this._fake.selectCell(this._fake.getRowIndex(this.cell.parentNode.idd),ind_t,false,false,true);
                       return false;
            		}
				  else
                       var z=this.doKeyA(ev);
                       globalActiveDHTMLGridObject=this;
                       return z;
                    }
                else{
                    if (this.cell){
                        var ind_t=this.cell._cellIndex+1;
                        while (this.rowsCol[0].childNodes[ind_t] && this.rowsCol[0].childNodes[ind_t].style.display=="none") ind_t++;
                        if (ind_t == this.rowsCol[0].childNodes.length){
					   if (ev.preventDefault)
					       ev.preventDefault();					
						var z=this.rowsBuffer[this.getRowIndex(this.cell.parentNode.idd)+1];
					    if (z) {
					    	this.showRow(z.idd);
					    	this._fake.selectCell(this._fake.getRowIndex(z.idd),0,false,false,true);
					    	return false;
				    	}
	                    }
                    }
                        return  this.doKeyA(ev);
                }
            }
            else{
                if (this._realfake){
                    if ((this.cell)&&(this.cell._cellIndex==0)){
					   if (ev.preventDefault)
					       ev.preventDefault();
					    var z=this._fake.rowsBuffer[this._fake.getRowIndex(this.cell.parentNode.idd)-1];
						if (z) {
							this._fake.showRow(z.idd);
							
							var ind_t=this._fake._cCount-1;
                        	while (z.childNodes[ind_t].style.display=="none") 
                        		ind_t--;
                        		
							this._fake.selectCell(this._fake.getRowIndex(z.idd),ind_t,false,false,true);
						}
                       return false;
                       }
                    else
                       return this.doKeyA(ev);
                    }
                else{
                    if ((this.cell)&&(this.cell._cellIndex==ind)){
					   if (ev.preventDefault)
					       ev.preventDefault();
                        this._fake.selectCell(this.getRowIndex(this.cell.parentNode.idd),ind-1,false,false,true);
                        return false;
                    }
                    else
                        return  this.doKeyA(ev);
                }
            }
       break;
    }
    return  this.doKeyA(ev);
}


this.editCellA=this.editCell;
this.editCell=function(){
	if (this.cell && this.cell.parentNode.grid != this) return this._fake.editCell();
	return this.editCellA();
}

this.deleteRowA = this.deleteRow;
this.deleteRow=function(row_id,node){
/*	if (!this._realfake)
		this._fake.loadedKidsHash=this.loadedKidsHash;*/

    if (this.deleteRowA(row_id,node)===false) return false;
    if (this._fake.rowsAr[row_id])
    	this._fake.deleteRow(row_id);
}

this.clearAllA = this.clearAll;
this.clearAll=function(){
    this.clearAllA();
    this._fake.clearAll();
}
this.editStopA = this.editStop;
this.editStop=function(){
	if (this._fake.editor)
		this._fake.editStop();
	else 
    	this.editStopA();
};


this.attachEvent("onAfterSorting",function(i,b,c){
	if (i>=ind) 
		this._fake.setSortImgState(false)
});



this._fake.sortField = function(a,b,c){ 
	this._fake.sortField.call(this._fake,a,b,this._fake.hdr.rows[0].cells[a]);
	if (this.fldSort[a]!="na" && this._fake.fldSorted){
		var mem = this._fake.getSortingState()[1];
		this._fake.setSortImgState(false);
		this.setSortImgState(true,arguments[0],mem)
	}
}

this.sortTreeRowsA = this.sortTreeRows;
this._fake.sortTreeRowsA = this._fake.sortTreeRows;
this.sortTreeRows=this._fake.sortTreeRows=function(col,type,order,ar){
    if (this._realfake) return this._fake.sortTreeRows(col,type,order,ar)

    this.sortTreeRowsA(col,type,order,ar);
    this._fake._h2syncModel();

                this._fake.setSortImgStateA(false);
	this._fake.fldSorted=null;
    }

/* SRND mode */
this._fake._fillers=[];
this._fake.rowsBuffer=this.rowsBuffer;
this.attachEvent("onClearAll",function(){
	this._fake.rowsBuffer=this.rowsBuffer;	
})
this._add_filler_s=this._add_filler;
this._add_filler=function(a,b,c,e){
	
	if (!this._fake._fillers) this._fake._fillers=[];
	if (this._realfake || !e){
		var d;
		if (c || !this._fake._fillers.length){
			if (c && c.idd) d=this._fake.rowsAr[c.idd];
			else if (c && c.nextSibling) {
				d = {};
				d.nextSibling=this._fake.rowsAr[c.nextSibling.idd];
				d.parentNode=d.nextSibling.parentNode;
			}		
		this._fake._fillers.push(this._fake._add_filler(a,b,d));
		}
	}
	
	return this._add_filler_s.apply(this,arguments);
}
this._add_from_buffer_s=this._add_from_buffer;
this._add_from_buffer=function() { 
	var res=this._add_from_buffer_s.apply(this,arguments);
	if (res!=-1){
		this._fake._add_from_buffer.apply(this._fake,arguments);
		if (this.multiLine) this._correctRowHeight(this.rowsBuffer[arguments[0]].idd);
	}
	return res;
    }
this._fake.render_row=function(ind){
	var row=this._fake.render_row(ind);

	if (row == -1) return -1;
	if (row) {
		return this.rowsAr[row.idd]=this.rowsAr[row.idd]||this._fake.copy_row(row);
    }
	return null;
        }
this._reset_view_s=this._reset_view;
this._reset_view=function(){
	this._fake._reset_view(true);
	this._fake._fillers=[];
	this._reset_view_s();
    }

this.moveColumn_s=this.moveColumn;
this.moveColumn=function(a,b){
	if (b>=ind) return this.moveColumn_s(a,b);
}

    
this.attachEvent("onCellChanged",function(id,i,val){
	if (this._split_event && i<ind && this.rowsAr[id]){
		
		var cell=this._fake.rowsAr[id];
		if (!cell) return;
		if (cell._childIndexes)
			cell=cell.childNodes[cell._childIndexes[i]];
		else
			cell=cell.childNodes[i];
		var tcell = this.rowsAr[id].childNodes[i];
	
		if (tcell._treeCell && tcell.firstChild.lastChild)
			tcell.firstChild.lastChild.innerHTML = val;
		else
			tcell.innerHTML=cell.innerHTML;
		tcell._clearCell=false;
		tcell.combo_value = cell.combo_value;
		tcell.chstate=cell.chstate;	//TODO - more universal solution
	}
})





    this._fake.combos=this.combos;
	this.setSizes();
	if (this.rowsBuffer[0]) this._reset_view();
	this.attachEvent("onXLE",function(){this._fake._correctSplit()})
	this._fake._correctSplit();
}

dhtmlXGridObject.prototype._correctSplit=function(a){ 
    a=a||(this.obj.scrollWidth-this.objBox.scrollLeft);
    a=Math.min(this.globalBox.offsetWidth, a);
    if (a>-1){
	    this.entBox.style.width=a+"px";
	    this.objBox.style.width=a+"px";
	
		var outerBorder=(this.globalBox.offsetWidth-this.globalBox.clientWidth)/2;
	    this._fake.entBox.style.left=a+"px";
	    this._fake.entBox.style.width=Math.max(0,this.globalBox.offsetWidth-a-(this.quirks?0:2)*outerBorder)+"px";
	    if (this._fake.ftr)
	    	this._fake.ftr.parentNode.style.width=this._fake.entBox.style.width;
	    if (_isIE){
		    var quirks=_isIE && !window.xmlHttpRequest;
			var outerBorder=(this.globalBox.offsetWidth-this.globalBox.clientWidth);
			this._fake.hdrBox.style.width=this._fake.objBox.style.width=Math.max(0,this.globalBox.offsetWidth-(quirks?outerBorder:0)-a)+"px";
		}
	}
}

dhtmlXGridObject.prototype._correctRowHeight=function(id,ind){
	if (!this.rowsAr[id] || !this._fake.rowsAr[id]) return;
	var h=this.rowsAr[id].offsetHeight;
	var h2=this._fake.rowsAr[id].offsetHeight;
	var max = Math.max(h,h2);
	if (!max) return;
	this.rowsAr[id].style.height=this._fake.rowsAr[id].style.height=max+"px";
	if (window._KHTMLrv) this.rowsAr[id].childNodes[this._fake._cCount].style.height=this._fake.rowsAr[id].firstChild.style.height=max+"px";
}
//(c)dhtmlx ltd. www.dhtmlx.com

//v.3.6 build 131108

/*
Copyright DHTMLX LTD. http://www.dhtmlx.com
To use this component please contact sales@dhtmlx.com to obtain license
*/
/**
*   @desc: enable smart rendering mode
*   @type: public
*   @param: mode - true|false - enable|disable mode
*   @param: buffer - has sense only in dynamic loading mode, count of rows requrested from server by single operation, optional
*   @topic: 0
*/
dhtmlXGridObject.prototype.enableSmartRendering=function(mode,buffer,reserved){
	if (arguments.length>2){
		if (buffer && !this.rowsBuffer[buffer-1]) this.rowsBuffer[buffer-1]=0;
		buffer=reserved;
	}
	this._srnd=convertStringToBoolean(mode);
	this._srdh=this._srdh||20;
	this._dpref=buffer||0;
	
};
/**
*   @desc: allows to pre-render rows during scrolling, make scrolling more smooth, but with small drop in overall perfomance
*   @type: public
*   @param: buffer - count of rows, which will be prerendered
*   @topic: 0
*/
dhtmlXGridObject.prototype.enablePreRendering=function(buffer){
	this._srnd_pr=parseInt(buffer||50);
};
/**
*   @desc: force grid in dyn. srnd mode fully load itself from server side
*   @type: public
*   @param: buffer - how much rows grid can request from server side in one operation
*   @topic: 0
*/
dhtmlXGridObject.prototype.forceFullLoading=function(buffer, callback){
	for (var i=0; i<this.rowsBuffer.length; i++)
		if (!this.rowsBuffer[i]){
			var usedbuffer = buffer || (this.rowsBuffer.length-i);
			if (this.callEvent("onDynXLS",[i,usedbuffer])){
				var self=this;
				this.load(this.xmlFileUrl+getUrlSymbol(this.xmlFileUrl)+"posStart="+i+"&count="+usedbuffer, function(){
					window.setTimeout(function(){	self.forceFullLoading(buffer, callback); },100); 
				}, this._data_type);
			}
			return;
		}
	if (callback) callback.call(this);
};

/**
*   @desc: set height which will be used in smart rendering mode for row calculation, function need to be used if you use custom skin for grid which changes default row height
*   @type: public
   @param: {int} height - awaited height of row
*   @returns: void
*   @topic: 0
*/      
dhtmlXGridObject.prototype.setAwaitedRowHeight = function(height) {
   this._srdh=parseInt(height);
};

dhtmlXGridObject.prototype._get_view_size=function(){
	return Math.floor(parseInt(this.entBox.offsetHeight)/this._srdh)+2;
};
dhtmlXGridObject.prototype._add_filler=function(pos,len,fil,rsflag){
	if (!len) return null;
	var id="__filler__";
	var row=this._prepareRow(id);
	row.firstChild.style.width="1px";
	for (var i=1; i<row.childNodes.length; i++)
	    row.childNodes[i].style.display='none';
 	row.firstChild.style.height=len*this._srdh+"px";
 	fil=fil||this.rowsCol[pos];
 	if (fil && fil.nextSibling) 
 		fil.parentNode.insertBefore(row,fil.nextSibling);
 	else
 		if (_isKHTML)
 			this.obj.appendChild(row);
 		else
 			this.obj.rows[0].parentNode.appendChild(row);
 			
 	this.callEvent("onAddFiller",[pos,len,row,fil,rsflag]);
 	return [pos,len,row];
};
dhtmlXGridObject.prototype._update_srnd_view=function(){
	    var min=Math.floor(this.objBox.scrollTop/this._srdh);
        var max=min+this._get_view_size();
        if (this.multiLine) {
        // Calculate the min, by Stephane Bernard
            var pxHeight = this.objBox.scrollTop;
            min = 0;
            while(pxHeight > 0) {
                pxHeight-=this.rowsCol[min]?this.rowsCol[min].offsetHeight:this._srdh;
                min++;
            }
            // Calculate the max
            max=min+this._get_view_size();
            if (min>0) min--;
        }        
        max+=(this._srnd_pr||0);//pre-rendering
        if (max>this.rowsBuffer.length) max=this.rowsBuffer.length;

        for (var j=min; j<max; j++){ 
            if (!this.rowsCol[j]){
				var res=this._add_from_buffer(j);
				if (res==-1){
					if (this.xmlFileUrl){
						if (this._dpref && this.rowsBuffer[max-1]){
							//we have last row in sett, assuming that we in scrolling up process
							var rows_count = this._dpref?this._dpref:(max-j)
							var start_pos = Math.max(0, max - this._dpref);
							this._current_load=[start_pos, max-start_pos];
						} else 
							this._current_load=[j,(this._dpref?this._dpref:(max-j))];
						if (this.callEvent("onDynXLS",this._current_load))
							this.load(this.xmlFileUrl+getUrlSymbol(this.xmlFileUrl)+"posStart="+this._current_load[0]+"&count="+this._current_load[1], this._data_type);
					}
					return;
				} else {
	               	if (this._tgle){
	               		this._updateLine(this._h2.get[this.rowsBuffer[j].idd],this.rowsBuffer[j]);
	               		this._updateParentLine(this._h2.get[this.rowsBuffer[j].idd],this.rowsBuffer[j]);
	           		}
					if (j && j==(this._realfake?this._fake:this)["_r_select"]){
						this.selectCell(j, this.cell?this.cell._cellIndex:0, true);
					}
				}
            }
		}
	if (this._fake && !this._realfake && this.multiLine) 
		this._fake.objBox.scrollTop = this.objBox.scrollTop;		
}
dhtmlXGridObject.prototype._add_from_buffer=function(ind){
	    var row=this.render_row(ind);
	    if (row==-1) return -1;
	    if (row._attrs["selected"] || row._attrs["select"]){
			this.selectRow(row,false,true);
			row._attrs["selected"]=row._attrs["select"]=null;
		}
						
	    if (!this._cssSP){ 
		    if (this._cssEven && ind%2 == 0 )
				row.className=this._cssEven+((row.className.indexOf("rowselected") != -1)?" rowselected ":" ")+(row._css||"");
			else if (this._cssUnEven && ind%2 == 1 )
			    row.className=this._cssUnEven+((row.className.indexOf("rowselected") != -1)?" rowselected ":" ")+(row._css||"");				
			} else if (this._h2) {
				var x=this._h2.get[row.idd];
				row.className+=" "+((x.level%2)?(this._cssUnEven+" "+this._cssUnEven):(this._cssEven+" "+this._cssEven))+"_"+x.level+(this.rowsAr[x.id]._css||"");
			}
			

	    //now we need to get location of node
	    for (var i=0; i<this._fillers.length; i++){
	    	var f=this._fillers[i];
	    	if (f && f[0]<=ind && (f[0]+f[1])>ind ){
	    		//filler found
	    		var pos=ind-f[0];
	    		if (pos==0){
	    			//start
	    			this._insert_before(ind,row,f[2]);
	    			this._update_fillers(i,-1,1);
	    		} else if (pos == f[1]-1){
	    			this._insert_after(ind,row,f[2]);
	    			this._update_fillers(i,-1,0);
	    		} else {
	    			this._fillers.push(this._add_filler(ind+1,f[1]-pos-1,f[2],1));
	    			this._insert_after(ind,row,f[2]);
	    			this._update_fillers(i,-f[1]+pos,0);
	    		}
	    		return;
	    	}
	    }
}
dhtmlXGridObject.prototype._update_fillers=function(ind,right,left){
	var f=this._fillers[ind];
	f[1]=f[1]+right;
	f[0]=f[0]+left;
	if (!f[1]){
		this.callEvent("onRemoveFiller",[f[2]]);
		f[2].parentNode.removeChild(f[2]);
		this._fillers.splice(ind,1);
	} else {
		f[2].firstChild.style.height=parseFloat(f[2].firstChild.style.height)+right*this._srdh+"px";	
		this.callEvent("onUpdateFiller",[f[2]]);
	}
}
dhtmlXGridObject.prototype._insert_before=function(ind,row,fil){
	fil.parentNode.insertBefore(row,fil);
	this.rowsCol[ind]=row;
	this.callEvent("onRowInserted",[row,null,fil,"before"]);
}
dhtmlXGridObject.prototype._insert_after=function(ind,row,fil){
	if (fil.nextSibling)
		fil.parentNode.insertBefore(row,fil.nextSibling);
	else
		fil.parentNode.appendChild(row);
	this.rowsCol[ind]=row;
	this.callEvent("onRowInserted",[row,null,fil,"after"]);
}

//v.3.6 build 131108

/*
Copyright DHTMLX LTD. http://www.dhtmlx.com
To use this component please contact sales@dhtmlx.com to obtain license
*/
/**
*   @desc: enable automatic size saving to cookie
*   @param: name - optional, cookie name
*   @param: cookie_param - additional parameters added to cookie
*   @type: public
*     @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.enableAutoSizeSaving = function(name,cookie_param){
		this.attachEvent("onResizeEnd",function(){ this.saveSizeToCookie(name,cookie_param) });
}

/**
*   @desc: store opene state of TreeGrid in cookie
*   @param: name - optional, cookie name
*   @param: cookie_param - additional parameters added to cookie
*   @type: public
*   @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.saveOpenStates = function(name,cookie_param){
	if (!name) name=this.entBox.id;
	var t=[];
	this._h2.forEachChild(0,function(el){
		if (el.state=="minus") t.push(el.id);
	});
	var str = "gridOpen"+(name||"") + "=" + t.join("|") +  (cookie_param?("; "+cookie_param):"");
	document.cookie = str;
}


/**
*   @desc: load open state of TreeGrid in cookie
*   @param: name - optional, cookie name
*   @param: cookie_param - additional parameters added to cookie
*   @type: public
*   @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.loadOpenStates = function(name,cookie_param){
	var val=this.getCookie(name,"gridOpen");
	if (!val) return;
	val=val.split("|");
	for (var i = 0; i < val.length; i++) {
		var pid = this.getParentId(val[i]);
		if (!this.getOpenState(pid)) continue;
		this.openItem(val[i]);
	}
}

/**
*   @desc: enable automatic saving column state ( hidden | shown )
*   @param: name - optional, cookie name
*   @param: cookie_param - additional parameters added to cookie
*   @type: public
*     @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.enableAutoHiddenColumnsSaving = function(name,cookie_param){
		this.attachEvent("onColumnHidden",function(){ 
				this.saveHiddenColumnsToCookie(name,cookie_param); 
		});
}

/**
*   @desc: enable automatic sorting state saving to cookie
*   @param: name - optional, cookie name
*   @param: cookie_param - additional parameters added to cookie
*   @type: public
*     @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.enableSortingSaving = function(name,cookie_param){
	this.attachEvent("onBeforeSorting",function(){ 
		var that=this;
		window.setTimeout(function(){
			that.saveSortingToCookie(name,cookie_param);
			},1);
		return true;
		});	
}

/**
*   @desc: enable automatic column order saving to cookie
*   @param: name - optional, cookie name
*   @param: cookie_param - additional parameters added to cookie
*   @type: public
*     @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.enableOrderSaving = function(name,cookie_param){
	this.attachEvent("onAfterCMove",function(){ 
		this.saveOrderToCookie(name,cookie_param);  
		this.saveSizeToCookie(name,cookie_param);
	});
}

/**
*   @desc: enable automatic saving of all possible params
*   @param: name - optional, cookie name
*   @param: cookie_param - additional parameters added to cookie
*   @type: public
*     @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.enableAutoSaving = function(name,cookie_param){
		this.enableOrderSaving(name,cookie_param);
		this.enableAutoSizeSaving(name,cookie_param);
		this.enableSortingSaving(name,cookie_param);
}


/**   @desc: save grid layout to cookie
*     @type: public
*     @param: name - optional, cookie name
*     @param: cookie_param - additional parameters added to cookie
*     @edition: Professional
*     @topic: 2
*/
dhtmlXGridObject.prototype.saveSizeToCookie=function(name,cookie_param){
	if (this.cellWidthType=='px')
		var z=this.cellWidthPX.join(",");
	else
		var z=this.cellWidthPC.join(",");
	var z2=(this.initCellWidth||(new  Array)).join(",");
	this.setCookie(name,cookie_param,0,z);
	this.setCookie(name,cookie_param,1,z2);
}

/**   @desc: save hidden columns to cookie
*     @type: public
*     @param: name - optional, cookie name
*     @param: cookie_param - additional parameters added to cookie
*     @edition: Professional
*     @topic: 2
*/
dhtmlXGridObject.prototype.saveHiddenColumnsToCookie=function(name,cookie_param){

    var hs=[].concat(this._hrrar||[]);
    if (this._fake && this._fake._hrrar)
        for (var i=0; i < this._fake._cCount; i++)
            hs[i]=this._fake._hrrar[i]?"1":"";
	this.setCookie(name,cookie_param,4,hs.join(",").replace(/display:none;/g,"1"));
}

/**   @desc: load sorting order from cookie
*     @type: public
*     @param: name - optional,cookie name
*     @edition: Professional
*     @topic: 2
*/
dhtmlXGridObject.prototype.loadHiddenColumnsFromCookie=function(name){
	var z=this._getCookie(name,4);
	var ar=(z||"").split(",");
	for (var i=0; i < this._cCount; i++) 
		this.setColumnHidden(i,(ar[i]?true:false));
}



/**   @desc: save sorting order to cookie
*     @type: public
*     @param: name - optional, cookie name
*     @param: cookie_param - additional parameters added to cookie
*     @edition: Professional
*     @topic: 2
*/
dhtmlXGridObject.prototype.saveSortingToCookie=function(name,cookie_param){
	this.setCookie(name,cookie_param,2,(this.getSortingState()||[]).join(","));
}


/**   @desc: load sorting order from cookie
*     @type: public
*     @param: name - optional,cookie name
*     @edition: Professional
*     @topic: 2
*/
dhtmlXGridObject.prototype.loadSortingFromCookie=function(name){
	var z=this._getCookie(name,2);
	z=(z||"").split(",");
	if (z.length>1 && z[0]<this._cCount){
		this.sortRows(z[0],null,z[1]);
		this.setSortImgState(true,z[0],z[1]);
	}
}



/**   @desc: save sorting order to cookie
*     @type: public
*     @param: name - optional, cookie name
*     @param: cookie_param - additional parameters added to cookie
*     @edition: Professional
*     @topic: 2
*/
dhtmlXGridObject.prototype.saveOrderToCookie=function(name,cookie_param){
	if (!this._c_order) {
		this._c_order=[];
		var l=this._cCount;
		for (var i=0; i<l; i++)
			this._c_order[i]=i;
	}
	this.setCookie(name,cookie_param,3,((this._c_order||[]).slice(0,this._cCount)).join(","));
	this.saveSortingToCookie();
}


/**   @desc: load sorting order from cookie
*     @type: public
*     @param: name - optional,cookie name
*     @edition: Professional
*     @topic: 2
*/
dhtmlXGridObject.prototype.loadOrderFromCookie=function(name){
	var z=this._getCookie(name,3);
	z=(z||"").split(",");
	if (z.length>1 && z.length<=this._cCount){
			//code below probably may be optimized
			for (var i=0; i<z.length; i++)
				if ((!this._c_order && z[i]!=i)||(this._c_order && z[i]!=this._c_order[i])){
					var t=z[i];
					if (this._c_order)
						for (var j=0; j<this._c_order.length; j++) {
							if (this._c_order[j]==z[i]) {
								t=j; break;
								}
						}
					this.moveColumn(t*1,i);
				}
	}
}


/**   @desc: load grid layout from cookie
*     @type: public
*     @param: name - optional,cookie name
*     @edition: Professional
*     @topic: 2
*/
dhtmlXGridObject.prototype.loadSizeFromCookie=function(name){ 
	var z=this._getCookie(name,1);
	if (z)
		this.initCellWidth=z.split(",");
	var z=this._getCookie(name,0);
	if ((z)&&(z.length)){
		if (!this._fake && this._hrrar) 
			for (var i=0; i<z.length; i++) 
				if ( this._hrrar[i]) z[i]=0;
		if (this.cellWidthType=='px')
			this.cellWidthPX=z.split(",");
		else
			this.cellWidthPC=z.split(",");
		}
	this.setSizes();
    return true;
}

/**   @desc: clear cookie with grid config details
*     @type: public
*     @param: name - optional,cookie name
*     @edition: Professional
*     @topic: 2
*/
dhtmlXGridObject.prototype.clearConfigCookie=function(name){
	if (!name) name=this.entBox.id;
	var str = "gridSettings"+name + "=||||";
	document.cookie = str;
}
dhtmlXGridObject.prototype.clearSizeCookie=dhtmlXGridObject.prototype.clearConfigCookie;


/**   @desc: save cookie
*     @type: private
*     @param: name - cookie name
*     @param: value - cookie value
*     @param: cookie_param - additional parameters added to cookie
*     @edition: Professional
*     @topic: 0
*/

dhtmlXGridObject.prototype.setCookie=function(name,cookie_param,pos,value) {
	if (!name) name=this.entBox.id;
	var t=this.getCookie(name);
	t=(t||"||||").split("|");
	t[pos]=value;
	var str = "gridSettings"+name + "=" + t.join("|").replace(/,/g,"-") +  (cookie_param?("; "+cookie_param):"");
//	console.log("save",str)
	document.cookie = str;
}

/**   @desc: get cookie
*     @type: private
*     @param: name - cookie name
*     @edition: Professional
*     @topic: 0
*/
dhtmlXGridObject.prototype.getCookie=function(name,surname) { 
	if (!name) name=this.entBox.id;
	name=(surname||"gridSettings")+name;
	var search = name + "=";
	if (document.cookie.length > 0) {
		var offset = document.cookie.indexOf(search);
		if (offset != -1) {
			offset += search.length;
			var end = document.cookie.indexOf(";", offset);
			if (end == -1)
				end = document.cookie.length;
			return document.cookie.substring(offset, end);
						}		}
};
dhtmlXGridObject.prototype._getCookie=function(name,pos) {
//	console.log("get",this.getCookie(name))
	return ((this.getCookie(name)||"||||").replace(/-/g,",").split("|"))[pos];
}
//(c)dhtmlx ltd. www.dhtmlx.com
//v.3.6 build 131108

/*
Copyright DHTMLX LTD. http://www.dhtmlx.com
To use this component please contact sales@dhtmlx.com to obtain license
*/
function dhtmlXGridFromTable(obj,init){
      if(typeof(obj)!='object')
         obj = document.getElementById(obj);
            var w=document.createElement("DIV");
            w.setAttribute("width",obj.getAttribute("gridWidth")||(obj.offsetWidth?(obj.offsetWidth+"px"):0)||(window.getComputedStyle?window.getComputedStyle(obj,null)["width"]:(obj.currentStyle?obj.currentStyle["width"]:0)));
            w.setAttribute("height",obj.getAttribute("gridHeight")||(obj.offsetHeight?(obj.offsetHeight+"px"):0)||(window.getComputedStyle?window.getComputedStyle(obj,null)["height"]:(obj.currentStyle?obj.currentStyle["height"]:0)));
			w.className = obj.className;
			obj.className="";
			if (obj.id) w.id = obj.id;

            var mr=obj;
            var drag=obj.getAttribute("dragAndDrop");
            mr.parentNode.insertBefore(w,mr);
            var f=mr.getAttribute("name")||("name_"+(new Date()).valueOf());

            var windowf=new dhtmlXGridObject(w);
            window[f]=windowf;

            var acs=mr.getAttribute("onbeforeinit");
            var acs2=mr.getAttribute("oninit");

			if (acs) eval(acs);

        	windowf.setImagePath(windowf.imgURL||(mr.getAttribute("imgpath")|| mr.getAttribute("image_path") ||""));
			var skin = mr.getAttribute("skin");
			if (skin) windowf.setSkin(skin);

        	if (init) init(windowf);

            var hrow=mr.rows[0];
            var za="";
            var zb="";
            var zc="";
            var zd="";
            var ze="";

            for (var i=0; i<hrow.cells.length; i++){
                za+=(za?",":"")+hrow.cells[i].innerHTML;
                var width=hrow.cells[i].getAttribute("width")||hrow.cells[i].offsetWidth||(window.getComputedStyle?window.getComputedStyle(hrow.cells[i],null)["width"]:(hrow.cells[i].currentStyle?hrow.cells[i].currentStyle["width"]:0));
                zb+=(zb?",":"")+(width=="*"?width:parseInt(width));
                zc+=(zc?",":"")+(hrow.cells[i].getAttribute("align")||"left");
                zd+=(zd?",":"")+(hrow.cells[i].getAttribute("type")||"ed");
                ze+=(ze?",":"")+(hrow.cells[i].getAttribute("sort")||"str");
            	var f_a=hrow.cells[i].getAttribute("format");
            	if (f_a)
            		if(hrow.cells[i].getAttribute("type").toLowerCase().indexOf("calendar")!=-1) 
            			windowf._dtmask=f_a;
            		else
            			windowf.setNumberFormat(f_a,i);
            }

        	windowf.setHeader(za);
        	windowf.setInitWidths(zb)
        	windowf.setColAlign(zc)
        	windowf.setColTypes(zd);
        	windowf.setColSorting(ze);
			if (obj.getAttribute("gridHeight")=="auto")
		    	windowf.enableAutoHeigth(true);

			if (obj.getAttribute("multiline")) windowf.enableMultiline(true);

			var lmn=mr.getAttribute("lightnavigation");
			if (lmn) windowf.enableLightMouseNavigation(lmn);

			var evr=mr.getAttribute("evenrow");
			var uevr=mr.getAttribute("unevenrow");

			if (evr||uevr) windowf.enableAlterCss(evr,uevr);
			if (drag) windowf.enableDragAndDrop(true);

            windowf.init();
            if (obj.getAttribute("split")) windowf.splitAt(obj.getAttribute("split"));

            //adding rows
            windowf._process_inner_html(mr,1);
            
			if (acs2) eval(acs2);            
			if (obj.parentNode && obj.parentNode.removeChild)
				obj.parentNode.removeChild(obj);
     return windowf;

            }
dhtmlXGridObject.prototype._process_html=function(xml){
	if (xml.tagName && xml.tagName == "TABLE") return this._process_inner_html(xml,0);
	var temp=document.createElement("DIV");
	temp.innerHTML=xml.xmlDoc.responseText;
	var mr = temp.getElementsByTagName("TABLE")[0];
	this._process_inner_html(mr,0);
}
dhtmlXGridObject.prototype._process_inner_html=function(mr,start){
	var n_l=mr.rows.length;
	for (var j=start; j<n_l; j++){
		var id=mr.rows[j].getAttribute("id")||j;
		this.rowsBuffer.push({ idd:id, data:mr.rows[j], _parser: this._process_html_row, _locator:this._get_html_data });
	}
	this.render_dataset();
	this.setSizes();
}
   
dhtmlXGridObject.prototype._process_html_row=function(r,xml){
	var cellsCol = xml.getElementsByTagName('TD');
    var strAr = [];
    
	r._attrs=this._xml_attrs(xml);
	
	//load cell data
    for(var j=0;j<cellsCol.length;j++){
    	var cellVal=cellsCol[j];
        var exc=cellVal.getAttribute("type");
        if (r.childNodes[j]){
        	if (exc)
        		r.childNodes[j]._cellType=exc;
       		r.childNodes[j]._attrs=this._xml_attrs(cellsCol[j]);
   		}
       
		if (cellVal.firstChild)
		    strAr.push(cellVal.innerHTML);
		else strAr.push("");
        
        if (cellVal.colSpan>1){
            r.childNodes[j]._attrs["colspan"]=cellVal.colSpan;		
            for (var k=1; k<cellVal.colSpan; k++){
                strAr.push("")
            }
        }
		
}
	for(j<cellsCol.length; j<r.childNodes.length; j++)
        r.childNodes[j]._attrs={};

        
    //back to common code
	this._fillRow(r,(this._c_order?this._swapColumns(strAr):strAr));
    return r;
}
dhtmlXGridObject.prototype._get_html_data=function(data,ind){
	data=data.firstChild;
	while (true){
		if (!data) return "";
		if (data.tagName=="TD") ind--;
		if (ind<0) break;
		data=data.nextSibling;
	}
  return (data.firstChild?data.firstChild.data:"");
}



dhtmlxEvent(window,"load",function(){
    var z=document.getElementsByTagName("table");
    for (var a=0; a<z.length; a++)
        if (z[a].className=="dhtmlxGrid"){
            dhtmlXGridFromTable(z[a]);
            //we have found IT!
        }
});


//(c)dhtmlx ltd. www.dhtmlx.com

//v.3.6 build 131108

/*
Copyright DHTMLX LTD. http://www.dhtmlx.com
To use this component please contact sales@dhtmlx.com to obtain license
*/
/**
*	@desc: enable Undo/Redo functionality in grid
*	@type: public
*	@edition: Professional
*/
dhtmlXGridObject.prototype.enableUndoRedo = function()
{ 
	var self = this;
	var func = function() {return self._onEditUndoRedo.apply(self,arguments);}
	this.attachEvent("onEditCell", func);
	var func2 = function(a,b,c) {return self._onEditUndoRedo.apply(self,[2,a,b,(c?1:0),(c?0:1)]);}		
	this.attachEvent("onCheckbox", func2);
	this._IsUndoRedoEnabled = true;
	this._UndoRedoData = [];
	this._UndoRedoPos = -1;
}
/**
*	@desc: disable Undo/Redo functionality in grid
*	@type: public
*	@edition: Professional
*/
dhtmlXGridObject.prototype.disableUndoRedo = function()
{
	this._IsUndoRedoEnabled = false;
	this._UndoRedoData = [];
	this._UndoRedoPos = -1;
}

dhtmlXGridObject.prototype._onEditUndoRedo = function(stage, row_id, cell_index, new_value, old_value)
{
	if (this._IsUndoRedoEnabled && stage == 2 && old_value != new_value) {
	    if (this._UndoRedoPos !== -1 && this._UndoRedoPos != ( this._UndoRedoData.length-1 ) ) {
	        this._UndoRedoData = this._UndoRedoData.slice(0, this._UndoRedoPos+1);
	    } else if (this._UndoRedoPos === -1 && this._UndoRedoData.length > 0) {
	        this._UndoRedoData = [];
	    }

	    var obj = { old_value:old_value,
	                new_value:new_value,
	                row_id:row_id,
	                cell_index:cell_index
	    };
	    this._UndoRedoData.push(obj);
	    this._UndoRedoPos++;
	}
	return true;
}
/**
*	@desc: UnDo
*	@type: public
*	@edition: Professional
*/
dhtmlXGridObject.prototype.doUndo = function()
{
	if (this._UndoRedoPos === -1)
		return false;
	var obj = this._UndoRedoData[this._UndoRedoPos--];
	var c=this.cells(obj.row_id, obj.cell_index);
	if (this.getColType(obj.cell_index)=="tree")
		c.setLabel(obj.old_value);
	else
		c.setValue(obj.old_value);

	this.callEvent("onUndo", [obj.row_id]);
}
/**
*	@desc: ReDo
*	@type: public
*	@edition: Professional
*/
dhtmlXGridObject.prototype.doRedo = function()
{
	if (this._UndoRedoPos == this._UndoRedoData.length-1)
		return false;
	var obj = this._UndoRedoData[++this._UndoRedoPos];
	this.cells(obj.row_id, obj.cell_index).setValue(obj.new_value);

	this.callEvent("onUndo", [obj.row_id]);
}
/**
*	@desc: get length of available ReDo operations
*	@type: public
*	@edition: Professional
*/
dhtmlXGridObject.prototype.getRedo = function()
{
	if (this._UndoRedoPos == this._UndoRedoData.length-1)
		return [];
	return this._UndoRedoData.slice(this._UndoRedoPos+1);
}
/**
*	@desc: get length of available UnDo operations
*	@type: public
*	@edition: Professional
*/
dhtmlXGridObject.prototype.getUndo = function()
{
	if (this._UndoRedoPos == -1)
		return [];
	return this._UndoRedoData.slice(0, this._UndoRedoPos+1);
}
//(c)dhtmlx ltd. www.dhtmlx.com
//v.3.6 build 131108

/*
Copyright DHTMLX LTD. http://www.dhtmlx.com
To use this component please contact sales@dhtmlx.com to obtain license
*/
function eXcell_sub_row(cell){
	if (cell){
		this.cell = cell;
    	this.grid = this.cell.parentNode.grid;
	}
	
	this.getValue = function(){
		return this.grid.getUserData(this.cell.parentNode.idd,"__sub_row");
	}
	this._setState = function(m,v){
		(v||this.cell).innerHTML="<img src='"+this.grid.imgURL+m+"' width='18' height='18' />";
		(v||this.cell).firstChild.onclick=this.grid._expandMonolite;
	}
	this.open = function (){
		this.cell.firstChild.onclick(null,true)
	}
	this.close = function (){
		this.cell.firstChild.onclick(null,false,true)
	}
	this.isOpen = function(){
		return !!this.cell.parentNode._expanded;
	}
	this.setValue = function(val){
		if (val)
			this.grid.setUserData(this.cell.parentNode.idd,"__sub_row",val);
		this._setState(val?"plus.gif":"blanc.gif");
	}
	this.setContent = function(val){
		if (this.cell.parentNode._expanded){
			this.cell.parentNode._expanded.innerHTML=val;
			this.resize();
		}
		else{
			this.cell._previous_content=null;
			this.setValue(val);
			this.cell._sub_row_type=null
		}
			
	}
	this.resize = function(){
		this.grid._detectHeight(this.cell.parentNode._expanded,this.cell,this.cell.parentNode._expanded.scrollHeight);
	},
	this.isDisabled = function(){ return true; }
	this.getTitle = function(){ return this.grid.getUserData(this.cell.parentNode.idd,"__sub_row")?"click to expand|collapse":""; }
}
eXcell_sub_row.prototype = new eXcell;

function eXcell_sub_row_ajax(cell){
	this.base=eXcell_sub_row;
	this.base(cell);
	
	this.setValue = function(val){
		if (val)
			this.grid.setUserData(this.cell.parentNode.idd,"__sub_row",val);
			this.cell._sub_row_type="ajax";
			this.cell._previous_content = null;
		this._setState(val?"plus.gif":"blanc.gif");
	}
}
eXcell_sub_row_ajax.prototype = new eXcell_sub_row;

function eXcell_sub_row_grid(cell){
	this.base=eXcell_sub_row;
	this.base(cell);
	
	this.setValue = function(val){
		if (val)
			this.grid.setUserData(this.cell.parentNode.idd,"__sub_row",val);
			this.cell._sub_row_type="grid";
		this._setState(val?"plus.gif":"blanc.gif");
	}
	this.getSubGrid = function(){
		if (!cell._sub_grid) return null;
		return cell._sub_grid;
	}
}
eXcell_sub_row_grid.prototype = new eXcell_sub_row;

dhtmlXGridObject.prototype._expandMonolite=function(n,show,hide){
	var td=this.parentNode;
	var row=td.parentNode;
	var that=row.grid;
	
	if (n||window.event){
		if (!hide && !row._expanded) that.editStop();
		(n||event).cancelBubble=true;
	}
	
	var c=that.getUserData(row.idd,"__sub_row");
	
	if (!that._sub_row_editor)
    	that._sub_row_editor=new eXcell_sub_row(td);
	
	if (!c) return;
	
	if (row._expanded && !show){
		that._sub_row_editor._setState("plus.gif",td);
		td._previous_content=row._expanded;
		that.objBox.removeChild(row._expanded);
		row._expanded=false;
		row.style.height=(row.oldHeight||20)+"px";
		td.style.height=(row.oldHeight||20)+"px";	
		
		if (that._fake)
			that._fake.rowsAr[row.idd].style.height=(row.oldHeight||20)+"px";
			
		for (var i=0; i<row.cells.length; i++){
			row.cells[i].style.verticalAlign="middle";
			row.cells[i].style.paddingTop="0px";
		}
		
		delete that._flow[row.idd];
		that._correctMonolite();
		row._expanded.ctrl=null;
	}else if (!row._expanded && !hide){
		that._sub_row_editor._setState("minus.gif",td);
		row.oldHeight=td.offsetHeight;
		if (td._previous_content){
			var d=td._previous_content;
			d.ctrl=td;
			that.objBox.appendChild(d);
			that._detectHeight(d,td,parseInt(d.style.height))	
		}
		else {
			var d=document.createElement("DIV");
			d.ctrl=td;
			if (td._sub_row_type)
				that._sub_row_render[td._sub_row_type](that,d,td,c);
			else
				d.innerHTML=c;
			d.style.cssText="position:absolute; left:0px; top:0px; overflow:auto; font-family:Tahoma; font-size:8pt; margin-top:2px; margin-left:4px;";
			d.className="dhx_sub_row";
			that.objBox.appendChild(d);
			that._detectHeight(d,td)			
		}
		

			
		
		if (!that._flow) {
			that.attachEvent("onGridReconstructed",function(){ 
				if ((this.pagingOn && !this.parentGrid) || this._srnd) this._collapsMonolite();
				else this._correctMonolite(); 
			});
			that.attachEvent("onResizeEnd",function(){ this._correctMonolite(true); });
			that.attachEvent("onAfterCMove",function(){ this._correctMonolite(true); });
			that.attachEvent("onDrop",function(){ this._correctMonolite(true); });
			that.attachEvent("onBeforePageChanged",function(){ this._collapsMonolite(); return true; });
			that.attachEvent("onGroupStateChanged",function(){ this._correctMonolite(); return true; });
			that.attachEvent("onFilterEnd",function(){ this._collapsMonolite(); });
			that.attachEvent("onUnGroup",function(){ this._collapsMonolite(); });
			that.attachEvent("onPageChanged",function(){ this._collapsMonolite(); });
			
			that.attachEvent("onXLE",function(){ this._collapsMonolite(); });
			that.attachEvent("onClearAll",function(){ for (var i in this._flow) {
				if (this._flow[i] && this._flow[i].parentNode) this._flow[i].parentNode.removeChild(this._flow[i]);
			}; this._flow=[]; });
			that.attachEvent("onEditCell",function(a,b,c){  if ((a!==2) && this._flow[b] && this.cellType[c]!="ch" && this.cellType[c]!="ra") this._expandMonolite.apply(this._flow[b].ctrl.firstChild,[0,false,true]);  return true; });
			that.attachEvent("onCellChanged",function(id,ind){ if (!this._flow[id]) return; 
				var c=this.cells(id,ind).cell;
				c.style.verticalAlign="top";
				c.style.paddingTop="3px";
			});
			
			that._flow=[];
		}
		that._flow[row.idd]=d;
		that._correctMonolite();
		//d.style.top=row.offsetTop+20+"px";
		
		var padtop = that._srdh > 30 ? 11:3;
		for (var i=0; i<row.cells.length; i++){
			row.cells[i].style.verticalAlign="top";
			row.cells[i].style.paddingTop=padtop+"px";
		}
		if (that._fake){
			var frow=that._fake.rowsAr[row.idd];
			for (var i=0; i<frow.cells.length; i++){
				frow.cells[i].style.verticalAlign="top";
				frow.cells[i].style.paddingTop=padtop+"px";
			}
		}
		td.style.paddingTop=(padtop-1)+"px";
		row._expanded=d;
	}
	if (that._ahgr)
		that.setSizes()
	if (that.parentGrid)
		that.callEvent("onGridReconstructed",[]);
	that.callEvent("onSubRowOpen",[row.idd,(!!row._expanded)]);
}
dhtmlXGridObject.prototype._sub_row_render={
    "ajax":function(that,d,td,c){
        d.innerHTML="Loading...";
        //d.innerHTML=that.i18n.loading;
        var xml=new dtmlXMLLoaderObject(function(){
            d.innerHTML=xml.xmlDoc.responseText;
            var z=xml.xmlDoc.responseText.match(/<script[^>]*>([^\f]+?)<\/script>/g);
            if (z)
                for (var i=0; i<z.length; i++)
                    eval(z[i].replace(/<([\/]{0,1})s[^>]*>/g,""));

			that._detectHeight(d,td)
			that._correctMonolite();
			that.setUserData(td.parentNode.idd,"__sub_row",xml.xmlDoc.responseText);
			td._sub_row_type=null;
			if (that._ahgr)
				that.setSizes()
			that.callEvent("onSubAjaxLoad",[td.parentNode.idd,xml.xmlDoc.responseText]);
		}, this,true,true);
		xml.loadXML(c);
	},
	"grid":function(that,d,td,c){
		   td._sub_grid= new dhtmlXGridObject(d);
		   if (that.skin_name)
				td._sub_grid.setSkin(that.skin_name);
				
		   td._sub_grid.parentGrid=that;
		   td._sub_grid.setImagePath(that.imgURL);
		   td._sub_grid.enableAutoHeight(true);
		   td._sub_grid._delta_x = td._sub_grid._delta_y = null;
		   td._sub_grid.attachEvent("onGridReconstructed",function(){
		   		that._detectHeight(d,td,td._sub_grid.objBox.scrollHeight+td._sub_grid.hdr.offsetHeight+(this.ftr?this.ftr.offsetHeight:0));
		   		that._correctMonolite();
		   		this.setSizes();
		   		if (that.parentGrid) that.callEvent("onGridReconstructed",[]);
	   	   })
		   if (!that.callEvent("onSubGridCreated",[td._sub_grid,td.parentNode.idd,td._cellIndex,c])) return;
		   td._sub_grid.loadXML(c,function(){
				that._detectHeight(d,td,td._sub_grid.objBox.scrollHeight+td._sub_grid.hdr.offsetHeight+(td._sub_grid.ftr?td._sub_grid.ftr.offsetHeight:0));
				td._sub_grid.objBox.style.overflow="hidden";
				that._correctMonolite();
				td._sub_row_type=null;
				if (!that.callEvent("onSubGridLoaded",[td._sub_grid,td.parentNode.idd,td._cellIndex,c])) return;
				if (that._ahgr) that.setSizes();
		   	});		   
	}
}

dhtmlXGridObject.prototype._detectHeight=function(d,td,h){
	var l=td.offsetLeft+td.offsetWidth;
		d.style.left=l+"px";
		d.style.width=Math.max(0,td.parentNode.offsetWidth-l-4)+"px"
		var h=h||d.scrollHeight;
		d.style.overflow="hidden";
		d.style.height=h+"px";		
		var row=td.parentNode;
		td.parentNode.style.height=(row.oldHeight||20)+3+h*1+"px";	
		td.style.height=(row.oldHeight||20)+3+h*1+"px";	
		if (this._fake){
			var tr=this._fake.rowsAr[td.parentNode.idd];
			tr.style.height=(row.oldHeight||20)+3+h*1+"px";	
		}
}
dhtmlXGridObject.prototype._correctMonolite=function(mode){
	if (this._in_correction) return;
	this._in_correction=true;
	
	for (var a in this._flow)
		if (this._flow[a] && this._flow[a].tagName=="DIV")
			if (this.rowsAr[a]){			
				if (this.rowsAr[a].style.display=="none") {
					this.cells4(this._flow[a].ctrl).close();
					continue;
				}
				this._flow[a].style.top=this.rowsAr[a].offsetTop+(this.rowsAr[a].oldHeight||20)+"px";
				if (mode) {
					var l=this._flow[a].ctrl.offsetLeft+this._flow[a].ctrl.offsetWidth;
					this._flow[a].style.left=l+"px";
					this._flow[a].style.width=this.rowsAr[a].offsetWidth-l-4+"px"
				}
			}
			else{
				this._flow[a].ctrl=null;
				this.objBox.removeChild(this._flow[a]);
				delete this._flow[a];
			}

	this._in_correction=false;
}
dhtmlXGridObject.prototype._collapsMonolite=function(){
		for (var a in this._flow)
			if (this._flow[a] && this._flow[a].tagName=="DIV")
				if (this.rowsAr[a])
					this.cells4(this._flow[a].ctrl).close();
}
//(c)dhtmlx ltd. www.dhtmlx.com

//v.3.6 build 131108

/*
Copyright DHTMLX LTD. http://www.dhtmlx.com
To use this component please contact sales@dhtmlx.com to obtain license
*/
//all purpose set of rules, based on http://code.google.com/p/validation-js
dhtmlxValidation=function(){};
dhtmlxValidation.prototype={
	trackInput:function(el,rule,callback_error,callback_correct){
			dhtmlxEvent(el,"keyup",function(e){ 
				if (dhtmlxValidation._timer) {
					window.clearTimeout(dhtmlxValidation._timer);
					dhtmlxValidation._timer = null;
				}
				dhtmlxValidation._timer = window.setTimeout(function(){

					if (!dhtmlxValidation.checkInput(el,rule)){
						if(!callback_error || callback_error(el,el.value,rule))
							el.className+=" dhtmlx_live_validation_error";
					} else {
						el.className=el.className.replace(/[ ]*dhtmlx_live_validation_error/g,"");
						if (callback_correct)
							callback_correct(el,el.value,rule);
					}
				
				},250);
			});
	},
	checkInput:function(input,rule){
		return this.checkValue(input.value,rule);
	},
	checkValue:function(value,rule){
		if (typeof rule=="string")
			rule = rule.split(",");
			
		var final_res=true;
		for (var i=0; i<rule.length; i++){
			if (!this["is"+rule[i]])
				alert("Incorrect validation rule: "+rule[i]);
			else
				final_res=final_res&&this["is"+rule[i]](value);;
		}
		return final_res;
	},
	isEmpty: function(value) {
		return value == '';
	},
	isNotEmpty: function(value) {
		return !value == '';
	},
	isValidBoolean: function(value) {
		return !!value.toString().match(/^(0|1|true|false)$/);
	},
	isValidEmail: function(value) {
		return !!value.toString().match(/(^[a-z0-9]([0-9a-z\-_\.]*)@([0-9a-z_\-\.]*)([.][a-z]{3})$)|(^[a-z]([0-9a-z_\.\-]*)@([0-9a-z_\-\.]*)(\.[a-z]{2,4})$)/i); 
	},
	isValidInteger: function(value) {
		return !!value.toString().match(/(^-?\d+$)/);
	},
	isValidNumeric: function(value) {
		return !!value.toString().match(/(^-?\d\d*[\.|,]\d*$)|(^-?\d\d*$)|(^-?[\.|,]\d\d*$)/);
	},
	isValidAplhaNumeric: function(value) {
		return !!value.toString().match(/^[_\-a-z0-9]+$/gi);
	},
	// 0000-00-00 00:00:00 to 9999:12:31 59:59:59 (no it is not a "valid DATE" function)
	isValidDatetime: function(value) {
		var dt = value.toString().match(/^(\d{4})-(\d{2})-(\d{2})\s(\d{2}):(\d{2}):(\d{2})$/);
		return dt && !!(dt[1]<=9999 && dt[2]<=12 && dt[3]<=31 && dt[4]<=59 && dt[5]<=59 && dt[6]<=59) || false;
	},
	// 0000-00-00 to 9999-12-31
	isValidDate: function(value) {
		var d = value.toString().match(/^(\d{4})-(\d{2})-(\d{2})$/);
		return d && !!(d[1]<=9999 && d[2]<=12 && d[3]<=31) || false;
	},
	// 00:00:00 to 59:59:59
	isValidTime: function(value) {
		var t = value.toString().match(/^(\d{1,2}):(\d{1,2}):(\d{1,2})$/);
		return t && !!(t[1]<=24 && t[2]<=59 && t[3]<=59) || false;
	},
	// 0.0.0.0 to 255.255.255.255
	isValidIPv4: function(value) { 
		var ip = value.toString().match(/^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})$/);
		return ip && !!(ip[1]<=255 && ip[2]<=255 && ip[3]<=255 && ip[4]<=255) || false;
	},
	isValidCurrency: function(value) { // Q: Should I consider those signs valid too ? : |
		return value.toString().match(/^\$?\s?\d+?[\.,\,]?\d+?\s?\$?$/) && true || false;
	},
	// Social Security Number (999-99-9999 or 999999999)
	isValidSSN: function(value) {
		return value.toString().match(/^\d{3}\-?\d{2}\-?\d{4}$/) && true || false;
	},
	// Social Insurance Number (999999999)
	isValidSIN: function(value) {
		return value.toString().match(/^\d{9}$/) && true || false;
	}	
};
dhtmlxValidation=new dhtmlxValidation();
//extension for the grid
dhtmlXGridObject.prototype.enableValidation=function(mode,live){
	mode=convertStringToBoolean(mode);
	if (mode){
		this._validators={ data:[] };
	}else
		this._validators=false;
		
	if (arguments.length>1)
		this._validators._live=live;
	if (!this._validators._event)
		this._validators._event=this.attachEvent("onEditCell",this.validationEvent);
		
	};
dhtmlXGridObject.prototype.setColValidators=function(vals){
	if (!this._validators) this.enableValidation(true);
	if (typeof vals == "string") vals=vals.split(this.delim);
	this._validators.data=vals;
};
dhtmlXGridObject.prototype.validationEvent=function(stage,id,ind,newval,oldval){
	var v=this._validators; 
	if (!v) return true; // validators disabled
	var rule=(v.data[ind]||this.cells(id,ind).getAttribute("validate"))||"";
	
	if (stage==1 && rule){
		var ed = this.editor||(this._fake||{}).editor;
		if (!ed) return true; //event was trigered by checkbox
		ed.cell.className=ed.cell.className.replace(/[ ]*dhtmlx_validation_error/g,"");
		if (v._live){
			var grid=this;
			dhtmlxValidation.trackInput(ed.getInput(),rule,function(element,value,rule){
				return grid.callEvent("onLiveValidationError",[id,ind,value,element,rule]);
			},function(element,value,rule){
				return grid.callEvent("onLiveValidationCorrect",[id,ind,value,element,rule]);
			});
		}
	}

	if (stage==2)
		this.validateCell(id,ind,rule,newval);
	
	return true;
};

dhtmlXGridObject.prototype.validateCell=function(id,ind,rule,value){
	rule=rule||(this._validators.data[ind]||this.cells(id,ind).getAttribute("validate"));
	value=value||this.cells(id,ind).getValue();
	if (!rule) return;
	var cell = this.cells(id,ind).cell;

	var result = true;
	if (typeof rule == "string")
		rule = rule.split(this.delim);
		
	for (var i=0; i < rule.length; i++) {
		if (!dhtmlxValidation.checkValue(value,rule[i])){
			if (this.callEvent("onValidationError",[id,ind,value,rule[i]]))
				cell.className+=" dhtmlx_validation_error";
			result = false;
		}
	}
	if (result){
		this.callEvent("onValidationCorrect",[id,ind,value,rule]);
		cell.className=cell.className.replace(/[ ]*dhtmlx_validation_error/g,"");		
	}
	return result;
};
//v.3.6 build 131108

/*
Copyright DHTMLX LTD. http://www.dhtmlx.com
To use this component please contact sales@dhtmlx.com to obtain license
*/
   //next function switch grid between fast and normal operation modes
   //limitation - will not work for paging|smart_rendering|dynamic|split modes, most events will not be generated
   
/**
*   @desc: start fast operation mode, in such mode events are not generated, some time consuming actions applied only once, which allow to increase performance
*   @type: public
*   @topic: 0
*/   
   dhtmlXGridObject.prototype.startFastOperations   =    function(){
   		this._disF=["setSizes","callEvent","_fixAlterCss","cells4","forEachRow"];
   		this._disA=[];
   		for (var i = this._disF.length - 1; i >= 0; i--){
   			this._disA[i]=this[this._disF[i]]; this[this._disF[i]]=function(){return true};
   		};
   		
   		this._cellCache=[];
   		this.cells4=function(cell){
   			var c=this._cellCache[cell._cellIndex]
   			if (!c){
   				c=this._cellCache[cell._cellIndex]=this._disA[3].apply(this,[cell]);
	   			c.destructor=function(){return true;}
   				c.setCValue=function(val){c.cell.innerHTML=val;}
   			}
   			
   			c.cell=cell;
   			c.combo=cell._combo||this.combos[cell._cellIndex];
   			return c;
   		}
   		
   }
/**
*   @desc: turn off fast operation mode, need to be executed to normalize view.
*   @type: public
*   @topic: 0
*/      
   dhtmlXGridObject.prototype.stopFastOperations   =    function(){
   		if (!this._disF) return;
   		for (var i = this._disF.length - 1; i >= 0; i--){
   			this[this._disF[i]]=this._disA[i];
   		};
   		
   		this.setSizes();
   		this.callEvent("onGridReconstructed",[]);
   }
   
   //(c)dhtmlx ltd. www.dhtmlx.com
//v.3.6 build 131108

/*
Copyright DHTMLX LTD. http://www.dhtmlx.com
To use this component please contact sales@dhtmlx.com to obtain license
*/
  /**
  *   @desc: sets marked cells support to enabled or disabled state
  *   @type: public
  *   @param: state - true or false
  */
 dhtmlXGridObject.prototype.enableMarkedCells = function(fl){
  	this.markedRowsArr = new dhtmlxArray(0);
	this.markedCellsArr = new Array(0);
	this.lastMarkedRow = null;
	this.lastMarkedColumn = null;
 	this.markedCells = true;
	this.lastMarkMethod = 0;
	if(arguments.length>0){
		if(!convertStringToBoolean(fl))
			this.markedCells = false;
	}
 };
  /**
  *   @desc: occures on cell click
  *   @type: private
  *   @param: [el] - cell to click on
  *   @param: [markMethod] - 0 - simple click, 1 - shift, 2 - ctrl
  */
 dhtmlXGridObject.prototype.doMark = function(el,markMethod){ 

				var _rowId = el.parentNode.idd;
				this.setActive(true);
				if (!_rowId) return;
				this.editStop();
				this.cell=el;
				this.row=el.parentNode;
				var _cellIndex = el._cellIndex;				
				
				if(!markMethod) markMethod = 0;
				
           	    if(markMethod==0){
                    this.unmarkAll() ;	 
                }
				else if(markMethod==1){
					
					if(this.lastMarkedRow) {
						var r_start = Math.min(this.getRowIndex(_rowId),this.getRowIndex(this.lastMarkedRow));
						var r_end = Math.max(this.getRowIndex(_rowId),this.getRowIndex(this.lastMarkedRow));
						
						var c_start = Math.min(_cellIndex,this.lastMarkedColumn);
						var c_end = Math.max(_cellIndex,this.lastMarkedColumn);
					
						for(var i = r_start; i < r_end+1; i++){
							for(var j = c_start; j < c_end+1; j++){
								this.mark(this.getRowId(i),j,true);
								
							}
						}
					}
				}
				else if(markMethod==2){
					if(this.markedRowsArr._dhx_find(_rowId)!=-1){ 
						for(var ci = 0; ci < this.markedCellsArr[_rowId].length; ci++){
							if(this.markedCellsArr[_rowId][ci]==_cellIndex){
								this.mark(_rowId,_cellIndex,false);
								return true;
							}
						}
						
					}
					
				}
				
				if(!this.markedCellsArr[_rowId]) 
					this.markedCellsArr[_rowId] = new dhtmlxArray(0);
				
				if(markMethod!=1) 
					this.mark(_rowId,_cellIndex);
					
				this.moveToVisible(this.cells(_rowId,_cellIndex).cell);
				this.lastMarkedRow = _rowId;
				this.lastMarkedColumn = _cellIndex;
				this.lastMarkMethod = markMethod;
				
 }
/**
  	*   @desc: sets selection or removes selection from specified cell
    *   @param: r - row object or row index
    *   @param: cInd - cell index
    *   @param: state - true or false 
	*   @type: public
 */
dhtmlXGridObject.prototype.mark = function(rid,cindex,fl){
	if(arguments.length>2){
		if(!convertStringToBoolean(fl)){
			this.cells(rid,cindex).cell.className = this.cells(rid,cindex).cell.className.replace(/cellselected/g,"");
			if(this.markedRowsArr._dhx_find(rid)!=-1){
				var ci = this.markedCellsArr[rid]._dhx_find(cindex);
				if(ci!=-1){
					this.markedCellsArr[rid]._dhx_removeAt(ci);
					if(this.markedCellsArr[rid].length==0){
						this.markedRowsArr._dhx_removeAt(this.markedRowsArr._dhx_find(rid));
					}
					this.callEvent("onCellUnMarked",[rid,cindex]);
				}
			}
			return true;
		}
	}
	this.cells(rid,cindex).cell.className+= " cellselected";
	
	if(this.markedRowsArr._dhx_find(rid)==-1) 
		this.markedRowsArr[this.markedRowsArr.length] = rid;
		
	if(!this.markedCellsArr[rid]) 
		this.markedCellsArr[rid] = new dhtmlxArray(0);
	if(this.markedCellsArr[rid]._dhx_find(cindex)==-1){
		this.markedCellsArr[rid][this.markedCellsArr[rid].length] = cindex;
		this.callEvent("onCellMarked",[rid,cindex]);
	}
	
}
/**
  	*   @desc: removes selection from all marked cell
   	*   @type: public
 */
dhtmlXGridObject.prototype.unmarkAll = function(){
	if(this.markedRowsArr){
		for(var ri = 0; ri < this.markedRowsArr.length; ri++){
			var rid = this.markedRowsArr[ri];
			if (this.rowsAr[rid])
				for(var ci = 0; ci < this.markedCellsArr[rid].length; ci++){
					this.callEvent("onCellUnMarked",[rid,this.markedCellsArr[rid][ci]])
					this.cells(rid,this.markedCellsArr[rid][ci]).cell.className = this.cells(rid,this.markedCellsArr[rid][ci]).cell.className.replace(/cellselected/g,"");
				}
		} 
		this.markedRowsArr = new dhtmlxArray(0);
		this.markedCellsArr = new Array(0);
	}
	return true;
}
/**
  	*   @desc: gets marked cells
   	*   @returns: the array of marked cells	(pairs of row id and column index)
	*   @type: public
 */
dhtmlXGridObject.prototype.getMarked = function(){
	var marked = new Array();
	if(this.markedRowsArr)
	for(var ri = 0; ri < this.markedRowsArr.length; ri++){
		var rid = this.markedRowsArr[ri];
		for(var ci = 0; ci < this.markedCellsArr[rid].length; ci++){
			marked[marked.length] = [rid,this.markedCellsArr[rid][ci]];
		}
	} 
	return marked;		
}

//v.3.6 build 131108

/*
Copyright DHTMLX LTD. http://www.dhtmlx.com
To use this component please contact sales@dhtmlx.com to obtain license
*/
	dhtmlXGridObject.prototype.post=function(url, post, call, type){
		this.callEvent("onXLS", [this]);
		if (arguments.length == 3 && typeof call != "function"){
			type=call;
			call=null;
		}
		type=type||"xml";
		post=post||"";
	
		if (!this.xmlFileUrl)
			this.xmlFileUrl=url;
		this._data_type=type;
		this.xmlLoader.onloadAction=function(that, b, c, d, xml){
			xml=that["_process_"+type](xml);
			if (!that._contextCallTimer)
			that.callEvent("onXLE", [that,0,0,xml]);
	
			if (call){
				call();
				call=null;
			}
		}
		this.xmlLoader.loadXML(url,true,post);
	}
//v.3.6 build 131108

/*
Copyright DHTMLX LTD. http://www.dhtmlx.com
To use this component please contact sales@dhtmlx.com to obtain license
*/
function eXcell_dhxCalendar(cell){
	if (cell){
      this.cell = cell;
      this.grid = this.cell.parentNode.grid;
                    if (!this.grid._grid_calendarA) {
                    		
                    		var cal=this.grid._grid_calendarA=new dhtmlxCalendarObject();
							cal.setWeekStartDay(7);
                    		this.grid.callEvent("onDhxCalendarCreated",[cal]);
                    		
                    		var sgrid=this.grid;
                    		cal.attachEvent("onClick",function(){
                    			this._last_operation_calendar=true;
                    			window.setTimeout(function(){sgrid.editStop()},1);
                    			return true;
                			});
                    		
							var zFunc=function(e){ (e||event).cancelBubble=true;  }
							dhtmlxEvent(cal.base,"click",zFunc);         
							cal=null;           		
	                    }      
	}
}
eXcell_dhxCalendar.prototype = new eXcell;

	eXcell_dhxCalendar.prototype.edit = function(){

                        var arPos = this.grid.getPosition(this.cell);
                        this.grid._grid_calendarA._show(false, false);
                        this.grid._grid_calendarA.setPosition(arPos[0],arPos[1]+this.cell.offsetHeight);
						this.grid._grid_calendarA._last_operation_calendar=false;						

	                    
	                    this.grid.callEvent("onCalendarShow",[this.grid._grid_calendarA,this.cell.parentNode.idd,this.cell._cellIndex]);
					//var arPos = this.grid.getPosition(this.cell);
                    //var pval=this._date2str2(this.cell.val||new Date());
                    //window._grid_calendar.render(arPos[0],arPos[1]+this.cell.offsetHeight,this,pval);
                    this.cell._cediton=true;
                    this.val=this.cell.val;
					this._val=this.cell.innerHTML;                    
                   // alert(this.cell.val);
                    var t=this.grid._grid_calendarA.draw; this.grid._grid_calendarA.draw=function(){};
				   	this.grid._grid_calendarA.setDateFormat((this.grid._dtmask||"%d/%m/%Y"));
                    this.grid._grid_calendarA.setDate(this.val||(new Date()));
                    this.grid._grid_calendarA.draw=t;
                    
                    //this.grid._grid_calendarA.draw();
				}
	eXcell_dhxCalendar.prototype.getDate = function(){	
		if (this.cell.val) return this.cell.val;
		return null;
	}
	
	eXcell_dhxCalendar.prototype.getValue = function(){
		if (this.cell._clearCell) return "";
		if (this.grid._dtmask_inc && this.cell.val)
			return this.grid._grid_calendarA.getFormatedDate(this.grid._dtmask_inc, this.cell.val).toString();
		return this.cell.innerHTML.toString()._dhx_trim()
	}

	eXcell_dhxCalendar.prototype.detach = function(){   
					if (!this.grid._grid_calendarA) return;
					this.grid._grid_calendarA.hide();
                    if (this.cell._cediton) this.cell._cediton=false;
                    else return;
                    if (this.grid._grid_calendarA._last_operation_calendar){
                    	var z1=this.grid._grid_calendarA.getFormatedDate((this.grid._dtmask||"%d/%m/%Y"));
                    	var z2=this.grid._grid_calendarA.getDate();
                    	this.cell.val=new Date(z2);
    					this.setCValue(z1,z2);
    					this.cell._clearCell=!z1;
    					var t=this.val; this.val=this._val;
						return (this.cell.val.valueOf()!=t);
					}
					return false;
				}

								
	eXcell_dhxCalendar.prototype.setValue = function(val){
						
						if (val && typeof val == "object"){
							this.cell.val=val;
							this.cell._clearCell=false;
							this.setCValue(this.grid._grid_calendarA.getFormatedDate((this.grid._dtmask||"%d/%m/%Y"),val).toString(),this.cell.val);
							return;
						}
						
                        
						if(!val || val.toString()._dhx_trim()==""){
							val="&nbsp";
							this.cell._clearCell=true;
                            this.cell.val="";
							}
						else{
							this.cell._clearCell=false;
							this.cell.val=new Date(this.grid._grid_calendarA.setFormatedDate((this.grid._dtmask_inc||this.grid._dtmask||"%d/%m/%Y"),val.toString(),null,true));
							if (this.grid._dtmask_inc)
								val = this.grid._grid_calendarA.getFormatedDate((this.grid._dtmask||"%d/%m/%Y"),this.cell.val);
						}

                        if ((this.cell.val=="NaN")||(this.cell.val=="Invalid Date")){                        	
                        	this.cell._clearCell=true;
                            this.cell.val=new Date();
                            this.setCValue("&nbsp;",0);
                        }
                        else
    						this.setCValue((val||"").toString(),this.cell.val);
				}


function eXcell_dhxCalendarA(cell){
	if (cell){
      this.cell = cell;
      this.grid = this.cell.parentNode.grid;
                    if (!this.grid._grid_calendarA) {
                    		
                    		
                    		var cal = this.grid._grid_calendarA = new dhtmlxCalendarObject();
                    		this.grid.callEvent("onDhxCalendarCreated",[cal]);
                    		
                    		var sgrid=this.grid;
                    		cal.attachEvent("onClick",function(){
                    			this._last_operation_calendar=true;
                    			window.setTimeout(function(){sgrid.editStop()},1);
                    			return true;
                			});
                    		
							var zFunc=function(e){ (e||event).cancelBubble=true;  }
							dhtmlxEvent(cal.base,"click",zFunc);                    		
	                    }      
	}
}
eXcell_dhxCalendarA.prototype = new eXcell;

	eXcell_dhxCalendarA.prototype.edit = function(){
						var arPos = this.grid.getPosition(this.cell);
						
						

	                    this.grid._grid_calendarA._show(false, false);
	                    this.grid._grid_calendarA.setPosition(arPos[0]*1+this.cell.offsetWidth,arPos[1]*1);
	                    this.grid.callEvent("onCalendarShow",[this.grid._grid_calendarA,this.cell.parentNode.idd,this.cell._cellIndex]);
	                    this.grid._grid_calendarA._last_operation_calendar=false;
					//var arPos = this.grid.getPosition(this.cell);
                    //var pval=this._date2str2(this.cell.val||new Date());
                    //window._grid_calendar.render(arPos[0],arPos[1]+this.cell.offsetHeight,this,pval);
                    this.cell._cediton=true;
                    this.val=this.cell.val;
                    this._val=this.cell.innerHTML;
                   // alert(this.cell.val);
					var t=this.grid._grid_calendarA.draw; this.grid._grid_calendarA.draw=function(){};
				   	this.grid._grid_calendarA.setDateFormat((this.grid._dtmask||"%d/%m/%Y"));
                    this.grid._grid_calendarA.setDate(this.val);
                    this.grid._grid_calendarA.draw=t;
                    this.grid._grid_calendarA.draw();
                    

					this.cell.atag=((!this.grid.multiLine)&&(_isKHTML||_isMacOS||_isFF))?"INPUT":"TEXTAREA";
					
					this.obj = document.createElement(this.cell.atag);
					this.obj.style.height = (this.cell.offsetHeight-(_isIE?4:2))+"px";
                    this.obj.className="dhx_combo_edit";
				   	this.obj.wrap = "soft";
					this.obj.style.textAlign = this.cell.align;
					this.obj.onclick = function(e){(e||event).cancelBubble = true}
					this.obj.onmousedown = function(e){(e||event).cancelBubble = true}
					this.obj.value = this.getValue();
					this.cell.innerHTML = "";
					this.cell.appendChild(this.obj);
				  	if (_isFF) {
						this.obj.style.overflow="visible";
						if ((this.grid.multiLine)&&(this.obj.offsetHeight>=18)&&(this.obj.offsetHeight<40)){
							this.obj.style.height="36px";
							this.obj.style.overflow="scroll";
						}
					}
                    this.obj.onselectstart=function(e){  if (!e) e=event; e.cancelBubble=true; return true;  };
					this.obj.focus()
  					this.obj.focus()
				                    
				}
				
	eXcell_dhxCalendarA.prototype.getDate = function(){	
		if (this.cell.val) return this.cell.val;
		return null;
	}
	
	eXcell_dhxCalendarA.prototype.getValue = function(){
		if (this.cell._clearCell) return "";
		if (this.grid._dtmask_inc && this.cell.val)
			return this.grid._grid_calendarA.getFormatedDate(this.grid._dtmask_inc, this.cell.val).toString();
		return this.cell.innerHTML.toString()._dhx_trim()
	}

	eXcell_dhxCalendarA.prototype.detach = function(){   
					if (!this.grid._grid_calendarA) return;
					this.grid._grid_calendarA.hide();
                    if (this.cell._cediton) this.cell._cediton=false;
                    else return;
                    if (this.grid._grid_calendarA._last_operation_calendar){
                    	this.grid._grid_calendarA._last_operation_calendar=false;
                    	var z1=this.grid._grid_calendarA.getFormatedDate(this.grid._dtmask||"%d/%m/%Y");
                    	var z2=this.grid._grid_calendarA.getDate();
                    	this.cell.val=new Date(z2);
    					this.setCValue(z1,z2);
    					this.cell._clearCell = !z1;
    					var t=this.val; this.val=this._val;
						return (this.cell.val.valueOf()!=(t|"").valueOf());
					}
						this.setValue(this.obj.value);
						var t=this.val; this.val=this._val;
						return (this.cell.val.valueOf()!=(t||"").valueOf());
				}
eXcell_dhxCalendarA.prototype.setValue = function(val){
						if (val && typeof val == "object"){
							this.cell.val=val;
							this.cell._clearCell=false;
							this.setCValue(this.grid._grid_calendarA.getFormatedDate((this.grid._dtmask||"%d/%m/%Y"),val).toString(),this.cell.val);
							return;
						}
						
						if(!val || val.toString()._dhx_trim()==""){
							val="&nbsp";
							this.cell._clearCell=true;
                            this.cell.val="";
							}
 						else{
							this.cell._clearCell=false;
							this.cell.val=new Date(this.grid._grid_calendarA.setFormatedDate((this.grid._dtmask_inc||this.grid._dtmask||"%d/%m/%Y"),val.toString(),null,true));
							if (this.grid._dtmask_inc)
								val = this.grid._grid_calendarA.getFormatedDate((this.grid._dtmask||"%d/%m/%Y"),this.cell.val);
						}
 						
                        if ((this.cell.val=="NaN")||(this.cell.val=="Invalid Date")){
                            this.cell.val=new Date();
                            this.cell._clearCell=true;
                            this.setCValue("&nbsp;",0);
                        }
                        else
    						this.setCValue((val||"").toString(),this.cell.val);
				}

//v.3.6 build 131108

/*
Copyright DHTMLX LTD. http://www.dhtmlx.com
To use this component please contact sales@dhtmlx.com to obtain license
*/
document.write("<script src='"+_js_prefix+"calendar/YAHOO.js'></script>");
document.write("<script src='"+_js_prefix+"calendar/event.js'></script>");
document.write("<script src='"+_js_prefix+"calendar/calendar.js'></script>");
document.write("<script src='"+_js_prefix+"calendar/calendar_init.js'></script>");

document.write("<link rel='stylesheet' type='text/css' href='"+_js_prefix+"calendar/calendar.css'></link>");

/**
*	@desc: calendar editor
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_calendar(cell){
	try{
		this.cell = cell;
		this.grid = this.cell.parentNode.grid;
	}catch(er){}
	this.edit = function(){
                    if (!window._grid_calendar) _grid_calendar_init();
					var arPos = this.grid.getPosition(this.cell);
                    var pval=this._date2str2(this.cell.val||new Date());
                    window._grid_calendar.render(arPos[0],arPos[1]+this.cell.offsetHeight,this,pval);
					var zFunc=function(e){ (e||event).cancelBubble=true;  }
					dhtmlxEvent(window._grid_calendar.table.parentNode.parentNode,"click",zFunc);
                    this.cell._cediton=true;
                    this.val=this.cell.val;
				}
	this.getValue = function(){
		//this.grid.editStop();
        if (this.cell.val) return this._date2str2(this.cell.val);
		return this.cell.innerHTML.toString()._dhx_trim()
	}

	this.getContent = function(){
		return this.cell.innerHTML.toString()._dhx_trim()
	}

	this.detach = function(){   
                    var z=window._grid_calendar.getSelectedDates()[0];
                    window._grid_calendar.hide();
					if (this._skip_detach) return;                    
                    if (!z.getFullYear()) return;
					
                    	this.cell.val=new Date(z.valueOf());
    					this.setCValue(this._date2str(z),z);
    					if (!this.val) return true;
						return (z.valueOf())!=(this.val.valueOf());
					
					return false;
				}
    this._2dg=function(val){
       if (val.toString().length==1)
        return ("0"+val.toString());
       return val;
    }
    this._date2str2=function(z){
      return ("m/d/y").replace("m",this._2dg((z.getMonth()*1+1))).replace("d",this._2dg(z.getDate())).replace("y",this._2dg((z.getFullYear()*1)));
    }
    this._date2str=function(z){
      return (this.grid._dtmask||"m/d/y").replace("m",this._2dg((z.getMonth()*1+1))).replace("d",this._2dg(z.getDate())).replace("y",this._2dg((z.getFullYear()*1)));
    }
}
eXcell_calendar.prototype = new eXcell;
eXcell_calendar.prototype.setValue = function(val){ 
						if(!val || val.toString()._dhx_trim()=="")
							val="";
                        this.cell.val=new Date(val.toString());

                        if ((this.cell.val=="NaN")||(this.cell.val=="Invalid Date")){
                            this.cell.val="";
                            this.setCValue("&nbsp;",0);
                        }
                        else
    						this.setCValue(this._date2str(this.cell.val),this.cell.val);
				}
//(c)dhtmlx ltd. www.dhtmlx.com

//v.3.6 build 131108

/*
Copyright DHTMLX LTD. http://www.dhtmlx.com
To use this component please contact sales@dhtmlx.com to obtain license
*/
/**
*	@desc: integration with dhtmlxCombo editor
*	@returns: dhtmlxGrid cell editor object
*/
dhtmlXGridObject.prototype._init_point_bcg=dhtmlXGridObject.prototype._init_point;
dhtmlXGridObject.prototype._init_point = function(){
	
	if(!window.dhx_globalImgPath) window.dhx_globalImgPath = this.imgURL;

	this._col_combos=[];
	for (var i=0; i<this._cCount; i++){
		if(this.cellType[i].indexOf("combo")==0)
			this._col_combos[i] = eXcell_combo.prototype.initCombo.call({grid:this},i);
	}
	if(!this._loading_handler_set){
		this._loading_handler_set = this.attachEvent("onXLE",function(a,b,c,xml){
			eXcell_combo.prototype.fillColumnCombos(this,xml);
			this.detachEvent(this._loading_handler_set);
			this._loading_handler_set = null;
		})
	}
	//this._init_point=this._init_point_bcg;
	//if (this._init_point) this._init_point();
	if (this._init_point_bcg) this._init_point_bcg();
};


function eXcell_combo(cell){
	
	if(!cell) return;

	this.cell = cell; 
	
	this.grid = cell.parentNode.grid;
	this._combo_pre = "";
	

				
		/**
		*	@desc: method called by grid to start editing
		*/
	this.edit = function(){
		if(!window.dhx_globalImgPath) window.dhx_globalImgPath = this.grid.imgURL;
		this.val=this.getValue();
		var val = this.getText();  
		if(this.cell._clearCell) val="";
		this.cell.innerHTML = "";

		if(!this.cell._brval)
			this.combo = (this.grid._realfake?this.grid._fake:this.grid)._col_combos[this.cell._cellIndex];
		else
			this.combo = this.cell._brval;
			
		this.cell.appendChild(this.combo.DOMParent);
		this.combo.DOMParent.style.margin="0";
	
		this.combo.DOMelem_input.focus();
		this.combo.setSize(this.cell.offsetWidth-2);
		if(!this.combo._xml){
			if(this.combo.getIndexByValue(this.cell.combo_value)!=-1)
				this.combo.selectOption(this.combo.getIndexByValue(this.cell.combo_value));
			else {
				if(this.combo.getOptionByLabel(val))
					this.combo.selectOption(this.combo.getIndexByValue(this.combo.getOptionByLabel(val).value));
				else this.combo.setComboText(val);
			}
		}
		else this.combo.setComboText(val);

		this.combo.openSelect();
	}
	
	this.selectComboOption = function(val,obj){
		obj.selectOption(obj.getIndexByValue(obj.getOptionByLabel(val).value));
	}
	
		/**
		*	@desc: get real value of the cell
		*/
		
	this.getValue = function(val){
		return this.cell.combo_value||"";
	}

	this.getText = function(val){
		var c = this.cell;
		if(this._combo_pre == ""&&c.childNodes[1])
			c = c.childNodes[1];
		else
			c.childNodes[0].childNodes[1];
		return  (_isIE ? c.innerText : c.textContent);
		
	}

	/**
	*	@desc: set formated value to the cell
	*/
	this.setValue = function(val){
		/*for(var i = 0; i < this.cell.parentNode.childNodes.length; i++){
			this.cell.parentNode.childNodes[i].tabIndex = 0;
		}
		*/	
			
		if(typeof(val)=="object"){
			this.cell._brval = this.initCombo();
			var index = this.cell._cellIndex;
			var idd = this.cell.parentNode.idd;
			if(!val.firstChild){
				this.cell.combo_value = "&nbsp;";
				this.cell._clearCell=true;
			}
			else this.cell.combo_value = val.firstChild.data;
			this.setComboOptions(this.cell._brval,val,this.grid,index,idd);
				
		}else{
			this.cell.combo_value = val;	
			var cm=null;
			if ((cm = this.cell._brval) && (typeof(this.cell._brval)=="object"))
				val=(cm.getOption(val)||{}).text||val;
			else if (cm = this.grid._col_combos[this.cell._cellIndex]||((this.grid._fake)&&(cm = this.grid._fake._col_combos[this.cell._cellIndex]))){
				val=(cm.getOption(val)||{}).text||val;
			}
			
						
			if ((val||"").toString()._dhx_trim()=="")
				val = null;
            
			if (val!==null)
 			    this.setComboCValue(val);
            else{
				 this.setComboCValue("&nbsp;","");
				 this.cell._clearCell=true;	 
			}	
		}
	}
	            
		/**
		*	@desc: this method called by grid to close editor
		*   @type: private 
		*/
	this.detach = function(){
		this.cell.removeChild(this.combo.DOMParent);
		var val = this.cell.combo_value;
		if (!this.combo.getComboText() || this.combo.getComboText().toString()._dhx_trim()==""){
			this.setComboCValue("&nbsp;");
			this.cell._clearCell=true;
    	}
		else{
			this.setComboCValue(this.combo.getComboText().replace(/\&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;"),this.combo.getActualValue());
			this.cell._clearCell = false;
		}
		this.combo._confirmSelection();
		this.cell.combo_value = this.combo.getActualValue();
		this.combo.closeAll();
		this.grid._still_active=true;
		this.grid.setActive(1);
		return val!=this.cell.combo_value;
	}
}

				
eXcell_combo.prototype = new eXcell;
eXcell_combo_v=function(cell){
    var combo = new eXcell_combo(cell);
	cell.style.paddingLeft = "0px";
	cell.style.paddingRight = "0px";
    combo._combo_pre = "<img src='"+(window.dhx_globalImgPath?window.dhx_globalImgPath:this.grid.imgURL)+"combo_select"+(dhtmlx.skin?"_"+dhtmlx.skin:"")+".gif' style='position:absolute;z-index:1;top:0px;right:0px;'/>";
    return combo;
}


		/**
		*	@desc: create combo object
		*   @returns: combo object
		*   @type: private 		  
		*/
eXcell_combo.prototype.initCombo = function(index){
	
	var container = document.createElement("DIV");
	var type = this.grid.defVal[arguments.length?index:this.cell._cellIndex];
	var combo = new dhtmlXCombo(container,"combo",0,type);
	this.grid.defVal[arguments.length?index:this.cell._cellIndex] = "";
	
	combo.DOMelem.className+=" fake_editable";
	var grid = this.grid;
	combo.DOMelem.onselectstart=function(){event.cancelBubble=true; return true;};
	combo.attachEvent("onKeyPressed",function(ev){if(ev==13||ev==27) {grid.editStop();if(grid._fake) grid._fake.editStop()}})
	dhtmlxEvent(combo.DOMlist,"click",function(){grid.editStop();if(grid._fake) grid._fake.editStop()});
	//combo.attachEvent("onBlur",function(){if(!this.ncm){grid.editStop();if(grid._fake) grid._fake.editStop()}})
	combo.DOMelem.style.border = "0px";
	combo.DOMelem.style.height = "18px";
	return combo;

}
		
eXcell_combo.prototype.fillColumnCombos = function(grid,xml){
	if (!xml) return;
	grid.combo_columns = grid.combo_columns||[];
	columns = grid.xmlLoader.doXPath("//column",xml);
	for(var i = 0; i < columns.length; i++){
		if((columns[i].getAttribute("type")||"").indexOf("combo")==0){
			grid.combo_columns[grid.combo_columns.length] = i; 
			
			this.setComboOptions(grid._col_combos[i],columns[i],grid,i);
			
		}
	}
	
}

eXcell_combo.prototype.setComboCValue = function(value,value2){
   	if(this._combo_pre!="")
   		value = "<div style='width:100%;position:relative;height:100%;overflow:hidden;line-height:20px'>"+this._combo_pre+"<span>"+value+"</span></div>";
   	if(arguments.length>1)
  		this.setCValue(value,value2);
	else
		this.setCValue(value);
}
		/**
		*	@desc: this method sets combo options and prorerties 
		*   @type: private 
		*/

		
eXcell_combo.prototype.setComboOptions = function(combo,obj,grid,index,idd){
	if(convertStringToBoolean(obj.getAttribute("xmlcontent"))){

		if(!obj.getAttribute("source")){
			options = obj.childNodes;
			var _optArr = [];
			for (var i=0; i < options.length; i++){
				if(options[i].tagName =="option"){
					var text_opt = options[i].firstChild? options[i].firstChild.data:"";
					_optArr[_optArr.length]= [options[i].getAttribute("value"),text_opt];
				}
			}
			combo.addOption(_optArr)
			if(arguments.length == 4){
					grid.forEachRowA(function(id){
						var c = grid.cells(id,index);
						if(!c.cell._brval&&!c.cell._cellType&&(c.cell._cellIndex==index)){
							if(c.cell.combo_value=="") c.setComboCValue("&nbsp;","");
							else{
								if(!combo.getOption(c.cell.combo_value))
									c.setComboCValue(c.cell.combo_value);
								else c.setComboCValue(combo.getOption(c.cell.combo_value).text);
							}
						}
					});	
				}
				else {
					var c = (this.cell)?this:grid.cells(idd,index);
					if(obj.getAttribute("text")) {
						if(obj.getAttribute("text")._dhx_trim()=="") c.setComboCValue("&nbsp;",""); 
						else c.setComboCValue(obj.getAttribute("text")); 
					}
					else{
						if((!c.cell.combo_value)||(c.cell.combo_value._dhx_trim()=="")) c.setComboCValue("&nbsp;","");
						else{
							if(!combo.getOption(c.cell.combo_value))
								c.setComboCValue(c.cell.combo_value);
							else c.setComboCValue(combo.getOption(c.cell.combo_value).text);
						}
					}
			}
			
		}				
	}

	if(obj.getAttribute("source")){
		if(obj.getAttribute("auto")&&convertStringToBoolean(obj.getAttribute("auto"))){
		
			if(obj.getAttribute("xmlcontent")){
				var c = (this.cell)?this:grid.cells(idd,index);
				if(obj.getAttribute("text")) c.setComboCValue(obj.getAttribute("text"));
			}
			else{
				grid.forEachRowA(function(id){
					var c = grid.cells(id,index);
					if(!c.cell._brval&&!c.cell._cellType){
						var str = c.cell.combo_value.toString();
						if(str.indexOf("^")!=-1){
							var arr = str.split("^");
							c.cell.combo_value = arr[0];
							c.setComboCValue(arr[1]);
						}
					}
				});
			}
			combo.enableFilteringMode(true,obj.getAttribute("source"),convertStringToBoolean(obj.getAttribute("cache")||true),convertStringToBoolean(obj.getAttribute("sub")||false));	
		
		}
		else {
			var that = this;
			var length = arguments.length; 
			combo.loadXML(obj.getAttribute("source"),function(){
				if(length == 4){
					grid.forEachRow(function(id){
						var c = grid.cells(id,index);
						if(!c.cell._brval&&!c.cell._cellType){
							if(combo.getOption(c.cell.combo_value))
								c.setComboCValue(combo.getOption(c.cell.combo_value).text);
							else{
								if ((c.cell.combo_value||"").toString()._dhx_trim()==""){
									c.setComboCValue("&nbsp;","");
									c.cell._clearCell=true;	 
								}
								else
									c.setComboCValue(c.cell.combo_value);
							}
						}
					});	
				}
				else {
					//var c = (that.cell)? that : grid.cells(idd,index);
					var c = grid.cells(idd,index);
					//c.setCValue(obj.getAttribute("text")); 
					if(combo.getOption(c.cell.combo_value))
						//c.setCValue(c._combo_pre+combo.getOption(c.cell.combo_value).text);
						c.setComboCValue(combo.getOption(c.cell.combo_value).text);
					else
						c.setComboCValue(c.cell.combo_value);
				}
			});
			
		}
	}
	if(!obj.getAttribute("auto")||!convertStringToBoolean(obj.getAttribute("auto"))){
	
		if(obj.getAttribute("editable")&&!convertStringToBoolean(obj.getAttribute("editable"))) combo.readonly(true);
		if(obj.getAttribute("filter")&&convertStringToBoolean(obj.getAttribute("filter"))) combo.enableFilteringMode(true);	
		
	}

}

		/**
		*	@desc: gets dhtmlxCombo object for specified cell  
		*   @returns: combo object
		*   @type: public 
		*/
eXcell_combo.prototype.getCellCombo = function(){
	
	if(this.cell._brval) return this.cell._brval;
	else {
		this.cell._brval = this.initCombo();
		return this.cell._brval;
	}
};

/**
 *	@desc: refreshes text of 'combo' cell
 *  @type: public
 */
eXcell_combo.prototype.refreshCell = function(){
	this.setValue(this.getValue());
};
		/**
		*	@desc: gets dhtmlxCombo object for specified column  
		*   @param: index - column index
		*   @returns: combo object 
		*   @type: public
		*/

dhtmlXGridObject.prototype.getColumnCombo = function(index){
	if(this._col_combos&&this._col_combos[index]) return this._col_combos[index];
	else{
		if(!this._col_combos) this._col_combos=[];
		this._col_combos[index] = eXcell_combo.prototype.initCombo.call({grid:this},index);
		
		return this._col_combos[index];
	}
}
/**
 *	@desc: refreshes text in cells of 'combo' column
 *  @type: public
 */
dhtmlXGridObject.prototype.refreshComboColumn = function(index){
	this.forEachRow(function(id){
	    if(this.cells(id,index).refreshCell)
		    this.cells(id,index).refreshCell();
	});
};
//(c)dhtmlx ltd. www.dhtmlx.com

//v.3.6 build 131108

/*
Copyright DHTMLX LTD. http://www.dhtmlx.com
To use this component please contact sales@dhtmlx.com to obtain license
*/
/**
*	@desc: auto counter editor
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_cntr(cell){
	this.cell = cell;
    this.grid = this.cell.parentNode.grid;
	if (!this.grid._ex_cntr_ready && !this._realfake){
		this.grid._ex_cntr_ready=true;
		if (this.grid._h2)
			this.grid.attachEvent("onOpenEn",function(id){
				this.resetCounter(cell._cellIndex);
			});
		this.grid.attachEvent("onBeforeSorting",function(){ 
			var that=this;
			window.setTimeout(function(){ 
				if (!that.resetCounter) return;
				if (that._fake && !that._realfake && cell._cellIndex<that._fake._cCount) 
					that._fake.resetCounter(cell._cellIndex); 
				else
				    that.resetCounter(cell._cellIndex);
			},1)
			return true;
		});
	}
	
	

	this.edit = function(){}
	this.getValue = function(){
		return this.cell.innerHTML;
	}
	this.setValue = function(val){
		this.cell.style.paddingRight = "2px";
		var cell=this.cell;
		
		window.setTimeout(function(){
			if (!cell.parentNode) return;
			var val=cell.parentNode.rowIndex;
			if (cell.parentNode.grid.currentPage || val<0 || cell.parentNode.grid._srnd) val=cell.parentNode.grid.rowsBuffer._dhx_find(cell.parentNode)+1;
			if (val<=0) return;
			cell.innerHTML = val;
			if (cell.parentNode.grid._fake && cell._cellIndex<cell.parentNode.grid._fake._cCount && cell.parentNode.grid._fake.rowsAr[cell.parentNode.idd]) cell.parentNode.grid._fake.cells(cell.parentNode.idd,cell._cellIndex).setCValue(val);
			cell=null;
		},100);
	}
}
dhtmlXGridObject.prototype.resetCounter=function(ind){
	if (this._fake && !this._realfake && ind < this._fake._cCount) this._fake.resetCounter(ind,this.currentPage);
	var i=arguments[0]||0;
	if (this.currentPage)
		i=(this.currentPage-1)*this.rowsBufferOutSize;
	for (i=0; i<this.rowsBuffer.length; i++)
		if (this.rowsBuffer[i] && this.rowsBuffer[i].tagName == "TR" && this.rowsAr[this.rowsBuffer[i].idd])
			this.rowsAr[this.rowsBuffer[i].idd].childNodes[ind].innerHTML=i+1;
}
eXcell_cntr.prototype = new eXcell;
//(c)dhtmlx ltd. www.dhtmlx.com

//v.3.6 build 131108

/*
Copyright DHTMLX LTD. http://www.dhtmlx.com
To use this component please contact sales@dhtmlx.com to obtain license
*/

/*
HTML Link eXcell v.1.0  for dhtmlxGrid 
(c)DHTMLX LTD. 2005


The corresponding  cell value in XML should be a "^" delimited list of following values:
1st - Link Text 
2nd - URL (optional)
3rd - target (optional, default is _blank)

Samples:
<cell>Stephen King</cell>
<cell>Stephen King^http://www.stephenking.com/</cell>
<cell>Stephen King^http://www.stephenking.com/^_self</cell>
*/

/**
*	@desc: link editor
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/

function eXcell_link(cell){
	this.cell = cell;
    this.grid = this.cell.parentNode.grid;
    this.isDisabled=function(){return true;}
	this.edit = function(){}
	this.getValue = function(){
		if(this.cell.firstChild.getAttribute){
			var target = this.cell.firstChild.getAttribute("target")
			return this.cell.firstChild.innerHTML+"^"+this.cell.firstChild.getAttribute("href")+(target?("^"+target):"");
		}

		else
			return "";
	}
	this.setValue = function(val){
		if((typeof(val)!="number") && (!val || val.toString()._dhx_trim()=="")){		
			this.setCValue("&nbsp;",valsAr);			
			return (this.cell._clearCell=true);
		}
		var valsAr = val.split("^");
		if(valsAr.length==1)
			valsAr[1] = "";
		else{
			if(valsAr.length>1){
				valsAr[1] = "href='"+valsAr[1]+"'";
				if(valsAr.length==3)
					valsAr[1]+= " target='"+valsAr[2]+"'";
				else
					valsAr[1]+= " target='_blank'";
			}
		}

		this.setCValue("<a "+valsAr[1]+" onclick='(_isIE?event:arguments[0]).cancelBubble = true;'>"+valsAr[0]+"</a>",valsAr);
	}
}

eXcell_link.prototype = new eXcell;
eXcell_link.prototype.getTitle=function(){
	var z=this.cell.firstChild;
	return ((z&&z.tagName)?z.getAttribute("href"):"");
}
eXcell_link.prototype.getContent=function(){
	var z=this.cell.firstChild;
	return ((z&&z.tagName)?z.innerHTML:"");
}
//(c)dhtmlx ltd. www.dhtmlx.com

//v.3.6 build 131108

/*
Copyright DHTMLX LTD. http://www.dhtmlx.com
To use this component please contact sales@dhtmlx.com to obtain license
*/
/**
*	@desc: multi select list editor
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_clist(cell){
	try{
		this.cell = cell;
		this.grid = this.cell.parentNode.grid;
	}catch(er){}
	this.edit = function(){
					this.val = this.getValue();
                    var a=(this.cell._combo||this.grid.clists[this.cell._cellIndex]);
                    if (!a) return;
					this.obj = document.createElement("DIV");
                    var b=this.val.split(",");
                    var text="";

                    for (var i=0; i<a.length; i++){
                        var fl=false;
                        for (var j=0; j<b.length; j++)
                            if (a[i]==b[j]) fl=true;
                        if (fl)
                         text+="<div><input type='checkbox' id='dhx_clist_"+i+"' checked='true' /><label for='dhx_clist_"+i+"'>"+a[i]+"</label></div>";
                        else
                         text+="<div><input type='checkbox' id='dhx_clist_"+i+"'/><label for='dhx_clist_"+i+"'>"+a[i]+"</label></div>";
                    }
                    text+="<div><input type='button' value='"+(this.grid.applyButtonText||"Apply")+"' style='width:100px; font-size:8pt;' onclick='this.parentNode.parentNode.editor.grid.editStop();'/></div>"

                    this.obj.editor=this;
                    this.obj.innerHTML=text;
                    document.body.appendChild(this.obj);
                    this.obj.style.position="absolute";
					this.obj.className="dhx_clist";
					this.obj.onclick=function(e){  (e||event).cancelBubble=true; return true; };
					var arPos = this.grid.getPosition(this.cell);
                    this.obj.style.left=arPos[0]+"px";
                    this.obj.style.top=arPos[1]+this.cell.offsetHeight+"px";

                    this.obj.getValue=function(){
                        var text="";
                        for (var i=0; i<this.childNodes.length-1; i++)
                            if (this.childNodes[i].childNodes[0].checked){
                                if (text) text+=",";
                                    text+=this.childNodes[i].childNodes[1].innerHTML;
                                }
                        return text.replace(/&amp;/g,"&");
                    }
				}
	this.getValue = function(){
		//this.grid.editStop();
		if (this.cell._clearCell) return "";
		return this.cell.innerHTML.toString()._dhx_trim().replace(/&amp;/g,"&");
	}

	this.detach = function(val){
                    if (this.obj){
    					this.setValue(this.obj.getValue());
                        this.obj.editor=null;
                        this.obj.parentNode.removeChild(this.obj);
                        this.obj=null;
                        }
					return this.val!=this.getValue();
				}
}
eXcell_clist.prototype = new eXcell;

eXcell_clist.prototype.setValue = function(val){
						if (typeof(val)=="object"){
							var optCol=this.grid.xmlLoader.doXPath("./option",val);
                            if (optCol.length)
                            	this.cell._combo=[];
                                for (var j=0;j<optCol.length; j++)
									this.cell._combo.push(optCol[j].firstChild?optCol[j].firstChild.data:"");
							val=val.firstChild.data;
						}
						if (val==="" || val === this.undefined){
							this.setCTxtValue(" ",val);
							this.cell._clearCell=true;
						}
						else{
                        	this.setCTxtValue(val);
                        	this.cell._clearCell=false;
                        }
					}

/**
*	@desc: register list of values for CList cell
*	@param: col - index of CList collumn
*	@param: list - array of list data
*	@type:  public
*   @edition: Professional
*/
dhtmlXGridObject.prototype.registerCList=function(col,list){
    if (!this.clists) this.clists=new Array();
	if (typeof(list)!="object") list=list.split(",");
    this.clists[col]=list;
    }

//(c)dhtmlx ltd. www.dhtmlx.com
//v.3.6 build 131108

/*
Copyright DHTMLX LTD. http://www.dhtmlx.com
To use this component please contact sales@dhtmlx.com to obtain license
*/
/**
*   @desc: radio editor
*   @returns: dhtmlxGrid cell editor object
*   @type: public
*/
function eXcell_ra_str(cell){
   if (cell){
   this.base = eXcell_ra;
   this.base(cell)
   this.grid = cell.parentNode.grid;
	}
}
eXcell_ra_str.prototype = new eXcell_ch;
eXcell_ra_str.prototype.setValue = function(val){
                  this.cell.style.verticalAlign = "middle";//nb:to center checkbox in line
                  if (val){
                           val=val.toString()._dhx_trim();
                     if ((val=="false")||(val=="0")) val="";
                     }
                  if(val){
		    if (this.grid.rowsAr[this.cell.parentNode.idd])
                     for (var i=0;i<this.grid._cCount;i++) {
			if (i!==this.cell._cellIndex) {
                            var cell = this.grid.cells(this.cell.parentNode.idd,i);
                            if ((cell.cell._cellType||this.grid.cellType[cell.cell._cellIndex])!="ra_str") continue;
                            if (cell.getValue())
                               cell.setValue("0");
			}
                     }
                     val = "1";
                     this.cell.chstate = "1";
                  }else{
                     val = "0";
                     this.cell.chstate = "0"
                  }
                  this.setCValue("<img src='"+this.grid.imgURL+"radio_chk"+val+".gif' onclick='new eXcell_ra_str(this.parentNode).changeState()'>",this.cell.chstate);
               }
//(c)dhtmlx ltd. www.dhtmlx.com
//v.3.6 build 131108

/*
Copyright DHTMLX LTD. http://www.dhtmlx.com
To use this component please contact sales@dhtmlx.com to obtain license
*/
/*_TOPICS_
@0:Initialization
@1:Selection control
@2:Add/delete
@3:Private
@4:Node/level control
@5:Checkboxes/user data manipulation
@6:Appearence control
@7: Handlers
*/

function xmlPointer(data){
	this.d=data;
}
xmlPointer.prototype={
	text:function(){ if (!_isFF) return this.d.xml; var x = new XMLSerializer();   return x.serializeToString(this.d); },
	get:function(name){return this.d.getAttribute(name); },
	exists:function(){return !!this.d },
	content:function(){return this.d.firstChild?this.d.firstChild.data:""; }, // <4k in FF
	each:function(name,f,t,i){  var a=this.d.childNodes; var c=new xmlPointer(); if (a.length) for (i=i||0; i<a.length; i++) if (a[i].tagName==name) { c.d=a[i]; if(f.apply(t,[c,i])==-1) return; } },
	get_all:function(){ var a={}; var b=this.d.attributes; for (var i=0; i<b.length; i++) a[b[i].name]=b[i].value; return a; },
	sub:function(name){ var a=this.d.childNodes; var c=new xmlPointer(); if (a.length) for (var i=0; i<a.length; i++) if (a[i].tagName==name) { c.d=a[i]; return c; } },
	up:function(name){ return new xmlPointer(this.d.parentNode);  },
	set:function(name,val){ this.d.setAttribute(name,val);  },
	clone:function(name){ return new xmlPointer(this.d); },
	sub_exists:function(name){ var a=this.d.childNodes; if (a.length) for (var i=0; i<a.length; i++) if (a[i].tagName==name) return true;  return false;  },
	through:function(name,rule,v,f,t){  var a=this.d.childNodes; if (a.length) for (var i=0; i<a.length; i++) { if (a[i].tagName==name && a[i].getAttribute(rule)!=null && a[i].getAttribute(rule)!="" &&  (!v || a[i].getAttribute(rule)==v )) { var c=new xmlPointer(a[i]);  f.apply(t,[c,i]); } var w=this.d; this.d=a[i]; this.through(name,rule,v,f,t); this.d=w;  } }
}



/**
*     @desc: tree constructor
*     @param: htmlObject - parent html object or id of parent html object
*     @param: width - tree width
*     @param: height - tree height
*     @param: rootId - id of virtual root node (same as tree node id attribute in xml)
*     @type: public
*     @topic: 0
*/
function dhtmlXTreeObject(htmlObject, width, height, rootId){
	if (_isIE) try { document.execCommand("BackgroundImageCache", false, true); } catch (e){}
	if (typeof(htmlObject)!="object")
      this.parentObject=document.getElementById(htmlObject);
	else
      this.parentObject=htmlObject;

	this.parentObject.style.overflow="hidden";
   	this._itim_dg=true;
    this.dlmtr=",";
    this.dropLower=false;
	this.enableIEImageFix();

   this.xmlstate=0;
   this.mytype="tree";
   this.smcheck=true;   //smart checkboxes
   this.width=width;
   this.height=height;
   this.rootId=rootId;
   this.childCalc=null;
      this.def_img_x="18px";
      this.def_img_y="18px";
      this.def_line_img_x="18px";
      this.def_line_img_y="18px";

    this._dragged=new Array();
   this._selected=new Array();

   this.style_pointer="pointer";
   
   this._aimgs=true;
   this.htmlcA=" [";
   this.htmlcB="]";
   this.lWin=window;
   this.cMenu=0;
   this.mlitems=0;
   this.iconURL="";
   this.dadmode=0;
   this.slowParse=false;
   this.autoScroll=true;
   this.hfMode=0;
   this.nodeCut=new Array();
   this.XMLsource=0;
   this.XMLloadingWarning=0;
   this._idpull={};
   this._pullSize=0;
   this.treeLinesOn=true;
   this.tscheck=false;
   this.timgen=true;
   this.dpcpy=false;
   this._ld_id=null;
	this._oie_onXLE=[];
   this.imPath=window.dhx_globalImgPath||""; 
   this.checkArray=new Array("iconUncheckAll.gif","iconCheckAll.gif","iconCheckGray.gif","iconUncheckDis.gif","iconCheckDis.gif","iconCheckDis.gif");
   this.radioArray=new Array("radio_off.gif","radio_on.gif","radio_on.gif","radio_off.gif","radio_on.gif","radio_on.gif");

   this.lineArray=new Array("line2.gif","line3.gif","line4.gif","blank.gif","blank.gif","line1.gif");
   this.minusArray=new Array("minus2.gif","minus3.gif","minus4.gif","minus.gif","minus5.gif");
   this.plusArray=new Array("plus2.gif","plus3.gif","plus4.gif","plus.gif","plus5.gif");
   this.imageArray=new Array("leaf.gif","folderOpen.gif","folderClosed.gif");
   this.cutImg= new Array(0,0,0);
   this.cutImage="but_cut.gif";
   
   dhtmlxEventable(this);

   this.dragger= new dhtmlDragAndDropObject();
//create root
   this.htmlNode=new dhtmlXTreeItemObject(this.rootId,"",0,this);
   this.htmlNode.htmlNode.childNodes[0].childNodes[0].style.display="none";
   this.htmlNode.htmlNode.childNodes[0].childNodes[0].childNodes[0].className="hiddenRow";
//init tree structures
   this.allTree=this._createSelf();
   this.allTree.appendChild(this.htmlNode.htmlNode);

   if (dhtmlx.$customScroll)
      dhtmlx.CustomScroll.enable(this);

    if(_isFF){
         this.allTree.childNodes[0].width="100%";
         this.allTree.childNodes[0].style.overflow="hidden";
    }

   var self=this;
   this.allTree.onselectstart=new Function("return false;");
   if (_isMacOS)
		this.allTree.oncontextmenu = function(e){ 
			return self._doContClick(e||window.event, true); 
		};   
   this.allTree.onmousedown = function(e){ return self._doContClick(e||window.event); };  
   
   this.XMLLoader=new dtmlXMLLoaderObject(this._parseXMLTree,this,true,this.no_cashe);
   if (_isIE) this.preventIECashing(true);

//#__pro_feature:01112006{
//#complex_move:01112006{
   this.selectionBar=document.createElement("DIV");
   this.selectionBar.className="selectionBar";
   this.selectionBar.innerHTML="&nbsp;";
   this.selectionBar.style.display="none";
   this.allTree.appendChild(this.selectionBar);
//#}
//#}

    
    if (window.addEventListener) window.addEventListener("unload",function(){try{  self.destructor(); } catch(e){}},false);
    if (window.attachEvent) window.attachEvent("onunload",function(){ try{ self.destructor(); } catch(e){}});

	this.setImagesPath=this.setImagePath;
	this.setIconsPath=this.setIconPath;

	if (dhtmlx.image_path) this.setImagePath(dhtmlx.image_path);
	if (dhtmlx.skin) this.setSkin(dhtmlx.skin);

   return this;
};


/**
*     @desc: set default data transfer mode 
*     @param: mode - data mode (json,xml,csv)
*     @type: public
*     @topic: 0
*/
dhtmlXTreeObject.prototype.setDataMode=function(mode){
		this._datamode=mode;
}


	
dhtmlXTreeObject.prototype._doContClick=function(ev, force){
	if (!force && ev.button!=2) {
		if(this._acMenu){
			if (this._acMenu.hideContextMenu)
				this._acMenu.hideContextMenu()
			else
				this.cMenu._contextEnd();
		}
		return true;
	}
	
 	

	
	var el=(_isIE?ev.srcElement:ev.target);
	while ((el)&&(el.tagName!="BODY")) {
		if (el.parentObject) break;
    	 el=el.parentNode;
	 }
    	
    if ((!el)||(!el.parentObject)) return true;
    
    var obj=el.parentObject;
    
    if (!this.callEvent("onRightClick",[obj.id,ev]))
        (ev.srcElement||ev.target).oncontextmenu = function(e){ (e||event).cancelBubble=true; return false; };
        
    	this._acMenu=(obj.cMenu||this.cMenu);
        if (this._acMenu){
       		if (!(this.callEvent("onBeforeContextMenu", [
					obj.id
				]))) return true; 	
				if(!_isMacOS)
	        (ev.srcElement||ev.target).oncontextmenu = function(e){ (e||event).cancelBubble=true; return false; };
	               
			if (this._acMenu.showContextMenu){

var dEl0=window.document.documentElement;
var dEl1=window.document.body;
var corrector = new Array((dEl0.scrollLeft||dEl1.scrollLeft),(dEl0.scrollTop||dEl1.scrollTop));
if (_isIE){
	var x= ev.clientX+corrector[0];
	var y = ev.clientY+corrector[1];
} else {
	var x= ev.pageX;
	var y = ev.pageY;
}
				
				this._acMenu.showContextMenu(x-1,y-1)
				this.contextID=obj.id;
				ev.cancelBubble=true;
				this._acMenu._skip_hide=true;
			} else {
				el.contextMenuId=obj.id;
				el.contextMenu=this._acMenu;
				el.a=this._acMenu._contextStart;
				el.a(el, ev);
				el.a=null;
			}
	        	
			return false;           
    	}
    return true;
}


/**
*     @desc: replace IMG tag with background images - solve problem with IE image caching , not works for IE6 SP1
*     @param: mode - true/false - enable/disable fix
*     @type: public
*     @topic: 0
*/
dhtmlXTreeObject.prototype.enableIEImageFix=function(mode){
	if (!mode){

	this._getImg=function(id){ return document.createElement((id==this.rootId)?"div":"img"); }
	this._setSrc=function(a,b){ a.src=b; }
	this._getSrc=function(a){ return a.src; }
	}	else	{

	this._getImg=function(){ var z=document.createElement("DIV"); z.innerHTML="&nbsp;"; z.className="dhx_bg_img_fix"; return z; }
	this._setSrc=function(a,b){ a.style.backgroundImage="url("+b+")"; }
	this._getSrc=function(a){ var z=a.style.backgroundImage;  return z.substr(4,z.length-5).replace(/(^")|("$)/g,""); }
	}
}

/**
*	@desc: deletes tree and clears memory
*	@type: public
*/
dhtmlXTreeObject.prototype.destructor=function(){
    for (var a in this._idpull){
        var z=this._idpull[a];
		if (!z) continue;
        z.parentObject=null;z.treeNod=null;z.childNodes=null;z.span=null;z.tr.nodem=null;z.tr=null;z.htmlNode.objBelong=null;z.htmlNode=null;
        this._idpull[a]=null;
        }
    this.parentObject.innerHTML="";
    
    if(this.XMLLoader)
        this.XMLLoader.destructor();
    
    this.allTree.onselectstart = null;
    this.allTree.oncontextmenu = null;
    this.allTree.onmousedown = null;
        
    for(var a in this){
        this[a]=null;
        }
}

function cObject(){
    return this;
}
cObject.prototype= new Object;
cObject.prototype.clone = function () {
       function _dummy(){};
       _dummy.prototype=this;
       return new _dummy();
    }

/**
*   @desc: tree node constructor
*   @param: itemId - node id
*   @param: itemText - node label
*   @param: parentObject - parent item object
*   @param: treeObject - tree object
*   @param: actionHandler - onclick event handler(optional)
*   @param: mode - do not show images
*   @type: private
*   @topic: 0
*/
function dhtmlXTreeItemObject(itemId,itemText,parentObject,treeObject,actionHandler,mode){
   this.htmlNode="";
   this.acolor="";
   this.scolor="";
   this.tr=0;
   this.childsCount=0;
   this.tempDOMM=0;
   this.tempDOMU=0;
   this.dragSpan=0;
   this.dragMove=0;
   this.span=0;
   this.closeble=1;
   this.childNodes=new Array();
   this.userData=new cObject();


   this.checkstate=0;
   this.treeNod=treeObject;
   this.label=itemText;
   this.parentObject=parentObject;
   this.actionHandler=actionHandler;
   this.images=new Array(treeObject.imageArray[0],treeObject.imageArray[1],treeObject.imageArray[2]);


   this.id=treeObject._globalIdStorageAdd(itemId,this);
   if (this.treeNod.checkBoxOff ) this.htmlNode=this.treeNod._createItem(1,this,mode);
   else  this.htmlNode=this.treeNod._createItem(0,this,mode);

   this.htmlNode.objBelong=this;
   return this;
   };   


/**
*     @desc: register node
*     @type: private
*     @param: itemId - node id
*     @param: itemObject - node object
*     @topic: 3  
*/
   dhtmlXTreeObject.prototype._globalIdStorageAdd=function(itemId,itemObject){
      if (this._globalIdStorageFind(itemId,1,1)) {   itemId=itemId +"_"+(new Date()).valueOf(); return this._globalIdStorageAdd(itemId,itemObject); }
	  	 this._idpull[itemId]=itemObject;
         this._pullSize++;
      return itemId;
   };

/**
*     @desc: unregister node
*     @type: private
*     @param: itemId - node id
*     @topic: 3
*/
   dhtmlXTreeObject.prototype._globalIdStorageSub=function(itemId){
        if (this._idpull[itemId]){
		    this._unselectItem(this._idpull[itemId]);
			this._idpull[itemId]=null;
			this._pullSize--;
        }
		if ((this._locker)&&(this._locker[itemId])) this._locker[itemId]=false;
   };
   
/**
*     @desc: return node object
*     @param: itemId - node id
*     @type: private
*     @topic: 3
*/
   dhtmlXTreeObject.prototype._globalIdStorageFind=function(itemId,skipXMLSearch,skipParsing,isreparse){
		var z=this._idpull[itemId]
        if (z){
//#__pro_feature:01112006{
//#smart_parsing:01112006{
            if ((z.unParsed)&&(!skipParsing))
                    {
                    this.reParse(z,0);
                    }
            if (this._srnd && !z.htmlNode) this._buildSRND(z,skipParsing);
                if ((isreparse)&&(this._edsbpsA)){
                    for (var j=0; j<this._edsbpsA.length; j++)
                        if (this._edsbpsA[j][2]==itemId){
                            dhtmlxError.throwError("getItem","Requested item still in parsing process.",itemId);
                            return null;
                        }
                    }
//#}
//#}
            return z;
            }
//#__pro_feature:01112006{
//#smart_parsing:01112006{
      if ((this.slowParse)&&(itemId!=0)&&(!skipXMLSearch)) return this.preParse(itemId);
      else
//#}
//#}
	  	return null;
   };
//#__pro_feature:01112006{
//#smart_parsing:01112006{
dhtmlXTreeObject.prototype._getSubItemsXML=function(p){
      var z=[];
      p.each("item",function(c){
      	z.push(c.get("id"));
      },this)
      return z.join(this.dlmtr);
    }

/**
*     @desc: enable/disable smart XML parsing mode (usefull for big, well structured XML)
*     @beforeInit: 1
*     @param: mode - 1 - on, 0 - off;
*     @type: public
*     @edition: Professional
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.enableSmartXMLParsing=function(mode) { this.slowParse=convertStringToBoolean(mode); };
   dhtmlXTreeObject.prototype.findXML=function(node,par,val){  }

dhtmlXTreeObject.prototype._getAllCheckedXML=function(p,list,mode){
	var z=[];
	
	if (mode==2)
		p.through("item","checked",-1,function(c){
			z.push(c.get("id"));
  		},this);
  	
  	if (mode==1)
  		p.through("item","id",null,function(c){
  			if (c.get("checked") && (c.get("checked") !=-1))
			z.push(c.get("id"));
  		},this);
  		
	if (mode==0)
  		p.through("item","id",null,function(c){
			if (!c.get("checked") || c.get("checked")==0 )
			z.push(c.get("id"));
  		},this);  		
    if(z.length)
  		return list+(list?this.dlmtr:"")+z.join(this.dlmtr);
      if (list) return list; else return "";
   };


/**
*     @desc: change state of node's checkbox and all childnodes checkboxes
*     @type: private
*     @param: itemId - target node id
*     @param: state - checkbox state
*     @param: sNode - target node object (optional, used by private methods)
*     @topic: 5
*/
   dhtmlXTreeObject.prototype._setSubCheckedXML=function(state,p){
	   	var val= state?"1":"";
	   	p.through("item","id",null,function(c){
			if (!c.get("disabled") || c.get("disabled")==0 )
	   		    c.set("checked",val);
	   	},this);
}

       dhtmlXTreeObject.prototype._getAllScraggyItemsXML=function(p,x){
        var z=[];
        var fff=function(c){
	   		if (!c.sub_exists("item"))
	   			z.push(c.get("id"));
	   		else
	   			c.each("item",fff,this);
		   	}
	    fff(p);
        return z.join(",");
    }
    
   dhtmlXTreeObject.prototype._getAllFatItemsXML=function(p,x){
        var z=[];
        var fff=function(c){
	   		if (!c.sub_exists("item"))
	   			return;
   			z.push(c.get("id"));
   			c.each("item",fff,this);
		   	}
	    fff(p);
        return z.join(",");
    }

dhtmlXTreeObject.prototype._getAllSubItemsXML=function(itemId,z,p){
      var z=[];
      p.through("item","id",null,function(c){
      	z.push(c.get("id"));
      },this)
      return z.join(",");
    }

/**
*     @desc: parse stored xml
*     @param: node - XML node
*     @type: private
*     @edition: Professional
*     @topic: 3  
*/
 dhtmlXTreeObject.prototype.reParse=function(node){
        var that=this;
      if (!this.parsCount) that.callEvent("onXLS",[that,node.id]);
      this.xmlstate=1;

      var tmp=node.unParsed;
      node.unParsed=0;
//               if (confirm("reParse "+node.id)) { window.asdasd.asdasd(); }
      this.XMLloadingWarning=1;
        var oldpid=this.parsingOn;
		var oldmd=this.waitUpdateXML;
		var oldpa=this.parsedArray;

		this.parsedArray=new Array();
	  	this.waitUpdateXML=false;
      this.parsingOn=node.id;
      this.parsedArray=new Array();

         this.setCheckList="";
         this._parse(tmp,node.id,2);
         var chArr=this.setCheckList.split(this.dlmtr);

      for (var i=0; i<this.parsedArray.length; i++)
         node.htmlNode.childNodes[0].appendChild(this.parsedArray[i]);
      
	  if (tmp.get("order") && tmp.get("order")!="none")
	  	 	this._reorderBranch(node,tmp.get("order"),true);
	  	 	
            this.oldsmcheck=this.smcheck;
            this.smcheck=false;

         for (var n=0; n<chArr.length; n++)
            if (chArr[n])  this.setCheck(chArr[n],1);
            this.smcheck=this.oldsmcheck;

      this.parsingOn=oldpid;
	  this.waitUpdateXML=oldmd;
	  this.parsedArray=oldpa;  	  
      this.XMLloadingWarning=0;
      this._redrawFrom(this,node);
      if (this._srnd && !node._sready)
      	this.prepareSR(node.id);
      this.xmlstate=0;
      return true;
   }

/**
*     @desc: search for item in unparsed chunks
*     @param: itemId - item ID
*     @type: private
*     @edition: Professional
*     @topic: 3
*/
dhtmlXTreeObject.prototype.preParse=function(itemId){
   if (!itemId || !this._p) return null; 
   var result=false;
   this._p.clone().through("item","id",itemId,function(c){ 
   		this._globalIdStorageFind(c.up().get("id"));
   		return result=true;
   	},this);
   	if (result){
   		var n=this._globalIdStorageFind(itemId,true,false);
   		if (!n)
   			dhtmlxError.throwError("getItem","The item "+itemId+" not operable. Seems you have non-unique|incorrect IDs in tree's XML.",itemId);
   	}
   	return n;
}

//#}
//#}

/**
*     @desc: escape string
*     @param: itemId - item ID
*     @type: private
*     @topic: 3
*/
   dhtmlXTreeObject.prototype._escape=function(str){
        switch(this.utfesc){
        case "none":
            return str;
            break;
        case "utf8":
         return encodeURIComponent(str);
            break;
        default:
         return escape(str);
            break;
        }
   }



/**
*     @desc: create and return  new line in tree
*     @type: private
*     @param: htmlObject - parent Node object
*     @param: node - item object
*     @topic: 2  
*/
   dhtmlXTreeObject.prototype._drawNewTr=function(htmlObject,node)
   {
      var tr =document.createElement('tr');
      var td1=document.createElement('td');
      var td2=document.createElement('td');
      td1.appendChild(document.createTextNode(" "));
      td2.colSpan=3;
      td2.appendChild(htmlObject);
      tr.appendChild(td1);  tr.appendChild(td2);
      return tr;
   };
/**
*     @desc: load tree from xml string
*     @type: public
*     @param: xmlString - XML string
*     @param: afterCall - function which will be called after xml loading
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.loadXMLString=function(xmlString,afterCall){
        var that=this;
      if (!this.parsCount) this.callEvent("onXLS",[that,null]);
      this.xmlstate=1;

        if (afterCall) this.XMLLoader.waitCall=afterCall;
      this.XMLLoader.loadXMLString(xmlString);  };
/**
*     @desc: load tree from xml file
*     @type: public
*     @param: file - link to XML file
*     @param: afterCall - function which will be called after xml loading
*     @topic: 0
*/
	dhtmlXTreeObject.prototype.loadXML=function(file,afterCall){ 
	  if (this._datamode && this._datamode!="xml") return this["load"+this._datamode.toUpperCase()](file,afterCall);
        var that=this;
      if (!this.parsCount) this.callEvent("onXLS",[that,this._ld_id]);
      this._ld_id=null;
      this.xmlstate=1;
      this.XMLLoader=new dtmlXMLLoaderObject(this._parseXMLTree,this,true,this.no_cashe);

      if (afterCall) this.XMLLoader.waitCall=afterCall;
      this.XMLLoader.loadXML(file);
   };
/**
*     @desc: create new child node
*     @type: private
*     @param: parentObject - parent node object
*     @param: itemId - new node id
*     @param: itemText - new node text
*     @param: itemActionHandler - function fired on node select event
*     @param: image1 - image for node without children;
*     @param: image2 - image for closed node;
*     @param: image3 - image for opened node
*     @param: optionStr - string of otions
*     @param: childs - node childs flag (for dynamical trees) (optional)
*     @param: beforeNode - node, after which new node will be inserted (optional)
*     @topic: 2
*/
   dhtmlXTreeObject.prototype._attachChildNode=function(parentObject,itemId,itemText,itemActionHandler,image1,image2,image3,optionStr,childs,beforeNode,afterNode){

         if (beforeNode && beforeNode.parentObject) parentObject=beforeNode.parentObject;
         if (((parentObject.XMLload==0)&&(this.XMLsource))&&(!this.XMLloadingWarning))
         {
            parentObject.XMLload=1;
                this._loadDynXML(parentObject.id);

         }

         var Count=parentObject.childsCount;
         var Nodes=parentObject.childNodes;


            if (afterNode && afterNode.tr.previousSibling){
            if (afterNode.tr.previousSibling.previousSibling){
               beforeNode=afterNode.tr.previousSibling.nodem;
               }
            else
               optionStr=optionStr.replace("TOP","")+",TOP";
               }

         if (beforeNode)
            {
            var ik,jk;
            for (ik=0; ik<Count; ik++)
               if (Nodes[ik]==beforeNode)
               {
               for (jk=Count; jk!=ik; jk--)
                  Nodes[1+jk]=Nodes[jk];
               break;
               }
            ik++;
            Count=ik;
            }


         if (optionStr) {
             var tempStr=optionStr.split(",");
            for (var i=0; i<tempStr.length; i++)
            {
               switch(tempStr[i])
               {
                  case "TOP": if (parentObject.childsCount>0) { beforeNode=new Object; beforeNode.tr=parentObject.childNodes[0].tr.previousSibling; }
				  	 parentObject._has_top=true;
                     for  (ik=Count; ik>0; ik--)
                        Nodes[ik]=Nodes[ik-1];
                        Count=0;
                     break;
               }
            };
          };

        	var n;
		if (!(n=this._idpull[itemId]) || n.span!=-1){
         	n=Nodes[Count]=new dhtmlXTreeItemObject(itemId,itemText,parentObject,this,itemActionHandler,1);
         	itemId = Nodes[Count].id;
         	parentObject.childsCount++;
     	}
        
        if(!n.htmlNode) {
           n.label=itemText;
		   n.htmlNode=this._createItem((this.checkBoxOff?1:0),n);
   		   n.htmlNode.objBelong=n;
   		  }

         if(image1) n.images[0]=image1;
         if(image2) n.images[1]=image2;
         if(image3) n.images[2]=image3;

		
         var tr=this._drawNewTr(n.htmlNode);
         if ((this.XMLloadingWarning)||(this._hAdI))
            n.htmlNode.parentNode.parentNode.style.display="none";

           
            if ((beforeNode)&&beforeNode.tr&&(beforeNode.tr.nextSibling))
               parentObject.htmlNode.childNodes[0].insertBefore(tr,beforeNode.tr.nextSibling);
            else
               if (this.parsingOn==parentObject.id){
                  this.parsedArray[this.parsedArray.length]=tr;
                        }
               else
                   parentObject.htmlNode.childNodes[0].appendChild(tr);


               if ((beforeNode)&&(!beforeNode.span)) beforeNode=null;

            if (this.XMLsource) if ((childs)&&(childs!=0)) n.XMLload=0; else n.XMLload=1;
            n.tr=tr;
            tr.nodem=n;

            if (parentObject.itemId==0)
                tr.childNodes[0].className="hiddenRow";

            if ((parentObject._r_logic)||(this._frbtr))
                this._setSrc(n.htmlNode.childNodes[0].childNodes[0].childNodes[1].childNodes[0],this.imPath+this.radioArray[0]);


          if (optionStr) {
             var tempStr=optionStr.split(",");

            for (var i=0; i<tempStr.length; i++)
            {
               switch(tempStr[i])
               {
                     case "SELECT": this.selectItem(itemId,false); break;
                  case "CALL": this.selectItem(itemId,true);   break;
                  case "CHILD":  n.XMLload=0;  break;
                  case "CHECKED":
                     if (this.XMLloadingWarning)
                        this.setCheckList+=this.dlmtr+itemId;
                     else
                        this.setCheck(itemId,1);
                        break;
                  case "HCHECKED":
                        this._setCheck(n,"unsure");
                        break;                        
                  case "OPEN": n.openMe=1;  break;
               }
            };
          };

      if (!this.XMLloadingWarning)
      {
             if ((this._getOpenState(parentObject)<0)&&(!this._hAdI)) this.openItem(parentObject.id);

             if (beforeNode)
                {
             this._correctPlus(beforeNode);
             this._correctLine(beforeNode);
                }
             this._correctPlus(parentObject);
             this._correctLine(parentObject);
             this._correctPlus(n);
             if (parentObject.childsCount>=2)
             {
                   this._correctPlus(Nodes[parentObject.childsCount-2]);
                   this._correctLine(Nodes[parentObject.childsCount-2]);
             }
             if (parentObject.childsCount!=2) this._correctPlus(Nodes[0]);

         if (this.tscheck) this._correctCheckStates(parentObject);

            if (this._onradh){
				if (this.xmlstate==1){
					var old=this.onXLE;
					this.onXLE=function(id){ this._onradh(itemId); if (old) old(id); }
					}
				else
					this._onradh(itemId);
			}

      }
   return n;
};


//#__pro_feature:01112006{
//#context_menu:01112006{

/**
*     @desc: enable context menu
*     @param: menu - dhtmlXMenu object
*     @edition: Professional
*     @type: public
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.enableContextMenu=function(menu){  if (menu) this.cMenu=menu; };

/**
*     @desc: set context menu to individual nodes
*     @type: public
*     @param: itemId - node id
*     @param: cMenu - context menu object
*     @edition: Professional
*     @topic: 2
*/
dhtmlXTreeObject.prototype.setItemContextMenu=function(itemId,cMenu){
   var l=itemId.toString().split(this.dlmtr);
   for (var i=0; i<l.length; i++)
      {
      var temp=this._globalIdStorageFind(l[i]);
      if (!temp) continue;
      temp.cMenu=cMenu;
      }
}

//#}
//#}

/**
*     @desc: create new node as a child to specified with parentId
*     @type: deprecated
*     @param: parentId - parent node id
*     @param: itemId - new node id
*     @param: itemText - new node text
*     @param: itemActionHandler - function fired on node select event (optional)
*     @param: image1 - image for node without children; (optional)
*     @param: image2 - image for closed node; (optional)
*     @param: image3 - image for opened node (optional)
*     @param: optionStr - options string (optional)            
*     @param: children - node children flag (for dynamical trees) (optional)
*     @topic: 2  
*/
   dhtmlXTreeObject.prototype.insertNewItem=function(parentId,itemId,itemText,itemActionHandler,image1,image2,image3,optionStr,children){
      var parentObject=this._globalIdStorageFind(parentId);
      if (!parentObject) return (-1);
      var nodez=this._attachChildNode(parentObject,itemId,itemText,itemActionHandler,image1,image2,image3,optionStr,children);
      if(!this._idpull[this.rootId].XMLload)
         this._idpull[this.rootId].XMLload = 1;
//#__pro_feature:01112006{
//#child_calc:01112006{
      if ((!this.XMLloadingWarning)&&(this.childCalc))  this._fixChildCountLabel(parentObject);
//#}
//#}
        return nodez;
   };
/**
*     @desc: create new node as a child to specified with parentId
*     @type: public
*     @param: parentId - parent node id
*     @param: itemId - new node id
*     @param: itemText - new node label
*     @param: itemActionHandler - function fired on node select event (optional)
*     @param: image1 - image for node without children; (optional)
*     @param: image2 - image for closed node; (optional)
*     @param: image3 - image for opened node (optional)
*     @param: optionStr - options string (optional)            
*     @param: children - node children flag (for dynamical trees) (optional)
*     @topic: 2  
*/
   dhtmlXTreeObject.prototype.insertNewChild=function(parentId,itemId,itemText,itemActionHandler,image1,image2,image3,optionStr,children){
      return this.insertNewItem(parentId,itemId,itemText,itemActionHandler,image1,image2,image3,optionStr,children);
   }   
/**  
*     @desc: parse xml
*     @type: private
*     @param: dhtmlObject - jsTree object
*     @param: node - top XML node
*     @param: parentId - parent node id
*     @param: level - level of tree
*     @topic: 2
*/
	dhtmlXTreeObject.prototype._parseXMLTree=function(a,b,c,d,xml){
		var p=new xmlPointer(xml.getXMLTopNode("tree"));
		a._parse(p);
		a._p=p;
	}
	
	dhtmlXTreeObject.prototype._parseItem=function(c,temp,preNode,befNode){ 
		var id;
		if (this._srnd && (!this._idpull[id=c.get("id")] || !this._idpull[id].span))
		{
			this._addItemSRND(temp.id,id,c);
			return; 
		}
		
  var a=c.get_all();
        
        if ((typeof(this.waitUpdateXML)=="object")&&(!this.waitUpdateXML[a.id])){
			this._parse(c,a.id,1);
			return;
		}    

//#__pro_feature:01112006{
			if ((a.text===null)||(typeof(a.text)=="undefined")){
				a.text=c.sub("itemtext");
				if (a.text) a.text=a.text.content();
			}
//#}
              



                  var zST=[];
                  if (a.select) zST.push("SELECT");
                  if (a.top) zST.push("TOP");
                  if (a.call) this.nodeAskingCall=a.id;
                  if (a.checked==-1) zST.push("HCHECKED");
                     else if (a.checked) zST.push("CHECKED");
                  if (a.open) zST.push("OPEN");
	
    	          if (this.waitUpdateXML){
				  		if (this._globalIdStorageFind(a.id))
	    	            	var newNode=this.updateItem(a.id,a.text,a.im0,a.im1,a.im2,a.checked,a.child);
						else{
							if (this.npl==0) zST.push("TOP");
							else preNode=temp.childNodes[this.npl];

		                    var newNode=this._attachChildNode(temp,a.id,a.text,0,a.im0,a.im1,a.im2,zST.join(","),a.child,0,preNode);
                        a.id = newNode.id;
							preNode=null;
						}
					 }
                  else
                     var newNode=this._attachChildNode(temp,a.id,a.text,0,a.im0,a.im1,a.im2,zST.join(","),a.child,(befNode||0),preNode);
                  if (a.tooltip)
					newNode.span.parentNode.parentNode.title=a.tooltip;

                  if (a.style)
                            if (newNode.span.style.cssText)
                                newNode.span.style.cssText+=(";"+a.style);
                            else
                                newNode.span.setAttribute("style",newNode.span.getAttribute("style")+"; "+a.style);

                        if (a.radio) newNode._r_logic=true;

                  if (a.nocheckbox){
                  	 var check_node=newNode.span.parentNode.previousSibling.previousSibling;
                     check_node.style.display="none";
                     newNode.nocheckbox=true;
                  }
                        if (a.disabled){
                            if (a.checked!=null) this._setCheck(newNode,a.checked);
                            this.disableCheckbox(newNode,1);
                            }

				
                  newNode._acc=a.child||0;

                  if (this.parserExtension) this.parserExtension._parseExtension.call(this,c,a,(temp?temp.id:0));

                  this.setItemColor(newNode,a.aCol,a.sCol);
                  if (a.locked=="1")    this.lockItem(newNode.id,true,true);

                  if ((a.imwidth)||(a.imheight))   this.setIconSize(a.imwidth,a.imheight,newNode);
                  if ((a.closeable=="0")||(a.closeable=="1"))  this.setItemCloseable(newNode,a.closeable);
                  var zcall="";
                  if (a.topoffset) this.setItemTopOffset(newNode,a.topoffset);
                  if ((!this.slowParse)||(typeof(this.waitUpdateXML)=="object")){ 
                  	if (c.sub_exists("item"))
                    	zcall=this._parse(c,a.id,1);
                  }
//#__pro_feature:01112006{
//#smart_parsing:01112006{
                  else {
                  	if ((!newNode.childsCount) && c.sub_exists("item"))
                      newNode.unParsed=c.clone();
                     
						c.each("userdata",function(u){
							this.setUserData(a.id,u.get("name"),u.content());
						},this);
     	  	      }
//#}                     
//#}
                  if (zcall!="") this.nodeAskingCall=zcall;

   
        c.each("userdata",function(u){
    	  		this.setUserData(c.get("id"),u.get("name"),u.content());
 	  	  },this)
		
		
	}
   	dhtmlXTreeObject.prototype._parse=function(p,parentId,level,start){ 
   		if (this._srnd && !this.parentObject.offsetHeight) {
   			var self=this;
   			return window.setTimeout(function(){
   				self._parse(p,parentId,level,start);
   			},100);
   		}
		if (!p.exists()) return;
		
		this.skipLock=true; //disable item locking
		//loading flags
		
		
		if (!parentId) {          //top level  
			parentId=p.get("id");
      var skey = p.get("dhx_security");
      if (skey)
          dhtmlx.security_key = skey;

			if (p.get("radio"))
				this.htmlNode._r_logic=true;
			this.parsingOn=parentId;                 
			this.parsedArray=new Array();
			this.setCheckList="";
			this.nodeAskingCall="";
		}
		
		var temp=this._globalIdStorageFind(parentId);
		if (!temp) return dhtmlxError.throwError("DataStructure","XML refers to not existing parent");

		this.parsCount=this.parsCount?(this.parsCount+1):1;
		this.XMLloadingWarning=1;

		if ((temp.childsCount)&&(!start)&&(!this._edsbps)&&(!temp._has_top))
            var preNode=0;//temp.childNodes[temp.childsCount-1];
        else
            var preNode=0;

        this.npl=0;

		p.each("item",function(c,i){
				
		temp.XMLload=1;
				
          this._parseItem(c,temp,0,preNode); 
 	  	  
//#__pro_feature:01112006{
//#distributed_load:01112006{
              if ((this._edsbps)&&(this.npl==this._edsbpsC)){
                this._distributedStart(p,i+1,parentId,level,temp.childsCount);
                return -1;
              }
//#}
//#}
              this.npl++;
         

 	  	  
      },this,start);


      if (!level) {
      	  p.each("userdata",function(u){
    	  		this.setUserData(p.get("id"),u.get("name"),u.content());
 	  	  },this);
 	  	  
	  	 temp.XMLload=1;
         if (this.waitUpdateXML){
            this.waitUpdateXML=false;
			for (var i=temp.childsCount-1; i>=0; i--)
				if (temp.childNodes[i]._dmark)
					this.deleteItem(temp.childNodes[i].id);
			}

         var parsedNodeTop=this._globalIdStorageFind(this.parsingOn);

         for (var i=0; i<this.parsedArray.length; i++)
               temp.htmlNode.childNodes[0].appendChild(this.parsedArray[i]);
		this.parsedArray = [];
		
         this.lastLoadedXMLId=parentId;
         this.XMLloadingWarning=0;

         var chArr=this.setCheckList.split(this.dlmtr);
         for (var n=0; n<chArr.length; n++)
            if (chArr[n]) this.setCheck(chArr[n],1);

               if ((this.XMLsource)&&(this.tscheck)&&(this.smcheck)&&(temp.id!=this.rootId)){
                if (temp.checkstate===0)
                    this._setSubChecked(0,temp);
                else if (temp.checkstate===1)
                    this._setSubChecked(1,temp);
            }

         this._redrawFrom(this,null,start)
		 if (p.get("order") && p.get("order")!="none")
	  	 	this._reorderBranch(temp,p.get("order"),true);
	  	 	
	  	 if (this.nodeAskingCall!="") this.callEvent("onClick",[this.nodeAskingCall,this.getSelectedItemId()]); 
         if (this._branchUpdate) this._branchUpdateNext(p);
	     }


      if (this.parsCount==1) {
      	 this.parsingOn=null;
//#__pro_feature:01112006{
//#smart_parsing:01112006{
          //if ((this.slowParse)&&(this.parsingOn==this.rootId))
         if (this._srnd && temp.id!=this.rootId){
 	  	 	this.prepareSR(temp.id);
 	  	 	if (this.XMLsource) this.openItem(temp.id)
 	  	 }
 	  	 
            p.through("item","open",null,function(c){
            	this.openItem(c.get("id"));
            	},this);
//#}
//#}

         
         if ((!this._edsbps)||(!this._edsbpsA.length)){
         		var that=this;
               	window.setTimeout( function(){  that.callEvent("onXLE",[that,parentId]); },1);
                this.xmlstate=0;
                }
             this.skipLock=false;
         }
      this.parsCount--;

//#__pro_feature:01112006{
//#distributed_load:01112006{
		var that=this;
        if (this._edsbps) window.setTimeout(function(){ that._distributedStep(parentId); },this._edsbpsD);
//#}
//#}

        
		
		if (!level && this.onXLE) this.onXLE(this,parentId);
      return this.nodeAskingCall;
  };
  

dhtmlXTreeObject.prototype._branchUpdateNext=function(p){
	p.each("item",function(c){
		var nid=c.get("id");
		if (this._idpull[nid] && (!this._idpull[nid].XMLload))  return;
		this._branchUpdate++;
		this.smartRefreshItem(c.get("id"),c);
	},this)
	this._branchUpdate--;
} 

  dhtmlXTreeObject.prototype.checkUserData=function(node,parentId){
      if ((node.nodeType==1)&&(node.tagName == "userdata"))
      {
         var name=node.getAttribute("name");
            if ((name)&&(node.childNodes[0]))
               this.setUserData(parentId,name,node.childNodes[0].data);
      }
  }




/**  
*     @desc: reset tree images from selected level
*     @type: private
*     @param: dhtmlObject - tree
*     @param: itemObject - current item
*     @topic: 6
*/
   dhtmlXTreeObject.prototype._redrawFrom=function(dhtmlObject,itemObject,start,visMode){
      if (!itemObject) {
      var tempx=dhtmlObject._globalIdStorageFind(dhtmlObject.lastLoadedXMLId);
      dhtmlObject.lastLoadedXMLId=-1;
      if (!tempx) return 0;
      }
      else tempx=itemObject;
      var acc=0;
      for (var i=(start?start-1:0); i<tempx.childsCount; i++)
      {
	  	 if ((!this._branchUpdate)||(this._getOpenState(tempx)==1))
	         if ((!itemObject)||(visMode==1)) tempx.childNodes[i].htmlNode.parentNode.parentNode.style.display="";
         if (tempx.childNodes[i].openMe==1)
            {
            this._openItem(tempx.childNodes[i]);
            tempx.childNodes[i].openMe=0;
            }

         dhtmlObject._redrawFrom(dhtmlObject,tempx.childNodes[i]);
//#__pro_feature:01112006{
//#child_calc:01112006{
      if (this.childCalc!=null){

      if ((tempx.childNodes[i].unParsed)||((!tempx.childNodes[i].XMLload)&&(this.XMLsource)))
      {

         if (tempx.childNodes[i]._acc)
         tempx.childNodes[i].span.innerHTML=tempx.childNodes[i].label+this.htmlcA+tempx.childNodes[i]._acc+this.htmlcB;
         else
         tempx.childNodes[i].span.innerHTML=tempx.childNodes[i].label;
      }
         if ((tempx.childNodes[i].childNodes.length)&&(this.childCalc))
         {
            if (this.childCalc==1)
               {
               tempx.childNodes[i].span.innerHTML=tempx.childNodes[i].label+this.htmlcA+tempx.childNodes[i].childsCount+this.htmlcB;
               }
            if (this.childCalc==2)
               {
               var zCount=tempx.childNodes[i].childsCount-(tempx.childNodes[i].pureChilds||0);
               if (zCount)
                  tempx.childNodes[i].span.innerHTML=tempx.childNodes[i].label+this.htmlcA+zCount+this.htmlcB;
               if (tempx.pureChilds) tempx.pureChilds++; else tempx.pureChilds=1;
               }
            if (this.childCalc==3)
               {
               tempx.childNodes[i].span.innerHTML=tempx.childNodes[i].label+this.htmlcA+tempx.childNodes[i]._acc+this.htmlcB;
               }
            if (this.childCalc==4)
               {
               var zCount=tempx.childNodes[i]._acc;
               if (zCount)
                  tempx.childNodes[i].span.innerHTML=tempx.childNodes[i].label+this.htmlcA+zCount+this.htmlcB;
               }               
         }
            else if (this.childCalc==4)   {
               acc++;
               }   
            
         acc+=tempx.childNodes[i]._acc;
         
         if (this.childCalc==3){
            acc++;
         }

         }
//#}
//#}

      };

      if ((!tempx.unParsed)&&((tempx.XMLload)||(!this.XMLsource)))
      tempx._acc=acc;
      dhtmlObject._correctLine(tempx);
      dhtmlObject._correctPlus(tempx);
//#__pro_feature:01112006{
//#child_calc:01112006{
      if ((this.childCalc)&&(!itemObject)) dhtmlObject._fixChildCountLabel(tempx);
//#}
//#}
   };

/**
*     @desc: create and return main html element of tree
*     @type: private
*     @topic: 0  
*/
   dhtmlXTreeObject.prototype._createSelf=function(){
      var div=document.createElement('div');
      div.className="containerTableStyle";
      div.style.width=this.width;
      div.style.height=this.height;
      this.parentObject.appendChild(div);
      return div;
   };

/**
*     @desc: collapse target node
*     @type: private
*     @param: itemObject - item object
*     @topic: 4  
*/
   dhtmlXTreeObject.prototype._xcloseAll=function(itemObject)
   {
        if (itemObject.unParsed) return;
      if (this.rootId!=itemObject.id) {
      		if (!itemObject.htmlNode) return;//srnd
          var Nodes=itemObject.htmlNode.childNodes[0].childNodes;
            var Count=Nodes.length;

          for (var i=1; i<Count; i++)
             Nodes[i].style.display="none";

          this._correctPlus(itemObject);
      }

       for (var i=0; i<itemObject.childsCount; i++)
            if (itemObject.childNodes[i].childsCount)
             this._xcloseAll(itemObject.childNodes[i]);
   };
/**
*     @desc: expand target node
*     @type: private
*     @param: itemObject - item object
*     @topic: 4
*/      
   dhtmlXTreeObject.prototype._xopenAll=function(itemObject)
   {
      this._HideShow(itemObject,2);
      for (var i=0; i<itemObject.childsCount; i++)
         this._xopenAll(itemObject.childNodes[i]);
   };      
/**  
*     @desc: set correct tree-line and node images
*     @type: private
*     @param: itemObject - item object
*     @topic: 6  
*/
   dhtmlXTreeObject.prototype._correctPlus=function(itemObject){
   		if (!itemObject.htmlNode) return;
        var imsrc=itemObject.htmlNode.childNodes[0].childNodes[0].childNodes[0].lastChild;
        var imsrc2=itemObject.htmlNode.childNodes[0].childNodes[0].childNodes[2].childNodes[0];

       var workArray=this.lineArray;
      if ((this.XMLsource)&&(!itemObject.XMLload))
      {
            var workArray=this.plusArray;
			this._setSrc(imsrc2,this.iconURL+itemObject.images[2]);
                if (this._txtimg) return (imsrc.innerHTML="[+]");
      }
      else
      if ((itemObject.childsCount)||(itemObject.unParsed))
      {
         if ((itemObject.htmlNode.childNodes[0].childNodes[1])&&( itemObject.htmlNode.childNodes[0].childNodes[1].style.display!="none" ))
            {
            if (!itemObject.wsign) var workArray=this.minusArray;
			this._setSrc(imsrc2,this.iconURL+itemObject.images[1]);
                if (this._txtimg) return (imsrc.innerHTML="[-]");
            }
         else
            {
            if (!itemObject.wsign) var workArray=this.plusArray;
			this._setSrc(imsrc2,this.iconURL+itemObject.images[2]);
                if (this._txtimg) return (imsrc.innerHTML="[+]");
            }
      }
      else
      {
         this._setSrc(imsrc2,this.iconURL+itemObject.images[0]);
       }


      var tempNum=2;
      if (!itemObject.treeNod.treeLinesOn) this._setSrc(imsrc,this.imPath+workArray[3]);
      else {
          if (itemObject.parentObject) tempNum=this._getCountStatus(itemObject.id,itemObject.parentObject);
		  this._setSrc(imsrc,this.imPath+workArray[tempNum]);
         }
   };

/**
*     @desc: set correct tree-line images
*     @type: private
*     @param: itemObject - item object
*     @topic: 6
*/
   dhtmlXTreeObject.prototype._correctLine=function(itemObject){
   	  if (!itemObject.htmlNode) return;
      var sNode=itemObject.parentObject;
      if (sNode)
         if ((this._getLineStatus(itemObject.id,sNode)==0)||(!this.treeLinesOn))
               for(var i=1; i<=itemObject.childsCount; i++){
                  if (!itemObject.htmlNode.childNodes[0].childNodes[i]) break;
                  itemObject.htmlNode.childNodes[0].childNodes[i].childNodes[0].style.backgroundImage="";
                  itemObject.htmlNode.childNodes[0].childNodes[i].childNodes[0].style.backgroundRepeat="";
                }
            else
               for(var i=1; i<=itemObject.childsCount; i++){
               	 if (!itemObject.htmlNode.childNodes[0].childNodes[i]) break;
               	 itemObject.htmlNode.childNodes[0].childNodes[i].childNodes[0].style.backgroundImage="url("+this.imPath+this.lineArray[5]+")";
               	 itemObject.htmlNode.childNodes[0].childNodes[i].childNodes[0].style.backgroundRepeat="repeat-y";
	     }
   };
/**
*     @desc: return type of node
*     @type: private
*     @param: itemId - item id
*     @param: itemObject - parent node object
*     @topic: 6
*/
   dhtmlXTreeObject.prototype._getCountStatus=function(itemId,itemObject){
      if (itemObject.childsCount<=1) { if (itemObject.id==this.rootId) return 4; else  return 0; }

      if (itemObject.childNodes[0].id==itemId) if (itemObject.id==this.rootId) return 2; else return 1;
      if (itemObject.childNodes[itemObject.childsCount-1].id==itemId) return 0;

      return 1;
   };
/**
*     @desc: return type of node
*     @type: private
*     @param: itemId - node id        
*     @param: itemObject - parent node object
*     @topic: 6
*/      
   dhtmlXTreeObject.prototype._getLineStatus =function(itemId,itemObject){
         if (itemObject.childNodes[itemObject.childsCount-1].id==itemId) return 0;
         return 1;
      }

/**  
*     @desc: open/close node 
*     @type: private
*     @param: itemObject - node object        
*     @param: mode - open/close mode [1-close 2-open](optional)
*     @topic: 6
*/      
   dhtmlXTreeObject.prototype._HideShow=function(itemObject,mode){
      if ((this.XMLsource)&&(!itemObject.XMLload)) {
            if (mode==1) return; //close for not loaded node - ignore it
            itemObject.XMLload=1;
            this._loadDynXML(itemObject.id);
            return; };
//#__pro_feature:01112006{
//#smart_parsing:01112006{
        if (itemObject.unParsed) this.reParse(itemObject);
//#}
//#}
      var Nodes=itemObject.htmlNode.childNodes[0].childNodes; var Count=Nodes.length;
      if (Count>1){
         if ( ( (Nodes[1].style.display!="none") || (mode==1) ) && (mode!=2) ) {
//nb:solves standard doctype prb in IE
          this.allTree.childNodes[0].border = "1";
          this.allTree.childNodes[0].border = "0";
         nodestyle="none";
         }
         else  nodestyle="";

      for (var i=1; i<Count; i++)
         Nodes[i].style.display=nodestyle;
      }
      this._correctPlus(itemObject);
   }

/**
*     @desc: return node state
*     @type: private
*     @param: itemObject - node object        
*     @topic: 6
*/
   dhtmlXTreeObject.prototype._getOpenState=function(itemObject){
   	  if (!itemObject.htmlNode) return 0; //srnd
   	  var z=itemObject.htmlNode.childNodes[0].childNodes;
      if (z.length<=1) return 0;
      if    (z[1].style.display!="none") return 1;
      else return -1;
   }

   

/**  
*     @desc: ondblclick item  event handler
*     @type: private
*     @topic: 0  
*/      
   dhtmlXTreeObject.prototype.onRowClick2=function(){
   	  var that=this.parentObject.treeNod;
      if (!that.callEvent("onDblClick",[this.parentObject.id,that])) return false;
      if ((this.parentObject.closeble)&&(this.parentObject.closeble!="0"))
         that._HideShow(this.parentObject);
      else
         that._HideShow(this.parentObject,2);

   	if    (that.checkEvent("onOpenEnd"))
           if (!that.xmlstate)
				that.callEvent("onOpenEnd",[this.parentObject.id,that._getOpenState(this.parentObject)]);
            else{
                that._oie_onXLE.push(that.onXLE);
                that.onXLE=that._epnFHe;
                }
    	return false;
   };
/**
*     @desc: onclick item event handler
*     @type: private
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.onRowClick=function(){ 
    var that=this.parentObject.treeNod;
	  if (!that.callEvent("onOpenStart",[this.parentObject.id,that._getOpenState(this.parentObject)])) return 0;
      if ((this.parentObject.closeble)&&(this.parentObject.closeble!="0"))
         that._HideShow(this.parentObject);
      else
         that._HideShow(this.parentObject,2);

	
   if    (that.checkEvent("onOpenEnd"))
           if (!that.xmlstate)
				that.callEvent("onOpenEnd",[this.parentObject.id,that._getOpenState(this.parentObject)]);
            else{
                that._oie_onXLE.push(that.onXLE);
                that.onXLE=that._epnFHe;
                }

   };

      dhtmlXTreeObject.prototype._epnFHe=function(that,id,flag){
      	if (id!=this.rootId)
	  		this.callEvent("onOpenEnd",[id,that.getOpenState(id)]);
        that.onXLE=that._oie_onXLE.pop();
        
        if (!flag && !that._oie_onXLE.length)
			if (that.onXLE) that.onXLE(that,id);
    }



/**
*     @desc: onclick item image event handler
*     @type: private
*     @edition: Professional
*     @topic: 0  
*/
   dhtmlXTreeObject.prototype.onRowClickDown=function(e){
            e=e||window.event;
         var that=this.parentObject.treeNod;
         that._selectItem(this.parentObject,e);
      };


/*****
SELECTION
*****/

/**
*     @desc: retun selected item id
*     @type: public
*     @return: id of selected item
*     @topic: 1
*/
   dhtmlXTreeObject.prototype.getSelectedItemId=function()
   {
        var str=new Array();
        for (var i=0; i<this._selected.length; i++) str[i]=this._selected[i].id;
      return (str.join(this.dlmtr));
   };

/**
*     @desc: visual select item in tree
*     @type: private
*     @param: node - tree item object
*     @edition: Professional
*     @topic: 0
*/
   dhtmlXTreeObject.prototype._selectItem=function(node,e){
   		if (this.checkEvent("onSelect")) this._onSSCFold=this.getSelectedItemId();
//#__pro_feature:01112006{
//#multiselect:01112006{
        if ((!this._amsel)||(!e)||((!e.ctrlKey)&&(!e.metaKey)&&(!e.shiftKey)))
//#}
//#}
            this._unselectItems();
//#__pro_feature:01112006{
//#multiselect:01112006{
            if ((node.i_sel)&&(this._amsel)&&(e)&&(e.ctrlKey || e.metaKey))
                this._unselectItem(node);
            else
            if ((!node.i_sel)&&((!this._amselS)||(this._selected.length==0)||(this._selected[0].parentObject==node.parentObject)))
                if ((this._amsel)&&(e)&&(e.shiftKey)&&(this._selected.length!=0)&&(this._selected[this._selected.length-1].parentObject==node.parentObject)){
                    var a=this._getIndex(this._selected[this._selected.length-1]);
                    var b=this._getIndex(node);
                    if (b<a) { var c=a; a=b; b=c; }
                    for (var i=a; i<=b; i++)
                        if (!node.parentObject.childNodes[i].i_sel)
                            this._markItem(node.parentObject.childNodes[i]);
                    }
                else
//#}
//#}
					this._markItem(node);
		if (this.checkEvent("onSelect")) {
		   	var z=this.getSelectedItemId();
			if (z!=this._onSSCFold)
				this.callEvent("onSelect",[z]);
		}
    }
    dhtmlXTreeObject.prototype._markItem=function(node){
              if (node.scolor)  node.span.style.color=node.scolor;
              node.span.className="selectedTreeRow";
             node.i_sel=true;
             this._selected[this._selected.length]=node;
    }

/**
*     @desc: retun node index in children collection by Id
*     @type: public
*     @param: itemId - node id
*     @return: node index
*     @topic: 2
*/
   dhtmlXTreeObject.prototype.getIndexById=function(itemId){
         var z=this._globalIdStorageFind(itemId);
         if (!z) return null;
         return this._getIndex(z);
   };
   dhtmlXTreeObject.prototype._getIndex=function(w){
        var z=w.parentObject;
        for (var i=0; i<z.childsCount; i++)
            if (z.childNodes[i]==w) return i;
   };





/**
*     @desc: visual unselect item in tree
*     @type: private
*     @param: node - tree item object
*     @edition: Professional
*     @topic: 0
*/
   dhtmlXTreeObject.prototype._unselectItem=function(node){
        if ((node)&&(node.i_sel))
            {

          node.span.className="standartTreeRow";
          if (node.acolor)  node.span.style.color=node.acolor;
            node.i_sel=false;
            for (var i=0; i<this._selected.length; i++)
                    if (!this._selected[i].i_sel) {
                        this._selected.splice(i,1);
                        break;
                 }
            }
       }

/**
*     @desc: visual unselect items in tree
*     @type: private
*     @param: node - tree item object
*     @edition: Professional
*     @topic: 0
*/
   dhtmlXTreeObject.prototype._unselectItems=function(){
      for (var i=0; i<this._selected.length; i++){
            var node=this._selected[i];
         node.span.className="standartTreeRow";
          if (node.acolor)  node.span.style.color=node.acolor;
         node.i_sel=false;
         }
         this._selected=new Array();
       }


/**  
*     @desc: select node text event handler
*     @type: private
*     @param: e - event object
*     @param: htmlObject - node object     
*     @param: mode - if false - call onSelect event
*     @topic: 0  
*/
   dhtmlXTreeObject.prototype.onRowSelect=function(e,htmlObject,mode){
      e=e||window.event;

        var obj=this.parentObject;
      if (htmlObject) obj=htmlObject.parentObject;
        var that=obj.treeNod;

        var lastId=that.getSelectedItemId();
		if ((!e)||(!e.skipUnSel))
	        that._selectItem(obj,e);

      if (!mode) {	 	
         if (obj.actionHandler) obj.actionHandler(obj.id,lastId);
		 else that.callEvent("onClick",[obj.id,lastId]);
         }
   };




   
/**
*     @desc: fix checkbox state
*     @type: private
*     @topic: 0
*/
dhtmlXTreeObject.prototype._correctCheckStates=function(dhtmlObject){
	
   if (!this.tscheck) return;
   if (!dhtmlObject) return;
   if (dhtmlObject.id==this.rootId) return;
   //calculate state
   var act=dhtmlObject.childNodes;
   var flag1=0; var flag2=0;
   if (dhtmlObject.childsCount==0) return;
   for (var i=0; i<dhtmlObject.childsCount; i++){
   	  if (act[i].dscheck) continue;
      if (act[i].checkstate==0) flag1=1;
      else if (act[i].checkstate==1) flag2=1;
         else { flag1=1; flag2=1; break; }
		 }

   if ((flag1)&&(flag2)) this._setCheck(dhtmlObject,"unsure");
   else if (flag1)  this._setCheck(dhtmlObject,false);
      else  this._setCheck(dhtmlObject,true);

      this._correctCheckStates(dhtmlObject.parentObject);
}

/**
*     @desc: checbox select action
*     @type: private
*     @topic: 0
*/   
   dhtmlXTreeObject.prototype.onCheckBoxClick=function(e){
	   	  if (!this.treeNod.callEvent("onBeforeCheck",[this.parentObject.id,this.parentObject.checkstate]))
	   	  	return;
   	  
      if (this.parentObject.dscheck) return true;
      if (this.treeNod.tscheck)
         if (this.parentObject.checkstate==1) this.treeNod._setSubChecked(false,this.parentObject);
         else this.treeNod._setSubChecked(true,this.parentObject);
      else
         if (this.parentObject.checkstate==1) this.treeNod._setCheck(this.parentObject,false);
         else this.treeNod._setCheck(this.parentObject,true);
      this.treeNod._correctCheckStates(this.parentObject.parentObject);

      return this.treeNod.callEvent("onCheck",[this.parentObject.id,this.parentObject.checkstate]);
   };
/**
*     @desc: create HTML elements for tree node
*     @type: private
*     @param: acheck - enable/disable checkbox
*     @param: itemObject - item object
*     @param: mode - mode
*     @topic: 0
*/
   dhtmlXTreeObject.prototype._createItem=function(acheck,itemObject,mode){

	 var table=document.createElement('table');
	 table.cellSpacing=0;table.cellPadding=0;
	 table.border=0;

	 if(this.hfMode)table.style.tableLayout="fixed";
	 table.style.margin=0;table.style.padding=0;

	 var tbody=document.createElement('tbody');
	 var tr=document.createElement('tr');

	 var td1=document.createElement('td');
	 td1.className="standartTreeImage";

	 if(this._txtimg){
		 var img0=document.createElement("div");
		 td1.appendChild(img0);
		 img0.className="dhx_tree_textSign";
	}
            else
            {
         var img0=this._getImg(itemObject.id);
            img0.border="0";
            if (img0.tagName=="IMG") img0.align="absmiddle";
            td1.appendChild(img0); img0.style.padding=0; img0.style.margin=0;
			img0.style.width=this.def_line_img_x; img0.style.height=this.def_line_img_y;
            }

      var td11=document.createElement('td');
//         var inp=document.createElement("input");            inp.type="checkbox"; inp.style.width="12px"; inp.style.height="12px";
         var inp=this._getImg(this.cBROf?this.rootId:itemObject.id);
         inp.checked=0; this._setSrc(inp,this.imPath+this.checkArray[0]); inp.style.width="16px"; inp.style.height="16px";
            //can cause problems with hide/show check

         if (!acheck) td11.style.display="none";
	   
         // td11.className="standartTreeImage";
               //if (acheck)
            td11.appendChild(inp);
            if ((!this.cBROf)&&(inp.tagName=="IMG")) inp.align="absmiddle";
            inp.onclick=this.onCheckBoxClick;
            inp.treeNod=this;
            inp.parentObject=itemObject;
            if (!window._KHTMLrv) td11.width="20px";
            else td11.width="16px";

      var td12=document.createElement('td');
         td12.className="standartTreeImage";
         var img=this._getImg(this.timgen?itemObject.id:this.rootId);
		 	img.onmousedown=this._preventNsDrag; img.ondragstart=this._preventNsDrag;
            img.border="0";
            if (this._aimgs){
               img.parentObject=itemObject;
               if (img.tagName=="IMG") img.align="absmiddle";
               img.onclick=this.onRowSelect; }
            if (!mode) this._setSrc(img,this.iconURL+this.imageArray[0]);
            td12.appendChild(img); img.style.padding=0; img.style.margin=0;
         if (this.timgen)
            {  
            	td12.style.width=img.style.width=this.def_img_x; img.style.height=this.def_img_y; }
         else
            {
                img.style.width="0px"; img.style.height="0px";
                if (_isOpera || window._KHTMLrv )    td12.style.display="none";
                }


      var td2=document.createElement('td');
         td2.className="standartTreeRow";

            itemObject.span=document.createElement('span');
            itemObject.span.className="standartTreeRow";
            if (this.mlitems) {
				itemObject.span.style.width=this.mlitems;
			   //	if (!_isIE)
					itemObject.span.style.display="block";
				}
            else td2.noWrap=true;
            	if (_isIE && _isIE>7) td2.style.width="999999px";
            	else if (!window._KHTMLrv) td2.style.width="100%";

//      itemObject.span.appendChild(document.createTextNode(itemObject.label));
         itemObject.span.innerHTML=itemObject.label;
      td2.appendChild(itemObject.span);
      td2.parentObject=itemObject;        td1.parentObject=itemObject;
      td2.onclick=this.onRowSelect; td1.onclick=this.onRowClick; td2.ondblclick=this.onRowClick2;
      if (this.ettip)
		  	tr.title=itemObject.label;

      if (this.dragAndDropOff) {
         if (this._aimgs) { this.dragger.addDraggableItem(td12,this); td12.parentObject=itemObject; }
         this.dragger.addDraggableItem(td2,this);
         }

      itemObject.span.style.paddingLeft="5px";      itemObject.span.style.paddingRight="5px";   td2.style.verticalAlign="";
       td2.style.fontSize="10pt";       td2.style.cursor=this.style_pointer;
      tr.appendChild(td1);            tr.appendChild(td11);            tr.appendChild(td12);
      tr.appendChild(td2);
      tbody.appendChild(tr);
      table.appendChild(tbody);

	  if (this.ehlt || this.checkEvent("onMouseIn") || this.checkEvent("onMouseOut")){//highlighting
		tr.onmousemove=this._itemMouseIn;
        tr[(_isIE)?"onmouseleave":"onmouseout"]=this._itemMouseOut;
      }
      return table;
   };
   

/**  
*     @desc: set path to images directory
*     @param: newPath - path to images directory (related to the page with tree or absolute http url)
*     @type: public
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.setImagePath=function( newPath ){ this.imPath=newPath; this.iconURL=newPath; };
    /**
	*   @desc: set path to external images used as tree icons
	*   @type: public
	*   @param: path - url (or relative path) of images folder with closing "/"
	*   @topic: 0,7
	*/
	dhtmlXTreeObject.prototype.setIconPath=function(path){
		this.iconURL=path;
	}	   

//#__pro_feature:01112006{
//#child_calc:01112006{

/**
*     @desc: return count of leafs
*     @param: itemNode -  node object
*     @type: private
*     @edition: Professional
*     @topic: 4
*/
   dhtmlXTreeObject.prototype._getLeafCount=function(itemNode){
      var a=0;
      for (var b=0; b<itemNode.childsCount; b++)
         if (itemNode.childNodes[b].childsCount==0) a++;
      return a;
   }

/**
*     @desc: get value of child counter (child counter must be enabled)
*     @type: private
*     @param: itemId - id of selected item
*     @edition: Professional
*     @return: counter value (related to counter mode)
*     @topic: 6
*/
   dhtmlXTreeObject.prototype._getChildCounterValue=function(itemId){
      var temp=this._globalIdStorageFind(itemId);
      if (!temp) return 0;
      if ((temp.unParsed)||((!temp.XMLload)&&(this.XMLsource)))
      return temp._acc
      switch(this.childCalc)
      {
         case 1: return temp.childsCount; break;
         case 2: return this._getLeafCount(temp); break;
         case 3: return temp._acc; break;
         case 4: return temp._acc; break;
      }
   }

  /**
*     @desc: fix node child counter
*     @param: itemNode -  node object
*     @type: private
*     @edition: Professional
*     @topic: 4
*/
   dhtmlXTreeObject.prototype._fixChildCountLabel=function(itemNode,index){
      if (this.childCalc==null) return;
      if ((itemNode.unParsed)||((!itemNode.XMLload)&&(this.XMLsource)))
      {
         if (itemNode._acc)
         itemNode.span.innerHTML=itemNode.label+this.htmlcA+itemNode._acc+this.htmlcB;
         else
         itemNode.span.innerHTML=itemNode.label;

      return;
      }

      switch(this.childCalc){
         case 1:
            if (itemNode.childsCount!=0)
               itemNode.span.innerHTML=itemNode.label+this.htmlcA+itemNode.childsCount+this.htmlcB;
            else itemNode.span.innerHTML=itemNode.label;
            break;
         case 2:
            var z=this._getLeafCount(itemNode);
            if (z!=0)
               itemNode.span.innerHTML=itemNode.label+this.htmlcA+z+this.htmlcB;
            else itemNode.span.innerHTML=itemNode.label;
            break;
         case 3:
            if (itemNode.childsCount!=0)
               {
               var bcc=0;
               for (var a=0; a<itemNode.childsCount; a++)   {
                  if (!itemNode.childNodes[a]._acc) itemNode.childNodes[a]._acc=0;
                  bcc+=itemNode.childNodes[a]._acc*1;      }
                  bcc+=itemNode.childsCount*1;

               itemNode.span.innerHTML=itemNode.label+this.htmlcA+bcc+this.htmlcB;
               itemNode._acc=bcc;
               }
            else { itemNode.span.innerHTML=itemNode.label;   itemNode._acc=0; }
            if ((itemNode.parentObject)&&(itemNode.parentObject!=this.htmlNode))
               this._fixChildCountLabel(itemNode.parentObject);
            break;
         case 4:
            if (itemNode.childsCount!=0)
               {
               var bcc=0;
               for (var a=0; a<itemNode.childsCount; a++)   {
                  if (!itemNode.childNodes[a]._acc) itemNode.childNodes[a]._acc=1;
                  bcc+=itemNode.childNodes[a]._acc*1;      }

               itemNode.span.innerHTML=itemNode.label+this.htmlcA+bcc+this.htmlcB;
               itemNode._acc=bcc;
               }
            else { itemNode.span.innerHTML=itemNode.label;   itemNode._acc=1; }
            if ((itemNode.parentObject)&&(itemNode.parentObject!=this.htmlNode))
               this._fixChildCountLabel(itemNode.parentObject);
            break;
      }
   }

/**
*     @desc: set children calculation mode
*     @param: mode - mode name as string . Possible values: child - children, no recursive; leafs - children without subchildren, no recursive;  ,childrec - children, recursive; leafsrec - children without subchildren, recursive; disabled (disabled by default)
*     @type: public
*     @edition: Professional
*     @topic: 0
*/ 
   dhtmlXTreeObject.prototype.setChildCalcMode=function( mode ){
      switch(mode){
         case "child": this.childCalc=1; break;
         case "leafs": this.childCalc=2; break;
         case "childrec": this.childCalc=3; break;
         case "leafsrec": this.childCalc=4; break;
         case "disabled": this.childCalc=null; break;
         default: this.childCalc=4;
      }
    }
/**
*     @desc: set children calculation prefix and postfix
*     @param: htmlA - postfix ([ - by default)
*     @param: htmlB - postfix (] - by default)
*     @type: public
*     @edition: Professional
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.setChildCalcHTML=function( htmlA,htmlB ){
      this.htmlcA=htmlA;      this.htmlcB=htmlB;
    }
//#}
//#}

/**
*     @desc: set function called when tree node selected
*     @param: (function) func - event handling function
*     @type: deprecated
*     @topic: 0,7
*     @event: onRightClick
*     @depricated: use grid.attachEvent("onRightClick",func); instead
*     @eventdesc:  Event occurs after right mouse button was clicked.
         Assigning this handler can disable default context menu, and incompattible with dhtmlXMenu integration.
*     @eventparam: (string) ID of clicked item
*     @eventparam: (object) event object
*/
   dhtmlXTreeObject.prototype.setOnRightClickHandler=function(func){  this.attachEvent("onRightClick",func);   };

/**
*     @desc: set function called when tree node clicked, also can be forced to call from API
*     @param: func - event handling function
*     @type: deprecated
*     @topic: 0,7
*     @event: onClick
*     @depricated: use grid.attachEvent("onClick",func); instead
*     @eventdesc: Event raises immideatly after text part of item in tree was clicked, but after default onClick functionality was processed.
              Richt mouse button click can be catched by onRightClick event handler.
*     @eventparam:  ID of clicked item
*     @eventparam:  ID of previously selected item
*/
   dhtmlXTreeObject.prototype.setOnClickHandler=function(func){  this.attachEvent("onClick",func);  };

/**
*     @desc: set function called when tree node selected or unselected, include any select change caused by any functionality
*     @param: func - event handling function
*     @type: deprecated
*     @topic: 0,7
*     @event: onSelect
*     @depricated: use grid.attachEvent("onSelect",func); instead
*     @eventdesc: Event raises immideatly after selection in tree was changed
*     @eventparam:  selected item ID ( list of IDs in case of multiselection)
*/
   dhtmlXTreeObject.prototype.setOnSelectStateChange=function(func){  this.attachEvent("onSelect",func); };


/**
*     @desc: enables dynamic loading from XML
*     @type: public
*     @param: filePath - name of script returning XML; in case of virtual loading - user defined function
*     @topic: 0  
*/
   dhtmlXTreeObject.prototype.setXMLAutoLoading=function(filePath){  this.XMLsource=filePath; };

   /**
*     @desc: set function called before checkbox checked/unchecked
*     @param: func - event handling function
*     @type: deprecated
*     @topic: 0,7
*     @event: onCheck
*     @depricated: use tree.attachEvent("onCheck",func); instead
*     @eventdesc: Event raises right before item in tree was checked/unchecked. can be canceled (return false from event handler)
*     @eventparam: ID of item which will be checked/unchecked
*     @eventparam: Current checkbox state. 1 - item checked, 0 - item unchecked.
*		@eventreturn: true - confirm changing checked state; false - deny chaning checked state;
*/
   dhtmlXTreeObject.prototype.setOnCheckHandler=function(func){ this.attachEvent("onCheck",func);  };


/**
*     @desc: set function called before tree node opened/closed
*     @param: func - event handling function
*     @type: deprecated
*     @topic: 0,7
*     @event:  onOpen
*     @depricated: use grid.attachEvent("onOpenStart",func); instead
*     @eventdesc: Event raises immideatly after item in tree got command to open/close , and before item was opened//closed. Event also raised for unclosable nodes and nodes without open/close functionality - in that case result of function will be ignored.
            Event does not occur if node was opened by dhtmlXtree API.
*     @eventparam: ID of node which will be opened/closed
*     @eventparam: Current open state of tree item. 0 - item has not children, -1 - item closed, 1 - item opened.
*     @eventreturn: true - confirm opening/closing; false - deny opening/closing;
*/
   dhtmlXTreeObject.prototype.setOnOpenHandler=function(func){  this.attachEvent("onOpenStart",func);   };
/**
*     @desc: set function called before tree node opened/closed
*     @param: func - event handling function
*     @type: deprecated
*     @topic: 0,7
*     @event:  onOpenStart
*     @depricated: use grid.attachEvent("onOpenStart",func); instead
*     @eventdesc: Event raises immideatly after item in tree got command to open/close , and before item was opened//closed. Event also raised for unclosable nodes and nodes without open/close functionality - in that case result of function will be ignored.
            Event not raised if node opened by dhtmlXtree API.
*     @eventparam: ID of node which will be opened/closed
*     @eventparam: Current open state of tree item. 0 - item has not children, -1 - item closed, 1 - item opened.
*     @eventreturn: true - confirm opening/closing; false - deny opening/closing;
*/
   dhtmlXTreeObject.prototype.setOnOpenStartHandler=function(func){  this.attachEvent("onOpenStart",func);    };

/**
*     @desc: set function called after tree node opened/closed
*     @param: func - event handling function
*     @type: deprecated
*     @topic: 0,7
*     @event:  onOpenEnd
*     @depricated: use grid.attachEvent("onOpenEnd",func); instead
*     @eventdesc: Event raises immideatly after item in tree was opened//closed. Event also raised for unclosable nodes and nodes without open/close functionality - in that case result of function will be ignored.
            Event not raised if node opened by dhtmlXtree API.
*     @eventparam: ID of node which will be opened/closed
*     @eventparam: Current open state of tree item. 0 - item has not children, -1 - item closed, 1 - item opened.
*/
   dhtmlXTreeObject.prototype.setOnOpenEndHandler=function(func){  this.attachEvent("onOpenEnd",func);  };

   /**
*     @desc: set function called when tree node double clicked
*     @param: func - event handling function
*     @type: public
*     @topic: 0,7
*     @event: onDblClick
*     @depricated: use grid.attachEvent("onDblClick",func); instead
*     @eventdesc: Event raised immideatly after item in tree was doubleclicked, before default onDblClick functionality was processed.
         Beware using both onClick and onDblClick events, because component can  generate onClick event before onDblClick event while doubleclicking item in tree.
         ( that behavior depend on used browser )
*     @eventparam:  ID of item which was doubleclicked
*     @eventreturn:  true - confirm opening/closing; false - deny opening/closing;
*/
   dhtmlXTreeObject.prototype.setOnDblClickHandler=function(func){ this.attachEvent("onDblClick",func);   };









   /**
*     @desc: expand target node and all sub nodes
*     @type: public
*     @param: itemId - node id
*     @topic: 4
*/
   dhtmlXTreeObject.prototype.openAllItems=function(itemId)
   {
      var temp=this._globalIdStorageFind(itemId);
      if (!temp) return 0;
      this._xopenAll(temp);
   };
   
/**
*     @desc: return open/close state
*     @type: public
*     @param: itemId - node id
*     @return: -1 - close, 1 - opened, 0 - node doesn't have children
*     @topic: 4
*/   
   dhtmlXTreeObject.prototype.getOpenState=function(itemId){
      var temp=this._globalIdStorageFind(itemId);
      if (!temp) return "";
      return this._getOpenState(temp);
   };

/**  
*     @desc: collapse target node and all sub nodes
*     @type: public
*     @param: itemId - node id
*     @topic: 4  
*/
   dhtmlXTreeObject.prototype.closeAllItems=function(itemId)
   {
        if (itemId===window.undefined) itemId=this.rootId;
        
      var temp=this._globalIdStorageFind(itemId);
      if (!temp) return 0;
      this._xcloseAll(temp);

//nb:solves standard doctype prb in IE
         this.allTree.childNodes[0].border = "1";
       this.allTree.childNodes[0].border = "0";

   };
   
   
/**
*     @desc: set user data for target node
*     @type: public
*     @param: itemId - target node id
*     @param: name - key for user data
*     @param: value - user data value
*     @topic: 5
*/
   dhtmlXTreeObject.prototype.setUserData=function(itemId,name,value){
      var sNode=this._globalIdStorageFind(itemId,0,true);
         if (!sNode) return;
         if(name=="hint")
			 sNode.htmlNode.childNodes[0].childNodes[0].title=value;
            if (typeof(sNode.userData["t_"+name])=="undefined"){
                 if (!sNode._userdatalist) sNode._userdatalist=name;
                else sNode._userdatalist+=","+name;
            }
            sNode.userData["t_"+name]=value;
   };
   
/**  
*     @desc: get user data from target node
*     @type: public
*     @param: itemId - target node id
*     @param: name - key for user data
*     @return: value of user data
*     @topic: 5
*/
   dhtmlXTreeObject.prototype.getUserData=function(itemId,name){
      var sNode=this._globalIdStorageFind(itemId,0,true);
      if (!sNode) return;
      return sNode.userData["t_"+name];
   };




/**
*     @desc: get node color (text color)
*     @param: itemId - id of node
*     @type: public
*     @return: color of node (empty string for default color);
*     @topic: 6  
*/   
   dhtmlXTreeObject.prototype.getItemColor=function(itemId)
   {
      var temp=this._globalIdStorageFind(itemId);
      if (!temp) return 0;

      var res= new Object();
      if (temp.acolor) res.acolor=temp.acolor;
      if (temp.scolor) res.scolor=temp.scolor;      
      return res;
   };
/**  
*     @desc: set node text color
*     @param: itemId - id of node
*     @param: defaultColor - node color
*     @param: selectedColor - selected node color
*     @type: public
*     @topic: 6
*/
   dhtmlXTreeObject.prototype.setItemColor=function(itemId,defaultColor,selectedColor)
   {
      if ((itemId)&&(itemId.span))
         var temp=itemId;
      else
         var temp=this._globalIdStorageFind(itemId);
      if (!temp) return 0;
         else {
         if (temp.i_sel)
            {  if (selectedColor) temp.span.style.color=selectedColor; }
         else
            {  if (defaultColor) temp.span.style.color=defaultColor;  }

         if (selectedColor) temp.scolor=selectedColor;
         if (defaultColor) temp.acolor=defaultColor;
         }
   };

/**
*     @desc: return node text
*     @param: itemId - id of node
*     @type: public
*     @return: text of item (with HTML formatting, if any)
*     @topic: 6
*/
   dhtmlXTreeObject.prototype.getItemText=function(itemId)
   {
      var temp=this._globalIdStorageFind(itemId);
      if (!temp) return 0;
      return(temp.htmlNode.childNodes[0].childNodes[0].childNodes[3].childNodes[0].innerHTML);
   };
/**  
*     @desc: return parent item id
*     @param: itemId - id of node
*     @type: public
*     @return: id of parent item
*     @topic: 4
*/         
   dhtmlXTreeObject.prototype.getParentId=function(itemId)
   {
      var temp=this._globalIdStorageFind(itemId);
      if ((!temp)||(!temp.parentObject)) return "";
      return temp.parentObject.id;
   };



/**  
*     @desc: change item id
*     @type: public
*     @param: itemId - old node id
*     @param: newItemId - new node id        
*     @topic: 4
*/    
   dhtmlXTreeObject.prototype.changeItemId=function(itemId,newItemId)
   {
   	if (itemId==newItemId) return;
      var temp=this._globalIdStorageFind(itemId);
      if (!temp) return 0;
        temp.id=newItemId;
        temp.span.contextMenuId=newItemId;
        this._idpull[newItemId]=this._idpull[itemId];
        delete this._idpull[itemId];
   };


/**
*     @desc: mark selected item as cut
*     @type: public
*     @topic: 2  
*/    
   dhtmlXTreeObject.prototype.doCut=function(){
      if (this.nodeCut) this.clearCut();
      this.nodeCut=(new Array()).concat(this._selected);
        for (var i=0; i<this.nodeCut.length; i++){
          var tempa=this.nodeCut[i];
            tempa._cimgs=new Array();
          tempa._cimgs[0]=tempa.images[0];
          tempa._cimgs[1]=tempa.images[1];
          tempa._cimgs[2]=tempa.images[2];
          tempa.images[0]=tempa.images[1]=tempa.images[2]=this.cutImage;
          this._correctPlus(tempa);
        }
   };

/**
*     @desc: insert previously cut branch
*     @param: itemId - id of new parent node
*     @type: public
*     @topic: 2  
*/    
   dhtmlXTreeObject.prototype.doPaste=function(itemId){
      var tobj=this._globalIdStorageFind(itemId);
      if (!tobj) return 0;
        for (var i=0; i<this.nodeCut.length; i++){
               if (this._checkPNodes(tobj,this.nodeCut[i])) continue;
                this._moveNode(this.nodeCut[i],tobj);
               }
      this.clearCut();
   };

/**  
*     @desc: clear cut
*     @type: public
*     @topic: 2  
*/
   dhtmlXTreeObject.prototype.clearCut=function(){
      for (var i=0; i<this.nodeCut.length; i++)
         {
          var tempa=this.nodeCut[i];
          tempa.images[0]=tempa._cimgs[0];
          tempa.images[1]=tempa._cimgs[1];
          tempa.images[2]=tempa._cimgs[2];
          this._correctPlus(tempa);
         }
          this.nodeCut=new Array();
   };
   


   /**  
*     @desc: move node with subnodes
*     @type: private
*     @param: itemObject - moved node object
*     @param: targetObject - new parent node
*     @topic: 2  
*/
   dhtmlXTreeObject.prototype._moveNode=function(itemObject,targetObject){
//#__pro_feature:01112006{
//#complex_move:01112006{
      var mode=this.dadmodec;
      if (mode==1)
        {
            var z=targetObject;
         if (this.dadmodefix<0)
         {

                while (true){
            z=this._getPrevNode(z);
            if ((z==-1)) { z=this.htmlNode; break; }
                if ((z.tr==0)||(z.tr.style.display=="")||(!z.parentObject)) break;
                }

                var nodeA=z;
                var nodeB=targetObject;

            }
            else
            {
				if ((z.tr)&&(z.tr.nextSibling)&&(z.tr.nextSibling.nodem)&&!this._getOpenState(z)){
  				 	z = z.tr.nextSibling.nodem;
				}
           		else{
            	   z=this._getNextNode(z);
				   if ((z==-1)) z=this.htmlNode; 
				}
				
                var nodeB=z;
                var nodeA=targetObject;
            }


            if (this._getNodeLevel(nodeA,0)>this._getNodeLevel(nodeB,0))
                {
                if (!this.dropLower)
                    return this._moveNodeTo(itemObject,nodeA.parentObject);
                else
                    if  (nodeB.id!=this.rootId)
                        return this._moveNodeTo(itemObject,nodeB.parentObject,nodeB);
                    else
                        return this._moveNodeTo(itemObject,this.htmlNode,null);
                }
            else
                {
                return this._moveNodeTo(itemObject,nodeB.parentObject,nodeB);
                }


      }
      else
//#}
//#}
	  return this._moveNodeTo(itemObject,targetObject);

   }

   /**
*     @desc: fix order of nodes in collection
*     @type: private
*     @param: target - parent item node
*     @param: zParent - before node
*     @edition: Professional
*     @topic: 2
*/

dhtmlXTreeObject.prototype._fixNodesCollection=function(target,zParent){
      var flag=0; var icount=0;
      var Nodes=target.childNodes;
      var Count=target.childsCount-1;

      if (zParent==Nodes[Count]) return;
      for (var i=0; i<Count; i++)
         if (Nodes[i]==Nodes[Count]) {  Nodes[i]=Nodes[i+1]; Nodes[i+1]=Nodes[Count]; }

//         Count=target.childsCount;
      for (var i=0; i<Count+1; i++)      
         {
         if (flag) { 
            var temp=Nodes[i];
            Nodes[i]=flag; 
            flag=temp; 
               }
         else 
         if (Nodes[i]==zParent) {   flag=Nodes[i]; Nodes[i]=Nodes[Count];  }
         }
   };
   
/**  
*     @desc: recreate branch
*     @type: private
*     @param: itemObject - moved node object
*     @param: targetObject - new parent node
*     @param: level - top level flag
*     @param: beforeNode - node for sibling mode
*     @mode: mode - DragAndDrop mode (0 - as child, 1 as sibling)
*     @edition: Professional
*     @topic: 2
*/
dhtmlXTreeObject.prototype._recreateBranch=function(itemObject,targetObject,beforeNode,level){
    var i; var st="";
    if (beforeNode){
    for (i=0; i<targetObject.childsCount; i++)
        if (targetObject.childNodes[i]==beforeNode) break;

    if (i!=0)
        beforeNode=targetObject.childNodes[i-1];
    else{
        st="TOP";
        beforeNode="";
        }
    }

   var t2=this._onradh; this._onradh=null;
   var newNode=this._attachChildNode(targetObject,itemObject.id,itemObject.label,0,itemObject.images[0],itemObject.images[1],itemObject.images[2],st,0,beforeNode);

   //copy user data
   newNode._userdatalist=itemObject._userdatalist;
   newNode.userData=itemObject.userData.clone();
   if(itemObject._attrs){
	   newNode._attrs={};
	   for(var attr in itemObject._attrs)
		   newNode._attrs[attr] = itemObject._attrs[attr];
	}

   newNode.XMLload=itemObject.XMLload;
   if (t2){
   	this._onradh=t2; this._onradh(newNode.id); }

//#__pro_feature:01112006{
//#smart_parsing:01112006{
   //copy unparsed chunk
      if (itemObject.treeNod.dpcpy) itemObject.treeNod._globalIdStorageFind(itemObject.id);
      else newNode.unParsed=itemObject.unParsed;
      this._correctPlus(newNode);
      //this._correctLine(newNode);
   
//#}
//#}
   for (var i=0; i<itemObject.childsCount; i++)
      this._recreateBranch(itemObject.childNodes[i],newNode,0,1);

//#__pro_feature:01112006{
//#child_calc:01112006{
      if ((!level)&&(this.childCalc)) { this._redrawFrom(this,targetObject);  }
//#}
//#}
   return newNode;
}

/**
*     @desc: move single node
*     @type: private
*     @param: itemObject - moved node object
*     @param: targetObject - new parent node
*     @mode: mode - DragAndDrop mode (0 - as child, 1 as sibling)
*     @topic: 2
*/
   dhtmlXTreeObject.prototype._moveNodeTo=function(itemObject,targetObject,beforeNode){
    //return;
    if   (itemObject.treeNod._nonTrivialNode)
        return itemObject.treeNod._nonTrivialNode(this,targetObject,beforeNode,itemObject);

	if (this._checkPNodes(targetObject,itemObject))
   		return false;
                           		
    if    (targetObject.mytype)
       var framesMove=(itemObject.treeNod.lWin!=targetObject.lWin);
    else
          var framesMove=(itemObject.treeNod.lWin!=targetObject.treeNod.lWin);

   if (!this.callEvent("onDrag",[itemObject.id,targetObject.id,(beforeNode?beforeNode.id:null),itemObject.treeNod,targetObject.treeNod])) return false;
      if ((targetObject.XMLload==0)&&(this.XMLsource))
         {
         targetObject.XMLload=1;
            this._loadDynXML(targetObject.id);
         }
	this.openItem(targetObject.id);

   var oldTree=itemObject.treeNod;
   var c=itemObject.parentObject.childsCount;
   var z=itemObject.parentObject;
   

   if ((framesMove)||(oldTree.dpcpy)) {//interframe drag flag
        var _otiid=itemObject.id;
      itemObject=this._recreateBranch(itemObject,targetObject,beforeNode);
        if (!oldTree.dpcpy) oldTree.deleteItem(_otiid);
        }
   else
      {
	
      var Count=targetObject.childsCount; var Nodes=targetObject.childNodes;
      	   	if (Count==0) targetObject._open=true;
      		oldTree._unselectItem(itemObject);
           Nodes[Count]=itemObject;
            itemObject.treeNod=targetObject.treeNod;
            targetObject.childsCount++;         
			
            var tr=this._drawNewTr(Nodes[Count].htmlNode);

            if (!beforeNode)
               {
                  targetObject.htmlNode.childNodes[0].appendChild(tr);
               if (this.dadmode==1) this._fixNodesCollection(targetObject,beforeNode);
               }
            else
               {
               targetObject.htmlNode.childNodes[0].insertBefore(tr,beforeNode.tr);
               this._fixNodesCollection(targetObject,beforeNode);
               Nodes=targetObject.childNodes;
               }

			
         }

            if ((!oldTree.dpcpy)&&(!framesMove))   {
                var zir=itemObject.tr;

                if ((document.all)&&(navigator.appVersion.search(/MSIE\ 5\.0/gi)!=-1))
                    {
                    window.setTimeout(function() { zir.parentNode.removeChild(zir); } , 250 );
                    }
                else   //if (zir.parentNode) zir.parentNode.removeChild(zir,true);

                itemObject.parentObject.htmlNode.childNodes[0].removeChild(itemObject.tr);

                //itemObject.tr.removeNode(true);
            if ((!beforeNode)||(targetObject!=itemObject.parentObject)){
               for (var i=0; i<z.childsCount; i++){
                  if (z.childNodes[i].id==itemObject.id) {
                  z.childNodes[i]=0;
                  break;            }}}
               else z.childNodes[z.childsCount-1]=0;

            oldTree._compressChildList(z.childsCount,z.childNodes);
            z.childsCount--;
            }


      if ((!framesMove)&&(!oldTree.dpcpy)) {
       itemObject.tr=tr;
      tr.nodem=itemObject;
      itemObject.parentObject=targetObject;

      if (oldTree!=targetObject.treeNod) {
	    if(itemObject.treeNod._registerBranch(itemObject,oldTree)) return;      this._clearStyles(itemObject);  this._redrawFrom(this,itemObject.parentObject);
		if(this._onradh) this._onradh(itemObject.id);
		   };

      this._correctPlus(targetObject);
      this._correctLine(targetObject);

      this._correctLine(itemObject);
      this._correctPlus(itemObject);

         //fix target siblings
      if (beforeNode)
      {

         this._correctPlus(beforeNode);
         //this._correctLine(beforeNode);
      }
      else 
      if (targetObject.childsCount>=2)
      {

         this._correctPlus(Nodes[targetObject.childsCount-2]);
         this._correctLine(Nodes[targetObject.childsCount-2]);
      }
      
      this._correctPlus(Nodes[targetObject.childsCount-1]);
      //this._correctLine(Nodes[targetObject.childsCount-1]);


      if (this.tscheck) this._correctCheckStates(targetObject);
      if (oldTree.tscheck) oldTree._correctCheckStates(z);

      }

      //fix source parent

      if (c>1) { oldTree._correctPlus(z.childNodes[c-2]);
               oldTree._correctLine(z.childNodes[c-2]);
               }


//      if (z.childsCount==0)
          oldTree._correctPlus(z);
            oldTree._correctLine(z);

//#__pro_feature:01112006{
//#child_calc:01112006{
      this._fixChildCountLabel(targetObject);
      oldTree._fixChildCountLabel(z);
//#}
//#}
      this.callEvent("onDrop",[itemObject.id,targetObject.id,(beforeNode?beforeNode.id:null),oldTree,targetObject.treeNod]);
      return itemObject.id;
   };

   

/**
*     @desc: recursive set default styles for node
*     @type: private
*     @param: itemObject - target node object
*     @topic: 6  
*/   
   dhtmlXTreeObject.prototype._clearStyles=function(itemObject){
   		if (!itemObject.htmlNode) return; //some weird case in SRND mode
         var td1=itemObject.htmlNode.childNodes[0].childNodes[0].childNodes[1];
         var td3=td1.nextSibling.nextSibling;

         itemObject.span.innerHTML=itemObject.label;
		 itemObject.i_sel=false;

   		 if (itemObject._aimgs)
	         this.dragger.removeDraggableItem(td1.nextSibling);

         if (this.checkBoxOff) {
		 	td1.childNodes[0].style.display="";
			td1.childNodes[0].onclick=this.onCheckBoxClick;
			this._setSrc(td1.childNodes[0],this.imPath+this.checkArray[itemObject.checkstate]);
			}
         else td1.childNodes[0].style.display="none";
         td1.childNodes[0].treeNod=this;

         this.dragger.removeDraggableItem(td3);
         if (this.dragAndDropOff) this.dragger.addDraggableItem(td3,this);
		 if (this._aimgs) this.dragger.addDraggableItem(td1.nextSibling,this);
		 		 
         td3.childNodes[0].className="standartTreeRow";
         td3.onclick=this.onRowSelect; td3.ondblclick=this.onRowClick2;
         td1.previousSibling.onclick=this.onRowClick;

         this._correctLine(itemObject);
         this._correctPlus(itemObject);
         for (var i=0; i<itemObject.childsCount; i++) this._clearStyles(itemObject.childNodes[i]); 

   };
/**
*     @desc: register node and all children nodes
*     @type: private
*     @param: itemObject - node object
*     @topic: 2  
*/
   dhtmlXTreeObject.prototype._registerBranch=function(itemObject,oldTree){
      if (oldTree) oldTree._globalIdStorageSub(itemObject.id);
      itemObject.id=this._globalIdStorageAdd(itemObject.id,itemObject);
      itemObject.treeNod=this;
         for (var i=0; i<itemObject.childsCount; i++)
            this._registerBranch(itemObject.childNodes[i],oldTree);
      return 0;
   };

   
/**  
*     @desc: enable three state checkboxes
*     @beforeInit: 1
*     @param: mode - 1 - on, 0 - off;
*     @type: public
*     @topic: 0  
*/
   dhtmlXTreeObject.prototype.enableThreeStateCheckboxes=function(mode) { this.tscheck=convertStringToBoolean(mode); };


/**
*     @desc: set function called when mouse is over tree node
*     @param: func - event handling function
*     @type: deprecated
*     @topic: 0,7
*     @event: onMouseIn
*     @depricated: use grid.attachEvent("onMouseIn",func); instead
*     @eventdesc: Event raised immideatly after mouse started moving over item
*     @eventparam:  ID of item
*/
   dhtmlXTreeObject.prototype.setOnMouseInHandler=function(func){
    	this.ehlt=true;
   		this.attachEvent("onMouseIn",func);
	};

/**
*     @desc: set function called when mouse is out of tree node
*     @param: func - event handling function
*     @type: deprecated
*     @topic: 0,7
*     @event: onMouseOut
*     @depricated: use grid.attachEvent("onMouseOut",func); instead
*     @eventdesc: Event raised immideatly after mouse moved out of item
*     @eventparam:  ID of clicked item
*/
   dhtmlXTreeObject.prototype.setOnMouseOutHandler=function(func){
		this.ehlt=true;
   		this.attachEvent("onMouseOut",func);
	};





//#__pro_feature:01112006{
/**
*     @desc: enable drag without removing (copy instead of move)
*     @beforeInit: 1
*     @param: mode - 1 - on, 0 - off;
*     @type: public
*     @edition:Professional
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.enableMercyDrag=function(mode){ this.dpcpy=convertStringToBoolean(mode); };
//#}



/**
*     @desc: enable tree images
*     @beforeInit: 1
*     @param: mode - 1 - on, 0 - off;
*     @type: public
*     @topic: 0  
*/         
   dhtmlXTreeObject.prototype.enableTreeImages=function(mode) { this.timgen=convertStringToBoolean(mode); };
   

   
/**
*     @desc: enable mode with fixed tables (looks better, but has no horisontal scrollbar)
*     @beforeInit: 1
*     @param: mode - 1 - on, 0 - off;
*     @type: private
*     @topic: 0  
*/
   dhtmlXTreeObject.prototype.enableFixedMode=function(mode) { this.hfMode=convertStringToBoolean(mode); };
   
/**  
*     @desc: show/hide checkboxes (all checkboxes in tree)
*     @type: public
*     @param: mode - true/false
*     @param: hidden - if set to true, checkboxes not rendered but can be shown by showItemCheckbox
*     @topic: 0  
*/
   dhtmlXTreeObject.prototype.enableCheckBoxes=function(mode, hidden){ this.checkBoxOff=convertStringToBoolean(mode); this.cBROf=(!(this.checkBoxOff||convertStringToBoolean(hidden))); 
   	};
/**
*     @desc: set default images for nodes (must be called before XML loading)
*     @type: public
*     @param: a0 - image for node without children;
*     @param: a1 - image for closed node;
*     @param: a2 - image for opened node                  
*     @topic: 6  
*/
   dhtmlXTreeObject.prototype.setStdImages=function(image1,image2,image3){
                  this.imageArray[0]=image1; this.imageArray[1]=image2; this.imageArray[2]=image3;};

/**
*     @desc: enable/disable tree lines (parent-child threads)
*     @type: public
*     @param: mode - enable/disable tree lines
*     @topic: 6
*/                  
   dhtmlXTreeObject.prototype.enableTreeLines=function(mode){
      this.treeLinesOn=convertStringToBoolean(mode);
   }

/**
*     @desc: set images used for parent-child threads drawing (lines, plus, minus)
*     @type: public
*     @param: arrayName - name of array: plus, minus
*     @param: image1 - line crossed image
*     @param: image2 - image with top line
*     @param: image3 - image with bottom line
*     @param: image4 - image without line
*     @param: image5 - single root image
*     @topic: 6
*/      
   dhtmlXTreeObject.prototype.setImageArrays=function(arrayName,image1,image2,image3,image4,image5){
      switch(arrayName){
      case "plus": this.plusArray[0]=image1; this.plusArray[1]=image2; this.plusArray[2]=image3; this.plusArray[3]=image4; this.plusArray[4]=image5; break;
      case "minus": this.minusArray[0]=image1; this.minusArray[1]=image2; this.minusArray[2]=image3; this.minusArray[3]=image4;  this.minusArray[4]=image5; break;
      }
   };

/**  
*     @desc: expand node
*     @param: itemId - id of node
*     @type: public
*     @topic: 4
*/ 
   dhtmlXTreeObject.prototype.openItem=function(itemId){
	   this.skipLock = true;
	   var temp=this._globalIdStorageFind(itemId);
	   if (!temp) return 0;
	   else return this._openItem(temp);
	   this.skipLock = false;
   };

/**  
*     @desc: expand node
*     @param: item - tree node object
*     @type: private
*     @editing: pro
*     @topic: 4  
*/ 
   dhtmlXTreeObject.prototype._openItem=function(item){ 
   		   var state=this._getOpenState(item);
		   if ((state<0)||(((this.XMLsource)&&(!item.XMLload)))){
	           if    (!this.callEvent("onOpenStart",[item.id,state])) return 0;
	           this._HideShow(item,2);
				   if    (this.checkEvent("onOpenEnd")){ 
						   if (this.onXLE==this._epnFHe) this._epnFHe(this,item.id,true);
	                       if (!this.xmlstate || !this.XMLsource)
	                       		this.callEvent("onOpenEnd",[item.id,this._getOpenState(item)]);
	                        else{
	                            this._oie_onXLE.push(this.onXLE);
	                            this.onXLE=this._epnFHe;
	                            }
							}
			   } else if (this._srnd) this._HideShow(item,2);
           if (item.parentObject && !this._skip_open_parent) this._openItem(item.parentObject);
   };
   
/**  
*     @desc: collapse node
*     @param: itemId - id of node
*     @type: public
*     @topic: 4  
*/
   dhtmlXTreeObject.prototype.closeItem=function(itemId){
	   if (this.rootId==itemId) return 0;
	   this.skipLock = true;
	   var temp=this._globalIdStorageFind(itemId);
	   if (!temp) return 0;
	   if (temp.closeble)
		   this._HideShow(temp,1);
	   this.skipLock = false;
   };
   
   

   
   
   
   
   

   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
      
/**
*     @desc: get node level (position in hierarchy)
*     @param: itemId - id of node
*     @type: public
*     @return: node level (0 if no such item in hierarchy - probably super root)
*     @topic: 4
*/
   dhtmlXTreeObject.prototype.getLevel=function(itemId){
      var temp=this._globalIdStorageFind(itemId);
      if (!temp) return 0;
      return this._getNodeLevel(temp,0);
   };
   
      

/**  
*     @desc: prevent node from closing
*     @param: itemId - id of node
*     @param: flag -  if 0 - node can't be closed, else node can be closed
*     @type: public
*     @topic: 4  
*/ 
   dhtmlXTreeObject.prototype.setItemCloseable=function(itemId,flag)
   {
      flag=convertStringToBoolean(flag);
      if ((itemId)&&(itemId.span)) 
         var temp=itemId;
      else      
         var temp=this._globalIdStorageFind(itemId);
      if (!temp) return 0;
         temp.closeble=flag;
   };

   /**  
*     @desc: recursive function used for node level calculation
*     @param: itemObject - pointer to node object
*     @param: count - counter of levels        
*     @type: private
*     @topic: 4  
*/   
   dhtmlXTreeObject.prototype._getNodeLevel=function(itemObject,count){
      if (itemObject.parentObject) return this._getNodeLevel(itemObject.parentObject,count+1);
      return(count);
   };
   
   /**  
*     @desc: return number of children
*     @param: itemId - id of node
*     @type: public
*     @return: number of child items for loaded branches; true - for not loaded branches
*     @topic: 4
*/
   dhtmlXTreeObject.prototype.hasChildren=function(itemId){
      var temp=this._globalIdStorageFind(itemId);
      if (!temp) return 0;
      else 
         {
            if ( (this.XMLsource)&&(!temp.XMLload) ) return true;
            else 
               return temp.childsCount;
         };
   };
   

   /**
*     @desc: get number of leafs (nodes without children)
*     @param: itemNode -  node object
*     @type: private
*     @edition: Professional
*     @topic: 4
*/
   dhtmlXTreeObject.prototype._getLeafCount=function(itemNode){
      var a=0;
      for (var b=0; b<itemNode.childsCount; b++)
         if (itemNode.childNodes[b].childsCount==0) a++;
      return a;
   }

   
/**
*     @desc: set new node text (HTML allowed)
*     @param: itemId - id of node
*     @param: newLabel - node text
*     @param: newTooltip - (optional)tooltip for the node
*     @type: public
*     @topic: 6
*/
   dhtmlXTreeObject.prototype.setItemText=function(itemId,newLabel,newTooltip)
   {
      var temp=this._globalIdStorageFind(itemId);
      if (!temp) return 0;
      temp.label=newLabel;
      temp.span.innerHTML=newLabel;
//#__pro_feature:01112006{
//#child_calc:01112006{
        if (this.childCalc) this._fixChildCountLabel(temp);
//#}
//#}
	      temp.span.parentNode.parentNode.title=newTooltip||"";
   };

/**
*     @desc: get item's tooltip
*     @param: itemId - id of node
*     @type: public
*     @topic: 6
*/
    dhtmlXTreeObject.prototype.getItemTooltip=function(itemId){
      var temp=this._globalIdStorageFind(itemId);
      if (!temp) return "";
	  return (temp.span.parentNode.parentNode._dhx_title||temp.span.parentNode.parentNode.title||"");
   };

/**  
*     @desc: refresh tree branch from xml (XML with child nodes rerequested from server)
*     @param: itemId - id of node, if not defined tree super root used.
*     @type: public
*     @topic: 6  
*/
   dhtmlXTreeObject.prototype.refreshItem=function(itemId){
      if (!itemId) itemId=this.rootId;
      var temp=this._globalIdStorageFind(itemId);
      this.deleteChildItems(itemId);
        this._loadDynXML(itemId);
   };

   /**  
*     @desc: set item images
*     @param: itemId - id of node
*     @param: image1 - node without children icon
*     @param: image2 - closed node icon          
*     @param: image3 - open node icon         
*     @type: public
*     @topic: 6
*/
   dhtmlXTreeObject.prototype.setItemImage2=function(itemId, image1,image2,image3){
      var temp=this._globalIdStorageFind(itemId);
      if (!temp) return 0;
            temp.images[1]=image2;
            temp.images[2]=image3;
            temp.images[0]=image1;
      this._correctPlus(temp);
   };
/**
*     @desc: set item icons (mostly usefull for childless nodes)
*     @param: itemId - id of node
*     @param: image1 - node without children icon or closed node icon (if image2 specified)
*     @param: image2 - open node icon (optional)        
*     @type: public
*     @topic: 6  
*/   
   dhtmlXTreeObject.prototype.setItemImage=function(itemId,image1,image2)
   {
      var temp=this._globalIdStorageFind(itemId);
      if (!temp) return 0;
         if (image2)
         {
            temp.images[1]=image1;
            temp.images[2]=image2;
         }
         else temp.images[0]=image1;
      this._correctPlus(temp);
   };


/**
*     @desc: Returns the list of all subitems Ids from the next level of tree, separated by commas.
*     @param: itemId - id of node
*     @type: public
*     @return: list of all subitems from the next level of tree, separated by commas.
*     @topic: 6
*/
   dhtmlXTreeObject.prototype.getSubItems =function(itemId)
   {
      var temp=this._globalIdStorageFind(itemId,0,1);
      if (!temp) return 0;
//#__pro_feature:01112006{
//#smart_parsing:01112006{
        if(temp.unParsed)
            return (this._getSubItemsXML(temp.unParsed));
//#}
//#}
      var z="";
      for (i=0; i<temp.childsCount; i++){
         if (!z) z= ""+temp.childNodes[i].id;
            else z+=this.dlmtr+temp.childNodes[i].id;

                                                         }

      return z;
   };




/**
*     @desc: Returns the list of all sub items from all next levels of tree, separated by commas.
*     @param: itemId - id of node
*     @edition: Professional
*     @type: private
*     @topic: 6
*/
   dhtmlXTreeObject.prototype._getAllScraggyItems =function(node)
   {
      var z="";
      for (var i=0; i<node.childsCount; i++)
        {
            if ((node.childNodes[i].unParsed)||(node.childNodes[i].childsCount>0))
            {
                    if (node.childNodes[i].unParsed)
                        var zb=this._getAllScraggyItemsXML(node.childNodes[i].unParsed,1);
                    else
                       var zb=this._getAllScraggyItems(node.childNodes[i])

                 if (zb)
                        if (z) z+=this.dlmtr+zb;
                        else z=zb;
         }
            else
               if (!z) z=""+node.childNodes[i].id;
             else z+=this.dlmtr+node.childNodes[i].id;
         }
          return z;
   };





/**
*     @desc: Returns the list of all children items from all next levels of tree, separated by commas.
*     @param: itemId - id of node
*     @type: private
*     @edition: Professional
*     @topic: 6
*/

   dhtmlXTreeObject.prototype._getAllFatItems =function(node)
   {
      var z="";
      for (var i=0; i<node.childsCount; i++)
        {
            if ((node.childNodes[i].unParsed)||(node.childNodes[i].childsCount>0))
            {
             if (!z) z=""+node.childNodes[i].id;
                else z+=this.dlmtr+node.childNodes[i].id;

                    if (node.childNodes[i].unParsed)
                        var zb=this._getAllFatItemsXML(node.childNodes[i].unParsed,1);
                    else
                       var zb=this._getAllFatItems(node.childNodes[i])

                 if (zb) z+=this.dlmtr+zb;
         }
         }
          return z;
   };


/**
*     @desc: Returns the list of all children items from all next levels of tree, separated by commas.
*     @param: itemId - id of node
*     @type: private
*     @topic: 6
*/
   dhtmlXTreeObject.prototype._getAllSubItems =function(itemId,z,node)
   {
      if (node) temp=node;
      else {
      var temp=this._globalIdStorageFind(itemId);
         };
      if (!temp) return 0;

      z="";
      for (var i=0; i<temp.childsCount; i++)
         {
         if (!z) z=""+temp.childNodes[i].id;
            else z+=this.dlmtr+temp.childNodes[i].id;
         var zb=this._getAllSubItems(0,z,temp.childNodes[i])

         if (zb) z+=this.dlmtr+zb;
         }

//#__pro_feature:01112006{
//#smart_parsing:01112006{
        if (temp.unParsed)
            z=this._getAllSubItemsXML(itemId,z,temp.unParsed);
//#}
//#}
          return z;
   };




   
/**  
*     @desc: select node ( and optionaly fire onselect event)
*     @type: public
*     @param: itemId - node id
*     @param: mode - If true, script function for selected node will be called.
*     @param: preserve - preserve earlier selected nodes
*     @topic: 1
*/
   dhtmlXTreeObject.prototype.selectItem=function(itemId,mode,preserve){
      mode=convertStringToBoolean(mode);
         var temp=this._globalIdStorageFind(itemId);
      if ((!temp)||(!temp.parentObject)) return 0;

            if (this.XMLloadingWarning)
                temp.parentObject.openMe=1;
            else
             	this._openItem(temp.parentObject);

      //temp.onRowSelect(0,temp.htmlNode.childNodes[0].childNodes[0].childNodes[3],mode);
        var ze=null;
        if (preserve)  {
			ze=new Object; ze.ctrlKey=true;
			if (temp.i_sel) ze.skipUnSel=true;
		}
      if (mode)
         this.onRowSelect(ze,temp.htmlNode.childNodes[0].childNodes[0].childNodes[3],false);
      else
         this.onRowSelect(ze,temp.htmlNode.childNodes[0].childNodes[0].childNodes[3],true);
   };
   
/**
*     @desc: retun selected node text
*     @type: public
*     @return: text of selected node (or list of all selected nodes text if more than one selected)
*     @topic: 1
*/
   dhtmlXTreeObject.prototype.getSelectedItemText=function()
   {
        var str=new Array();
        for (var i=0; i<this._selected.length; i++) str[i]=this._selected[i].span.innerHTML;
      return (str.join(this.dlmtr));
   };




/**  
*     @desc: correct childNode list after node deleting
*     @type: private
*     @param: Count - childNodes collection length        
*     @param: Nodes - childNodes collection
*     @topic: 4  
*/   
   dhtmlXTreeObject.prototype._compressChildList=function(Count,Nodes)
   {
      Count--;
      for (var i=0; i<Count; i++)
      {
         if (Nodes[i]==0) { Nodes[i]=Nodes[i+1]; Nodes[i+1]=0;}
      };
   };
/**  
*     @desc: delete node
*     @type: private
*     @param: itemId - target node id
*     @param: htmlObject - target node object        
*     @param: skip - node unregistration mode (optional, used by private methods)
*     @topic: 2
*/      
   dhtmlXTreeObject.prototype._deleteNode=function(itemId,htmlObject,skip){
   if ((!htmlObject)||(!htmlObject.parentObject)) return 0;
   var tempos=0; var tempos2=0;
   if (htmlObject.tr.nextSibling)  tempos=htmlObject.tr.nextSibling.nodem;
   if (htmlObject.tr.previousSibling)  tempos2=htmlObject.tr.previousSibling.nodem;
   
      var sN=htmlObject.parentObject;
      var Count=sN.childsCount;
      var Nodes=sN.childNodes;
            for (var i=0; i<Count; i++)
            {
               if (Nodes[i].id==itemId) { 
               if (!skip) sN.htmlNode.childNodes[0].removeChild(Nodes[i].tr);
               Nodes[i]=0;
               break;
               }
            }
      this._compressChildList(Count,Nodes);
      if (!skip) {
        sN.childsCount--;
                 }

      if (tempos) {
      this._correctPlus(tempos);
      this._correctLine(tempos);
               }
      if (tempos2) {
      this._correctPlus(tempos2);
      this._correctLine(tempos2);
               }
      if (this.tscheck) this._correctCheckStates(sN);

      if (!skip) {
        this._globalIdStorageRecSub(htmlObject);
                 }
   };
/**
*     @desc: set state of node's checkbox
*     @type: public
*     @param: itemId - target node id
*     @param: state - checkbox state (0/1/"unsure")
*     @topic: 5
*/
   dhtmlXTreeObject.prototype.setCheck=function(itemId,state){
      var sNode=this._globalIdStorageFind(itemId,0,1);
      if (!sNode) return;

        if (state==="unsure")
            this._setCheck(sNode,state);
        else
        {
      state=convertStringToBoolean(state);
        if ((this.tscheck)&&(this.smcheck)) this._setSubChecked(state,sNode);
      else this._setCheck(sNode,state);
        }
      if (this.smcheck)
         this._correctCheckStates(sNode.parentObject);
   };

   dhtmlXTreeObject.prototype._setCheck=function(sNode,state){
   		if (!sNode) return;
        if (((sNode.parentObject._r_logic)||(this._frbtr))&&(state))
			if (this._frbtrs){
				if (this._frbtrL)   this.setCheck(this._frbtrL.id,0);
				this._frbtrL=sNode;
			} else
    	        for (var i=0; i<sNode.parentObject.childsCount; i++)
	                this._setCheck(sNode.parentObject.childNodes[i],0);

      var z=sNode.htmlNode.childNodes[0].childNodes[0].childNodes[1].childNodes[0];

      if (state=="unsure") sNode.checkstate=2;
      else if (state) sNode.checkstate=1; else sNode.checkstate=0;
      if (sNode.dscheck) sNode.checkstate=sNode.dscheck;
      this._setSrc(z,this.imPath+((sNode.parentObject._r_logic||this._frbtr)?this.radioArray:this.checkArray)[sNode.checkstate]);
   };

/**
*     @desc: change state of node's checkbox and all children checkboxes
*     @type: public
*     @param: itemId - target node id
*     @param: state - checkbox state
*     @topic: 5
*/
dhtmlXTreeObject.prototype.setSubChecked=function(itemId,state){
   var sNode=this._globalIdStorageFind(itemId);
   this._setSubChecked(state,sNode);
   this._correctCheckStates(sNode.parentObject);
}



/**  
*     @desc: change state of node's checkbox and all childnodes checkboxes
*     @type: private
*     @param: itemId - target node id
*     @param: state - checkbox state
*     @param: sNode - target node object (optional, used by private methods)
*     @topic: 5  
*/
   dhtmlXTreeObject.prototype._setSubChecked=function(state,sNode){
      state=convertStringToBoolean(state);
      if (!sNode) return;
        if (((sNode.parentObject._r_logic)||(this._frbtr))&&(state))
            for (var i=0; i<sNode.parentObject.childsCount; i++)
                this._setSubChecked(0,sNode.parentObject.childNodes[i]);

//#__pro_feature:01112006{
//#smart_parsing:01112006{
      if (sNode.unParsed)
         this._setSubCheckedXML(state,sNode.unParsed)
//#}
//#}
        if (sNode._r_logic||this._frbtr)
           this._setSubChecked(state,sNode.childNodes[0]);
        else
      for (var i=0; i<sNode.childsCount; i++)
         {
             this._setSubChecked(state,sNode.childNodes[i]);
         };
      var z=sNode.htmlNode.childNodes[0].childNodes[0].childNodes[1].childNodes[0];

      if (state) sNode.checkstate=1;
      else    sNode.checkstate=0;
      if (sNode.dscheck)  sNode.checkstate=sNode.dscheck;



      this._setSrc(z,this.imPath+((sNode.parentObject._r_logic||this._frbtr)?this.radioArray:this.checkArray)[sNode.checkstate]);
   };

/**
*     @desc: get state of nodes's checkbox
*     @type: public
*     @param: itemId - target node id
*     @return: node state (0 - unchecked,1 - checked, 2 - third state)
*     @topic: 5  
*/      
   dhtmlXTreeObject.prototype.isItemChecked=function(itemId){
      var sNode=this._globalIdStorageFind(itemId);
      if (!sNode) return;      
      return   sNode.checkstate;
   };







/**
*     @desc: delete all children of node
*     @type: public
*     @param: itemId - node id
*     @topic: 2
*/
    dhtmlXTreeObject.prototype.deleteChildItems=function(itemId)
   {
      var sNode=this._globalIdStorageFind(itemId);
      if (!sNode) return;
      var j=sNode.childsCount;
      for (var i=0; i<j; i++)
      {
         this._deleteNode(sNode.childNodes[0].id,sNode.childNodes[0]);
      };
   };

/**
*     @desc: delete node
*     @type: public
*     @param: itemId - node id
*     @param: selectParent - If true parent of deleted item get selection, else no selected items leaving in tree.
*     @topic: 2  
*/      
dhtmlXTreeObject.prototype.deleteItem=function(itemId,selectParent){
    if ((!this._onrdlh)||(this._onrdlh(itemId))){
		var z=this._deleteItem(itemId,selectParent);
//#__pro_feature:01112006{
//#child_calc:01112006{
    if (z)
        this._fixChildCountLabel(z);
//#}
//#}
	}

    //nb:solves standard doctype prb in IE
      this.allTree.childNodes[0].border = "1";
      this.allTree.childNodes[0].border = "0";
}
/**
*     @desc: delete node
*     @type: private
*     @param: id - node id
*     @param: selectParent - If true parent of deleted item get selection, else no selected items leaving in tree.
*     @param: skip - unregistering mode (optional, used by private methods)        
*     @topic: 2  
*/
dhtmlXTreeObject.prototype._deleteItem=function(itemId,selectParent,skip){
      selectParent=convertStringToBoolean(selectParent);
      var sNode=this._globalIdStorageFind(itemId);
      if (!sNode) return;
        var pid=this.getParentId(itemId);

      var zTemp=sNode.parentObject;
      this._deleteNode(itemId,sNode,skip);
      if(this._editCell&&this._editCell.id==itemId)
     	this._editCell = null;
      this._correctPlus(zTemp);
      this._correctLine(zTemp);

      if  ((selectParent)&&(pid!=this.rootId)) this.selectItem(pid,1);
      return    zTemp;
   };

/**
*     @desc: uregister all child nodes of target node
*     @type: private
*     @param: itemObject - node object
*     @topic: 3  
*/      
   dhtmlXTreeObject.prototype._globalIdStorageRecSub=function(itemObject){
      for(var i=0; i<itemObject.childsCount; i++)
      {
         this._globalIdStorageRecSub(itemObject.childNodes[i]);
         this._globalIdStorageSub(itemObject.childNodes[i].id);
      };
      this._globalIdStorageSub(itemObject.id);

      	  /*anti memory leaking*/
	  	var z=itemObject;
//		var par=z.span.parentNode.parentNode.childNodes;
//		par[0].parentObject=null;
//		par[1].childNodes[0].parentObject=null;
//		par[2].childNodes[0].parentObject=null;
//		par[2].childNodes[0].treeNod=null;
//		par[2].parentObject=null;
//		par[3].parentObject=null;
		z.span=null;
		z.tr.nodem=null;
		z.tr=null;
		z.htmlNode=null;
   };

/**  
*     @desc: create new node next to specified
*     @type: public
*     @param: itemId - node id
*     @param: newItemId - new node id
*     @param: itemText - new node text
*     @param: itemActionHandler - function fired on node select event (optional)
*     @param: image1 - image for node without children; (optional)
*     @param: image2 - image for closed node; (optional)
*     @param: image3 - image for opened node (optional)
*     @param: optionStr - options string (optional)            
*     @param: children - node children flag (for dynamical trees) (optional)
*     @topic: 2  
*/
   dhtmlXTreeObject.prototype.insertNewNext=function(itemId,newItemId,itemText,itemActionHandler,image1,image2,image3,optionStr,children){
      var sNode=this._globalIdStorageFind(itemId);
      if ((!sNode)||(!sNode.parentObject)) return (0);

      var nodez=this._attachChildNode(0,newItemId,itemText,itemActionHandler,image1,image2,image3,optionStr,children,sNode);
//#__pro_feature:01112006{
//#child_calc:01112006{
      if ((!this.XMLloadingWarning)&&(this.childCalc))  this._fixChildCountLabel(sNode.parentObject);
//#}
//#}
        return nodez;
   };


   
/**
*     @desc: retun node id by index
*     @type: public
*     @param: itemId - parent node id
*     @param: index - index of node, 0 based
*     @return: node id
*     @topic: 1
*/
   dhtmlXTreeObject.prototype.getItemIdByIndex=function(itemId,index){
       var z=this._globalIdStorageFind(itemId);
       if ((!z)||(index>=z.childsCount)) return null;
          return z.childNodes[index].id;
   };

/**
*     @desc: retun child node id by index
*     @type: public
*     @param: itemId - parent node id        
*     @param: index - index of child node
*     @return: node id
*     @topic: 1
*/      
   dhtmlXTreeObject.prototype.getChildItemIdByIndex=function(itemId,index){
       var z=this._globalIdStorageFind(itemId);
       if ((!z)||(index>=z.childsCount)) return null;
          return z.childNodes[index].id;
   };



   

/**
*     @desc: set function called when drag-and-drop event occured
*     @param: aFunc - event handling function
*     @type: deprecated
*     @topic: 0,7
*     @event:    onDrag
*     @depricated: use grid.attachEvent("onDrag",func); instead
*     @eventdesc: Event occured after item was dragged and droped on another item, but before item moving processed.
      Event also raised while programmatic moving nodes.
*     @eventparam:  ID of source item
*     @eventparam:  ID of target item
*     @eventparam:  if node droped as sibling then contain id of item before whitch source node will be inserted
*     @eventparam:  source Tree object
*     @eventparam:  target Tree object
*     @eventreturn:  true - confirm drag-and-drop; false - deny drag-and-drop;
*/
   dhtmlXTreeObject.prototype.setDragHandler=function(func){ this.attachEvent("onDrag",func); };
   
   /**
*     @desc: clear selection from node
*     @param: htmlNode - pointer to node object
*     @type: private
*     @topic: 1
*/
    dhtmlXTreeObject.prototype._clearMove=function(){
		if (this._lastMark){
	   		this._lastMark.className=this._lastMark.className.replace(/dragAndDropRow/g,"");
	   		this._lastMark=null;
		}
//#__pro_feature:01112006{
//#complex_move:01112006{
		this.selectionBar.style.display="none";
//#}
//#}
		this.allTree.className=this.allTree.className.replace(" selectionBox","");
   };

   /**  
*     @desc: enable/disable drag-and-drop
*     @type: public
*     @param: mode - enabled/disabled [ can be true/false/temporary_disabled - last value mean that tree can be D-n-D can be switched to true later ]
*     @param: rmode - enabled/disabled drag and drop on super root
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.enableDragAndDrop=function(mode,rmode){
        if  (mode=="temporary_disabled"){
            this.dADTempOff=false;
            mode=true;                  }
        else
            this.dADTempOff=true;

      this.dragAndDropOff=convertStringToBoolean(mode);
         if (this.dragAndDropOff) this.dragger.addDragLanding(this.allTree,this);
        if (arguments.length>1)
            this._ddronr=(!convertStringToBoolean(rmode));
       };   

/**
*     @desc: set selection on node
*     @param: node - pointer to node object
*     @type: private
*     @topic: 1
*/    
   dhtmlXTreeObject.prototype._setMove=function(htmlNode,x,y){
      if (htmlNode.parentObject.span) {
      //window.status=x;
      var a1=getAbsoluteTop(htmlNode);
      var a2=getAbsoluteTop(this.allTree)-this.allTree.scrollTop;

      this.dadmodec=this.dadmode;//this.dadmode;
      this.dadmodefix=0;
//#__pro_feature:01112006{
//#complex_move:01112006{
      if (this.dadmode==2)
      {

      var z=y-a1+(document.body.scrollTop||document.documentElement.scrollTop)-2-htmlNode.offsetHeight/2;
      if ((Math.abs(z)-htmlNode.offsetHeight/6)>0)
      {
         this.dadmodec=1;
         //sibbling zone
         if (z<0)
            this.dadmodefix=0-htmlNode.offsetHeight;
      }
      else this.dadmodec=0;

      }
      if (this.dadmodec==0)
         {
//#}
//#} 

			var zN=htmlNode.parentObject.span;
			zN.className+=" dragAndDropRow";
			this._lastMark=zN;
//#__pro_feature:01112006{
//#complex_move:01112006{
         }
      else{
 	  	 this._clearMove();
         this.selectionBar.style.top=(a1-a2+((parseInt(htmlNode.parentObject.span.parentNode.previousSibling.childNodes[0].style.height)||18)-1)+this.dadmodefix)+"px";
         this.selectionBar.style.left="5px";
           if (this.allTree.offsetWidth>20)
                this.selectionBar.style.width=(this.allTree.offsetWidth-(_isFF?30:25))+"px";
         this.selectionBar.style.display="";
         }
//#}
//#}
         this._autoScroll(null,a1,a2);

      }
   };

dhtmlXTreeObject.prototype._autoScroll=function(node,a1,a2){
         if (this.autoScroll)
         {
		 	if (node){
				a1=getAbsoluteTop(node);
	      		a2=getAbsoluteTop(this.allTree)-this.allTree.scrollTop;
			}
            //scroll down
            if ( (a1-a2-parseInt(this.allTree.scrollTop))>(parseInt(this.allTree.offsetHeight)-50) )
               this.allTree.scrollTop=parseInt(this.allTree.scrollTop)+20;
            //scroll top
            if ( (a1-a2)<(parseInt(this.allTree.scrollTop)+30) )
               this.allTree.scrollTop=parseInt(this.allTree.scrollTop)-20;
         }
}

/**
*     @desc: create html element for dragging
*     @type: private
*     @param: htmlObject - html node object
*     @topic: 1
*/
dhtmlXTreeObject.prototype._createDragNode=function(htmlObject,e){
      if (!this.dADTempOff) return null;

     var obj=htmlObject.parentObject;
     if (!this.callEvent("onBeforeDrag",[obj.id, e])) return null;
    if (!obj.i_sel){

         this._selectItem(obj,e);
}
//#__pro_feature:01112006{
//#multiselect:01112006{
      this._checkMSelectionLogic();
//#}
//#}
      var dragSpan=document.createElement('div');

            var text=new Array();
            if (this._itim_dg)
                    for (var i=0; i<this._selected.length; i++)
                        text[i]="<table cellspacing='0' cellpadding='0'><tr><td><img width='18px' height='18px' src='"+this._getSrc(this._selected[i].span.parentNode.previousSibling.childNodes[0])+"'></td><td>"+this._selected[i].span.innerHTML+"</td></tr></table>";
            else
                text=this.getSelectedItemText().split(this.dlmtr);

            dragSpan.innerHTML=text.join("");
         dragSpan.style.position="absolute";
         dragSpan.className="dragSpanDiv";
      this._dragged=(new Array()).concat(this._selected);
     return dragSpan;
}



/**  
*     @desc: focus item in tree
*     @type: private
*     @param: item - node object
*     @edition: Professional
*     @topic: 0  
*/
dhtmlXTreeObject.prototype._focusNode=function(item){
	var z=getAbsoluteTop(item.htmlNode)-getAbsoluteTop(this.allTree);
	if ((z>(this.allTree.offsetHeight-30)) || (z<0))
		this.allTree.scrollTop=z+this.allTree.scrollTop;
};




              








///DragAndDrop

dhtmlXTreeObject.prototype._preventNsDrag=function(e){
   if ((e)&&(e.preventDefault)) { e.preventDefault(); return false; }
   return false;
}

dhtmlXTreeObject.prototype._drag=function(sourceHtmlObject,dhtmlObject,targetHtmlObject){
      if (this._autoOpenTimer) clearTimeout(this._autoOpenTimer);

      if (!targetHtmlObject.parentObject){
            targetHtmlObject=this.htmlNode.htmlNode.childNodes[0].childNodes[0].childNodes[1].childNodes[0];
            this.dadmodec=0;
            }

      this._clearMove();
      var z=sourceHtmlObject.parentObject.treeNod;
        if ((z)&&(z._clearMove))   z._clearMove("");

       if ((!this.dragMove)||(this.dragMove()))
          {
              if ((!z)||(!z._clearMove)||(!z._dragged)) var col=new Array(sourceHtmlObject.parentObject);
              else var col=z._dragged;
				var trg=targetHtmlObject.parentObject;

                for (var i=0; i<col.length; i++){
                   var newID=this._moveNode(col[i],trg);
				   if ((this.dadmodec)&&(newID!==false)) trg=this._globalIdStorageFind(newID,true,true);
                   if ((newID)&&(!this._sADnD)) this.selectItem(newID,0,1);
                }

         }
        if (z) z._dragged=new Array();


}

dhtmlXTreeObject.prototype._dragIn=function(htmlObject,shtmlObject,x,y){

                    if (!this.dADTempOff) return 0;
                    var fobj=shtmlObject.parentObject;
                    var tobj=htmlObject.parentObject;
	                if ((!tobj)&&(this._ddronr)) return;
                    if (!this.callEvent("onDragIn",[fobj.id,tobj?tobj.id:null,fobj.treeNod,this])){
                    	if (tobj) this._autoScroll(htmlObject);
                    	return 0;
                    }
						

					if (!tobj) 
		            	this.allTree.className+=" selectionBox";
					else
					{
	                    if (fobj.childNodes==null){
		                	this._setMove(htmlObject,x,y);
        	             	return htmlObject;
                    	}

	                    var stree=fobj.treeNod;
    	                for (var i=0; i<stree._dragged.length; i++)
                        	if (this._checkPNodes(tobj,stree._dragged[i])){
						   		this._autoScroll(htmlObject);
                           		return 0;
							}
//#__pro_feature:01112006{
//#complex_move:01112006{	 
				this.selectionBar.parentNode.removeChild(this.selectionBar);
				tobj.span.parentNode.appendChild(this.selectionBar);
//#}
//#}
                       this._setMove(htmlObject,x,y);
                       if (this._getOpenState(tobj)<=0){
                           this._autoOpenId=tobj.id;
                             this._autoOpenTimer=window.setTimeout(new callerFunction(this._autoOpenItem,this),1000);
                                    }
					}
					
				return htmlObject;

}
dhtmlXTreeObject.prototype._autoOpenItem=function(e,treeObject){
   treeObject.openItem(treeObject._autoOpenId);
};
dhtmlXTreeObject.prototype._dragOut=function(htmlObject){
this._clearMove();
if (this._autoOpenTimer) clearTimeout(this._autoOpenTimer);
 }


//#__pro_feature:01112006{

/**  
*     @desc: return next node
*     @type: private
*     @param: item - node object
*     @param: mode - inner flag
*     @return: next node or -1
*     @topic: 2
*/
dhtmlXTreeObject.prototype._getNextNode=function(item,mode){
   if ((!mode)&&(item.childsCount)) return item.childNodes[0];
   if (item==this.htmlNode)
      return -1;
   if ((item.tr)&&(item.tr.nextSibling)&&(item.tr.nextSibling.nodem))
   return item.tr.nextSibling.nodem;

   return this._getNextNode(item.parentObject,true);
};

/**  
*     @desc: return last child of item (include all sub-child collections)
*     @type: private
*     @param: item - node object
*     @topic: 2  
*/
dhtmlXTreeObject.prototype._lastChild=function(item){
   if (item.childsCount)
      return this._lastChild(item.childNodes[item.childsCount-1]);
   else return item;
};

/**  
*     @desc: return previous node
*     @type: private
*     @param: item - node object
*     @param: mode - inner flag
*     @return: previous node or -1
*     @topic: 2  
*/
dhtmlXTreeObject.prototype._getPrevNode=function(node,mode){
   if ((node.tr)&&(node.tr.previousSibling)&&(node.tr.previousSibling.nodem))
   return this._lastChild(node.tr.previousSibling.nodem);

   if (node.parentObject)
      return node.parentObject;
   else return -1;
};



//#find_item:01112006{

/**
*     @desc: find tree item by text, select and focus it
*     @type: public
*     @param: searchStr - search text
*     @param: direction - 0: top -> bottom; 1: bottom -> top
*     @param: top - 1: start searching from top
*     @return: node id
*     @edition: Professional
*     @topic: 2
*/
dhtmlXTreeObject.prototype.findItem=function(searchStr,direction,top){
   var z=this._findNodeByLabel(searchStr,direction,(top?this.htmlNode:null));
   if (z){
      this.selectItem(z.id,true);
      this._focusNode(z);
      return z.id;
      }
      else return null;
}

/**  
*     @desc: find tree item by text
*     @type: public
*     @param: searchStr - search text
*     @param: direction - 0: top -> bottom; 1: bottom -> top
*     @param: top - 1: start searching from top
*     @return: node id
*     @edition: Professional
*     @topic: 2  
*/
dhtmlXTreeObject.prototype.findItemIdByLabel=function(searchStr,direction,top){
   var z=this._findNodeByLabel(searchStr,direction,(top?this.htmlNode:null));
   if (z)
      return z.id
   else return null;
}

//#smart_parsing:01112006{
/**  
*     @desc: find tree item by text in unParsed XML
*     @type: private
*     @param: node - start xml node
*     @param: field - name of xml attribute
*     @param: cvalue - search text
*     @return: true/false
*     @topic: 2  
*/
dhtmlXTreeObject.prototype.findStrInXML=function(node,field,cvalue){ 
   if (!node.childNodes && node.item) return this.findStrInJSON(node,field,cvalue);
   if(!node.childNodes)
       return false;
   for (var i=0; i<node.childNodes.length; i++)
   {
   if (node.childNodes[i].nodeType==1)
      {
      	
        var z=node.childNodes[i].getAttribute(field);
        if (!z && node.childNodes[i].tagName=="itemtext")  z=node.childNodes[i].firstChild.data; 
      if ((z)&&(z.toLowerCase().search(cvalue)!=-1))
         return true;
      if (this.findStrInXML(node.childNodes[i],field,cvalue)) return true;
      }
   }
   return false;
}
dhtmlXTreeObject.prototype.findStrInJSON=function(node,field,cvalue){ 
   for (var i=0; i<node.item.length; i++)
   {
	    var z=node.item[i].text;
        if ((z)&&(z.toLowerCase().search(cvalue)!=-1))
         return true;
      if (node.item[i].item && this.findStrInJSON(node.item[i],field,cvalue)) return true;
   }
   return false;
}
//#}

/**  
*     @desc: find tree item by text
*     @type: private
*     @param: searchStr - search text
*     @param: direction - 0: top -> bottom; 1: bottom -> top
*     @param: fromNode - node from which search begin
*     @return: node id
*     @topic: 2  
*/
dhtmlXTreeObject.prototype._findNodeByLabel=function(searchStr,direction,fromNode){
   //trim
   var searchStr=searchStr.replace(new RegExp("^( )+"),"").replace(new RegExp("( )+$"),"");
   searchStr =  new RegExp(searchStr.replace(/([\?\*\+\\\[\]\(\)]{1})/gi,"\\$1").replace(/ /gi,".*"),"gi");

   //get start node
   if (!fromNode)
      {
      fromNode=this._selected[0];
      if (!fromNode) fromNode=this.htmlNode;
      }

   var startNode=fromNode;

   //first step
   if (!direction){
      if ((fromNode.unParsed)&&(this.findStrInXML(fromNode.unParsed.d,"text",searchStr)))
      this.reParse(fromNode);
   fromNode=this._getNextNode(startNode);
   if (fromNode==-1) fromNode=this.htmlNode.childNodes[0];
   }
   else
   {
      var z2=this._getPrevNode(startNode);
      if (z2==-1) z2=this._lastChild(this.htmlNode);
      if ((z2.unParsed)&&(this.findStrInXML(z2.unParsed.d,"text",searchStr)))
      {   this.reParse(z2); fromNode=this._getPrevNode(startNode); }
      else fromNode=z2;
      if (fromNode==-1) fromNode=this._lastChild(this.htmlNode);
   }



   while ((fromNode)&&(fromNode!=startNode)){
      if ((fromNode.label)&&(fromNode.label.search(searchStr)!=-1))
            return (fromNode);

      if (!direction){
      if (fromNode==-1) { if (startNode==this.htmlNode) break; fromNode=this.htmlNode.childNodes[0]; }
      if ((fromNode.unParsed)&&(this.findStrInXML(fromNode.unParsed.d,"text",searchStr)))
         this.reParse(fromNode);
      fromNode=this._getNextNode(fromNode);
      if (fromNode==-1) fromNode=this.htmlNode;
      }
      else
      {
      var z2=this._getPrevNode(fromNode);
      if (z2==-1) z2=this._lastChild(this.htmlNode);
      if ((z2.unParsed)&&(this.findStrInXML(z2.unParsed.d,"text",searchStr)))
         {   this.reParse(z2); fromNode=this._getPrevNode(fromNode); }
      else fromNode=z2;
      if (fromNode==-1) fromNode=this._lastChild(this.htmlNode);
      }
   }
   return null;
};

//#}
//#}


//#complex_move:01112006{

/**
*     @desc: move item (inside of tree)
*     @type:  public
*     @param: itemId - item Id
*     @param: mode - moving mode (left,up,down,item_child,item_sibling,item_sibling_next,up_strict,down_strict)
*     @param: targetId - target Node in item_child and item_sibling mode
*     @param: targetTree - used for moving between trees (optional)
*     @return: node id
*     @topic: 2
*/
dhtmlXTreeObject.prototype.moveItem=function(itemId,mode,targetId,targetTree)
{
	var sNode=this._globalIdStorageFind(itemId);
	if (!sNode) return (0);
	var resultId = null;
	switch(mode){
		case "right":
			alert('Not supported yet');
			break;
		case "item_child":
			var tNode=(targetTree||this)._globalIdStorageFind(targetId);
			if (!tNode) return (0);
			resultId = (targetTree||this)._moveNodeTo(sNode,tNode,0);
			break;
		case "item_sibling":
			var tNode=(targetTree||this)._globalIdStorageFind(targetId);
			if (!tNode) return (0);
			resultId = (targetTree||this)._moveNodeTo(sNode,tNode.parentObject,tNode);
			break;
		case "item_sibling_next":
			var tNode=(targetTree||this)._globalIdStorageFind(targetId);
			if (!tNode) return (0);
			if ((tNode.tr)&&(tNode.tr.nextSibling)&&(tNode.tr.nextSibling.nodem))
				resultId = (targetTree||this)._moveNodeTo(sNode,tNode.parentObject,tNode.tr.nextSibling.nodem);
			else
				resultId = (targetTree||this)._moveNodeTo(sNode,tNode.parentObject);
			break;
		case "left":
			if (sNode.parentObject.parentObject)
				resultId = this._moveNodeTo(sNode,sNode.parentObject.parentObject,sNode.parentObject);
			break;
		case "up":
			var z=this._getPrevNode(sNode);
			if ((z==-1)||(!z.parentObject)) return null;
			resultId = this._moveNodeTo(sNode,z.parentObject,z);
			break;
		case "up_strict":
			var z=this._getIndex(sNode);
			if (z!=0)
				resultId = this._moveNodeTo(sNode,sNode.parentObject,sNode.parentObject.childNodes[z-1]);
			break;
		case "down_strict":
			var z=this._getIndex(sNode);
			var count=sNode.parentObject.childsCount-2;
			if (z==count)
				resultId = this._moveNodeTo(sNode,sNode.parentObject);
			else if (z<count)
				resultId = this._moveNodeTo(sNode,sNode.parentObject,sNode.parentObject.childNodes[z+2]);
			break;
		case "down":
			var z=this._getNextNode(this._lastChild(sNode));
			if ((z==-1)||(!z.parentObject)) return;
			if (z.parentObject==sNode.parentObject)
				var z=this._getNextNode(z);
			if (z==-1){
				resultId = this._moveNodeTo(sNode,sNode.parentObject);
			}
			else{
				if ((z==-1)||(!z.parentObject)) return;
				resultId = this._moveNodeTo(sNode,z.parentObject,z);
			}
			break;
	}
	if (_isIE && _isIE<8){
		this.allTree.childNodes[0].border = "1";
		this.allTree.childNodes[0].border = "0";
	}
	return resultId;
}

//#__pro_feature:01112006{

/**
*     @desc: set Drag-And-Drop behavior (child - drop as chils, sibling - drop as sibling, complex - complex drop behaviour )
*     @type: public
*     @edition: Professional
*     @param: mode - behavior name (child,sibling,complex)
*     @param: select - select droped node after drag-n-drop, true by default
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.setDragBehavior=function(mode,select){
		this._sADnD=(!convertStringToBoolean(select));
		switch (mode) {
			case "child": this.dadmode=0; break;
			case "sibling": this.dadmode=1; break;
			case "complex": this.dadmode=2; break;
		}    };




//#}
//#}







/**
*     @desc: load xml for tree branch
*     @param: id - id of parent node
*     @param: src - path to xml, optional
*     @type: private
*     @topic: 1
*/
   dhtmlXTreeObject.prototype._loadDynXML=function(id,src) {
   		src=src||this.XMLsource;
        var sn=(new Date()).valueOf();
        this._ld_id=id;
//#__pro_feature:01112006{
        if (this.xmlalb=="function"){
            if (src) src(this._escape(id));
            }
        else
        if (this.xmlalb=="name")
            this.loadXML(src+this._escape(id));
        else
        if (this.xmlalb=="xmlname")
            this.loadXML(src+this._escape(id)+".xml?uid="+sn);
        else
//#}
            this.loadXML(src+getUrlSymbol(src)+"uid="+sn+"&id="+this._escape(id));
        };


//#__pro_feature:01112006{
//#multiselect:01112006{
/**
*     @desc: enable multiselection
*     @beforeInit: 1
*     @param: mode - 1 - on, 0 - off;
*     @param: strict - 1 - on, 0 - off; in strict mode only items on the same level can be selected
*     @type: public
*     @edition: Professional
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.enableMultiselection=function(mode,strict) {
        this._amsel=convertStringToBoolean(mode);
        this._amselS=convertStringToBoolean(strict);
        };

/**
*     @desc: check logic of selection
*     @type: private
*     @edition: Professional
*     @topic: 0
*/
dhtmlXTreeObject.prototype._checkMSelectionLogic=function() {
            var usl=new Array();
         for (var i=0; i<this._selected.length; i++)
            for (var j=0; j<this._selected.length; j++)
                  if ((i!=j)&&(this._checkPNodes(this._selected[j],this._selected[i])))
                            usl[usl.length]=this._selected[j];

         for (var i=0; i<usl.length; i++)
             this._unselectItem(usl[i]);

         };
//#}
//#}




/**
*     @desc: check possibility of drag-and-drop
*     @type: private
*     @param: itemId - draged node id
*     @param: htmlObject - droped node object
*     @param: shtmlObject - sourse node object
*     @topic: 6
*/
    dhtmlXTreeObject.prototype._checkPNodes=function(item1,item2){
      if (this._dcheckf) return false;
      if (item2==item1) return 1
      if (item1.parentObject) return this._checkPNodes(item1.parentObject,item2); else return 0;
   };
   dhtmlXTreeObject.prototype.disableDropCheck = function(mode){
      this._dcheckf = convertStringToBoolean(mode);
   };


//#__pro_feature:01112006{
//#distributed_load:01112006{

/**
*     @desc: enable distributed parsing of big tree (items loaded portion by portion with some timeouts)
*     @type: public
*     @edition: Professional
*     @param: mode - true/false
*     @param: count - critical count to start distibuting (optional)
*     @param: delay - delay between distributed calls, ms (optional)
*     @topic: 2
*/
dhtmlXTreeObject.prototype.enableDistributedParsing=function(mode,count,delay){
    this._edsbps=convertStringToBoolean(mode);
    this._edsbpsA=new Array();
    this._edsbpsC=count||10;
    this._edsbpsD=delay||250;
}
/**
*     @desc: get current state of distributed parsing
*     @type: public
*     @edition: Professional
*     @returns: true - still parsing; false - parsing finished
*     @topic: 2
*/
dhtmlXTreeObject.prototype.getDistributedParsingState=function(){
    return (!((!this._edsbpsA)||(!this._edsbpsA.length)));
}
/**
*     @desc: get current parsing state of item
*     @type: public
*     @edition: Professional
*     @returns: 1 - item already parsed; 0 - item not parsed yet; -1 - item in parsing process
*     @topic: 2
*/
dhtmlXTreeObject.prototype.getItemParsingState=function(itemId){
    var z=this._globalIdStorageFind(itemId,true,true)
    if (!z) return 0;
    if (this._edsbpsA)
        for (var i=0; i<this._edsbpsA.length; i++)
            if (this._edsbpsA[i][2]==itemId) return -1;

    return 1;
}

dhtmlXTreeObject.prototype._distributedStart=function(node,start,parentId,level,start2){
    if (!this._edsbpsA)
        this._edsbpsA=new Array();
    this._edsbpsA[this._edsbpsA.length]=[node,start,parentId,level,start2];
}

dhtmlXTreeObject.prototype._distributedStep=function(pId){
    var self=this;
    if ((!this._edsbpsA)||(!this._edsbpsA.length)) {
         self.XMLloadingWarning=0;
         return;
         }
    var z=this._edsbpsA[0];
    this.parsedArray=new Array();
    this._parse(z[0],z[2],z[3],z[1]);
    var zkx=this._globalIdStorageFind(z[2]);
    this._redrawFrom(this,zkx,z[4],this._getOpenState(zkx));
    var chArr=this.setCheckList.split(this.dlmtr);
   for (var n=0; n<chArr.length; n++)
      if (chArr[n]) this.setCheck(chArr[n],1);

    this._edsbpsA=(new Array()).concat(this._edsbpsA.slice(1));


    if ((!this._edsbpsA.length)){
         window.setTimeout( function(){ if (self.onXLE) self.onXLE(self,pId); self.callEvent("onXLE",[self,pId]); },1);
            self.xmlstate=0;
            }
}

//#}
//#}




//#__pro_feature:01112006{

/**
*     @desc: replace images with text signs
*     @type: public
*     @param: mode - true/false
*     @edition: Professional
*     @topic: 1
*/
dhtmlXTreeObject.prototype.enableTextSigns=function(mode){
    this._txtimg=convertStringToBoolean(mode);
}

//#}

/**
*   @desc:  prevent caching in IE  by adding random value to URL string
*   @param: mode - enable/disable random value ( disabled by default )
*   @type: public
*   @topic: 0
*/
dhtmlXTreeObject.prototype.preventIECaching=function(mode){
      this.no_cashe = convertStringToBoolean(mode);
      this.XMLLoader.rSeed=this.no_cashe;
}
dhtmlXTreeObject.prototype.preventIECashing=dhtmlXTreeObject.prototype.preventIECaching;





/**
*     @desc: disable checkbox
*     @param: itemId - Id of tree item
*     @param: mode - 1 - on, 0 - off;
*     @type: public
*     @topic: 5
*/
   dhtmlXTreeObject.prototype.disableCheckbox=function(itemId,mode) {
            if (typeof(itemId)!="object")
             var sNode=this._globalIdStorageFind(itemId,0,1);
            else
                var sNode=itemId;
         if (!sNode) return;
            sNode.dscheck=convertStringToBoolean(mode)?(((sNode.checkstate||0)%3)+3):((sNode.checkstate>2)?(sNode.checkstate-3):sNode.checkstate);
            this._setCheck(sNode);
                if (sNode.dscheck<3) sNode.dscheck=false;
         };

//#__pro_feature:01112006{


/**
*     @desc: refresh specified tree branch (get XML from server, add new nodes, remove not used nodes)
*     @param: itemId -  top node in branch
*     @param: source - server side script , optional
*     @type: public
*     @edition: Professional
*     @topic: 6
*/
   dhtmlXTreeObject.prototype.smartRefreshBranch=function(itemId,source){
   		this._branchUpdate=1;
		this.smartRefreshItem(itemId,source);
   }

/**
*     @desc: refresh specified tree item (get XML from server, add new nodes, remove not used nodes)
*     @param: itemId -  top node in branch
*     @param: source - server side script , optional
*     @type: public
*     @edition: Professional
*     @topic: 6
*/
dhtmlXTreeObject.prototype.smartRefreshItem=function(itemId,source){
		var sNode=this._globalIdStorageFind(itemId);
		for (var i=0; i<sNode.childsCount; i++)
			sNode.childNodes[i]._dmark=true;

		this.waitUpdateXML=true;
		if (source && source.exists)
			this._parse(source,itemId);
		else
			this._loadDynXML(itemId,source);
};


/**
*     @desc: refresh specified tree nodes (get XML from server and updat only nodes included in itemIdList)
*     @param: itemIdList - list of node identificators
*     @param: source - server side script
*     @type: public
*     @edition: Professional
*     @topic: 6
*/
   dhtmlXTreeObject.prototype.refreshItems=function(itemIdList,source){
   		var z=itemIdList.toString().split(this.dlmtr);
		this.waitUpdateXML=new Array();
		for (var i=0; i<z.length; i++)
			this.waitUpdateXML[z[i]]=true;
        this.loadXML((source||this.XMLsource)+getUrlSymbol(source||this.XMLsource)+"ids="+this._escape(itemIdList));
   };


/**
*     @desc: update item properties
*     @param: itemId - list of node identificators
*     @param: name - list of node identificators, optional
*     @param: im0 - list of node identificators, optional
*     @param: im1 - list of node identificators, optional
*     @param: im2 - list of node identificators, optional
*     @param: achecked - list of node identificators, optional
*     @param: child - child attribute for dynamic loading
*     @type: public
*     @edition: Professional
*     @topic: 6
*/
   dhtmlXTreeObject.prototype.updateItem=function(itemId,name,im0,im1,im2,achecked,child){
      var sNode=this._globalIdStorageFind(itemId);
	  sNode.userData=new cObject(); 
      if (name) sNode.label=name;
      sNode.images=new Array(im0||this.imageArray[0],im1||this.imageArray[1],im2||this.imageArray[2]);
	  this.setItemText(itemId,name);
      if (achecked) this._setCheck(sNode,true);
	  if(child=="1" && !this.hasChildren(itemId)) sNode.XMLload = 0;
      this._correctPlus(sNode);
	  sNode._dmark=false;
      return sNode;
   };

/**
*     @desc: set function called after drag-and-drap event occured
*     @param: func - event handling function
*     @type: deprecated
*     @edition: Professional
*     @topic: 0,7
*     @event:  onDrop
*     @depricated: use grid.attachEvent("onDrop",func); instead
*     @eventdesc:  Event raised after drag-and-drop processed. Event also raised while programmatic moving nodes.
*     @eventparam:  ID of source item (ID after inserting in tree, my be not equal to initial ID)
*     @eventparam:  ID of target item
*     @eventparam:  if node droped as sibling then contain id of item before whitch source node will be inserted
*     @eventparam:  source Tree object
*     @eventparam:  target Tree object
*/
   dhtmlXTreeObject.prototype.setDropHandler=function(func){  this.attachEvent("onDrop",func);  };

/**
*     @desc: set function called before xml loading/parsing started
*     @param: func - event handling function
*     @type: deprecated
*     @edition: Professional
*     @topic: 0,7
*     @event:  onXLS
*     @depricated: use grid.attachEvent("onXLS",func); instead
*     @eventdesc: event fired simultaneously with starting XML parsing
*     @eventparam: tree object
*     @eventparam: item id, for which xml loaded
*/
   dhtmlXTreeObject.prototype.setOnLoadingStart=function(func){    this.attachEvent("onXLS",func);  };
      /**
*     @desc: set function called after xml loading/parsing ended
*     @param: func - event handling function
*     @type: deprecated
*     @edition: Professional
*     @topic: 0,7
*     @event:  onXLE
*     @depricated: use grid.attachEvent("onXLE",func); instead
*     @eventdesc: event fired simultaneously with ending XML parsing, new items already available in tree
*     @eventparam: tree object
*     @eventparam: last parsed parent id
*/
     dhtmlXTreeObject.prototype.setOnLoadingEnd=function(func){  this.attachEvent("onXLE",func); };



/**
*     @desc: define which script be called on dynamic loading
*     @param: mode - id for some_script?id=item_id ;  name for  some_scriptitem_id, xmlname for  some_scriptitem_id.xml ; function for calling user defined handler
*     @type: public
*     @edition: Professional
*     @topic: 1
*/
   dhtmlXTreeObject.prototype.setXMLAutoLoadingBehaviour=function(mode) {
            this.xmlalb=mode;
         };


/**
*     @desc: enable smart checkboxes ,true by default (auto checking children and parents for 3-state checkboxes)
*     @param: mode - 1 - on, 0 - off;
*     @type: public
*     @edition: Professional
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.enableSmartCheckboxes=function(mode) { this.smcheck=convertStringToBoolean(mode); };

/**
*     @desc: return current state of XML loading
*     @type: public
*     @edition: Professional
*     @return: current state, true - xml loading now
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.getXMLState=function(){ return (this.xmlstate==1); };

/**
*     @desc: set top offset for item
*     @type: public
*     @param: itemId - id of item
*     @param: value - value of top offset in px
*     @edition: Professional
*     @topic: 2
*/
dhtmlXTreeObject.prototype.setItemTopOffset=function(itemId,value){
    var node;
    if (typeof(itemId)!="object")
        node=this._globalIdStorageFind(itemId);
    else
        node=itemId;
    var z=node.span.parentNode.parentNode;
    node.span.style.paddingBottom="1px";
  
    for (var i=0; i<z.childNodes.length; i++){
        if (i!=0){
      
            if (_isIE){
                z.childNodes[i].style.height="18px";
                z.childNodes[i].style.paddingTop=parseInt(value)+"px";
            }else
                z.childNodes[i].style.height=18+parseInt(value)+"px";
        }
        else{
            var w=z.childNodes[i].firstChild;
            if (z.childNodes[i].firstChild.tagName!='DIV'){
              w=document.createElement("DIV");
              z.childNodes[i].insertBefore(w,z.childNodes[i].firstChild);
            }
            w.style.height=parseInt(value)+"px";
            if ((node.parentObject.id!=this.rootId || node.parentObject.childNodes[0]!=node) && this.treeLinesOn)
                w.style.backgroundImage="url("+this.imPath+this.lineArray[5]+")";
            w.innerHTML="&nbsp;";
            w.style.overflow='hidden';
            if (parseInt(value)==0)
                z.childNodes[i].removeChild(w);
        }
        if (!_isIE)
            z.childNodes[i].style.verticalAlign="bottom";
        if (_isIE){
            this.allTree.childNodes[0].border = "1";
            this.allTree.childNodes[0].border = "0";
        }
    }
}

/**
*     @desc: set size of icons
*     @type:  public
*     @param: newWidth - new icon width
*     @param: newHeight - new icon height
*     @param: itemId - item Id, if skipped set default value for all new icons, optional
*     @edition: Professional
*     @topic: 2
*/
dhtmlXTreeObject.prototype.setIconSize=function(newWidth,newHeight,itemId)
{
      if (itemId){
         if ((itemId)&&(itemId.span))
            var sNode=itemId;
         else
            var sNode=this._globalIdStorageFind(itemId);

         if (!sNode) return (0);
         var img=sNode.span.parentNode.previousSibling.childNodes[0];
            if (newWidth) {
            	img.style.width=newWidth;
            	if (window._KHTMLrv) img.parentNode.style.width=newWidth;
        	}
            if (newHeight) {
            	img.style.height=newHeight;
            	if (window._KHTMLrv) img.parentNode.style.height=newHeight;
        	}
         }
      else{
         this.def_img_x=newWidth;
         this.def_img_y=newHeight;
      }
}

/**
*     @desc: get url of item image
*     @type: public
*     @param: itemId - id of item
*     @param: imageInd - index of image ( 0 - leaf, 1 - closed folder, 2 - opened folder)
*     @param: value - value of top offset
*     @edition: Professional
*     @topic: 2
*/
dhtmlXTreeObject.prototype.getItemImage=function(itemId,imageInd,fullPath){
    var node=this._globalIdStorageFind(itemId);
    if (!node) return "";
    var img=node.images[imageInd||0];
    if (fullPath) img=this.iconURL+img;
    return img;
}

/**
*     @desc: replace checkboxes with radio buttons
*     @type: public
*     @param: mode - true/false
*     @param: itemId - node for which replacement called (optional)
*     @edition: Professional
*     @topic: 1
*/
dhtmlXTreeObject.prototype.enableRadioButtons=function(itemId,mode){
    if (arguments.length==1){
        this._frbtr=convertStringToBoolean(itemId);
        this.checkBoxOff=this.checkBoxOff||this._frbtr;
        return;
        }


    var node=this._globalIdStorageFind(itemId);
    if (!node) return "";
    mode=convertStringToBoolean(mode);
    if ((mode)&&(!node._r_logic)){
            node._r_logic=true;
            for (var i=0; i<node.childsCount; i++)
                this._setCheck(node.childNodes[i],node.childNodes[i].checkstate);
        }

    if ((!mode)&&(node._r_logic)){
            node._r_logic=false;
            for (var i=0; i<node.childsCount; i++)
                this._setCheck(node.childNodes[i],node.childNodes[i].checkstate);
        }
}
/**
*     @desc: replace checkboxes with radio buttons
*     @type: public
*     @param: mode - true/false
*     @param: itemId - node for which replacement called (optional)
*     @edition: Professional
*     @topic: 1
*/
dhtmlXTreeObject.prototype.enableSingleRadioMode=function(mode){
     this._frbtrs=convertStringToBoolean(mode);
}


/**
*     @desc: configure if parent node will be expanded immideatly after child item added
*     @type: public
*     @param: mode - true/false
*     @edition: Professional
*     @topic: 2
*/
dhtmlXTreeObject.prototype.openOnItemAdded=function(mode){
    this._hAdI=!convertStringToBoolean(mode);
}
dhtmlXTreeObject.prototype.openOnItemAdding=function(mode){
    this._hAdI=!convertStringToBoolean(mode);
}

/**
*     @desc: enable multi line items
*     @beforeInit: 1
*     @param: width - text width, if equls zero then use single lines items;
*     @type: public
*     @edition: Professional
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.enableMultiLineItems=function(width) { if (width===true) this.mlitems="100%"; else this.mlitems=width; }

/**
*     @desc: enable auto tooltips (node text as tooltip)
*     @beforeInit: 1
*     @param: mode - 1 - on, 0 - off;
*     @type: public
*     @edition:Professional
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.enableAutoTooltips=function(mode) { this.ettip=convertStringToBoolean(mode); };


/**
*     @desc: unselect item in tree
*     @type: public
*     @param: itemId - used in multi selection tree (optional)
*     @edition: Professional
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.clearSelection=function(itemId){
       if (itemId)
            this._unselectItem(this._globalIdStorageFind(itemId));
            else
            this._unselectItems();
            }

/**
*     @desc: show/hide (+/-) icon (works only for individual items, not for entire tree )
*     @type: public
*     @param: itemId - id of selected item
*     @param: state - show state : 0/1
*     @edition: Professional
*     @topic: 6
*/
   dhtmlXTreeObject.prototype.showItemSign=function(itemId,state){
      var temp=this._globalIdStorageFind(itemId);
      if (!temp) return 0;

      var z=temp.span.parentNode.previousSibling.previousSibling.previousSibling;
      if (!convertStringToBoolean(state)){
         this._openItem(temp)
         temp.closeble=false;
         temp.wsign=true;
      }
      else
      {
         temp.closeble=true;
         temp.wsign=false;
      }
      this._correctPlus(temp);
   }
/**
*     @desc: show/hide checkbox for tree item (works only for individual items, not for entire tree )
*     @type: public
*     @param: itemId - id of selected item, optional, set null to change states of all items
*     @param: state - checkbox show state : 0/1
*     @edition: Professional
*     @topic: 5
*/
   dhtmlXTreeObject.prototype.showItemCheckbox=function(itemId,state){
      if (!itemId)
		for (var a in this._idpull)
			this.showItemCheckbox(this._idpull[a],state);

      if (typeof(itemId)!="object")
	      itemId=this._globalIdStorageFind(itemId,0,0);

      if (!itemId) return 0;
   	  itemId.nocheckbox=!convertStringToBoolean(state);
      var t=itemId.span.parentNode.previousSibling.previousSibling.childNodes[0];
      t.parentNode.style.display=(!itemId.nocheckbox)?"":"none";
   }

/**
*     @desc: set list separator ("," by default)
*     @type: public
*     @param: separator - char or string to use for separating items in lists
*     @edition: Professional
*     @topic: 0
*/
dhtmlXTreeObject.prototype.setListDelimeter=function(separator){
    this.dlmtr=separator;
}

//#}


/**
*     @desc: set escaping mode (used for escaping ID in requests)
*     @param: mode - escaping mode ("utf8" for UTF escaping)
*     @type: public
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.setEscapingMode=function(mode){
        this.utfesc=mode;
        }


/**
*     @desc: enable item highlighting (item text highlited on mouseover)
*     @beforeInit: 1
*     @param: mode - 1 - on, 0 - off;
*     @type: public
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.enableHighlighting=function(mode) { this.ehlt=true; this.ehlta=convertStringToBoolean(mode); };

/**
*     @desc: called on mouse out
*     @type: private
*     @topic: 0
*/
   dhtmlXTreeObject.prototype._itemMouseOut=function(){
   		var that=this.childNodes[3].parentObject;
		var tree=that.treeNod;
 		tree.callEvent("onMouseOut",[that.id]);
		if (that.id==tree._l_onMSI) tree._l_onMSI=null;
        if (!tree.ehlta) return;
 	    that.span.className=that.span.className.replace("_lor","");
   }
/**
*     @desc: called on mouse in
*     @type: private
*     @topic: 0
*/
   dhtmlXTreeObject.prototype._itemMouseIn=function(){
   		var that=this.childNodes[3].parentObject;
		var tree=that.treeNod;

		if (tree._l_onMSI!=that.id) tree.callEvent("onMouseIn",[that.id]);
		tree._l_onMSI=that.id;
        if (!tree.ehlta) return;
 	    that.span.className=that.span.className.replace("_lor","");
 	    that.span.className=that.span.className.replace(/((standart|selected)TreeRow)/,"$1_lor");
   }

/**
*     @desc: enable active images (clickable and dragable). By default only text part of the node is active
*     @beforeInit: 1
*     @param: mode - 1 - on, 0 - off;
*     @type: public
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.enableActiveImages=function(mode){this._aimgs=convertStringToBoolean(mode); };

/**
*     @desc: focus item in tree (scroll to it if necessary)
*     @type: public
*     @param: itemId - item Id
*     @topic: 0
*/
dhtmlXTreeObject.prototype.focusItem=function(itemId){
      var sNode=this._globalIdStorageFind(itemId);
      if (!sNode) return (0);
      this._focusNode(sNode);
   };


/**
*     @desc: Returns the list of all children from all next levels of tree, separated by default delimiter.
*     @param: itemId - id of node
*     @type: public
*     @return: list of all children items from all next levels of tree, separated by default delimiter
*     @topic: 6
*/
   dhtmlXTreeObject.prototype.getAllSubItems =function(itemId){
      return this._getAllSubItems(itemId);
   }

/**
*     @desc: Returns the list of all items which doesn't have child nodes.
*     @type: public
*     @return: list of all items which doesn't have child nodes.
*     @topic: 6
*/
	dhtmlXTreeObject.prototype.getAllChildless =function(){
		return this._getAllScraggyItems(this.htmlNode);
	}
	dhtmlXTreeObject.prototype.getAllLeafs=dhtmlXTreeObject.prototype.getAllChildless;


/**
*     @desc: Returns the list of all children from all next levels of tree, separated by default delimiter.
*     @param: itemId - id of node
*     @edition: Professional
*     @type: private
*     @topic: 6
*/
   dhtmlXTreeObject.prototype._getAllScraggyItems =function(node)
   {
      var z="";
      for (var i=0; i<node.childsCount; i++)
        {
            if ((node.childNodes[i].unParsed)||(node.childNodes[i].childsCount>0))
            {
                    if (node.childNodes[i].unParsed)
                        var zb=this._getAllScraggyItemsXML(node.childNodes[i].unParsed,1);
                    else
                       var zb=this._getAllScraggyItems(node.childNodes[i])

                 if (zb)
                        if (z) z+=this.dlmtr+zb;
                        else z=zb;
         }
            else
               if (!z) z=""+node.childNodes[i].id;
             else z+=this.dlmtr+node.childNodes[i].id;
         }
          return z;
   };





/**
*     @desc: Returns the list of all children from all next levels of tree, separated by default delimiter.
*     @param: itemId - id of node
*     @type: private
*     @edition: Professional
*     @topic: 6
*/
   dhtmlXTreeObject.prototype._getAllFatItems =function(node)
   {
      var z="";
      for (var i=0; i<node.childsCount; i++)
        {
            if ((node.childNodes[i].unParsed)||(node.childNodes[i].childsCount>0))
            {
             if (!z) z=""+node.childNodes[i].id;
                else z+=this.dlmtr+node.childNodes[i].id;

                    if (node.childNodes[i].unParsed)
                        var zb=this._getAllFatItemsXML(node.childNodes[i].unParsed,1);
                    else
                       var zb=this._getAllFatItems(node.childNodes[i])

                 if (zb) z+=this.dlmtr+zb;
         }
         }
          return z;
   };

/**
*     @desc: Returns the list of all items which have child nodes, separated by default delimiter.
*     @type: public
*     @return: list of all items which has child nodes, separated by default delimiter.
*     @topic: 6
*/
	dhtmlXTreeObject.prototype.getAllItemsWithKids =function(){
		return this._getAllFatItems(this.htmlNode);
	}
	dhtmlXTreeObject.prototype.getAllFatItems=dhtmlXTreeObject.prototype.getAllItemsWithKids;



/**
*     @desc: return list of identificators of nodes with checked checkboxes, separated by default delimiter
*     @type: public
*     @return: list of ID of items with checked checkboxes, separated by default delimiter
*     @topic: 5
*/
   dhtmlXTreeObject.prototype.getAllChecked=function(){
      return this._getAllChecked("","",1);
   }
/**
*     @desc: return list of identificators of nodes with unchecked checkboxes, separated by default delimiter
*     @type: public
*     @return: list of ID of items with unchecked checkboxes, separated by default delimiter
*     @topic: 5
*/
   dhtmlXTreeObject.prototype.getAllUnchecked=function(itemId){
        if (itemId)
            itemId=this._globalIdStorageFind(itemId);
      return this._getAllChecked(itemId,"",0);
    }


/**
*     @desc: return list of identificators of nodes with third state checkboxes, separated by default delimiter
*     @type: public
*     @return: list of ID of items with third state checkboxes, separated by default delimiter
*     @topic: 5
*/
   dhtmlXTreeObject.prototype.getAllPartiallyChecked=function(){
      return this._getAllChecked("","",2);
   }


/**
*     @desc: return list of identificators of nodes with checked and third state checkboxes, separated by default delimiter
*     @type: public
*     @return: list of ID of items with checked and third state checkboxes, separated by default delimiter
*     @topic: 5
*/
   dhtmlXTreeObject.prototype.getAllCheckedBranches=function(){
        var temp = [this._getAllChecked("","",1)];
        var second = this._getAllChecked("","",2);
        if (second) temp.push(second);
        return temp.join(this.dlmtr);
   }

/**
*     @desc: return list of identificators of nodes with checked checkboxes
*     @type: private
*     @param: node - node object (optional, used by private methods)
*     @param: list - initial identificators list (optional, used by private methods)
*     @topic: 5
*/
   dhtmlXTreeObject.prototype._getAllChecked=function(htmlNode,list,mode){
      if (!htmlNode) htmlNode=this.htmlNode;

      if (htmlNode.checkstate==mode)
         if (!htmlNode.nocheckbox)  { if (list) list+=this.dlmtr+htmlNode.id; else list=""+htmlNode.id;  }
      var j=htmlNode.childsCount;
      for (var i=0; i<j; i++)
      {
         list=this._getAllChecked(htmlNode.childNodes[i],list,mode);
      };
//#__pro_feature:01112006{
//#smart_parsing:01112006{
        if  (htmlNode.unParsed)
            list=this._getAllCheckedXML(htmlNode.unParsed,list,mode);
//#}
//#}

      if (list) return list; else return "";
   };

/**
*     @desc: set individual item style
*     @type: public
*     @param: itemId - node id
*     @param: styleString - valid CSS string
*     @param: resetCss - reset current style : 0/1
*     @topic: 2
*/
dhtmlXTreeObject.prototype.setItemStyle=function(itemId,style_string,resetCss){ 
	var resetCss= resetCss|| false; 
	var temp=this._globalIdStorageFind(itemId); 
	if (!temp) return 0; 
	if (!temp.span.style.cssText) 
		temp.span.setAttribute("style",temp.span.getAttribute("style")+"; "+style_string); 
	else 
		temp.span.style.cssText = resetCss? style_string : temp.span.style.cssText+";"+style_string; 
}

/**
*     @desc: enable draging item image with item text
*     @type: public
*     @param: mode - true/false
*     @topic: 1
*/
dhtmlXTreeObject.prototype.enableImageDrag=function(mode){
    this._itim_dg=convertStringToBoolean(mode);
}

/**
*     @desc: set function called when tree item draged over another item
*     @param: func - event handling function
*     @type: depricated
*     @edition: Professional
*     @topic: 4
*     @event: onDragIn
*     @depricated: use grid.attachEvent("onDragIn",func); instead
*     @eventdesc: Event raised when item draged other other dropable target
*     @eventparam:  ID draged item
*     @eventparam:  ID potencial drop landing
*     @eventparam:  source object
*     @eventparam:  target object
*     @eventreturn: true - allow drop; false - deny drop;
*/
	dhtmlXTreeObject.prototype.setOnDragIn=function(func){
		this.attachEvent("onDragIn",func);
        };

/**
*     @desc: enable/disable auto scrolling while drag-and-drop
*     @type: public
*     @param: mode - enabled/disabled
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.enableDragAndDropScrolling=function(mode){ this.autoScroll=convertStringToBoolean(mode); };


dhtmlXTreeObject.prototype.setSkin=function(name){
	var tmp = this.parentObject.className.replace(/dhxtree_[^ ]*/gi,"");
	this.parentObject.className= tmp+" dhxtree_"+name;
  if (name == "dhx_terrace")
    this.enableTreeLines(false);
};

//tree
(function(){
	
	dhtmlx.extend_api("dhtmlXTreeObject",{
		_init:function(obj){
			return [obj.parent,(obj.width||"100%"),(obj.height||"100%"),(obj.root_id||0)];
		},
		auto_save_selection:"enableAutoSavingSelected",
		auto_tooltip:"enableAutoTooltips",
		checkbox:"enableCheckBoxes",
		checkbox_3_state:"enableThreeStateCheckboxes",
		checkbox_smart:"enableSmartCheckboxes",
		context_menu:"enableContextMenu",
		distributed_parsing:"enableDistributedParsing",
		drag:"enableDragAndDrop",
		drag_copy:"enableMercyDrag",
		drag_image:"enableImageDrag",
		drag_scroll:"enableDragAndDropScrolling",
		editor:"enableItemEditor",
		hover:"enableHighlighting",
		images:"enableTreeImages",
		image_fix:"enableIEImageFix",
		image_path:"setImagePath",
		lines:"enableTreeLines",
		loading_item:"enableLoadingItem",
		multiline:"enableMultiLineItems",
		multiselect:"enableMultiselection",
		navigation:"enableKeyboardNavigation",
		radio:"enableRadioButtons",
		radio_single:"enableSingleRadioMode",
		rtl:"enableRTL",
		search:"enableKeySearch",
		smart_parsing:"enableSmartXMLParsing",
		smart_rendering:"enableSmartRendering",
		text_icons:"enableTextSigns",
		xml:"loadXML",
		skin:"setSkin"
	},{});
	
})();

dhtmlXTreeObject.prototype._dp_init=function(dp){
	dp.attachEvent("insertCallback", function(upd, id, parent) {
		var data = this._loader.doXPath(".//item",upd);
		var text = data[0].getAttribute('text');
		this.obj.insertNewItem(parent, id, text, 0, 0, 0, 0, "CHILD");
	});

	dp.attachEvent("updateCallback", function(upd, id, parent) {
		var data = this._loader.doXPath(".//item",upd);
		var text = data[0].getAttribute('text');
		this.obj.setItemText(id, text);
		if (this.obj.getParentId(id) != parent) {
			this.obj.moveItem(id, 'item_child', parent);
		}
		this.setUpdated(id, true, 'updated');
	});

	dp.attachEvent("deleteCallback", function(upd, id, parent) {
		this.obj.setUserData(id, this.action_param, "true_deleted");
		this.obj.deleteItem(id, false);
	});
	
	dp._methods=["setItemStyle","","changeItemId","deleteItem"];
    this.attachEvent("onEdit",function(state,id){
        if (state==3)
            dp.setUpdated(id,true)
		return true;
	});
    this.attachEvent("onDrop",function(id,id_2,id_3,tree_1,tree_2){
    	if (tree_1==tree_2)
        	dp.setUpdated(id,true);
    });
    this._onrdlh=function(rowId){
		var z=dp.getState(rowId);
		if (z=="inserted") {  dp.set_invalid(rowId,false); dp.setUpdated(rowId,false);	return true; }
		if (z=="true_deleted")  { dp.setUpdated(rowId,false); return true; }

		dp.setUpdated(rowId,true,"deleted")
		return false;
	};
	this._onradh=function(rowId){
		dp.setUpdated(rowId,true,"inserted")
	};
	dp._getRowData=function(rowId){
		var data = {};
		var z=this.obj._globalIdStorageFind(rowId);
		var z2=z.parentObject;
			
		var i=0;
		for (i=0; i<z2.childsCount; i++)
			if (z2.childNodes[i]==z) break;
		
		data["tr_id"] = z.id;
		data["tr_pid"] = z2.id;
		data["tr_order"] = i;
		data["tr_text"] = z.span.innerHTML;
		
		z2=(z._userdatalist||"").split(",");
		for (i=0; i<z2.length; i++)
			data[z2[i]]=z.userData["t_"+z2[i]];
			
    	return data;
	};	
};

//(c)dhtmlx ltd. www.dhtmlx.com
//v.3.6 build 131108

/*
Copyright DHTMLX LTD. http://www.dhtmlx.com
To use this component please contact sales@dhtmlx.com to obtain license
*/
dhtmlXTreeObject.prototype.parserExtension={
	_parseExtension:function(p,a,pid) {
		this._idpull[a.id]._attrs=a;
	}
};

dhtmlXTreeObject.prototype.getAttribute=function(id,name){
	this._globalIdStorageFind(id)
	var t=this._idpull[id]._attrs;
	return t?t[name]:window.undefined;
}
dhtmlXTreeObject.prototype.setAttribute=function(id,name,value){
	this._globalIdStorageFind(id)
	var t=(this._idpull[id]._attrs)||{};
	t[name]=value;
	this._idpull[id]._attrs=t;
}

//v.3.6 build 131108

/*
Copyright DHTMLX LTD. http://www.dhtmlx.com
To use this component please contact sales@dhtmlx.com to obtain license
*/
/**
*     @desc: adds drag-n-drop capabilities (with possibility to drop into dhtmlxTree) to HTML object. 
*     @param: obj - HTML object, or HTML object ID
*     @param: func - custom drag processor function, optional
*     @type: public
*     @topic: 0
*/
dhtmlXTreeObject.prototype.makeDraggable=function(obj,func){
	if (typeof(obj)!="object")
		obj=document.getElementById(obj);

    dragger=new dhtmlDragAndDropObject();
	dropper=new dhx_dragSomethingInTree();

    dragger.addDraggableItem(obj,dropper);
    obj.dragLanding=null;
    obj.ondragstart=dropper._preventNsDrag;
    obj.onselectstart=new Function("return false;");

    obj.parentObject=new Object;
    obj.parentObject.img=obj;
    obj.parentObject.treeNod=dropper;
	dropper._customDrop=func;
}
dhtmlXTreeObject.prototype.makeDragable=dhtmlXTreeObject.prototype.makeDraggable;
/**
*     @desc: adds drag-n-drop capabilities (with possibility to drop into dhtmlxTree) to all HTML items with dragInDhtmlXTree attribute
*     @param: func - custom drag processor function, optional
*     @type: public
*     @topic: 0
*/
dhtmlXTreeObject.prototype.makeAllDraggable=function(func){
	var z=document.getElementsByTagName("div");
	for (var i=0; i<z.length; i++)
		if (z[i].getAttribute("dragInDhtmlXTree"))
			this.makeDragable(z[i],func);
}

function dhx_dragSomethingInTree(){
	this.lWin=window;
	//this function creates a HTML object which will be used while drag-n-drop
    this._createDragNode=function(node){
    	var dragSpan=document.createElement('div');
        dragSpan.style.position="absolute";
        dragSpan.innerHTML=(node.innerHTML||node.value);
        dragSpan.className="dragSpanDiv";
        return dragSpan;
    };
	//this function necessary for correct browser support
	//doesn't change anything in it
    this._preventNsDrag=function(e){
    	(e||window.event).cancelBubble=true;
        if ((e)&&(e.preventDefault)) { e.preventDefault(); return false; }
        return false;
    }
	//this function contains a reaction on drop operation
	//the tree don't know what to do with custom item
	//so you must define this reaction
    this._nonTrivialNode=function(tree,item,bitem,source){
		if (this._customDrop) return this._customDrop(tree,source.img.id,item.id,bitem?bitem.id:null);

        var image=(source.img.getAttribute("image")||"");
		var id=source.img.id||"new";
		var text=(source.img.getAttribute("text")||(_isIE?source.img.innerText:source.img.textContent));
        tree[bitem?"insertNewNext":"insertNewItem"](bitem?bitem.id:item.id,id,text,"",image,image,image);
     }
}
//(c)dhtmlx ltd. www.dhtmlx.com
//v.3.6 build 131108

/*
Copyright DHTMLX LTD. http://www.dhtmlx.com
To use this component please contact sales@dhtmlx.com to obtain license
*/
/*
Purpose: item edit extension
*/


/**
*     @desc: enable editing of item text
*     @param:  mode - true/false
*     @type: public
*     @topic: 0
*/
dhtmlXTreeObject.prototype.enableItemEditor=function(mode){
        this._eItEd=convertStringToBoolean(mode);
        if (!this._eItEdFlag){

            this._edn_click_IE=true;
            this._edn_dblclick=true;
            this._ie_aFunc=this.aFunc;
            this._ie_dblclickFuncHandler=this.dblclickFuncHandler;

            this.setOnDblClickHandler(function (a,b) {
                if (this._edn_dblclick) this._editItem(a,b);
                return true;
				});

            this.setOnClickHandler(function (a,b) {
                this._stopEditItem(a,b);
                    if ((this.ed_hist_clcik==a)&&(this._edn_click_IE))
                        this._editItem(a,b);
                this.ed_hist_clcik=a;
                return true;
                });

            this._eItEdFlag=true;

            }
        };

/**
*     @desc: set onEdit handler ( multi handler event)
*     @param:  func - function which will be called on edit related events
*     @type: depricated
*     @event:  onEdit
*     @depricated: use grid.attachEvent("onEdit",func); instead
*     @eventdesc: Event occurs on 4 different stages of edit process: before editing started (cancelable), after editing started, before closing (cancelable), after closed
*     @eventparam: state - 0 before editing started , 1 after editing started, 2 before closing, 3 after closed
*     @eventparam: id - id of edited items
*     @eventparam: tree - tree object
*     @eventparam: value - for stage 0 and 2, value of editor
*     @eventreturn: for stages 0 and 2; true - confirm opening/closing, false - deny opening/closing;  text - edit value
*     @topic: 0
*/
dhtmlXTreeObject.prototype.setOnEditHandler=function(func){
		this.attachEvent("onEdit",func);
        };



/**
*     @desc: define which events must start editing
*     @param:  click_IE - click on already selected item - true/false [true by default]
*     @param:  dblclick - on double click
*     @type: public
*     @topic: 0
*/
dhtmlXTreeObject.prototype.setEditStartAction=function(click_IE, dblclick){
        this._edn_click_IE=convertStringToBoolean(click_IE);
        this._edn_dblclick=convertStringToBoolean(dblclick);
        };

dhtmlXTreeObject.prototype._stopEdit=function(a,mode){
    if  (this._editCell){
        this.dADTempOff=this.dADTempOffEd;
        if (this._editCell.id!=a){
			
			var editText=true;
			if(!mode){
	            editText=this.callEvent("onEdit",[2,this._editCell.id,this,this._editCell.span.childNodes[0].value]);
			}
			else{
				editText = false;
				this.callEvent("onEditCancel",[this._editCell.id,this._editCell._oldValue]);
			}
	        if (editText===true)
	           	editText=this._editCell.span.childNodes[0].value;
	        else if (editText===false) editText=this._editCell._oldValue;
	        
			var changed = (editText!=this._editCell._oldValue);
	        this._editCell.span.innerHTML=editText;
	        this._editCell.label=this._editCell.span.innerHTML;
			var cSS=this._editCell.i_sel?"selectedTreeRow":"standartTreeRow";
	        this._editCell.span.className=cSS;
	        this._editCell.span.parentNode.className="standartTreeRow";
	        this._editCell.span.style.paddingRight=this._editCell.span.style.paddingLeft='5px';
	        this._editCell.span.onclick=this._editCell.span.ondblclick=function(){};
	        
	        var id=this._editCell.id; 
	        if (this.childCalc)  this._fixChildCountLabel(this._editCell);
	        this._editCell=null;
	        
			if(!mode)
	        	this.callEvent("onEdit",[3,id,this,changed]);
	        
			if (this._enblkbrd){
				this.parentObject.lastChild.focus();
				this.parentObject.lastChild.focus();
			}
        }
    }
}

dhtmlXTreeObject.prototype._stopEditItem=function(id,tree){
    this._stopEdit(id);
};

/**
*     @desc:  switch currently edited item back to normal view
*     @type: public
*     @topic: 0
*/

dhtmlXTreeObject.prototype.stopEdit=function(mode){
    if (this._editCell)
        this._stopEdit(this._editCell.id+"_non",mode);
}

/**
*     @desc: open editor for specified item
*     @param:  id - item ID
*     @type: public
*     @topic: 0
*/
dhtmlXTreeObject.prototype.editItem=function(id){
    this._editItem(id,this);
}

dhtmlXTreeObject.prototype._editItem=function(id,tree){
    if (this._eItEd){
        this._stopEdit();
        var temp=this._globalIdStorageFind(id);
		if (!temp) return;
				
	    var editText = this.callEvent("onEdit",[0,id,this,temp.span.innerHTML]);
        if (editText===true)
            editText = (typeof temp.span.innerText!="undefined"?temp.span.innerText:temp.span.textContent);
        else if (editText===false) return;
        this.dADTempOffEd=this.dADTempOff;
        this.dADTempOff=false;


        this._editCell=temp;
        temp._oldValue=editText;
        temp.span.innerHTML="<input type='text' class='intreeeditRow' />";
        temp.span.style.paddingRight=temp.span.style.paddingLeft='0px';
        temp.span.onclick = temp.span.ondblclick= function(e){
			(e||event).cancelBubble = true;
		}

        temp.span.childNodes[0].value=editText;

        temp.span.childNodes[0].onselectstart=function(e){
            (e||event).cancelBubble=true;
            return true;
        }
        temp.span.childNodes[0].onmousedown=function(e){
            (e||event).cancelBubble=true;
            return true;
        }

        temp.span.childNodes[0].focus();
        temp.span.childNodes[0].focus();
//		temp.span.childNodes[0].select();
        temp.span.onclick=function (e){ (e||event).cancelBubble=true; return false; };
        temp.span.className="";
        temp.span.parentNode.className="";

        var self=this;

        temp.span.childNodes[0].onkeydown=function(e){
            if (!e) e=window.event;
            if (e.keyCode==13){
				 e.cancelBubble=true;
				 self._stopEdit(window.undefined);	
			}
			else if (e.keyCode==27){
				self._stopEdit(window.undefined, true);
			}
			(e||event).cancelBubble=true;
        }
        this.callEvent("onEdit",[1,id,this]);
    }
};
//(c)dhtmlx ltd. www.dhtmlx.com

//v.3.6 build 131108

/*
Copyright DHTMLX LTD. http://www.dhtmlx.com
To use this component please contact sales@dhtmlx.com to obtain license
*/
function jsonPointer(data,parent){
	this.d=data;
	this.dp=parent;
}
jsonPointer.prototype={
	text:function(){ var afff=function(n){ var p=[]; for(var i=0; i<n.length; i++) p.push("{"+sfff(n[i])+"}"); return p.join(","); }; var sfff=function(n){ var p=[]; for (var a in n) if (typeof(n[a])=="object"){ if (a.length) p.push('"'+a+'":['+afff(n[a])+"]");  else p.push('"'+a+'":{'+sfff(n[a])+"}"); }else p.push('"'+a+'":"'+n[a]+'"'); return p.join(","); }; return "{"+sfff(this.d)+"}"; },
	get:function(name){return this.d[name]; },
	exists:function(){return !!this.d },
	content:function(){return this.d.content; },
	each:function(name,f,t){  var a=this.d[name]; var c=new jsonPointer(); if (a) for (var i=0; i<a.length; i++) { c.d=a[i]; f.apply(t,[c,i]); } },
	get_all:function(){ return this.d; },
	sub:function(name){ return new jsonPointer(this.d[name],this.d) },
	sub_exists:function(name){ return !!this.d[name]; },
	each_x:function(name,rule,f,t,i){  var a=this.d[name]; var c=new jsonPointer(0,this.d); if (a) for (i=i||0; i<a.length; i++) if (a[i][rule]) { c.d=a[i]; if(f.apply(t,[c,i])==-1) return; } },
	up:function(name){ return new jsonPointer(this.dp,this.d);  },
	set:function(name,val){ this.d[name]=val;  },
	clone:function(name){ return new jsonPointer(this.d,this.dp); },
	through:function(name,rule,v,f,t){  var a=this.d[name]; if (a.length) for (var i=0; i<a.length; i++) { if (a[i][rule]!=null && a[i][rule]!="" &&  (!v || a[i][rule]==v )) { 
		var c=new jsonPointer(a[i],this.d);  f.apply(t,[c,i]); }  var w=this.d; this.d=a[i]; 
		if (this.sub_exists(name)) this.through(name,rule,v,f,t); this.d=w;   } }
}

/**
*     @desc: load tree from js array file|stream
*     @type: public
*     @param: file - link to JSArray file
*     @param: afterCall - function which will be called after xml loading
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.loadJSArrayFile=function(file,afterCall){
      if (!this.parsCount) this.callEvent("onXLS",[this,this._ld_id]); this._ld_id=null; this.xmlstate=1;
      var that=this;
      
      this.XMLLoader=new dtmlXMLLoaderObject(function(){
      	eval("var z="+arguments[4].xmlDoc.responseText);
      	that.loadJSArray(z);
      },this,true,this.no_cashe);
	  if (afterCall) this.XMLLoader.waitCall=afterCall;
      this.XMLLoader.loadXML(file);
   };
   
/**
*     @desc: load tree from csv file|stream
*     @type: public
*     @param: file - link to CSV file
*     @param: afterCall - function which will be called after xml loading
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.loadCSV=function(file,afterCall){
      if (!this.parsCount) this.callEvent("onXLS",[this,this._ld_id]); this._ld_id=null; this.xmlstate=1;
      var that=this;
	this.XMLLoader=new dtmlXMLLoaderObject(function(){
      	that.loadCSVString(arguments[4].xmlDoc.responseText);
      },this,true,this.no_cashe);
	  if (afterCall) this.XMLLoader.waitCall=afterCall;
      this.XMLLoader.loadXML(file);
   };
   
/**
*     @desc: load tree from js array object
*     @type: public
*     @param: ar - js array
*     @param: afterCall - function which will be called after xml loading
*     @topic: 0
*/  
dhtmlXTreeObject.prototype.loadJSArray=function(ar,afterCall){
	//array id,parentid,text
	var z=[];
	for (var i=0; i<ar.length; i++){
		if (!z[ar[i][1]]) z[ar[i][1]]=[];
		z[ar[i][1]].push({id:ar[i][0],text:ar[i][2]});
	}
	
	var top={id: this.rootId};
	var f=function(top,f){
		if (z[top.id]){
			top.item=z[top.id];
			for (var j=0; j<top.item.length; j++)
				f(top.item[j],f);
		}
	}
	f(top,f);
	this.loadJSONObject(top,afterCall);
}


/**
*     @desc: load tree from csv string
*     @type: public
*     @param: csv - csv string 
*     @param: afterCall - function which will be called after xml loading
*     @topic: 0
*/
dhtmlXTreeObject.prototype.loadCSVString=function(csv,afterCall){
	//array id,parentid,text
	var z=[];
	var ar=csv.split("\n");
	for (var i=0; i<ar.length; i++){
		var t=ar[i].split(",");
		if (!z[t[1]]) z[t[1]]=[];
		z[t[1]].push({id:t[0],text:t[2]});
	}
	
	var top={id: this.rootId};
	var f=function(top,f){
		if (z[top.id]){
			top.item=z[top.id];
			for (var j=0; j<top.item.length; j++)
				f(top.item[j],f);
		}
	}
	f(top,f);
	this.loadJSONObject(top,afterCall);
}


/**
*     @desc: load tree from json object
*     @type: public
*     @param: json - json object
*     @param: afterCall - function which will be called after xml loading
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.loadJSONObject=function(json,afterCall){
      if (!this.parsCount) this.callEvent("onXLS",[this,null]);this.xmlstate=1;
      var p=new jsonPointer(json);
	  this._parse(p);
	  this._p=p;
      if (afterCall) afterCall();
   };
   

/**   
*     @desc: load tree from json file
*     @type: public
*     @param: file - link to JSON file
*     @param: afterCall - function which will be called after xml loading
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.loadJSON=function(file,afterCall){
      if (!this.parsCount) this.callEvent("onXLS",[this,this._ld_id]); this._ld_id=null; this.xmlstate=1;
      var that=this;
      
      this.XMLLoader=new dtmlXMLLoaderObject(function(){
      	try {
			eval("var t="+arguments[4].xmlDoc.responseText);
		} catch(e){
				dhtmlxError.throwError("LoadXML", "Incorrect JSON", [
					(arguments[4].xmlDoc),
					this
				]);
				return;
		}
      	var p=new jsonPointer(t);
      	that._parse(p);
      	that._p=p;
      },this,true,this.no_cashe);
      
	  if (afterCall) this.XMLLoader.waitCall=afterCall;
      this.XMLLoader.loadXML(file);
   };   
   
   
/**   
*     @desc: return tree as json string
*     @type: public
*     @topic: 0
*/
dhtmlXTreeObject.prototype.serializeTreeToJSON=function(){
	var out=['{"id":"'+this.rootId+'", "item":['];
	var p=[];
		for (var i=0; i<this.htmlNode.childsCount; i++)
			p.push(this._serializeItemJSON(this.htmlNode.childNodes[i]));
	out.push(p.join(","));
	out.push("]}");	
	return out.join("");
};
dhtmlXTreeObject.prototype._serializeItemJSON=function(itemNode){
	var out=[];
	if (itemNode.unParsed)
			return (itemNode.unParsed.text());
  
	if (this._selected.length)
		var lid=this._selected[0].id;
	else lid="";
    var text=itemNode.span.innerHTML;

	text=text.replace(/\"/g, "\\\"", text);

	if (!this._xfullXML)
		out.push('{ "id":"'+itemNode.id+'", '+(this._getOpenState(itemNode)==1?' "open":"1", ':'')+(lid==itemNode.id?' "select":"1",':'')+' "text":"'+text+'"'+( ((this.XMLsource)&&(itemNode.XMLload==0))?', "child":"1" ':''));
	else
		out.push('{ "id":"'+itemNode.id+'", '+(this._getOpenState(itemNode)==1?' "open":"1", ':'')+(lid==itemNode.id?' "select":"1",':'')+' "text":"'+text+'", "im0":"'+itemNode.images[0]+'", "im1":"'+itemNode.images[1]+'", "im2":"'+itemNode.images[2]+'" '+(itemNode.acolor?(', "aCol":"'+itemNode.acolor+'" '):'')+(itemNode.scolor?(', "sCol":"'+itemNode.scolor+'" '):'')+(itemNode.checkstate==1?', "checked":"1" ':(itemNode.checkstate==2?', "checked":"-1"':''))+(itemNode.closeable?', "closeable":"1" ':'')+( ((this.XMLsource)&&(itemNode.XMLload==0))?', "child":"1" ':''));

	if ((this._xuserData)&&(itemNode._userdatalist))
		{
			out.push(', "userdata":[');
			var names=itemNode._userdatalist.split(",");
			var p=[];
			for  (var i=0; i<names.length; i++)
				p.push('{ "name":"'+names[i]+'" , "content":"'+itemNode.userData["t_"+names[i]]+'" }');
			out.push(p.join(",")); out.push("]");
		}
		
		if (itemNode.childsCount){
			out.push(', "item":[');
			var p=[];
		for (var i=0; i<itemNode.childsCount; i++)
			p.push(this._serializeItemJSON(itemNode.childNodes[i]));
			out.push(p.join(","));
			out.push("]\n");
		}
			
		out.push("}\n")
	return out.join("");
}   
//(c)dhtmlx ltd. www.dhtmlx.com
//v.3.6 build 131108

/*
Copyright DHTMLX LTD. http://www.dhtmlx.com
To use this component please contact sales@dhtmlx.com to obtain license
*/
/*
Purpose: keyboard navigation extension
*/

/**
*     @desc: enable keyboard navigation in tree
*     @param: mode - true/false
*     @edition: Professional
*     @type: public
*     @topic: 4
*/
dhtmlXTreeObject.prototype.enableKeyboardNavigation=function(mode){
        this._enblkbrd=convertStringToBoolean(mode);
        if (this._enblkbrd){
            if (_isFF){
                var z=window.getComputedStyle(this.parentObject,null)["position"];
                if ((z!="absolute")&&(z!="relative"))
                    this.parentObject.style.position="relative";
                }
            this._navKeys=[["up",38],["down",40],["open",39],["close",37],["call",13],["edit",113]];
            var self=this;
            var z=document.createElement("INPUT");
                z.className="a_dhx_hidden_input";
                z.autocomplete="off";
                if (window._KHTMLrv) z.style.color="white";
            this.parentObject.appendChild(z);
            this.parentObject[_isOpera?"onkeypress":"onkeydown"]=function(e){
            	if (self.callEvent("onKeyPress",[(e||window.event).keyCode,(e||window.event)]))
                	return self._onKeyDown(e||window.event)
                
            }
            this.parentObject.onclick=function(e){
                    if (_isFF || _isIE)
                    	z.select();
                    if (window._KHTMLrv || _isOpera) 
                    	z.focus();
            }
        }
        else
            this.parentObject.onkeydown=null;
}


dhtmlXTreeObject.prototype._onKeyDown=function(e){
    if (window.globalActiveDHTMLGridObject && globalActiveDHTMLGridObject.isActive) 
        return true;
    var self=this;
    for (var i=0; i<this._navKeys.length; i++)
        if (this._navKeys[i][1]==e.keyCode){
        	
            this["_onkey_"+this._navKeys[i][0]].apply(this,[this.getSelectedItemId()]);
            if (e.preventDefault) e.preventDefault();
			(e||event).cancelBubble=true;
            return false;
            }
    if (this._textSearch) {
    	return this._searchItemByKey(e);
    }
    return true;
}

dhtmlXTreeObject.prototype._onkey_up=function(id){
   	var temp=this._globalIdStorageFind(id);
    if (!temp) return;
    var next=this._getPrevVisibleNode(temp);
    if (next.id==this.rootId) return;
    this.focusItem(next.id);
    this.selectItem(next.id,false);
}
dhtmlXTreeObject.prototype._onkey_down=function(id){
   	var temp=this._globalIdStorageFind(id);
    if (!temp) return;
    var next=this._getNextVisibleNode(temp);
    if (next.id==this.rootId) return;
    this.focusItem(next.id);
    this.selectItem(next.id,false);
}
dhtmlXTreeObject.prototype._onkey_open=function(id){
    this.openItem(id);
}
dhtmlXTreeObject.prototype._onkey_close=function(id){
    this.closeItem(id);
}
dhtmlXTreeObject.prototype._onkey_call=function(id){
	if (this.stopEdit){
		this.stopEdit();
		this.parentObject.lastChild.focus();
		this.parentObject.lastChild.focus();
	    this.selectItem(id,true);
		}
	else
	    this.selectItem(this.getSelectedItemId(),true);
}
dhtmlXTreeObject.prototype._onkey_edit=function(id){
	if (this.editItem)
   		this.editItem(id);
}


dhtmlXTreeObject.prototype._getNextVisibleNode=function(item,mode){
	if ((!mode)&&(this._getOpenState(item)>0)) return item.childNodes[0];
	if ((item.tr)&&(item.tr.nextSibling)&&(item.tr.nextSibling.nodem))
    	return item.tr.nextSibling.nodem;

    if (item.parentObject) return  this._getNextVisibleNode(item.parentObject,1);
	return item;
};

dhtmlXTreeObject.prototype._getPrevVisibleNode=function(item){
	if ((item.tr)&&(item.tr.previousSibling)&&(item.tr.previousSibling.nodem))
    	return this._lastVisibleChild(item.tr.previousSibling.nodem);

	if (item.parentObject)
		return item.parentObject;
	else return item;
};

dhtmlXTreeObject.prototype._lastVisibleChild=function(item){
	if (this._getOpenState(item)>0)
		return this._lastVisibleChild(item.childNodes[item.childsCount-1]);
	else return item;
};


dhtmlXTreeObject.prototype._searchItemByKey=function(e){
	if (e.keyCode==8) {
		this._textSearchString='';
		return true;
	}
    var key = String.fromCharCode(e.keyCode).toUpperCase();
    if (key.match(/[A-Z,a-z,0-9\ ]/)) {
	    this._textSearchString += key;
	    this._textSearchInProgress = true;
		if (!(this.getSelectedItemText()||"").match(RegExp('^'+this._textSearchString,"i"))){
		    this.findItem('^'+this._textSearchString, 0);
		}
		this._textSearchInProgress = false;
	    if (e.preventDefault) e.preventDefault();
	    (e||event).cancelBubble=true;
	    return false;
    }
    return true;
}



/**
*     @desc: configure keys used for keyboard navigation
*     @param: keys - configuration array, please check pro_key_nav.html in samples for more details
*     @edition: Professional
*     @type: public
*     @topic: 4
*/
dhtmlXTreeObject.prototype.assignKeys=function(keys){
      this._navKeys=keys;
}

/**
*     @desc: enable search items by pressing keys (any item in tree should be focused/selected to make search work)
*     @param: mode - true/false
*     @edition: Professional
*     @type: public
*     @topic: 4
*/
dhtmlXTreeObject.prototype.enableKeySearch=function(mode){
	this._textSearch = convertStringToBoolean(mode);
	if (!this._textSearch) return;
	this._textSearchString = '';
	var self = this;
	this._markItem2 = this._markItem;
	this._markItem = function(node)
				     { 
				     	if (!self._textSearchInProgress)
	                    	self._textSearchString = '';
						self._markItem2(node);
				     }

}
//(c)dhtmlx ltd. www.dhtmlx.com

//v.3.6 build 131108

/*
Copyright DHTMLX LTD. http://www.dhtmlx.com
To use this component please contact sales@dhtmlx.com to obtain license
*/
/*
Purpose: temporary loading XML item
Warining - this extension is an experimental and not fully compatible
*/


/**
*     @desc: enable/disable "Loading..." item
*     @param: text - text of temporary item (default is "Loading...")
*     @edition: Professional
*     @type: public
*     @topic: 0
*/
 	dhtmlXTreeObject.prototype.enableLoadingItem=function(text) {
            this.attachEvent("onXLS",this._showFakeItem);
            this.attachEvent("onXLE",this._hideFakeItem);

            this._tfi_text=text||"Loading...";
    };


 	dhtmlXTreeObject.prototype._showFakeItem=function(tree,id) {
        if ((id===null)||(this._globalIdStorageFind("fake_load_xml_"+id))) return;
        var temp = this.XMLsource; this.XMLsource=null;
        this.insertNewItem(id,"fake_load_xml_"+id,this._tfi_text);
        this.XMLsource=temp;
    }
 	dhtmlXTreeObject.prototype._hideFakeItem=function(tree,id) {
        if (id===null) return;
        this.deleteItem("fake_load_xml_"+id);
    }
//(c)dhtmlx ltd. www.dhtmlx.com

//v.3.6 build 131108

/*
Copyright DHTMLX LTD. http://www.dhtmlx.com
To use this component please contact sales@dhtmlx.com to obtain license
*/

/*
Purpose: locked item extension for dhtmlxTree
Last updated: 11.01.2006
*/


/**
*     @desc: get locked state of item
*     @param: itemId - id of item
*     @returns: true/false  - locked/unlocked
*     @edition: Professional
*     @type: public
*     @topic: 4
*/
dhtmlXTreeObject.prototype.isLocked=function(itemId)
	{
        if (!this._locker) this._init_lock();
        return  (this._locker[itemId]==true);
	};

dhtmlXTreeObject.prototype._lockItem=function(sNode,state,skipdraw){
	if (!this._locker) this._init_lock();
    if (state){

            if (this._locker[sNode.id]==true) return;
            this._locker[sNode.id]=true;

            sNode.bIm0=sNode.images[0];
            sNode.bIm1=sNode.images[1];
            sNode.bIm2=sNode.images[2];

            sNode.images[0]=this.lico0;
            sNode.images[1]=this.lico1;
            sNode.images[2]=this.lico2;

            var z1=sNode.span.parentNode;
            var z2=z1.previousSibling;

            this.dragger.removeDraggableItem(z1);
            this.dragger.removeDraggableItem(z2);
        }
        else{
            if (this._locker[sNode.id]!=true) return;
            this._locker[sNode.id]=false;

            sNode.images[0]=sNode.bIm0;
            sNode.images[1]=sNode.bIm1;
            sNode.images[2]=sNode.bIm2;

            var z1=sNode.span.parentNode;
            var z2=z1.previousSibling;

            this.dragger.addDraggableItem(z1,this);
            this.dragger.addDraggableItem(z2,this);
        }

       if (!skipdraw) this._correctPlus(sNode);
}
/**
*     @desc: lock/unlock item
*     @param: itemId - id of item
*     @param: state - true/false  - lock/unlock item
*     @edition: Professional
*     @type: public
*     @topic: 4
*/
dhtmlXTreeObject.prototype.lockItem=function(itemId,state)
	{
        if (!this._locker) this._init_lock();
        this._lockOn=false;
		var sNode=this._globalIdStorageFind(itemId);
        this._lockOn=true;
        this._lockItem(sNode,convertStringToBoolean(state));
	}
/**
*     @desc: set icon for locked items
*     @param: im0 - icon for locked leaf
*     @param: im1 - icon for closed branch
*     @param: im2 - icon for opened branch
*     @edition: Professional
*     @type: public
*     @topic: 4
*/
dhtmlXTreeObject.prototype.setLockedIcons=function(im0,im1,im2)
	{
        if (!this._locker) this._init_lock();
        this.lico0=im0;
        this.lico1=im1;
        this.lico2=im2;
    };


dhtmlXTreeObject.prototype._init_lock=function()
	{
        this._locker=new Array();
        this._locker_count="0";
        this._lockOn=true;
        this._globalIdStorageFindA=this._globalIdStorageFind;
        this._globalIdStorageFind=this._lockIdFind;

        if (this._serializeItem){
            this._serializeItemA=this._serializeItem;
            this._serializeItem=this._serializeLockItem;


            this._serializeTreeA=this.serializeTree;
            this.serializeTree=this._serializeLockTree;

            }

        this.setLockedIcons(this.imageArray[0],this.imageArray[1],this.imageArray[2]);
    };


dhtmlXTreeObject.prototype._lockIdFind=function(itemId,skipXMLSearch,skipParsing)
	{
        if (!this.skipLock)
            if ((!skipParsing)&&(this._lockOn==true)&&(this._locker[itemId]==true)) {  return null; }
        return this._globalIdStorageFindA(itemId,skipXMLSearch,skipParsing);
    };
dhtmlXTreeObject.prototype._serializeLockItem=function(node)
	{
        if (this._locker[node.id]==true) return "";
        return this._serializeItemA(node);
    };
dhtmlXTreeObject.prototype._serializeLockTree=function()
	{
        var out=this._serializeTreeA();
        return out.replace(/<item[^>]+locked\=\"1\"[^>]+\/>/g,"");
    };


dhtmlXTreeObject.prototype._moveNodeToA=dhtmlXTreeObject.prototype._moveNodeTo;
dhtmlXTreeObject.prototype._moveNodeTo=function(itemObject,targetObject,beforeNode){
	   	if ((targetObject.treeNod.isLocked)&&(targetObject.treeNod.isLocked(targetObject.id))) {
			return false;
		}
		return this._moveNodeToA(itemObject,targetObject,beforeNode);
		}



/**
*     @desc: lock tree
*     @param: isLock - bool value. True - lock, false - unlock
*     @edition: Professional
*     @type: public
*     @topic: 4
*/
dhtmlXTreeObject.prototype.lockTree=function(isLock)
{
	if (convertStringToBoolean(isLock))
		this._initTreeLocker();
	else
		if (this._TreeLocker) {
			this._TreeLocker.parentNode.removeChild(this._TreeLocker);
			this._TreeLocker=null;
		}
};


dhtmlXTreeObject.prototype._initTreeLocker=function(isLock)
{
	if (this._TreeLocker) return;
	this.parentObject.style.overflow="hidden";
   	if (this.parentObject.style.position != 'absolute')
		this.parentObject.style.position = 'relative';


	var div = document.createElement('div');
	div.style.position = 'absolute';
	div.style.left = '0px';
	div.style.top = '0px';
	div.className = 'dhx_tree_opacity';

	div.style.width = this.allTree.offsetWidth+'px';
	div.style.backgroundColor = '#FFFFFF';

	div.style.height = this.allTree.offsetHeight+'px';
	//div.style.display = 'none';
	this._TreeLocker = div;
   	this.parentObject.appendChild(this._TreeLocker);
};
//(c)dhtmlx ltd. www.dhtmlx.com
//v.3.6 build 131108

/*
Copyright DHTMLX LTD. http://www.dhtmlx.com
To use this component please contact sales@dhtmlx.com to obtain license
*/
/*
Purpose: right-to-left extension for dhtmlxTree
Last updated: 17.02.2006
*/

/**
*     @desc: enables Right-to-Left mode in tree
*     @type: public
*     @param: mode - true/false
*     @edition: Professional
*     @topic: 2
*/
dhtmlXTreeObject.prototype.enableRTL=function(mode){
        var z=convertStringToBoolean(mode);
        if (((z)&&(!this.rtlMode))||((!z)&&(this.rtlMode)))
        {
        this.rtlMode=z;
        this._switchToRTL(this.rtlMode);
        }
};



dhtmlXTreeObject.prototype._switchToRTL=function(mode) {
        if (mode){
            this.allTree.className=
            this._ltr_line=this.lineArray;
            this._ltr_min=this.minusArray;
            this._ltr_plus=this.plusArray;
        	this.lineArray=new Array("line2_rtl.gif","line3_rtl.gif","line4_rtl.gif","blank.gif","blank.gif","line1_rtl.gif");
        	this.minusArray=new Array("minus2_rtl.gif","minus3_rtl.gif","minus4_rtl.gif","minus.gif","minus5_rtl.gif");
    	    this.plusArray=new Array("plus2_rtl.gif","plus3_rtl.gif","plus4_rtl.gif","plus.gif","plus5_rtl.gif");
            this.allTree.className="containerTableStyleRTL";
                }
            else
                {
            this.allTree.className="containerTableStyle";
            this.lineArray=this._ltr_line;
            this.minusArray=this._ltr_min;
            this.plusArray=this._ltr_plus;
                }
           if (this.htmlNode.childsCount)
                this._redrawFrom(this,this.htmlNode);
};

//(c)dhtmlx ltd. www.dhtmlx.com


//v.3.6 build 131108

/*
Copyright DHTMLX LTD. http://www.dhtmlx.com
To use this component please contact sales@dhtmlx.com to obtain license
*/
/*
Purpose: sorting extension for dhtmlxTree
Last updated: 03.05.2005
*/


/**
*     @desc: reorder items in tree according to their text
*     @type: public
*     @param: nodeId - id of node to start sorting from
*     @param: all_levels - sorting all levels or only current level
*     @param: order - sorting order - ASC or DES
*     @edition: Professional
*     @topic: 0
*/

dhtmlXTreeObject.prototype.sortTree=function(nodeId,order,all_levels)
	{
		var sNode=this._globalIdStorageFind(nodeId);
		if (!sNode) return false;

		this._reorderBranch(sNode,(order.toString().toLowerCase()=="asc"),convertStringToBoolean(all_levels))
	};

/**
*     @desc: set custom sort functions, which has two parametrs - id_of_item1,id_of_item2
*     @type: public
*     @param: func - sorting function
*     @edition: Professional
*     @topic: 0
*/
dhtmlXTreeObject.prototype.setCustomSortFunction=function(func)
	{
        this._csfunca=func;
	};
	
	
dhtmlXTreeObject.prototype._reorderBranch=function(node,order,all_levels){ 
	var m=[];
	var count=node.childsCount;
	if (!count) return;

	var parent = node.childNodes[0].tr.parentNode;
	for (var i=0; i<count; i++){
			m[i]=node.childNodes[i];
			parent.removeChild(m[i].tr);
			}

var self=this;
if (order==1)
    if(this._csfunca)
    	m.sort( function(a,b){ return self._csfunca(a.id,b.id); } );
    else
    	m.sort( function(a,b){ return ((a.span.innerHTML.toUpperCase()>b.span.innerHTML.toUpperCase())?1:((a.span.innerHTML.toUpperCase()==b.span.innerHTML.toUpperCase())?0:-1)) } );
else
    if(this._csfunca)
    	m.sort( function(a,b){ return self._csfunca(b.id,a.id); } );
    else
    	m.sort( function(a,b){ return ((a.span.innerHTML.toUpperCase()<b.span.innerHTML.toUpperCase())?1:((a.span.innerHTML.toUpperCase()==b.span.innerHTML.toUpperCase())?0:-1)) } );

	for (var i=0; i<count; i++){
		parent.appendChild(m[i].tr);
		node.childNodes[i]=m[i];
		
		if ((all_levels)&&(m[i].unParsed))
			m[i].unParsed.set("order",order?1:-1);
		else
		if ((all_levels)&&(m[i].childsCount))
			this._reorderBranch(m[i],order,all_levels);
		
		}
	
	for (var i=0; i<count; i++){
		this._correctPlus(m[i]);
		this._correctLine(m[i]);
		}
}

dhtmlXTreeObject.prototype._reorderXMLBranch=function(node){
	var orderold=node.getAttribute("order");
    if (orderold=="none") return;
	var order=(orderold==1);
	var count=node.childNodes.length;
	if (!count) return;

	var m=new Array();
    var j=0;

	for (var i=0; i<count; i++)
        if (node.childNodes[i].nodeType==1)
    		{ m[j]=node.childNodes[i]; j++ }

	for (var i=count-1; i!=0; i--)
		node.removeChild(node.childNodes[i]);


	if (order)
		m.sort( function(a,b){ return ((a.getAttribute("text")>b.getAttribute("text"))?1:((a.getAttribute("text")==b.getAttribute("text"))?0:-1)) } );
	else
		m.sort( function(a,b){ return ((a.getAttribute("text")<b.getAttribute("text"))?1:((a.getAttribute("text")==b.getAttribute("text"))?0:-1)) } );

	for (var i=0; i<j; i++){
		m[i].setAttribute("order",orderold);
		node.appendChild(m[i]);
		}

    node.setAttribute("order","none");
}
//(c)dhtmlx ltd. www.dhtmlx.com
//v.3.6 build 131108

/*
Copyright DHTMLX LTD. http://www.dhtmlx.com
To use this component please contact sales@dhtmlx.com to obtain license
*/
/**
*	@desc: enables smart rendering mode (usefull for big trees with lots f items on each level)
*   @edition: professional
*	@type: public
*/
dhtmlXTreeObject.prototype.enableSmartRendering=function(){
	this.enableSmartXMLParsing(true);
	this._srnd=true;
	this.itemHeight=18;
	var that=this;
	this.allTree.onscroll=function(){
		if (that._srndT) return;
		that._srndT=window.setTimeout(function(){
			that._srndT=null;
			that._renderState();
			
		},300);
	};
	
	this.attachEvent("onXLE",function(){
		that._renderState();
	});
	this._singleTimeSRND();
}

dhtmlXTreeObject.prototype._renderState=function(){ 
		//var z=this.allTree.parentNode;
		//var t=z.removeChild(this.allTree);
		
		
		if (!this._idpull[this.rootId]._sready) 
			this.prepareSR(this.rootId,true);
		var top=this.allTree.scrollTop;
		var pos=Math.floor(top/this.itemHeight);
		var height=Math.ceil(this.allTree.offsetHeight/this.itemHeight);
		
		this._group_render=true;
		this._getItemByPos(top,this.itemHeight,height,null,false,this._renderItemSRND);
		this._group_render=false;
		
		//z.appendChild(this.allTree);
}

dhtmlXTreeObject.prototype._renderItemSRND=function(a,b){ 
			if (!a.span){
				//render row
				a.span=-1;
				var z=a.parentObject.htmlNode.childNodes[0].childNodes;
				var count=b*this.itemHeight; var x=null;
				for (var i=1; i<z.length; i++) {
					
					x=z[i]; 
					var y=x.nodem?this.itemHeight:(x.offsetHeight||parseInt(x.childNodes[1].firstChild.style.height));
					
					count-=y;
					if (count<0) {
						if (count==-1) { count++; continue; } //magic
						var h=x.childNodes[1].firstChild;
					//	console.log("top: "+this.allTree.scrollTop+",original: "+y+",stop at:"+count+", current height:"+(parseInt(h.style.height))+",new height:"+(parseInt(h.style.height)-(y-Math.abs(count)+this.itemHeight))+"px");
						h.style.height=(parseInt(h.style.height)-(y-Math.abs(count)+this.itemHeight))+"px";
						if (Math.abs(count)!=y){
						//	console.log("add new as "+(count+y));
							var fill=this._drawNewHolder(count+y,true);
							x.parentNode.insertBefore(fill,x)
							
						}							
					x.tr={nextSibling:x};
					break;
					}				
				}
				
				if (h && h.style.height!="0px" && !x.offsetHeight)
					{ var rh=this._hAdI; this._hAdI=true; }
				this._parseItem(a._sxml,a.parentObject,null,x);
				if (h && h.style.height!="0px" && !x.offsetHeight)
					{ this._hAdI=rh; }
				if (a.unParsed) this._correctPlus(a);
				if (h && h.style.height=="0px") x.parentNode.removeChild(x);
			}			
}

dhtmlXTreeObject.prototype._buildSRND=function(z,skipParsing){ 
	if (z.parentObject) 
		this._globalIdStorageFind(z.parentObject.id);
	if (!this._idpull[this.rootId]._sready) 
			this.prepareSR(this.rootId,true);
		
	this._renderItemSRND(z,this._getIndex(z));
	if ((z.unParsed)&&(!skipParsing))
        this.reParse(z,0);
                    
	if (!z.prepareSR)
		this.prepareSR(z.id);
}

dhtmlXTreeObject.prototype._getIndex=function(z){
       for (var a=0; a<z.parentObject.childsCount; a++)
       if (z.parentObject.childNodes[a]==z) return a;
};

dhtmlXTreeObject.prototype.prepareSR=function(it,mode){ 
	it=this._idpull[it];
	if (it._sready) return;
    var tr=this._drawNewHolder(this.itemHeight*it.childsCount,mode);
	it.htmlNode.childNodes[0].appendChild(tr);
	it._sready=true;
	//it.tr=tr; tr.nodem=it;
}



dhtmlXTreeObject.prototype._drawNewHolder=function(s,mode){ 
	var t=document.createElement("TR");
	var b=document.createElement("TD");
	var b2=document.createElement("TD");
	var z=document.createElement("DIV");
	z.innerHTML="&nbsp;";
	b.appendChild(z)
	t.appendChild(b2); t.appendChild(b);
	if (!mode){
		t.style.display="none";
	}
	
	z.style.height=s+'px';
	return t;
}

dhtmlXTreeObject.prototype._getNextNodeSR=function(item,mode){
   if ((!mode)&&(item.childsCount)) return item.childNodes[0];
   if (item==this.htmlNode)
      return -1;
   if ((item.tr)&&(item.tr.nextSibling)&&(item.tr.nextSibling.nodem))
   return item.tr.nextSibling.nodem;

   return this._getNextNode(item.parentObject,true);
};

dhtmlXTreeObject.prototype._getItemByPos=function(pos,h,l,i,m,f){
	/*
		current implementation can be slow in case of deep hierarchy, in future we can move 
		counter login in HideShow function, so each top level item will know it real position
	*/
	if (!i){
		this._pos_c=pos;
		i=this._idpull[this.rootId];
	}
	
	for (var j=0; j<i.childsCount; j++){
		this._pos_c-=h;
		if (this._pos_c<=0) m=true;
		if (m) {
			f.apply(this,[i.childNodes[j],j]);
			l--;}
		if (l<0) return l;
		if (i.childNodes[j]._open){
			l=this._getItemByPos(null,h,l,i.childNodes[j],m,f);
		if (l<0) return l;
		}
	}
	return l;
}


   dhtmlXTreeObject.prototype._addItemSRND=function(pid,id,p){
   		var parentObject=this._idpull[pid];
        var Count=parentObject.childsCount;
        var Nodes=parentObject.childNodes;



        Nodes[Count]=new dhtmlXTreeItemObject(id,"",parentObject,this,null,1);
		itemId = Nodes[Count].id;
		Nodes[Count]._sxml=p.clone();

        parentObject.childsCount++;
   	}
   	
   	
dhtmlXTreeObject.prototype._singleTimeSRND=function(){ 
    this._redrawFrom=function(){}
    var _originalTreeItem=dhtmlXTreeItemObject;
    this._singleTimeSRND=function(){};
	window.dhtmlXTreeItemObject=function(itemId,itemText,parentObject,treeObject,actionHandler,mode){
		if (!treeObject._srnd) {
			return _originalTreeItem.call(this,itemId,itemText,parentObject,treeObject,actionHandler,mode);
		}
   this.htmlNode="";
   this.acolor="";
   this.scolor="";
   this.tr=0;
   this.childsCount=0;
   this.tempDOMM=0;
   this.tempDOMU=0;
   this.dragSpan=0;
   this.dragMove=0;
   this.span=0;
   this.closeble=1;
   this.childNodes=new Array();
   this.userData=new cObject();


   this.checkstate=0;
   this.treeNod=treeObject;
   this.label=itemText;
   this.parentObject=parentObject;
   this.actionHandler=actionHandler;
   this.images=new Array(treeObject.imageArray[0],treeObject.imageArray[1],treeObject.imageArray[2]);


   this.id=treeObject._globalIdStorageAdd(itemId,this);
   
	if (itemId==treeObject.rootId){
		if (this.treeNod.checkBoxOff ) this.htmlNode=this.treeNod._createItem(1,this,mode);
   		else  this.htmlNode=this.treeNod._createItem(0,this,mode);
   		this.htmlNode.objBelong=this;
	}
   
   return this;
};     

/*

Updates to existing code


*/
this.setCheckSR=this.setCheck;
this.setCheck=function(itemId,state){
	this._globalIdStorageFind(itemId);
	return this.setCheckSR(itemId,state);
};
this._get_srnd_p=function(id){
	var p=[];
	while(id!=this.rootId){
		var pid=this.getParentId(id);
		for (var i=0; i < this._idpull[pid].childsCount; i++) 
   			if (this._idpull[pid].childNodes[i].id==id){
   	 			p.push([pid,i])
   	 			break;
   	 		}
   	 	id=pid;
	}
	p.reverse();
	return p
};
this._get_srnd_p_last=function(id,p,mask){
	p=p||[];

	var pos=0;
	while (true){
		var i=this._idpull[id];
		if (i._sxml && this.findStrInXML(i._sxml.d,"text",mask))
			this._globalIdStorageFind(i.id);	
		var pos=i.childsCount;
		if (!pos) break;
		p.push([id,pos-1])
		id=i.childNodes[pos-1].id;
	}

	return p;
};
this._get_prev_srnd=function(p,mask){
    var last;
	if (!p.length){
        p.push.apply(p,this._get_srnd_p_last(this.rootId,null,mask));
        last=p[p.length-1];
        return this._idpull[last[0]].childNodes[last[1]];
    }
	last=p[p.length-1];
	if (last[1]) {
        last[1]--;
		var curr=this._idpull[last[0]].childNodes[last[1]];
		this._get_srnd_p_last(curr.id,p,mask);
		var last=p[p.length-1];
		return this._idpull[last[0]].childNodes[last[1]];
	} else {
		p.pop();
		if (!p.length) return this._get_prev_srnd(p,mask)
		var last=p[p.length-1];
		return this._idpull[last[0]].childNodes[last[1]];
	}
};

this._get_next_srnd=function(p,skip){
	if (!p.length){
		p.push([this.rootId,0]);
		return this._idpull[this.rootId].childNodes[0];
	}		
		
var last=p[p.length-1];
	var curr=this._idpull[last[0]].childNodes[last[1]];
	if (curr.childsCount && !skip){
		p.push([curr.id,0]);
		return curr.childNodes[0];
	}
	last[1]++;
	var curr=this._idpull[last[0]].childNodes[last[1]];
	if (curr)
		return curr;
	p.pop();
	if (!p.length)
		return this.htmlNode;
	
	return this._get_next_srnd(p,true);
};
this._findNodeByLabel=function(searchStr,direction,fromNode){
   //default next|prev locators is not reliable
   var searchStr=searchStr.replace(new RegExp("^( )+"),"").replace(new RegExp("( )+$"),"");
   searchStr =  new RegExp(searchStr.replace(/([\*\+\\\[\]\(\)]{1})/gi,"\\$1").replace(/ /gi,".*"),"gi");

   //get start node
   if (!fromNode)
      {
      fromNode=this._selected[0];
      if (!fromNode) fromNode=this.htmlNode;
      }
   var startNode=fromNode;
   var p=this._get_srnd_p(startNode.id);
   while (fromNode=(direction?this._get_prev_srnd(p,searchStr):this._get_next_srnd(p))){
   		if (fromNode.label){
   			if (fromNode.label.search(searchStr)!=-1) return fromNode
   		} else {
   			if (fromNode._sxml){
   				if (fromNode._sxml.get("text").search(searchStr)!=-1)
   					return fromNode;
   				if (this.findStrInXML(fromNode._sxml.d,"text",searchStr))
					this._globalIdStorageFind(fromNode.id);	
   			} 
   		}
   		
		if ((fromNode.unParsed)&&(this.findStrInXML(fromNode.unParsed.d,"text",searchStr)))
			this.reParse(fromNode);	
		
   		if (startNode.id==fromNode.id) break;
        if(direction&&p.length==1&&p[0][1]==0)
             break;

   }
   
   return null;
};
this.deleteChildItems=function(id){  
	if (this.rootId==id){
		this._selected=new Array();
		this._idpull={};
		this._p=this._pos_c=this._pullSize=null;
		this.allTree.removeChild(this.htmlNode.htmlNode);
		
		this.htmlNode=new dhtmlXTreeItemObject(this.rootId,"",0,this);
   		this.htmlNode.htmlNode.childNodes[0].childNodes[0].style.display="none";
   		this.htmlNode.htmlNode.childNodes[0].childNodes[0].childNodes[0].className="hiddenRow";
   		
   		this.allTree.insertBefore(this.htmlNode.htmlNode,this.selectionBar);
		if(_isFF){
			this.allTree.childNodes[0].width="100%";
			this.allTree.childNodes[0].style.overflow="hidden";
		}
	}
}
this._HideShow=function(itemObject,mode){
      if ((this.XMLsource)&&(!itemObject.XMLload)) {
            if (mode==1) return; //close for not loaded node - ignore it
            itemObject.XMLload=1;
            this._loadDynXML(itemObject.id);
            return; };
//#__pro_feature:01112006{
//#smart_parsing:01112006{
		if (!itemObject.span)
			this._buildSRND(itemObject);
		
        if (itemObject.unParsed){
        	this.reParse(itemObject);
			this.prepareSR(itemObject.id);
        }
        
        if (itemObject.childsCount==0) return;
//#}
//#}
      var Nodes=itemObject.htmlNode.childNodes[0].childNodes; var Count=Nodes.length;
      if (Count>1){
         if ( ( (Nodes[1].style.display!="none") || (mode==1) ) && (mode!=2) ) {
//nb:solves standard doctype prb in IE
          this.allTree.childNodes[0].border = "1";
          this.allTree.childNodes[0].border = "0";
         var nodestyle="none";
         itemObject._open=false;
         }
         else  {
	     	var nodestyle="";
         	itemObject._open=true;
     	}

      for (var i=1; i<Count; i++)
         Nodes[i].style.display=nodestyle;
         
      this._renderState();
      }
      this._correctPlus(itemObject);
   }
 }

//(c)dhtmlx ltd. www.dhtmlx.com



//v.3.6 build 131108

/*
Copyright DHTMLX LTD. http://www.dhtmlx.com
To use this component please contact sales@dhtmlx.com to obtain license
*/
function dhtmlXTreeFromHTML(obj){
			if (typeof(obj)!="object")
				obj=document.getElementById(obj);

            var n=obj;
			var id=n.id;
			var cont="";

			for (var j=0; j<obj.childNodes.length; j++)
				if (obj.childNodes[j].nodeType=="1"){
					if (obj.childNodes[j].tagName=="XMP"){
						var cHead=obj.childNodes[j];
						for (var m=0; m<cHead.childNodes.length; m++)
							cont+=cHead.childNodes[m].data;

						}
					else if (obj.childNodes[j].tagName.toLowerCase()=="ul")
						cont=dhx_li2trees(obj.childNodes[j],new Array(),0);
					break;
					}
			obj.innerHTML="";


			var t=new dhtmlXTreeObject(obj,"100%","100%",0);
			var z_all=new Array();
			for ( b in t )
				z_all[b.toLowerCase()]=b;

			var atr=obj.attributes;
			for (var a=0; a<atr.length; a++)
				if ((atr[a].name.indexOf("set")==0)||(atr[a].name.indexOf("enable")==0)){
					var an=atr[a].name;
                    if (!t[an])
						an=z_all[atr[a].name];
					t[an].apply(t,atr[a].value.split(","));
					}

			if (typeof(cont)=="object"){
			    t.XMLloadingWarning=1;
				for (var i=0; i<cont.length; i++){
					var n=t.insertNewItem(cont[i][0],cont[i][3],cont[i][1]);
					if (cont[i][2]) t._setCheck(n,cont[i][2]);
					}
				t.XMLloadingWarning=0;
				t.lastLoadedXMLId=0;
				t._redrawFrom(t);
			}
			else
			t.loadXMLString("<tree id='0'>"+cont+"</tree>");
            window[id]=t;
            
            var oninit = obj.getAttribute("oninit");
            if (oninit) eval(oninit);
			return t;
}

function dhx_init_trees(){
    var z=document.getElementsByTagName("div");
    for (var i=0; i<z.length; i++)
        if (z[i].className=="dhtmlxTree")
			dhtmlXTreeFromHTML(z[i])
}

function dhx_li2trees(tag,data,ind){
	for (var i=0; i<tag.childNodes.length; i++){
        var z=tag.childNodes[i];
		if ((z.nodeType==1)&&(z.tagName.toLowerCase()=="li")){
			var c=""; var ul=null;
				var check=z.getAttribute("checked");
				for (var j=0; j<z.childNodes.length; j++){
				var zc=z.childNodes[j];
				if (zc.nodeType==3) c+=zc.data;
				else if (zc.tagName.toLowerCase()!="ul")  c+=dhx_outer_html(zc);
					 else ul=zc;
			}

			data[data.length]=[ind,c,check,(z.id||(data.length+1))];
			if (ul)
				data=dhx_li2trees(ul,data,(z.id||data.length));
		}
	}
	return data;
}

function dhx_outer_html(node){
		if (node.outerHTML) return node.outerHTML;
		var temp=document.createElement("DIV");
		temp.appendChild(node.cloneNode(true));
		temp=temp.innerHTML;
		return temp;
}

if (window.addEventListener) window.addEventListener("load",dhx_init_trees,false);
else    if (window.attachEvent) window.attachEvent("onload",dhx_init_trees);
//(c)dhtmlx ltd. www.dhtmlx.com



//v.3.6 build 131108

/*
Copyright DHTMLX LTD. http://www.dhtmlx.com
To use this component please contact sales@dhtmlx.com to obtain license
*/
/*
Purpose: saving state extension for dhtmlxTree
Inner Version: 1.3
Last updated: 05.07.2005
*/

dhtmlXTreeObject.prototype._serEnts=[["&","&amp;"],["<","&lt;"],[">","&gt;"]];

/**
*     @desc: register XML entity for replacement while initialization (default are: ampersand, lessthen and greaterthen symbols)
*     @type: public
*     @edition: Professional
*	  @param: rChar - source char
*	  @param: rEntity - target entity
*     @topic: 2
*/
dhtmlXTreeObject.prototype.registerXMLEntity=function(rChar,rEntity){
    this._serEnts[this._serEnts.length]=[rChar,rEntity,new RegExp(rChar,"g")];
}

/**
*     @desc: configure XML serialization
*     @type: public
*     @edition: Professional
*	  @param: userData - enable/disable user data serialization
*	  @param: fullXML - enable/disable full XML serialization
*	  @param: escapeEntities - convert tag brackets to related html entitites
*	  @param: userDataAsCData - output user data in CDATA sections
*	  @param: DTD - if specified, then set as XML's DTD
*     @topic: 2
*/
dhtmlXTreeObject.prototype.setSerializationLevel=function(userData,fullXML,escapeEntities,userDataAsCData,DTD){
	this._xuserData=convertStringToBoolean(userData);
	this._xfullXML=convertStringToBoolean(fullXML);
    this._dtd=DTD;
    this._xescapeEntities=convertStringToBoolean(escapeEntities);
    if (convertStringToBoolean(userDataAsCData)){
        this._apreUC="<![CDATA[";
        this._apstUC="]]>";
    }
    else{
    }

    for (var i=0; i< this._serEnts.length; i++)
        this._serEnts[i][2]=new RegExp(this._serEnts[i][0],"g");
}

/**
*     @desc: get xml representation (as string) of tree
*     @type: public
*     @edition: Professional
*     @topic: 2
*/
dhtmlXTreeObject.prototype.serializeTree=function(){
    if (this.stopEdit) this.stopEdit();
    this._apreUC=this._apreUC||"";
    this._apstUC=this._apstUC||"";
	var out='<?xml version="1.0"?>';
    if (this._dtd)
        out+="<!DOCTYPE tree SYSTEM \""+this._dtd+"\">";
    out+='<tree id="'+this.rootId+'">';

		if ((this._xuserData)&&(this._idpull[this.rootId]._userdatalist))
		{
		var names=this._idpull[this.rootId]._userdatalist.split(",");
		for  (var i=0; i<names.length; i++)
			out+="<userdata name=\""+names[i]+"\">"+this._apreUC+this._idpull[this.rootId].userData["t_"+names[i]]+this._apstUC+"</userdata>";
		}


		for (var i=0; i<this.htmlNode.childsCount; i++)
		out+=this._serializeItem(this.htmlNode.childNodes[i]);
		
	out+="</tree>";
	return out;
};
/**  
*     @desc: return xml description of tree item
*     @type: private
*     @param: itemNode - tree item object
*     @edition: Professional
*     @topic: 2
*/
dhtmlXTreeObject.prototype._serializeItem=function(itemNode){


	if (itemNode.unParsed)
		if (document.all)
			return itemNode.unParsed.d.xml;
		else{
  var xmlSerializer = new XMLSerializer();
  return xmlSerializer.serializeToString(itemNode.unParsed.d);
		}

		
	var out="";
	if (this._selected.length)
		var lid=this._selected[0].id;
	else lid="\"";


    var text=itemNode.span.innerHTML;

    if (this._xescapeEntities)
        for (var i=0; i<this._serEnts.length; i++)
            text=text.replace(this._serEnts[i][2],this._serEnts[i][1]);

	if (!this._xfullXML)
		out='<item id="'+itemNode.id+'" '+(this._getOpenState(itemNode)==1?' open="1" ':'')+(lid==itemNode.id?' select="1"':'')+' text="'+text+'"'+( ((this.XMLsource)&&(itemNode.XMLload==0))?" child=\"1\" ":"")+'>';
	else
		out='<item id="'+itemNode.id+'" '+(this._getOpenState(itemNode)==1?' open="1" ':'')+(lid==itemNode.id?' select="1"':'')+' text="'+text+'" im0="'+itemNode.images[0]+'" im1="'+itemNode.images[1]+'" im2="'+itemNode.images[2]+'" '+(itemNode.acolor?('aCol="'+itemNode.acolor+'" '):'')+(itemNode.scolor?('sCol="'+itemNode.scolor+'" '):'')+(itemNode.checkstate==1?'checked="1" ':(itemNode.checkstate==2?'checked="-1"':''))+(itemNode.closeable?'closeable="1" ':'')+( ((this.XMLsource)&&(itemNode.XMLload==0))?" child=\"1\" ":"")+'>';

	if ((this._xuserData)&&(itemNode._userdatalist))
		{
		var names=itemNode._userdatalist.split(",");
		for  (var i=0; i<names.length; i++)
			out+="<userdata name=\""+names[i]+"\">"+this._apreUC+itemNode.userData["t_"+names[i]]+this._apstUC+"</userdata>";
		}

		for (var i=0; i<itemNode.childsCount; i++)
			out+=this._serializeItem(itemNode.childNodes[i]);
			


	out+="</item>";
	return out;
}
/**  
*     @desc: save selected item to cookie
*     @type: public
*     @param: name - optional, cookie name
*     @param: cookie_param - additional parametrs added to cookie
*     @edition: Professional
*     @topic: 2
*/
dhtmlXTreeObject.prototype.saveSelectedItem=function(name,cookie_param){
	name=name||"";
	this.setCookie("treeStateSelected"+name,this.getSelectedItemId(),cookie_param);
}
/**     @desc: restore selected item from cookie
*     @type: public
*     @param: name - optional, cookie name
*     @edition: Professional
*     @topic: 2
*/
dhtmlXTreeObject.prototype.restoreSelectedItem=function(name){
	name=name||"";
	var z=this.getCookie("treeStateSelected"+name);
	this.selectItem(z,false);
}


/**   @desc: enable/disable autosaving selected node in cookie
*     @type: public
*     @param: mode - true/false
*     @edition: Professional
*     @topic: 2
*/	
dhtmlXTreeObject.prototype.enableAutoSavingSelected=function(mode,cookieName){
 this.assMode=convertStringToBoolean(mode);
 if ((this.assMode)&&(!this.oldOnSelect)){
		 this.oldOnSelect=this.onRowSelect;
		 this.onRowSelect=function(e,htmlObject,mode){
 			if (!htmlObject) htmlObject=this;
			htmlObject.parentObject.treeNod.oldOnSelect(e,htmlObject,mode);
			if (htmlObject.parentObject.treeNod.assMode)
				htmlObject.parentObject.treeNod.saveSelectedItem(htmlObject.parentObject.treeNod.assCookieName);
		}
 }

 this.assCookieName=cookieName;
}


/**   @desc: save tree to cookie
*     @type: public
*     @param: name - optional, cookie name
*     @param: cookie_param - additional parametrs added to cookie
*     @edition: Professional
*     @topic: 2
*/
dhtmlXTreeObject.prototype.saveState=function(name,cookie_param){
	var z=this._escape(this.serializeTree());
	var kusok = 4000;
	if (z.length>kusok)
	{
		if(navigator.appName.indexOf("Microsoft")!=-1)
			return false;//IE max cookie length is ~4100
	this.setCookie("treeStatex"+name,Math.ceil(z.length/kusok));
		for (var i=0; i<Math.ceil(z.length/kusok); i++)
		{
			this.setCookie("treeStatex"+name+"x"+i,z.substr(i*kusok,kusok),cookie_param);
		}
	}
	else
		this.setCookie("treeStatex"+name,z,cookie_param);
	var z=this.getCookie("treeStatex"+name);
    if (!z) {
		this.setCookie("treeStatex"+name,"",cookie_param);
		return false;
	}
    return true;
}
/**   @desc: load tree from cookie
*     @type: public
*     @param: name - optional,cookie name
*     @edition: Professional
*     @topic: 2
*/
dhtmlXTreeObject.prototype.loadState=function(name){
	var z=this.getCookie("treeStatex"+name);
//    alert("treeStatex"+name);
    if (!z) return false;

	if (z.length)
	{
		if (z.toString().length<4)
		{

			var z2="";
			for (var i=0; i<z; i++){
				z2+=this.getCookie("treeStatex"+name+"x"+i);
                }
			z=z2;
		}
		this.loadXMLString((this.utfesc=="utf8")?decodeURI(z):unescape(z));
	}

    return true;
}
/**   @desc: save cookie
*     @type: private
*     @param: name - cookie name
*     @param: value - cookie value
*     @param: cookie_param - additional parametrs added to cookie
*     @edition: Professional
*     @topic: 0
*/

dhtmlXTreeObject.prototype.setCookie=function(name,value,cookie_param) {
	var str = name + "=" + value +  (cookie_param?("; "+cookie_param):"");
  /*  ((expires) ? "; expires=" + expires.toGMTString() : "") +
    ((path) ? "; path=" + path : "; path=/") +
    ((domain) ? "; domain=" + domain : "") +
    ((secure) ? "; secure" : "");*/
	document.cookie = str;
}

/**   @desc: get cookie
*     @type: private
*     @param: name - cookie name
*     @edition: Professional
*     @topic: 0
*/	
dhtmlXTreeObject.prototype.getCookie=function(name) {
	var search = name + "=";
	if (document.cookie.length > 0) {
		var offset = document.cookie.indexOf(search);
		if (offset != -1) {
			offset += search.length;
			var end = document.cookie.indexOf(";", offset);
			if (end == -1)
				end = document.cookie.length;
			return document.cookie.substring(offset, end);
						}		}
};



/**   @desc: save open nodes to cookie
*     @type: public
*     @edition: Professional
*     @param: name - optional,cookie name
*     @param: cookie_param - additional parametrs added to cookie
*     @topic: 2
*/
dhtmlXTreeObject.prototype.saveOpenStates=function(name,cookie_param){
    var z=[];
    for (var i=0; i<this.htmlNode.childsCount; i++)
    	z=z.concat(this._collectOpenStates(this.htmlNode.childNodes[i]));
    z=z.join(this.dlmtr);

	this.setCookie("treeOpenStatex"+name,z,cookie_param);
};

/**   @desc: restore open nodes from cookie
*     @type: public
*     @edition: Professional
*     @param: name - optional,cookie name
*     @topic: 2
*/
dhtmlXTreeObject.prototype.loadOpenStates=function(name){
	for (var i=0; i<this.htmlNode.childsCount; i++)
    	this._xcloseAll(this.htmlNode.childNodes[i]);

 this.allTree.childNodes[0].border = "1";
 this.allTree.childNodes[0].border = "0";

	var z=getCookie("treeOpenStatex"+name);
	if (z) {
		var arr=z.split(this.dlmtr);
		for (var i=0; i<arr.length; i++)
			{
            var zNode=this._globalIdStorageFind(arr[i]);
            if (zNode){
                if  ((this.XMLsource)&&(!zNode.XMLload)&&(zNode.id!=this.rootId)){
                     this._delayedLoad(zNode,"loadOpenStates('"+name+"')");
                     return;
                    }
                else
           			this.openItem(arr[i]);
                }
			}
		}
	this.callEvent("onAllOpenDynamic",[]);
};

dhtmlXTreeObject.prototype._delayedLoad=function(node,name){
    this.afterLoadMethod=name;
	this.onLoadReserve = this.onXLE; //save loading end handler
	this.onXLE=this._delayedLoadStep2; //set on XML data loading end handler
	this._loadDynXML(node.id);
}
dhtmlXTreeObject.prototype._delayedLoadStep2=function(tree){
	tree.onXLE=tree.onLoadReserve; //save loading end handler
//    if (tree.onXLE) tree.onXLE(tree);
    window.setTimeout( function() { dhtmlx.temp = tree; eval("dhtmlx.temp."+tree.afterLoadMethod);  } ,100);
	if (tree.onXLE) tree.onXLE(tree);
	tree.callEvent("onXLE",[tree]);

}

/**   @desc: build list of opened nodes
*     @type: private
*     @edition: Professional
*     @param: node - start tree item
*     @param: list - start list value
*     @topic: 2
*/
dhtmlXTreeObject.prototype._collectOpenStates=function(node){
	var list=[];
	if (this._getOpenState(node)==1)
    {
    list.push(node.id);
	for (var i=0; i<node.childsCount; i++)
		list=list.concat(this._collectOpenStates(node.childNodes[i]));
    }
	return list;
};

/**   @desc: save cookie
*     @type: private
*     @edition: Professional
*     @param: name - cookie name
*     @param: value - cookie value
*     @topic: 0
*/
function setCookie(name,value) {
	document.cookie = name+'='+value;
}

/**   @desc: get cookie
*     @type: private
*     @edition: Professional
*     @param: name - cookie name
*     @topic: 0
*/
function getCookie(name) {
	var search = name + "=";
	if (document.cookie.length > 0) {
		var offset = document.cookie.indexOf(search);
		if (offset != -1) {
			offset += search.length;
			var end = document.cookie.indexOf(";", offset);
			if (end == -1)
				end = document.cookie.length;
			return (document.cookie.substring(offset, end));
						}		}
};

/**
*     @desc: expand target node and all child nodes (same as openAllItems, but works in dynamic trees)
*     @type: public
*     @edition: Professional
*     @param: itemId - node id, optional
*     @topic: 4
*/
	dhtmlXTreeObject.prototype.openAllItemsDynamic = function(itemId)
	{
        this.ClosedElem=new Array();
        this.G_node=null;
		var itemNode = this._globalIdStorageFind(itemId||this.rootId); //get node object by id of tree sart node
		if (itemNode.id != this.rootId &&this.getOpenState(itemNode.id) != 0) this.openItem(itemId);
		this._openAllNodeChilds(itemNode, 0); //open closed nodes that have data, or find nodes that have no data yet


		if(this.ClosedElem.length>0){
			this.onLoadReserve = this.onXLE; //save loading end handler
			this.onXLE=this._loadAndOpen; //set on XML data loading end handler
			this._loadAndOpen(this); //if there are not loaded items -> run load&open routine
		}
	};

	dhtmlXTreeObject.prototype._openAllNodeChilds = function(itemNode)
	{
			//for dynamic loading
    	if ((itemNode.XMLload==0)||(itemNode.unParsed))  this.ClosedElem.push(itemNode);  //if not loaded put in array
		for (var i=0; i<itemNode.childsCount; i++) //for all childnodes
		{
			//no dynamic loading
			if(this._getOpenState(itemNode.childNodes[i])<0) this._HideShow(itemNode.childNodes[i],2); //if closed -> open
			if(itemNode.childNodes[i].childsCount>0) this._openAllNodeChilds(itemNode.childNodes[i]); //if has childs -> run same routine for that node

			//for dynamic loading
			if ((itemNode.childNodes[i].XMLload==0)||(itemNode.childNodes[i].unParsed)) this.ClosedElem.push(itemNode.childNodes[i]); //if not loaded put in array
		}
	}

	dhtmlXTreeObject.prototype._loadAndOpen = function(that)
	{
		if(that.G_node) //if there was loaded one node
		{
			that._openItem(that.G_node); //open it
			that._openAllNodeChilds(that.G_node); //run open/find closed nodes for childs of this node
			that.G_node = null; //erase "just loaded node" pointer
		}

		if(that.ClosedElem.length>0) that.G_node = that.ClosedElem.shift(); //get not loaded node if any left in array

		if(that.G_node)
            if (that.G_node.unParsed)
                that.reParse(that.G_node);
            else
                window.setTimeout( function(){  that._loadDynXML(that.G_node.id); },100);
        else
			{
            that.onXLE = that.onLoadReserve; //restore loading end handler if finished opening
            if (that.onXLE) that.onXLE(that);
			that.callEvent("onAllOpenDynamic",[that]);
			}
	}


/**
*     @desc: expand list of nodes in dynamic tree (wait of loading of node before expanding next)
*     @type: public
*     @edition: Professional
*     @param: list - list of nodes which will be expanded
*     @param: flag - true/false - select last node in the list
*     @topic: 4
*/
    dhtmlXTreeObject.prototype.openItemsDynamic=function(list,flag){
    	if (this.onXLE==this._stepOpen) return;
        this._opnItmsDnmcFlg=convertStringToBoolean(flag);
        this.onLoadReserve = this.onXLE;
        this.onXLE=this._stepOpen;
        this.ClosedElem=list.split(",").reverse();
        this._stepOpen(this);
        }

	dhtmlXTreeObject.prototype._stepOpen=function(that){
		if(!that.ClosedElem.length){
			that.onXLE = that.onLoadReserve;
			if (that._opnItmsDnmcFlg)
				that.selectItem(that.G_node,true);
			if ((that.onXLE)&&(arguments[1]))
				that.onXLE.apply(that,arguments);
			that.callEvent("onOpenDynamicEnd",[]);
			return;
		}
		that.G_node=that.ClosedElem.pop();
		that.skipLock = true;
		var temp=that._globalIdStorageFind(that.G_node);

		if(temp){
			if (temp.XMLload===0)
				that.openItem(that.G_node);
			else{
				that.openItem(that.G_node);
				that._stepOpen(that);
			}
		}
		that.skipLock = false;
	}

//(c)dhtmlx ltd. www.dhtmlx.com


//v.3.6 build 131108

/*
Copyright DHTMLX LTD. http://www.dhtmlx.com
To use this component please contact sales@dhtmlx.com to obtain license
*/
/**
*   @desc: switch current row state (collapse/expand) tree grid row
*   @param: obj - row object
*   @type: private
*/
dhtmlXGridObject.prototype._updateTGRState=function(z){ 
	if (!z.update || z.id==0) return;
	if (this.rowsAr[z.id].imgTag)
	this.rowsAr[z.id].imgTag.src=this.imgURL+z.state+".gif";
	z.update=false;
}


dhtmlXGridObject.prototype.doExpand=function(obj){  
	this.editStop();
    var row = obj.parentNode.parentNode.parentNode;
	var r=this._h2.get[row.idd];
	if (!this.callEvent("onOpen",[row.idd,(r.state=="plus"?-1:1)])) return;
    if(r.state=="plus")
      this.expandKids(row)
    else
   	  if((r.state=="minus")&&(!r._closeable))
          this.collapseKids(row)
}


function dhtmlxHierarchy(){
		
		var z={id:0, childs:[], level:-1, parent:null, index:0, state:dhtmlXGridObject._emptyLineImg};
		this.order=[z];
		this.get={"0":z};

		this.swap=function(a,b){
			var p=a.parent;
			var z=a.index;
			p.childs[z]=b;
			p.childs[b.index]=a;
			a.index=b.index; b.index=z;
		}
		this.forEachChildF=function(id,funct,that,funct2){
			var z=this.get[id];
			for (var i=0; i<z.childs.length; i++){
				if (!funct.apply((that||this),[z.childs[i]])) continue;
				if (z.childs[i].childs.length) this.forEachChildF(z.childs[i].id,funct,that,funct2);
				if (funct2) funct2.call((that||this),z.childs[i]);
			}
		}
		this.forEachChild=function(id,funct,that){
				var z=this.get[id];
				for (var i=0; i<z.childs.length; i++){
					funct.apply((that||this),[z.childs[i]]);
					if (z.childs[i].childs.length) this.forEachChild(z.childs[i].id,funct,that);
				}
		}
		this.change=function(id,name,val){
			var z=this.get[id];
			if (z[name]==val) return;
				z[name]=val;
				z.update=true;
		}
		this.add=function(id,parentId){ 
			return this.addAfter(id,parentId);
		}
		this.addAfter=function(id,parentId,afterId,fix){  
			var z=this.get[parentId||0];
			if (afterId)
				var ind=this.get[afterId].index+(fix?0:1);
			else var ind=z.childs.length;
			
			var x={id:id, childs:[], level:z.level+1, parent:z, index:ind, state:dhtmlXGridObject._emptyLineImg}
			if (z.state==dhtmlXGridObject._emptyLineImg)  this.change(parentId,"state",(parentId==0?"minus":"plus"));
			
			if (afterId){
				for (var i=ind; i<z.childs.length; i++) z.childs[i].index++;
				z.childs=z.childs.slice(0,ind).concat([x]).concat(z.childs.slice(ind,z.childs.length));
			}else
				z.childs.push(x);
			this.get[id]=x;
			return x;
		}
		this.addBefore=function(id,parentId,beforeId){
			return this.addAfter(id,parentId,beforeId,true)
		}		
		this.remove=function(id){  
			var z=this.get[id||0];
			for (var i=0; i<z.childs.length; i++)
				this.deleteAll(z.childs[i].id)
			z.childs=[];	
			z.parent.childs=z.parent.childs.slice(0,z.index).concat(z.parent.childs.slice(z.index+1));				
			for (var i=z.index; i<z.parent.childs.length; i++)
				z.parent.childs[i].index--;
			delete this.get[id];
		}
		this.deleteAll=function(id){
			var z=this.get[id||0];
			for (var i=0; i<z.childs.length; i++)
				this.deleteAll(z.childs[i].id)
				
			z.childs=[];				
			delete this.get[id];
		}		
		
		return this;
	}

dhtmlXGridObject.prototype._getOpenLenght=function(id,start){
	
	var z=this._h2.get[id].childs;
	start+=z.length;
	for (var i=0; i<z.length; i++)
		if (z[i].childs.length && z[i].state=='minus')
			start+=this._getOpenLenght(z[i].id,0);
	return start;
}
/**
*   @desc: close row of treegrid (removes kids from dom)
*   @param: curRow - row to process kids of
*   @type: private
*/
dhtmlXGridObject.prototype.collapseKids=function(curRow){ 
	var r=this._h2.get[curRow.idd];
    if (r.state!="minus") return;
    if (!this.callEvent("onOpenStart",[curRow.idd,1])) return;

    var start = curRow.rowIndex;
    //why Safari doesn't support standards?
    if (start<0) start=this.rowsCol._dhx_find(curRow)+1;

   	this._h2.change(r.id,"state","plus");
   	this._updateTGRState(r);

    if (this._srnd || this.pagingOn){
    	this._h2_to_buff();
    	this._renderSort();
    } else {
    var len=this._getOpenLenght(this.rowsCol[start-1].idd,0);
    for (var i=0; i<len; i++)
    	this.rowsCol[start+i].parentNode.removeChild(this.rowsCol[start+i]);
    this.rowsCol.splice(start,len);
	}

    //if (this._cssEven && !this._cssSP)
    this.callEvent("onGridReconstructed",[]);

    this.setSizes();
    this._h2_to_buff();
    this.callEvent("onOpenEnd",[curRow.idd,-1]);
}



dhtmlXGridObject.prototype._massInsert=function(r,start,ind,skip){  
	var anew=[];
	var par=(_isKHTML?this.obj:this.obj.rows[0].parentNode)
	this._h2_to_buff();
	if (this._srnd || this.pagingOn) return this._renderSort();
	var len=this._getOpenLenght(r.id,0);
	for(var i=0;i<len;i++){
		var ra=this.render_row(ind+i);
		if (start)
			start.parentNode.insertBefore(ra,start);
		else
			par.appendChild(ra);
		anew.push(ra)
		}
	this.rowsCol=dhtmlxArray(this.rowsCol.slice(0,ind).concat(anew).concat(this.rowsCol.slice(ind)));
	
	return r.childs.length+anew.length;
}
/**
*   @desc: change parent of row, correct kids collections
*   @param: curRow - row to process
*   @type: private
*/
dhtmlXGridObject.prototype.expandKids=function(curRow,sEv){

	var r=this._h2.get[curRow.idd];
	if ((!r.childs.length)&&(!r._xml_await)) return;
	if (r.state!="plus") return;
    
    
    if (!r._loading && !sEv)
    	if (!this.callEvent("onOpenStart",[r.id,-1])) return;
        


   var start = this.getRowIndex(r.id)+1;
   if(r.childs.length){
        r._loading=false;
        this._h2.change(r.id,"state","minus")
        this._updateTGRState(r);
		var len=this._massInsert(r,this.rowsCol[start],start);
		
		//if (this._cssEven && !this._cssSP)
		this.callEvent("onGridReconstructed",[]);
			

   }else{	
        if (r._xml_await){
			r._loading=true;
			if (this.callEvent("onDynXLS",[r.id]))
				this.load(this.kidsXmlFile+""+(this.kidsXmlFile.indexOf("?")!=-1?"&":"?")+"id="+r.id, this._data_type);
        }
   }
    this.setSizes();
    if (!r._loading)
    this.callEvent("onOpenEnd",[r.id,1]);
    this._fixAlterCss();
}

dhtmlXGridObject.prototype.kidsXmlFile = "";



/**
*   @desc: sorts treegrid by specified column
*   @param: col - column index
*   @param:   type - str.int.date
*   @param: order - asc.desc
*   @type: public
*   @edition: Professional
*   @topic: 2,3,5,9
*/
dhtmlXGridObject.prototype.sortTreeRows = function(col,type,order){
				var amet="getValue";
				if (this.cells5({parentNode:{grid:this}},this.getColType(col)).getDate){ //FIXME! move inside cells5 in 2.2
					amet="getDate";
					type="str";
				}		
					

	            this.forEachRow(function(id){
                	var z=this._h2.get[id];
                	if (!z) return;
                	
                	var label=this._get_cell_value(z.buff,col,amet);
                	if(type=='int'){
						   z._sort=parseFloat(label);
						   z._sort=isNaN(z._sort)?-99999999999999:z._sort;
                     }else
                        z._sort=label;
                	});
                	
				var self=this;
				var pos=1; var neg=-1;
				if (order=="des") { pos=-1; neg=1; }
					
				var funct=null;
	                if(type=='cus')
    	                 funct=function(a,b){
                            return self._customSorts[col](a._sort,b._sort,order,a.id,b.id);
                                    };
     	
                   if(type=='str')
                     funct=function(a,b){return (a._sort<b._sort?neg:(a._sort==b._sort?0:pos))}

                  if(type=='int')
                     funct=function(a,b){return (a._sort<b._sort?neg:(a._sort==b._sort?0:pos))}

                  if(type=='date')
                     funct=function(a,b){return (Date.parse(new Date(a._sort||"01/01/1900"))-Date.parse(new Date(b._sort||"01/01/1900")))*pos}
                  
                  this._sortTreeRows(funct,0);
                  this._renderSort(0,true);

            this.callEvent("onGridReconstructed",[]);
               
}

dhtmlXGridObject.prototype._sortTreeRows = function(funct,id){
				var ar=this._h2.get[id].childs;
				if (this.rowsCol.stablesort)
					this.rowsCol.stablesort.call(ar,funct);
				else
					ar.sort(funct);
					
				for (var i=0; i<ar.length; i++){
					if (ar[i].childs.length) 
						this._sortTreeRows(funct,ar[i].id);
					ar[i].index=i;
				}
};
dhtmlXGridObject.prototype._renderSort = function(id,mode){ 
	this._h2_to_buff();
	var top=this.objBox.scrollTop;
	this._reset_view();
	this.objBox.scrollTop=top;
};

dhtmlXGridObject.prototype._fixAlterCssTGR = function(){ 
if (!this._realfake)	
	this._h2.forEachChild(0,function(x){
		if (x.buff.tagName=="TR"){
			var cs=(this._cssSP?(x.level%2):(x.index%2))?this._cssUnEven:this._cssEven;
			this.rowsAr[x.id].className=(cs + (this._cssSU?(" "+cs+"_"+x.level):""))+" "+(this.rowsAr[x.id]._css||"")+((this.rowsAr[x.id].className.indexOf("rowselected") != -1)?" rowselected":"");
		}
	},this);
}
dhtmlXGridObject.prototype.moveRowUDTG = function(id,dir){ 
	var x=this._h2.get[id];
	var p=x.parent.childs[x.index+dir]
	if ((!p) || (p.parent!=x.parent)) return;
	var state=[x.state,p.state];
	this.collapseKids(this.rowsAr[x.id]);
	this.collapseKids(this.rowsAr[p.id]);	
	var ind = this.rowsCol._dhx_find(this.rowsAr[id]);
	var bInd = this.rowsBuffer._dhx_find(this.rowsAr[id]);
	
	var nod=this.obj.rows[0].parentNode.removeChild(this.rowsCol[ind]);	
	var tar=this.rowsCol[ind+((dir==1)?2:dir)];
	if (tar)
		tar.parentNode.insertBefore(nod,tar);
	else
		this.obj.rows[0].parentNode.appendChild(nod);
	this.rowsCol._dhx_swapItems(ind,ind+dir)
	this.rowsBuffer._dhx_swapItems(bInd,bInd+dir);
	this._h2.swap(p,x);
	
	
	if (state[0]=="minus") this.expandKids(this.rowsAr[x.id]);
	if (state[1]=="minus") this.expandKids(this.rowsAr[p.id]);	
	
	this._fixAlterCss(Math.min(ind,ind+dir));
}

/**
*   @desc: TreeGrid cell constructor (only for TreeGrid package)
*   @param: cell - cell object
*   @type: public
*/
function eXcell_tree(cell){
   if (cell){
      this.cell = cell;
      this.grid = this.cell.parentNode.grid;
   }
   this.isDisabled = function(){ return this.cell._disabled||this.grid._edtc; }
   this.edit = function(){
        if ((this.er)||(this.grid._edtc)) return;
        this.er=this.cell.parentNode.valTag;
        this.val=this.getLabel();
        this.cell.atag=((!this.grid.multiLine)&&(_isKHTML||_isMacOS||_isFF)) ? "INPUT" : "TEXTAREA";
        this.er.innerHTML="<"+this.cell.atag+" class='dhx_combo_edit' type='text' style='height:"+(this.cell.offsetHeight-6)+"px; width:100%; border:0px; margin:0px; padding:0px; padding-top:"+(_isFF?1:2)+"px; overflow:hidden;'></"+this.cell.atag+">";
        this.er.childNodes[0].onmousedown = function(e){(e||event).cancelBubble = true}
        this.er.childNodes[0].onselectstart=function(e){  if (!e) e=event; e.cancelBubble=true; return true;  };
        if (_isFF)         this.er.style.top="1px";
        this.er.className+=" editable";
        this.er.firstChild.onclick = function(e){(e||event).cancelBubble = true};
        this.er.firstChild.value=this.val;
        this.obj=this.er.firstChild;
		this.er.firstChild.style.width=Math.max(0,this.cell.offsetWidth-this.er.offsetLeft)+"px";        
        this.er.firstChild.focus();
        if (_isIE)
			this.er.firstChild.focus();
    }
   this.detach = function(){
        if (!this.er) return;
            this.setLabel(this.er.firstChild.value);
            this.er.className=this.er.className.replace("editable","");
            var z=(this.val!=this.er.innerHTML);
            if (_isFF) this.er.style.top="2px";
			this.obj=this.er=null;
        return (z);
    }
   this.getValue = function(){
   		return this.getLabel();
   }

    
    /**
    *   @desc: get image of treegrid item
    *   @param: content - new text of label
    *   @type: private
    */
   this.setImage = function(url){
        this.cell.parentNode.imgTag.nextSibling.src=this.grid.iconURL+url;
        this.grid._h2.get[this.cell.parentNode.idd].image=url;
   }
    /**
    *   @desc: set image of treegrid item
    *   @param: content - new text of label
    *   @type: private
    */
   this.getImage = function(){
   		return this.grid._h2.get[this.cell.parentNode.idd].image;
   }

   /**
   *   @desc: sets text representation of cell ( setLabel doesn't triger math calculations as setValue do)
   *   @param: val - new value
   *   @type: public
   */
   this.setLabel = function(val){
                  this.setValueA(val);
            }

   /**
   *   @desc: sets text representation of cell ( setLabel doesn't triger math calculations as setValue do)
   *   @param: val - new value
   *   @type: public
   */
   this.getLabel = function(val){
     return this.cell.parentNode.valTag.innerHTML;
    }
}
    /**
    *   @desc: set value of grid item
    *   @param: val  - new value (for treegrid this method only used while adding new rows)
    *   @type: private
    */
	
eXcell_tree.prototype = new eXcell;
    /**
    *   @desc: set label of treegrid item
    *   @param: content - new text of label
    *   @type: private
    */
   eXcell_tree.prototype.setValueA = function(content){
 		this.cell.parentNode.valTag.innerHTML=content;
		this.grid.callEvent("onCellChanged",[this.cell.parentNode.idd,this.cell._cellIndex,content])
    }
	eXcell_tree.prototype.setValue = function(valAr){
		if (this.cell.parentNode.imgTag)
			return this.setLabel(valAr);
			
			
		if ((this.grid._tgc.imgURL==null)||(this.grid._tgc.imgURL!=this.grid.imgURL)){
			var _tgc={};
			_tgc.spacer="<img src='"+this.grid.imgURL+"blank.gif'  align='absmiddle' class='space'>";
			_tgc.imst="<img src='"+this.grid.imgURL;
			_tgc.imsti="<img src='"+(this.grid.iconURL||this.grid.imgURL);
			_tgc.imact="' align='absmiddle'  onclick='this."+(_isKHTML?"":"parentNode.")+"parentNode.parentNode.parentNode.parentNode.grid.doExpand(this);event.cancelBubble=true;'>"
			_tgc.plus=_tgc.imst+"plus.gif"+_tgc.imact;
			_tgc.minus=_tgc.imst+"minus.gif"+_tgc.imact;
			_tgc.blank=_tgc.imst+"blank.gif"+_tgc.imact;
			_tgc.start="<div class='treegrid_cell' style='overflow:hidden; white-space : nowrap; height:"+(_isIE?20:18)+"px;'>";
			
			_tgc.itemim="' align='absmiddle' "+(this.grid._img_height?(" height=\""+this.grid._img_height+"\""):"")+(this.grid._img_width?(" width=\""+this.grid._img_width+"\""):"")+" ><span "+((_isFF||_isOpera)?"style='position:relative; top:2px;'":"")+"id='nodeval'>";
			_tgc.close="</span></div>";
			this.grid._tgc=_tgc;
		}
		var _h2=this.grid._h2;
		var _tgc=this.grid._tgc;
				
		var rid=this.cell.parentNode.idd;
		var row=this.grid._h2.get[rid];
		
		if (this.grid.kidsXmlFile || this.grid._slowParse) { 
			row.has_kids=(row.has_kids||(this.cell.parentNode._attrs["xmlkids"]&&(row.state!="minus")));
			row._xml_await=!!row.has_kids;
		}
		
		
		row.image=row.image||(this.cell._attrs["image"]||"leaf.gif");
		row.label=valAr;
               
        var html=[_tgc.start];
		
        for(var i=0;i<row.level;i++)
        	html.push(_tgc.spacer);
        
       //if has children
        if(row.has_kids){
        	html.push(_tgc.plus);
        	row.state="plus"
        	}
        else
        	html.push(_tgc.imst+row.state+".gif"+_tgc.imact);
                        
		html.push(_tgc.imsti);
		html.push(row.image);
		html.push(_tgc.itemim);
		html.push(row.label);
		html.push(_tgc.close);
		
                    

		this.cell.innerHTML=html.join("");
		this.cell._treeCell=true;
		this.cell.parentNode.imgTag=this.cell.childNodes[0].childNodes[row.level];
		this.cell.parentNode.valTag=this.cell.childNodes[0].childNodes[row.level+2];
		if (_isKHTML) this.cell.vAlign="top";
		if (row.parent.id!=0 && row.parent.state=="plus") {
				this.grid._updateTGRState(row.parent,false);
				this.cell.parentNode._skipInsert=true;		
			}

		this.grid.callEvent("onCellChanged",[rid,this.cell._cellIndex,valAr]);
	}
    
dhtmlXGridObject.prototype._process_tree_xml=function(xml,top,pid){
	this._parsing=true;
	var main=false;
	if (!top){
		this.render_row=this.render_row_tree;
		main=true;
		top=xml.getXMLTopNode(this.xml.top)	
		pid=top.getAttribute("parent")||0;
		if (pid=="0") pid=0;
		if (!this._h2)	 this._h2=new dhtmlxHierarchy();
		if (this._fake) this._fake._h2=this._h2;
	} 
	//var cr=parseInt(xml.doXPath("//"+this.xml.top)[0].getAttribute("pos")||0);
	//var total=parseInt(xml.doXPath("//"+this.xml.top)[0].getAttribute("total_count")||0);
	var rows=xml.doXPath(this.xml.row,top)
	this._open=this._open||[];
	for (var i=0; i < rows.length; i++) {
		var id=rows[i].getAttribute("id");
		if (!id) {
			id=this.uid();
			rows[i].setAttribute("id",id);
		}
		var row=this._h2.add(id,pid);
		row.buff={ idd:id, data:rows[i], _parser: this._process_xml_row, _locator:this._get_xml_data };
		if (rows[i].getAttribute("open")){
			row.state="minus";
			this._open.push(id);
		}
		
		this.rowsAr[id]=row.buff;
		this._process_tree_xml(xml,rows[i],id);
	}
	if (main){ 
		if (!rows.length) this._h2.change(pid,"state",dhtmlXGridObject._emptyLineImg);
		else if (pid!=0 && !this._srnd) {
			this._h2.change(pid,"state","minus");
		}
		for (var i=0; i < this._open.length; i++) {
			var r=this._h2.get[this._open[i]];
			if (!r.childs.length)
					r.state=dhtmlXGridObject._emptyLineImg;
		};
		
		this._updateTGRState(this._h2.get[pid]);
		this._h2_to_buff();
		if (pid!=0 && this._srnd) this.openItem(pid);
		else {
			if (this.pagingOn)
				this._renderSort();
			else
				this.render_dataset();
		}

		if (this.kidsXmlFile){
			for (var i=0; i < this._open.length; i++) {
				var r=this._h2.get[this._open[i]];
				if (r._xml_await) 
					this.expandKids({idd:r.id});
			}
		}
		this._open=[];

		if (this._slowParse===false){
			this.forEachRow(function(id){
				this.render_row_tree(0,id)
			})
		}
		this._parsing=false;
		if (pid!=0 && !this._srnd) {
		    this.callEvent("onOpenEnd",[pid,1]);
		}
	}
	return xml.xmlDoc.responseXML?xml.xmlDoc.responseXML:xml.xmlDoc;
}	
dhtmlXGridObject.prototype._h2_to_buff=function(top){
	if (!top){
		top=this._h2.get[0];
		this.rowsBuffer = new dhtmlxArray();
		if (this._fake && !this._realfake) this._fake.rowsBuffer = this.rowsBuffer;
	}
	for (var i=0; i < top.childs.length; i++) {
		this.rowsBuffer.push(top.childs[i].buff);
		if (top.childs[i].state == "minus")
			this._h2_to_buff(top.childs[i]);
	}
};
dhtmlXGridObject.prototype.render_row_tree=function(ind,id){ 
	if (id){
		var r=this._h2.get[id];
		r=r?r.buff:r;
	} else
	var r=this.rowsBuffer[ind];
	if (!r) 
		return -1;
	
	if (r._parser){
		if (this.rowsAr[r.idd] && this.rowsAr[r.idd].tagName=="TR")
			return this._h2.get[r.idd].buff=this.rowsBuffer[ind]=this.rowsAr[r.idd];
		var row=this._prepareRow(r.idd);
		this.rowsAr[r.idd]=row;

		if (!id)
			this.rowsBuffer[ind]=row;
		this._h2.get[r.idd].buff=row;	//treegrid specific
		
		r._parser.call(this,row,r.data);
		this._postRowProcessing(row);		
		
		return row;
		}
	return r;
}
    
    /**
    *   @desc: remove row from treegrid
    *   @param: node  - row object
    *   @type: private
    */
dhtmlXGridObject.prototype._removeTrGrRow=function(node,x){ 
		 if(x){
		     this._h2.forEachChild(x.id,function(x){
		     	this._removeTrGrRow(null,x);
	    		delete this.rowsAr[x.id];
    		},this);
    		return;
		 }
		 
		 var ind=this.getRowIndex(node.idd);
		 var x=this._h2.get[node.idd];
		 
		 
		 if (ind!=-1 && ind!==this.undefined){// in case of dnd we can receive delete command for some child item, which was not rendered yet
		 	var len=1;
		 	if (x && x.state=="minus") len+=this._getOpenLenght(x.id,0)
		 	for (var i=0; i<len; i++)
		 		if (this.rowsCol[i+ind])
            		this.rowsCol[i+ind].parentNode.removeChild(this.rowsCol[i+ind]);
            if (this._fake){
            	for (var i=0; i<len; i++)
            		if (this._fake.rowsCol[i+ind])
            			this._fake.rowsCol[i+ind].parentNode.removeChild(this._fake.rowsCol[i+ind]);
            	if (len>1)
            		this._fake.rowsCol.splice(ind+1,len-1);
        	}
            	
	         this.rowsCol.splice(ind,len);
	         this.rowsBuffer.splice(ind,len);
	         
	    }
	    
	    if (!x) return;
	    this._removeTrGrRow(null,x);
    		
    	delete this.rowsAr[x.id];
	
    	if (x.parent.childs.length==1){
    		this._h2.change(x.parent.id,"state",dhtmlXGridObject._emptyLineImg);
    		this._updateTGRState(x.parent);
    	}
    	this._h2.remove(x.id);
      }




/**
*   @desc: expand row
*   @param: rowId - id of row
*   @type:  public
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype.openItem=function(rowId){
		var y=this._h2.get[rowId||0];
        var x=this.getRowById(rowId||0);
		if (!x) return;
        if (y.parent && y.parent.id!=0)
        	this.openItem(y.parent.id);
        this.expandKids(x);
}

dhtmlXGridObject.prototype._addRowClassic=dhtmlXGridObject.prototype.addRow;

    /**
    *   @desc: add new row to treeGrid
    *   @param: new_id  - new row id
    *   @param: text  - array of row label
    *   @param: ind  - position of row (set to null, for using parentId)
    *   @param: parent_id  - id of parent row
    *   @param: img  - img url for new row
    *   @param: child - child flag [optional]
    *   @type: public
    *   @edition: Professional
    */
dhtmlXGridObject.prototype.addRow=function(new_id,text,ind,parent_id,img,child){ 
	if (!this._h2) return this._addRowClassic(new_id,text,ind);
	parent_id=parent_id||0;
	var trcol=this.cellType._dhx_find("tree");
    if (typeof(text)=="string") text=text.split(this.delim);
    var row=this._h2.get[new_id];
    if (!row){
	    if (parent_id==0) ind=this.rowsBuffer.length;
	    else{
	    	ind=this.getRowIndex(parent_id)+1;
			if (this._h2.get[parent_id].state=="minus") 
				ind+=this._getOpenLenght(parent_id,0);
            else
				this._skipInsert=true;
            }
}
	row=row||this._h2.add(new_id,parent_id);
	row.image=img;
	row.has_kids=child;
    return row.buff=this._addRowClassic(new_id,text,ind);
}
    /**
    *   @desc: add new row to treeGrid, before some other row
    *   @param: new_id  - new row id
    *   @param: text  - array of row label
    *   @param: sibl_id  - id of row, related to which new one will be added
    *   @param: img  - img url for new row
    *   @param: child - child flag [optional]
    *   @type: public
    *   @edition: Professional
    */
dhtmlXGridObject.prototype.addRowBefore=function(new_id,text,sibl_id,img,child){
	var sb=this.rowsAr[sibl_id];
	if (!sb) return;
	if (!this._h2) return this.addRow(new_id,text,this.getRowIndex(sibl_id));
	var pid=this._h2.get[sibl_id].parent.id;

	var ind=this.getRowIndex(sibl_id);
	if (ind==-1) this._skipInsert=true;
	this._h2.addBefore(new_id,pid,sibl_id);
	return this.addRow(new_id,text,ind,this._h2.get[sibl_id].parent.id,img,child);
}
    /**
    *   @desc: add new row to treeGrid, after some other row
    *   @param: new_id  - new row id
    *   @param: text  - array of row label
    *   @param: sibl_id  - id of row, related to which new one will be added
    *   @param: img  - img url for new row
    *   @param: child - child flag [optional]
    *   @type: public
    *   @edition: Professional
    */
dhtmlXGridObject.prototype.addRowAfter=function(new_id,text,sibl_id,img,child){
	var sb=this.rowsAr[sibl_id];
	if (!sb) return;
	if (!this._h2) return this.addRow(new_id,text,this.getRowIndex(sibl_id)+1);
	var pid=this._h2.get[sibl_id].parent.id;

	var ind=this.getRowIndex(sibl_id);
	if (ind==-1) this._skipInsert=true;
	if (this._h2.get[sibl_id].state=="minus") ind+=this._getOpenLenght(sibl_id,0)+1;	
	else	ind++;
	
	this._h2.addAfter(new_id,pid,sibl_id);
	return this.addRow(new_id,text,ind,pid,img,child);
}





dhtmlXGridObject.prototype.enableSmartXMLParsing=function(mode) {
	this._slowParse=convertStringToBoolean(mode);
};



    /**
    *   @desc: copy content between different rows
    *   @param: frRow  - source row object
    *   @param: from_row_id  - source row id
    *   @param: to_row_id  - target row id
    *   @type: private
    */
dhtmlXGridObject.prototype._copyTreeGridRowContent=function(frRow,from_row_id,to_row_id){
    var z=this.cellType._dhx_find("tree");
    for(i=0;i<frRow.cells.length;i++){
        if (i!=z)
           this.cells(to_row_id,i).setValue(this.cells(from_row_id,i).getValue())
        else
            this.cells(to_row_id,i).setValueA(this.cells(from_row_id,i).getValue())

    }
}

/**
*   @desc: collapse row
*   @param: rowId - id of row
*   @type:  public
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype.closeItem=function(rowId){
        var x=this.getRowById(rowId);
        if (!x) return;
        this.collapseKids(x);
}
/**
*   @desc: delete all childs of row in question
*   @param: rowId - id of row
*   @type:  public
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype.deleteChildItems=function(rowId){
        var z=this._h2.get[rowId];
        if (!z) return;
        while (z.childs.length)
            this.deleteRow(z.childs[0].id);
            
}
/**
*   @desc: get list of id of all nested rows
*   @param: rowId - id of row
*   @type:  public
*   @returns: list of id of all nested rows
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype.getAllSubItems=function(rowId){
        var str=[];
        var z=this._h2.get[rowId||0];
        if (z)
        for (var i=0; i<z.childs.length; i++){
            str.push(z.childs[i].id);
            if (z.childs[i].childs.length)
            str=str.concat(this.getAllSubItems(z.childs[i].id).split(this.delim));
            }

        return str.join(this.delim);
}

/**
*   @desc: get id of child item at specified position
*   @param: rowId - id of row
*   @param: ind - child node index
*   @type:  public
*   @returns: id of child item at specified position
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype.getChildItemIdByIndex=function(rowId,ind){
		var z=this._h2.get[rowId||0];
        if (!z) return null;
        return (z.childs[ind]?z.childs[ind].id:null);
}

/**
*   @desc: get real caption of tree col
*   @param: rowId - id of row
*   @type:  public
*   @edition: Professional
*   @returns: real caption of tree col
*   @topic: 7
*/
dhtmlXGridObject.prototype.getItemText=function(rowId){
        return this.cells(rowId,this.cellType._dhx_find("tree")).getLabel();
}

/**
*   @desc: return open/close state of row
*   @param: rowId - id of row
*   @type:  public
*   @returns: open/close state of row
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype.getOpenState=function(rowId){
        var z=this._h2.get[rowId||0];
        if (!z) return;
        if (z.state=="minus") return true;
        return false;
}
/**
*   @desc: return id of parent row
*   @param: rowId - id of row
*   @type:  public
*   @edition: Professional
*   @returns: id of parent row
*   @topic: 7
*/
dhtmlXGridObject.prototype.getParentId=function(rowId){
        var z=this._h2.get[rowId||0];
        if ((!z) || (!z.parent)) return null;
        return z.parent.id;
}
/**
*   @desc: return list of child row id, sparated by comma
*   @param: rowId - id of row
*   @type:  public
*   @edition: Professional
*   @returns: list of child rows
*   @topic: 7
*/
dhtmlXGridObject.prototype.getSubItems=function(rowId){
      var str=[];
      var z=this._h2.get[rowId||0];
      if (z)
      	for (var i=0; i<z.childs.length; i++)
      		str.push(z.childs[i].id);
      return str.join(this.delim);
}


/**
*   @desc: expand all tree structure
*   @type:  public
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype.expandAll=function(rowId){
	this._renderAllExpand(rowId||0);
	this._h2_to_buff();
	this._reset_view();
	this.setSizes();
	this.callEvent("onGridReconstructed",[]);
	if (this._redrawLines) this._redrawLines();
}
	
dhtmlXGridObject.prototype._renderAllExpand=function(z){
	var x=this._h2.get[z].childs;
	for (var i=0; i<x.length; i++){
		if (x[i].childs.length){
			this._h2.change(x[i].id,"state","minus")
			this._updateTGRState(x[i]);
			this._renderAllExpand(x[i].id)
		}
	}
}
/**
*   @desc: collapse all tree structure
*   @type:  public
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype.collapseAll=function(rowId){
	this._h2.forEachChild((rowId||0),function(z){
		if (z && z.state=="minus"){
			z.state="plus";
			z.update=true;
			this._updateTGRState(z);
		}
	},this);
	this._h2_to_buff();
	this._reset_view();
	this.setSizes();
	this.callEvent("onGridReconstructed",[]);
	if (this._redrawLines) this._redrawLines();
}

/**
*   @desc: return children count
*   @param: rowId - id of row
*   @type:  public
*   @edition: Professional
*   @returns: children count
*   @topic: 7
*/
dhtmlXGridObject.prototype.hasChildren=function(rowId){
        var x=this._h2.get[rowId];
        if (x && x.childs.length) return x.childs.length;
        if (x._xml_await) return -1;
        return 0;
}


/**
*   @desc: enable/disable closing of row
*   @param: rowId - id of row
*   @param: status - true/false
*   @type:  public
*   @edition: Professional
*   @topic: 7
*/

dhtmlXGridObject.prototype.setItemCloseable=function(rowId,status){
        var x=this._h2.get[rowId];
        if (!x) return;
        x._closeable=(!convertStringToBoolean(status));
}
/**
*   @desc: set real caption of tree col
*   @param: rowId - id of row
*   @param: newtext - new text
*   @type:  public
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype.setItemText=function(rowId,newtext){
	return this.cells(rowId,this.cellType._dhx_find("tree")).setLabel(newtext);
}


/**
*   @desc: set image of tree col
*   @param: rowId - id of row
*   @param: url - image url
*   @type:  public
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype.setItemImage=function(rowId,url){
	this._h2.get[rowId].image=url; 
	this.rowsAr[rowId].imgTag.nextSibling.src=(this.iconURL||"")+url; 
}

/**
*   @desc: get image of tree col
*   @param: rowId - id of row
*   @type:  public
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype.getItemImage=function(rowId){
	this.getRowById(rowId);
	return this._h2.get[rowId].image;  
}


/**
*   @desc: set size of treegrid images
*   @param: width -  width of image
*   @param: height - height of image
*   @type:  public
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype.setImageSize=function(width,height){
        this._img_width=width;
        this._img_height=height;
}


dhtmlXGridObject.prototype._getRowImage=function(row){
	return this._h2.get[row.idd].image;    
        }


/**
*     @desc: set function called before tree node opened/closed
*     @param: func - event handling function
*     @type: public
*     @topic: 0,10
*     @event:  onOpenStart
*     @eventdesc: Event raised immideatly after item in tree got command to open/close , and before item was opened//closed. Event also raised for unclosable nodes and nodes without open/close functionality - in that case result of function will be ignored.
            Event not raised if node opened by dhtmlXtree API.
*     @eventparam: ID of node which will be opened/closed
*     @eventparam: Current open state of tree item. -1 - item closed, 1 - item opened.
*     @eventreturn: true - confirm opening/closing; false - deny opening/closing;
*/
   dhtmlXGridObject.prototype.setOnOpenStartHandler=function(func){  this.attachEvent("onOpenStart",func); };
   
/**
*     @desc: set function called after tree node opened/closed
*     @param: func - event handling function
*     @type: public
*     @topic: 0,10
*     @event:  onOpenEnd
*     @eventdesc: Event raised immideatly after item in tree got command to open/close , and before item was opened//closed. Event also raised for unclosable nodes and nodes without open/close functionality - in that case result of function will be ignored.
            Event not raised if node opened by dhtmlXtree API.
*     @eventparam: ID of node which will be opened/closed
*     @eventparam: Current open state of tree item. -1 - item closed, 1 - item opened.
*/
   dhtmlXGridObject.prototype.setOnOpenEndHandler=function(func){  this.attachEvent("onOpenEnd",func);   };


    /**
*     @desc: enable/disable editor of tree cell ; enabled by default
*     @param: mode -  (boolean) true/false
*     @type: public
*     @topic: 0
*/
   dhtmlXGridObject.prototype.enableTreeCellEdit=function(mode){
        this._edtc=!convertStringToBoolean(mode);
    };



/**
*   @desc: return level of treeGrid row
*   @param: rowId - id of row
*   @type:  public
*   @returns: level of treeGrid row
*   @topic: 7
*/
dhtmlXGridObject.prototype.getLevel=function(rowId){      
        var z=this._h2.get[rowId||0];
        if (!z) return -1;
        return z.level;
}

dhtmlXGridObject.prototype._fixHiddenRowsAllTG=function(ind,state){
  for (i in this.rowsAr){
     if ((this.rowsAr[i])&&(this.rowsAr[i].childNodes))
        this.rowsAr[i].childNodes[ind].style.display=state;
  }
}

dhtmlXGridObject._emptyLineImg="blank";
//(c)dhtmlx ltd. www.dhtmlx.com

//v.3.6 build 131108

/*
Copyright DHTMLX LTD. http://www.dhtmlx.com
To use this component please contact sales@dhtmlx.com to obtain license
*/
dhtmlXGridObject.prototype._updateLine=function(z,row){ 
	row=row||this.rowsAr[z.id];
	if (!row) return;
	var im=row.imgTag;
	if (!im) return;
	if (z.state=="blank") return im.src=this.imgURL+"blank.gif";
	
		var n=1;
		if (z.index==0){
			if (z.level==0){
				if ((z.parent.childs.length-1)>z.index)
					n=3;
				else n=1;
			}
			else
			{
				if ((z.parent.childs.length-1)>z.index)
					n=3;
				else
					n=2;
			}
		}
		else
			if ((z.parent.childs.length-1)>z.index)
				n=3;
			else
				n=2;
			
		
		im.src=this.imgURL+z.state+n+".gif";
}
dhtmlXGridObject.prototype._updateParentLine=function(z,row){
		row=row||this.rowsAr[z.id];
		if (!row) return;
		var im=row.imgTag;
		if (!im) return;
		for (var i=z.level; i>0; i--){
			if (z.id==0) break;
			im=im.previousSibling;
			z=z.parent;
			if ((z.parent.childs.length-1)>z.index)
				im.src=this.imgURL+"line1.gif";
			else
				im.src=this.imgURL+"blank.gif";
		}
}

dhtmlXGridObject.prototype._renderSortA=dhtmlXGridObject.prototype._renderSort;
dhtmlXGridObject.prototype._renderSort=function(){
	this._renderSortA.apply(this,arguments);
	this._redrawLines(0)	
} 
dhtmlXGridObject.prototype._redrawLines=function(id){
		if (this._tgle)
			this._h2.forEachChild((id||0),function(z){
					this._updateLine(z);
					this._updateParentLine(z);
			},this);
	}
/**
*   @desc: enable lines in treeGrid 
*   @type: public
*   @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.enableTreeGridLines=function(){
	dhtmlXGridObject._emptyLineImg="line";
	
	this._updateTGRState=function(z,force){ 
		if (force || !z.update || z.id==0) return;
		if (this._tgle)
			this._updateLine(z,this.rowsAr[z.id]);
		z.update=false;
	}

	this._tgle=true;
	this.attachEvent("onXLE",function(a,b,id){
		this._redrawLines(id)
	});    
	
	this.attachEvent("onOpenEnd",function(id){
		this._redrawLines(id)
	});    
	
	
	this.attachEvent("onRowAdded",function(id){ 
		var z=this._h2.get[id];
		this._updateLine(z); 
		this._updateParentLine(z);
		if (z.index<(z.parent.childs.length-1)){
			z=z.parent.childs[z.index+1];
			this._updateLine(z);
			this._updateParentLine(z);
		}
		else if (z.index!=0){
			z=z.parent.childs[z.index-1];
			this._updateLine(z);
			this._updateParentLine(z);
			if (z.childs.length)
				this._h2.forEachChild(z.id,function(c_el){
					this._updateParentLine(c_el)
				},this)
		}
	});
	this.attachEvent("onOpen",function(id,state){ 
		if (state){ 
			var z=this._h2.get[id];
			for (var i=0; i < z.childs.length; i++) 
				this._updateParentLine(z.childs[i]);
		}
		return true;
	});
	this.attachEvent("onBeforeRowDeleted",function(id){
		var self=this;
		var z=this._h2.get[id];
		var w=null;
		if (z.index!=0)
			w=z.parent.childs[z.index-1];
		z=z.parent;
			
		window.setTimeout(function(){
			z  = self._h2.get[z.id];
			if (!z) return;
						
			self._updateLine(z);
			self._updateParentLine(z);
			
			if (w){
				self._updateLine(w);
				if (w.state=="minus")
				self._h2.forEachChild(w.id,function(z){
					self._updateParentLine(z);
				},self);
			}
		},1);
		return true;
	});
} 

//(c)dhtmlx ltd. www.dhtmlx.com

//v.3.6 build 131108

/*
Copyright DHTMLX LTD. http://www.dhtmlx.com
To use this component please contact sales@dhtmlx.com to obtain license
*/
//beware that function started from _in_header_ must not be obfuscated


/**
*   @desc: allows to define , which level of tree must be used for filtering
*   @type: public
*   @param: level - level value, -1 value means last one
*	@edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.setFiltrationLevel=function(level,show_lower,show_upper){
	this._tr_strfltr=level;
	this._tr_fltr_c=show_lower;
	this._tr_fltr_d=show_upper;
	this.refreshFilters();
}


/**
*   @desc: filter grid by mask
*   @type: public
*   @param: column - {number} zero based index of column
*   @param: value - {string} filtering mask
*   @param: preserve - {bool} filter current or initial state ( false by default )
*	@edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.filterTreeBy=function(column, value, preserve){
	var origin = this._h2;
	if (typeof this._tr_strfltr == "undefined") this._tr_strfltr=-1;
	if (this._f_rowsBuffer){
		if (!preserve){
			this._h2=this._f_rowsBuffer;
			if (this._fake) this._fake._h2=this._h2;
		}
	} else
		this._f_rowsBuffer=this._h2;	//backup copy
	
	//if (!this.rowsBuffer.length && preserve) return;
	var d=true;
	this.dma(true)
	this._fbf={};
	if (typeof(column)=="object")
		for (var j=0; j<value.length; j++)
			this._filterTreeA(column[j],value[j]);
	else
			this._filterTreeA(column,value);
	this._fbf=null;
	this.dma(false)
	this._fix_filtered_images(this._h2,origin);
	this._renderSort()
	this.callEvent("onGridReconstructed",[])
}
dhtmlXGridObject.prototype._filterTreeA=function(column,value){ 
	if (value=="") return;
	var d=true;
	if (typeof(value)=="function") d=false;
	else value=(value||"").toString().toLowerCase();
	
	var add_line=function(el,s,t){
			var z=t.get[el.parent.id];
			if (!z) z=add_line(el.parent,s,t)
			var t=temp.get[el.id];
			if (!t){
				t={id:el.id, childs:[], level:el.level, parent:z, index:z.childs.length, image:el.image, state:el.state, buff:el.buff, has_kids:el.has_kids, _xml_await:el._xml_await};
			z.childs.push(t);
			temp.get[t.id]=t;
			}
			return t;
	}
	var fbf=this._fbf;
	var temp = new dhtmlxHierarchy();
	var check; 
	var mode = this._tr_strfltr;
	var that=this;	
	var temp_c=function(el){
		for (var i=0; i < el.childs.length; i++) 
			that.temp(el.childs[i]);
	}
	switch(mode.toString()){
		case "-2": check=function(el){ if (fbf[el.id]) return false; temp_c(el); return true;}; break;
		case "-1": check=function(el){return !el.childs.length;}; break;
		default: check=function(el){return mode==el.level}; break;
	}
	this.temp=function(el){
		if (el.id!=0 && check(el)){
			if (d?(this._get_cell_value(el.buff,column).toString().toLowerCase().indexOf(value)==-1):(!value(this._get_cell_value(el.buff,column),el.id))){
				fbf[el.id]=true;
				if (this._tr_fltr_c) add_line(el.parent,this._h2,temp);
				return false;
			} else {
				add_line(el,this._h2,temp);
				if (el.childs && mode!=-2)
					this._h2.forEachChild(el.id,function(cel){
						add_line(cel,this._h2,temp);
					},this)
				return true;
			}
		} else {
			if (this._tr_fltr_d && this._tr_strfltr > el.level && el.id!=0) add_line(el,this._h2,temp);
			temp_c(el);
		}
	}

	
	this.temp(this._h2.get[0]);
	this._h2=temp;	
	if (this._fake) this._fake._h2=this._h2;
}

dhtmlXGridObject.prototype._fix_filtered_images=function(temp,origin){
		temp.forEachChild(0,function(el){
		if (!el.childs.length && !el.has_kids){
			if (el.state!=dhtmlXGridObject._emptyLineImg){
				el.state=dhtmlXGridObject._emptyLineImg;
				el.update=true;
				this._updateTGRState(el);
			}
		} else {
			if (el.buff.tagName=="TR"){
				var prev=origin.get[el.id];
				if (prev && prev.state!=dhtmlXGridObject._emptyLineImg)
					el.state=prev.state;
				el.update=true;
				this._updateTGRState(el);
			}
		}
	},this)
}
/**
*   @desc: get all possible values in column
*   @type: public
*   @param: column - {number} zero based index of column
*   @returns: {array} array of all possible values in column
*	@edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.collectTreeValues=function(column){
	if (typeof this._tr_strfltr == "undefined") this._tr_strfltr=-1;
	this.dma(true)
	this._build_m_order();		
	column=this._m_order?this._m_order[column]:column;
	var c={}; var f=[];
	var col=this._f_rowsBuffer||this._h2;
	col.forEachChild(0,function(el){
		if (this._tr_strfltr==-2 || (this._tr_strfltr==-1 && !el.childs.length) || (this._tr_strfltr==el.level)){
			var val=this._get_cell_value(el.buff,column);
			if (val) c[val]=true;
    	}
	},this);
	this.dma(false)
	
	var vals=this.combos[column];
	for (var d in c) 
		if (c[d]===true) f.push(vals?(vals.get(d)||d):d);
	
	return f.sort();			
}




dhtmlXGridObject.prototype._in_header_stat_tree_total=function(t,i,c){
	var calck=function(){
		var summ=0;
		this._build_m_order();
		var ii = this._m_order?this._m_order[i]:i;
		this._h2.forEachChild(0,function(el){
			var v=parseFloat(this._get_cell_value((el.buff||this.rowsAr[el.id]),ii));
			summ+=isNaN(v)?0:v;
		},this)
		return this._maskArr[i]?this._aplNF(summ,i):(Math.round(summ*100)/100);
	}
	this._stat_in_header(t,calck,i,c,c);
}
dhtmlXGridObject.prototype._in_header_stat_tree_total_leaf=function(t,i,c){
	var calck=function(){
		var summ=0;
		this._build_m_order();
		var ii = this._m_order?this._m_order[i]:i;
		this._h2.forEachChild(0,function(el){
			if (el.childs.length) return;
			var v=parseFloat(this._get_cell_value((el.buff||this.rowsAr[el.id]),ii));
			summ+=isNaN(v)?0:v;
		},this)
		return this._maskArr[i]?this._aplNF(summ,i):(Math.round(summ*100)/100);
	}
	this._stat_in_header(t,calck,i,c,c);
}
dhtmlXGridObject.prototype._in_header_stat_tree_multi_total=function(t,i,c){
	var cols=c[1].split(":"); c[1]="";
	var calck=function(){
		var summ=0;
		this._h2.forEachChild(0,function(el){
			var v=parseFloat(this._get_cell_value((el.buff||this.rowsAr[el.id]),cols[0]))*parseFloat(this._get_cell_value((el.buff||this.rowsAr[el.id]),cols[1]));
			summ+=isNaN(v)?0:v;
		},this)
		return this._maskArr[i]?this._aplNF(summ,i):(Math.round(summ*100)/100);
	}
	this._stat_in_header(t,calck,i,c,c);
}
dhtmlXGridObject.prototype._in_header_stat_tree_multi_total_leaf=function(t,i,c){
	var cols=c[1].split(":"); c[1]="";
	var calck=function(){
		var summ=0;
		this._h2.forEachChild(0,function(el){
			if (el.childs.length) return;
			var v=parseFloat(this._get_cell_value((el.buff||this.rowsAr[el.id]),cols[0]))*parseFloat(this._get_cell_value((el.buff||this.rowsAr[el.id]),cols[1]));
			summ+=isNaN(v)?0:v;
		},this)
		return this._maskArr[i]?this._aplNF(summ,i):(Math.round(summ*100)/100);
	}
	this._stat_in_header(t,calck,i,c,c);
}
dhtmlXGridObject.prototype._in_header_stat_tree_max=function(t,i,c){
	var calck=function(){
		var summ=-999999999;
		this._build_m_order();
		var ii = this._m_order?this._m_order[i]:i;
		if (this.getRowsNum()==0) return "";
		this._h2.forEachChild(0,function(el){
			var d=parseFloat(this._get_cell_value((el.buff||this.rowsAr[el.id]),ii));
			if (!isNaN(d))
				summ=Math.max(summ,d);
		},this)
		return this._maskArr[i]?this._aplNF(summ,i):summ;
	}
	this._stat_in_header(t,calck,i,c);
}
dhtmlXGridObject.prototype._in_header_stat_tree_min=function(t,i,c){
	var calck=function(){
		var summ=999999999;
		this._build_m_order();
		var ii = this._m_order?this._m_order[i]:i;
		if (this.getRowsNum()==0) return "";
		this._h2.forEachChild(0,function(el){
			var d=parseFloat(this._get_cell_value((el.buff||this.rowsAr[el.id]),ii));
			if (!isNaN(d))
				summ=Math.min(summ,d);
		},this)
		return this._maskArr[i]?this._aplNF(summ,i):summ;
	}
	this._stat_in_header(t,calck,i,c);
}
dhtmlXGridObject.prototype._in_header_stat_tree_average=function(t,i,c){
	var calck=function(){
		var summ=0; var count=0;
		this._build_m_order();
		var ii = this._m_order?this._m_order[i]:i;
		this._h2.forEachChild(0,function(el){
			var v=parseFloat(this._get_cell_value((el.buff||this.rowsAr[el.id]),ii));
			summ+=isNaN(v)?0:v;
			count++;
		},this)
		return this._maskArr[i]?this._aplNF(summ,i):(Math.round(summ/count*100)/100);
	}
	this._stat_in_header(t,calck,i,c);
}
dhtmlXGridObject.prototype._in_header_stat_tree_max_leaf=function(t,i,c){
	var calck=function(){
		var summ=-999999999;
		this._build_m_order();
		var ii = this._m_order?this._m_order[i]:i;
		if (this.getRowsNum()==0) return "";
		this._h2.forEachChild(0,function(el){
			if (el.childs.length) return;
			var d=parseFloat(this._get_cell_value((el.buff||this.rowsAr[el.id]),ii));
			if (!isNaN(d))
				summ=Math.max(summ,d);
		},this)
		return this._maskArr[i]?this._aplNF(summ,i):summ;
	}
	this._stat_in_header(t,calck,i,c);
}
dhtmlXGridObject.prototype._in_header_stat_tree_min_leaf=function(t,i,c){
	var calck=function(){
		var summ=999999999;
		this._build_m_order();
		var ii = this._m_order?this._m_order[i]:i;
		if (this.getRowsNum()==0) return "";
		this._h2.forEachChild(0,function(el){
			if (el.childs.length) return;
			var d=parseFloat(this._get_cell_value((el.buff||this.rowsAr[el.id]),ii));
			if (!isNaN(d))
				summ=Math.min(summ,d);
		},this)
		return this._maskArr[i]?this._aplNF(summ,i):summ;
	}
	this._stat_in_header(t,calck,i,c);
}
dhtmlXGridObject.prototype._in_header_stat_tree_average_leaf=function(t,i,c){
	var calck=function(){
		var summ=0; var count=0;
		this._build_m_order();
		var ii = this._m_order?this._m_order[i]:i;
		this._h2.forEachChild(0,function(el){
			if (el.childs.length) return;
			var v=parseFloat(this._get_cell_value((el.buff||this.rowsAr[el.id]),ii));
			summ+=isNaN(v)?0:v;
			count++;
		},this)
		return this._maskArr[i]?this._aplNF(summ,i):(Math.round(summ/count*100)/100);
	}
	this._stat_in_header(t,calck,i,c);
}
dhtmlXGridObject.prototype._in_header_stat_tree_count=function(t,i,c){
	var calck=function(){
		var count=0;
		this._h2.forEachChild(0,function(el){
			count++;
		},this)
		return count;
	}
	this._stat_in_header(t,calck,i,c);
}
dhtmlXGridObject.prototype._in_header_stat_tree_count_leaf=function(t,i,c){
	var calck=function(){
		var count=0;
		this._h2.forEachChild(0,function(el){
			if (!el.childs.length) count++;
		},this)
		return count;
	}
	this._stat_in_header(t,calck,i,c);
}

dhtmlXGridObject.prototype._stat_in_header=function(t,calck,i,c){
//	if (this._realfake) return this._fake._stat_in_header(t,calck,i,c);
	var that=this;
	var f=function(){
		this.dma(true)
		t.innerHTML=(c[0]?c[0]:"")+calck.call(this)+(c[1]?c[1]:"");
		this.dma(false)
		this.callEvent("onStatReady",[])
	}
	if (!this._stat_events) {
		this._stat_events=[];
		this.attachEvent("onClearAll",function(){ 
			if (!this.hdr.rows[1]){
				for (var i=0; i<this._stat_events.length; i++)
					for (var j=0; j < 4; j++) 
						this.detachEvent(this._stat_events[i][j]);
				this._stat_events=[];	
			}
		})
	}
	
	this._stat_events.push([
	this.attachEvent("onGridReconstructed",f),
	this.attachEvent("onXLE",f),
	this.attachEvent("onFilterEnd",f),
	this.attachEvent("onEditCell",function(stage,id,ind){
		if (stage==2 && ind==i) f.call(this);
		return true;
		})]);
	t.innerHTML="";
}
dhtmlXGridObject.prototype._build_m_order=function(){
	if (this._c_order){
		this._m_order=[]
		for (var i=0; i < this._c_order.length; i++) {
			this._m_order[this._c_order[i]]=i;
		};
	}
}


//(c)dhtmlx ltd. www.dhtmlx.com

//v.3.6 build 131108

/*
Copyright DHTMLX LTD. http://www.dhtmlx.com
To use this component please contact sales@dhtmlx.com to obtain license
*/
/**
*   @desc: a constructor, creates a new dhtmlxMenu object, baseId defines a base object for the top menu level
*   @param: baseId - id of the html element to which a menu will be attached, in case of a contextual menu - if specified, will used as a contextual zone
*   @type: public
*/
function dhtmlXMenuObject(baseId, skin) {
	var main_self = this;
	
	this.addBaseIdAsContextZone = null;
	
	this.isDhtmlxMenuObject = true;
	
	// skin settings
	this.skin = (skin != null ? skin : (typeof(dhtmlx) != "undefined" && typeof(dhtmlx.skin) == "string" ? dhtmlx.skin : "dhx_skyblue"));
	this.imagePath = "";
	
	// iframe
	this._isIE6 = false;
	if (_isIE) this._isIE6 = (window.XMLHttpRequest==null?true:false);
	
	if (baseId == null) {
		this.base = document.body;
	} else {
		var baseObj = (typeof(baseId)=="string"?document.getElementById(baseId):baseId);
		if (baseObj != null) {
			this.base = baseObj;
			if (!this.base.id) this.base.id = (new Date()).valueOf();
			while (this.base.childNodes.length > 0) { this.base.removeChild(this.base.childNodes[0]); }
			this.base.className += " dhtmlxMenu_"+this.skin+"_Middle dir_left";
			this.base._autoSkinUpdate = true;
			 // preserv default oncontextmenu for future restorin in case of context menu
			if (this.base.oncontextmenu) this.base._oldContextMenuHandler = this.base.oncontextmenu;
			//
			this.addBaseIdAsContextZone = this.base.id;
			this.base.onselectstart = function(e) { e = e || event; e.returnValue = false; return false; }
			this.base.oncontextmenu = function(e) { e = e || event; e.returnValue = false; return false; }
		} else {
			this.base = document.body;
		}
	}
	// this.topId = topId;
	this.topId = "dhxWebMenuTopId";
	
	// 
	if (!this.extendedModule) {
		// add notify for menu
		var t = function(){alert(this.i18n.dhxmenuextalert);};
		var extMethods = new Array("setItemEnabled", "setItemDisabled", "isItemEnabled", "_changeItemState", "getItemText", "setItemText",
				"loadFromHTML", "hideItem", "showItem", "isItemHidden", "_changeItemVisible", "setUserData", "getUserData",
				"setOpenMode", "setWebModeTimeout", "enableDynamicLoading", "_updateLoaderIcon", "getItemImage", "setItemImage",
				"clearItemImage", "setAutoShowMode", "setAutoHideMode", "setContextMenuHideAllMode", "getContextMenuHideAllMode",
				"setVisibleArea", "setTooltip", "getTooltip", "setHotKey", "getHotKey", "setItemSelected", "setTopText", "setRTL",
				"setAlign", "setHref", "clearHref", "getCircuit", "_clearAllSelectedSubItemsInPolygon", "_checkArrowsState",
				"_addUpArrow", "_addDownArrow", "_removeUpArrow", "_removeDownArrow", "_isArrowExists", "_doScrollUp", "_doScrollDown",
				"_countPolygonItems", "setOverflowHeight", "_getRadioImgObj", "_setRadioState", "_radioOnClickHandler",
				"getRadioChecked", "setRadioChecked", "addRadioButton", "_getCheckboxState", "_setCheckboxState", "_readLevel",
				"_updateCheckboxImage", "_checkboxOnClickHandler", "setCheckboxState", "getCheckboxState", "addCheckbox", "serialize");
		for (var q=0; q<extMethods.length; q++) if (!this[extMethods[q]]) this[extMethods[q]] = t;
		extMethods = null;
	}
	
	// should be used for frameset in IE
	this.fixedPosition = false;
	
	this.menuSelected = -1;
	this.menuLastClicked = -1;
	this.idPrefix = "";
	this.itemTagName = "item";
	this.itemTextTagName = "itemtext";
	this.userDataTagName = "userdata";
	this.itemTipTagName = "tooltip";
	this.itemHotKeyTagName = "hotkey";
	this.itemHrefTagName = "href";
	this.dirTopLevel = "bottom";
	this.dirSubLevel = "right";
	this.menuX1 = null;
	this.menuX2 = null;
	this.menuY1 = null;
	this.menuY2 = null;
	this.menuMode = "web";
	this.menuTimeoutMsec = 400;
	this.menuTimeoutHandler = null;
	this.autoOverflow = false;
	this.idPull = {};
	this.itemPull = {};
	this.userData = {};
	this.radio = {};
	//
	this._rtl = false;
	this._align = "left";
	//
	this.menuTouched = false;
	//
	this.zIndInit = 1200;
	this.zInd = this.zIndInit;
	this.zIndStep = 50;
	//
	this.menuModeTopLevelTimeout = true; // shows sublevel polygons from toplevel items with delay
	this.menuModeTopLevelTimeoutTime = 200; // msec
	//
	// default skin
	// this.skin = "Standard";
	
	// skin-based params
	this._topLevelBottomMargin = 1;
	this._topLevelRightMargin = 0;
	this._topLevelOffsetLeft = 1;
	this._arrowFFFix = (_isIE?(document.compatMode=="BackCompat"?0:-4):-4); // border fixer for FF for arrows polygons
	
	/**
	*   @desc: changes menu skin
	*   @param: skin - skin name
	*   @type: public
	*/
	this.setSkin = function(skin) {
		var oldSkin = this.skin;
		this.skin = skin;
		switch (this.skin){
			case "dhx_black":
			case "dhx_blue":
			case "dhx_skyblue":
			case "dhx_web":
				this._topLevelBottomMargin = 2;
				this._topLevelRightMargin = 1;
				this._topLevelOffsetLeft = 1;
				this._arrowFFFix = (_isIE?(document.compatMode=="BackCompat"?0:-4):-4);
				break;
			case "dhx_web":
				this._arrowFFFix = 0;
				break;
			case "dhx_terrace":
				this._topLevelBottomMargin = 0;
				this._topLevelRightMargin = 0;
				this._topLevelOffsetLeft = 0;
				this._arrowFFFix = (_isIE?(document.compatMode=="BackCompat"?0:-4):-4);
				break;
		}
		if (this.base._autoSkinUpdate) {
			this.base.className = this.base.className.replace("dhtmlxMenu_"+oldSkin+"_Middle", "")+" dhtmlxMenu_"+this.skin+"_Middle";
		}
		
		for (var a in this.idPull) {
			this.idPull[a].className = String(this.idPull[a].className).replace(oldSkin, this.skin);
			
		}
	}
	this.setSkin(this.skin);
	//
	this.dLoad = false;
	this.dLoadUrl = "";
	this.dLoadSign = "?";
	this.loaderIcon = false;
	this.limit = 0;
	//
	this._scrollUpTM = null;
	this._scrollUpTMTime = 20;
	this._scrollUpTMStep = 3;
	this._scrollDownTM = null;
	this._scrollDownTMTime = 20;
	this._scrollDownTMStep = 3;
	/* context menu */
	this.context = false;
	this.contextZones = {};
	this.contextMenuZoneId = false;
	this.contextAutoShow = true;	/* default open action */
	this.contextAutoHide = true;	/* default close action */
	this.contextHideAllMode = true; /* true will hide all opened contextual menu polygons on mouseout, false - all except topleft */
	
	this._selectedSubItems = new Array();
	this._openedPolygons = new Array();
	this._addSubItemToSelected = function(item, polygon) {
		var t = true;
		for (var q=0; q<this._selectedSubItems.length; q++) { if ((this._selectedSubItems[q][0] == item) && (this._selectedSubItems[q][1] == polygon)) { t = false; } }
		if (t == true) { this._selectedSubItems.push(new Array(item, polygon)); }
		return t;
	}
	this._removeSubItemFromSelected = function(item, polygon) {
		var m = new Array();
		var t = false;
		for (var q=0; q<this._selectedSubItems.length; q++) { if ((this._selectedSubItems[q][0] == item) && (this._selectedSubItems[q][1] == polygon)) { t = true; } else { m[m.length] = this._selectedSubItems[q]; } }
		if (t == true) { this._selectedSubItems = m; }
		return t;
	}
	this._getSubItemToDeselectByPolygon = function(polygon) {
		var m = new Array();
		for (var q=0; q<this._selectedSubItems.length; q++) {
			if (this._selectedSubItems[q][1] == polygon) {
				m[m.length] = this._selectedSubItems[q][0];
				m = m.concat(this._getSubItemToDeselectByPolygon(this._selectedSubItems[q][0]));
				var t = true;
				for (var w=0; w<this._openedPolygons.length; w++) { if (this._openedPolygons[w] == this._selectedSubItems[q][0]) { t = false; } }
				if (t == true) { this._openedPolygons[this._openedPolygons.length] = this._selectedSubItems[q][0]; }
				this._selectedSubItems[q][0] = -1;
				this._selectedSubItems[q][1] = -1;
			}
		}
		return m;
	}
	/* end */
	/* define polygon's position for dinamic content rendering and shows it, added in version 0.3 */
	this._hidePolygon = function(id) {
		if (this.idPull["polygon_" + id] != null) {
			if (typeof(this._menuEffect) != "undefined" && this._menuEffect !== false) {
				this._hidePolygonEffect("polygon_"+id);
			} else {
				// already hidden
				if (this.idPull["polygon_"+id].style.display == "none") return;
				//
				this.idPull["polygon_"+id].style.display = "none";
				if (this.idPull["arrowup_"+id] != null) { this.idPull["arrowup_"+id].style.display = "none"; }
				if (this.idPull["arrowdown_"+id] != null) { this.idPull["arrowdown_"+id].style.display = "none"; }
				this._updateItemComplexState(id, true, false);
				// hide ie6 cover
				if (this._isIE6) { if (this.idPull["polygon_"+id+"_ie6cover"] != null) { this.idPull["polygon_"+id+"_ie6cover"].style.display = "none"; } }
			}
			// call event
			id = String(id).replace(this.idPrefix, "");
			if (id == this.topId) id = null;
			this.callEvent("onHide", [id]);
			
			// corners
			if (id != null && this.skin == "dhx_terrace" && this.itemPull[this.idPrefix+id].parent == this.idPrefix+this.topId) {
				this._improveTerraceButton(this.idPrefix+id, true);
			}
			
			
		}
	}
	this._showPolygon = function(id, openType) {
		
		var itemCount = this._countVisiblePolygonItems(id);
		if (itemCount == 0) return;
		var pId = "polygon_"+id;
		if ((this.idPull[pId] != null) && (this.idPull[id] != null)) {
		
			if (this.menuModeTopLevelTimeout && this.menuMode == "web" && !this.context) {
				if (!this.idPull[id]._mouseOver && openType == this.dirTopLevel) return;
			}
			
			// detect visible area
			if (!this.fixedPosition) this._autoDetectVisibleArea();
			
			// show arrows
			var arrUpH = 0;
			var arrDownH = 0;
			//
			var arrowUp = null;
			var arrowDown = null;
			
			// show polygon
			this.idPull[pId].style.visibility = "hidden";
			this.idPull[pId].style.left = "0px";
			this.idPull[pId].style.top = "0px";
			this.idPull[pId].style.display = "";
			this.idPull[pId].style.zIndex = this.zInd;
			
			//
			if (this.autoOverflow) {
				if (this.idPull[pId].firstChild.offsetHeight > this.menuY1+this.menuY2) {
					var t0 = Math.floor((this.menuY2-this.menuY1-35)/24);
					this.limit = t0;
				} else {
					this.limit = 0;
					
					if (this.idPull["arrowup_"+id] != null) this._removeUpArrow(String(id).replace(this.idPrefix,""));
					if (this.idPull["arrowdown_"+id] != null) this._removeDownArrow(String(id).replace(this.idPrefix,""));
				}
			}
			
			//#menu_overflow:06062008#{
			if (this.limit > 0 && this.limit < itemCount)  {
				
				// add overflow arrows if they not exists
				if (this.idPull["arrowup_"+id] == null) this._addUpArrow(String(id).replace(this.idPrefix,""));
				if (this.idPull["arrowdown_"+id] == null) this._addDownArrow(String(id).replace(this.idPrefix,""));
				
				// configure up arrow
				arrowUp = this.idPull["arrowup_"+id];
				arrowUp.style.visibility = "hidden";
				arrowUp.style.display = "";
				arrowUp.style.zIndex = this.zInd;
				arrUpH = arrowUp.offsetHeight;
				
				// configure bottom arrow
				arrowDown = this.idPull["arrowdown_"+id];
				arrowDown.style.visibility = "hidden";
				arrowDown.style.display = "";
				arrowDown.style.zIndex = this.zInd;
				arrDownH = arrowDown.offsetHeight;
			}
			//#}
			
			if (this.limit > 0) {
				if (this.limit < itemCount)  {
					// set fixed size
					// this.idPull[pId].style.height = this.idPull[pId].tbd.childNodes[0].offsetHeight*this.limit+"px";// + arrUpH + arrDownH;
					this.idPull[pId].style.height = 24*this.limit+"px";
					this.idPull[pId].scrollTop = 0;
				} else {
					// remove fixed size
					this.idPull[pId].style.height = "";
				}
			}
			//
			this.zInd += this.zIndStep;
			//
			// console.log(this.idPull)
			if (this.itemPull[id] != null) {
				var parPoly = "polygon_"+this.itemPull[id]["parent"];
			} else if (this.context) {
				var parPoly = this.idPull[this.idPrefix+this.topId];
			}
			/*
			// debug info
			if (parPoly == null) {
				alert("Implementation error. Please report support@dhtmlx.com");
			}
			*/
			//
			//
			// define position
			var srcX = (this.idPull[id].tagName != null ? getAbsoluteLeft(this.idPull[id]) : this.idPull[id][0]);
			var srcY = (this.idPull[id].tagName != null ? getAbsoluteTop(this.idPull[id]) : this.idPull[id][1]);
			var srcW = (this.idPull[id].tagName != null ? this.idPull[id].offsetWidth : 0);
			var srcH = (this.idPull[id].tagName != null ? this.idPull[id].offsetHeight : 0);
			
			var x = 0;
			var y = 0;
			var w = this.idPull[pId].offsetWidth;
			var h = this.idPull[pId].offsetHeight + arrUpH + arrDownH;
			
			//console.log(srcY,h,window.innerHeight,document.body.scrollTop)
			/*
			var bottomOverflow = (srcY+h > window.innerHeight+document.body.scrollTop);
			if (bottomOverflow) {
				if (openType == "bottom") openType = "top";
				if (openType == "right" || openType == "left") {
					srcY = srcY-h;
				}
			}
			*/
			// pos
			if (openType == "bottom") {
				if (this._rtl) {
					x = srcX + (srcW!=null?srcW:0) - w;
				} else {
					if (this._align == "right") {
						x = srcX + srcW - w;
					} else {
						x = srcX - 1 + (openType==this.dirTopLevel?this._topLevelRightMargin:0);
					}
				}
				y = srcY - 1 + srcH + this._topLevelBottomMargin;
			}
			if (openType == "right") { x = srcX + srcW - 1; y = srcY + 2; }
			if (openType == "left") { x = srcX - this.idPull[pId].offsetWidth + 2; y = srcY + 2; }
			if (openType == "top") { x = srcX - 1; y = srcY - h + 2; }
			
			// overflow check
			if (this.fixedPosition) {
				// use fixed document.body/window dimension if required
				var mx = 65536;
				var my = 65536;
			} else {
				var mx = (this.menuX2!=null?this.menuX2:0);
				var my = (this.menuY2!=null?this.menuY2:0);
				
				if (mx == 0) {
					if (window.innerWidth) {
						mx = window.innerWidth;
						my = window.innerHeight;
					} else {
						mx = document.body.offsetWidth;
						my = document.body.scrollHeight;
					}
				}
			}
			if (x+w > mx && !this._rtl) {
				// no space on right, open to left
				x = srcX - w + 2;
			}
			if (x < this.menuX1 && this._rtl) {
				// no space on left, open to right
				x = srcX + srcW - 2;
			}
			if (x < 0) {
				// menu floats left
				x = 0;
			}
			if (y+h > my && this.menuY2 != null) {
				y = Math.max(srcY + srcH - h + 2, (this._isVisibleArea?this.menuY1+2:2));
				// open from top level
				if (this.context && this.idPrefix+this.topId == id && arrowDown != null) {
					// autoscroll prevent because menu mouse pointer will right over downarrow
					y = y-2;
				}
				if (this.itemPull[id] != null && !this.context) {
					if (this.itemPull[id]["parent"] == this.idPrefix+this.topId) y = y - this.base.offsetHeight;
				}
			}
			//
			this.idPull[pId].style.left = x+"px";
			this.idPull[pId].style.top = y+arrUpH+"px";
			//
			if (typeof(this._menuEffect) != "undefined" && this._menuEffect !== false) {
				this._showPolygonEffect(pId);
			} else {
				this.idPull[pId].style.visibility = "";
				//#menu_overflow:06062008#{
				if (this.limit > 0 && this.limit < itemCount)  {
					// this.idPull[pId].scrollTop = 0;
					arrowUp.style.left = x+"px";
					arrowUp.style.top = y+"px";
					arrowUp.style.width = w+this._arrowFFFix+"px";
					arrowUp.style.visibility = "";
					//
					arrowDown.style.left = x+"px";
					arrowDown.style.top = y+h-arrDownH+"px";
					arrowDown.style.width = w+this._arrowFFFix+"px";
					arrowDown.style.visibility = "";
					//
					this._checkArrowsState(id);
				}
				//#}
				// show ie6 cover
				if (this._isIE6) {
					var pIdIE6 = pId+"_ie6cover";
					if (this.idPull[pIdIE6] == null) {
						var ifr = document.createElement("IFRAME");
						ifr.className = "dhtmlxMenu_IE6CoverFix_"+this.skin;
						ifr.frameBorder = 0;
						ifr.setAttribute("src", "javascript:false;");
						document.body.insertBefore(ifr, document.body.firstChild);
						this.idPull[pIdIE6] = ifr;
					}
					this.idPull[pIdIE6].style.left = x+"px";
					this.idPull[pIdIE6].style.top = y+"px";
					this.idPull[pIdIE6].style.width = w+"px";
					this.idPull[pIdIE6].style.height = h+"px";
					this.idPull[pIdIE6].style.zIndex = this.idPull[pId].style.zIndex-1;
					this.idPull[pIdIE6].style.display = "";
				}
			}
			
			id = String(id).replace(this.idPrefix, "");
			if (id == this.topId) id = null;
			this.callEvent("onShow", [id]);
			
			// corners
			if (id != null && this.skin == "dhx_terrace" && this.itemPull[this.idPrefix+id].parent == this.idPrefix+this.topId) {
				this._improveTerraceButton(this.idPrefix+id, false);
			}
			// this.callEvent("_onPolyShow",[id.replace(this.idPrefix,"")]);
			
		}
	}
	/* redistrib sublevel selection: select id and deselect other, added in version 0.3 */
	this._redistribSubLevelSelection = function(id, parentId) {
		// clear previosly selected items
		while (this._openedPolygons.length > 0) this._openedPolygons.pop();
		// this._openedPolygons = new Array();
		var i = this._getSubItemToDeselectByPolygon(parentId);
		this._removeSubItemFromSelected(-1, -1);
		for (var q=0; q<i.length; q++) { if ((this.idPull[i[q]] != null) && (i[q] != id)) { if (this.itemPull[i[q]]["state"] == "enabled") { this.idPull[i[q]].className = "sub_item"; } } }
		// hide polygons
		for (var q=0; q<this._openedPolygons.length; q++) { if (this._openedPolygons[q] != parentId) { this._hidePolygon(this._openedPolygons[q]); } }
		// add new selection into list new
		if (this.itemPull[id]["state"] == "enabled") {
			this.idPull[id].className = "sub_item_selected";
			if (this.itemPull[id]["complex"] && this.dLoad && (this.itemPull[id]["loaded"]=="no")) {
				if (this.loaderIcon == true) { this._updateLoaderIcon(id, true); }
				var xmlLoader = new dtmlXMLLoaderObject(this._xmlParser, window);
				this.itemPull[id]["loaded"] = "get";
				this.callEvent("onXLS", []);
				xmlLoader.loadXML(this.dLoadUrl+this.dLoadSign+"action=loadMenu&parentId="+id.replace(this.idPrefix,"")+"&etc="+new Date().getTime());
			}
			// show
			if (this.itemPull[id]["complex"] || (this.dLoad && (this.itemPull[id]["loaded"] == "yes"))) {
				// make arrow over
				if ((this.itemPull[id]["complex"]) && (this.idPull["polygon_" + id] != null))  {
					this._updateItemComplexState(id, true, true);
					this._showPolygon(id, this.dirSubLevel);
				}
			}
			this._addSubItemToSelected(id, parentId);
			this.menuSelected = id;
		}
	}
	/* onClickMenu action (click on any end item to perform some actions)
	   optimized in version 0.3 added type feature (click on disabled items, click on complex nodes)
	   attachEvent feature from 0.4 */
	this._doOnClick = function(id, type, casState) {
		this.menuLastClicked = id;
		// href
		if (this.itemPull[this.idPrefix+id]["href_link"] != null && this.itemPull[this.idPrefix+id].state == "enabled") {
			var form = document.createElement("FORM");
			var k = String(this.itemPull[this.idPrefix+id]["href_link"]).split("?");
			form.action = k[0];
			if (k[1] != null) {
				var p = String(k[1]).split("&");
				for (var q=0; q<p.length; q++) {
					var j = String(p[q]).split("=");
					var m = document.createElement("INPUT");
					m.type = "hidden";
					m.name = (j[0]||"");
					m.value = (j[1]||"");
					form.appendChild(m);
				}
			}
			if (this.itemPull[this.idPrefix+id]["href_target"] != null) { form.target = this.itemPull[this.idPrefix+id]["href_target"]; }
			form.style.display = "none";
			document.body.appendChild(form);
			form.submit();
			if (form != null) {
				document.body.removeChild(form);
				form = null;
			}
			return;
		}
		//
		// some fixes
		if (type.charAt(0)=="c") return; // can't click on complex item
		if (type.charAt(1)=="d") return; // can't click on disabled item
		if (type.charAt(2)=="s") return; // can't click on separator
		//
		if (this.checkEvent("onClick")) {
			// this.callEvent("onClick", [id, type, this.contextMenuZoneId]);
			this.callEvent("onClick", [id, this.contextMenuZoneId, casState]);
		} else {
			if ((type.charAt(1) == "d") || (this.menuMode == "win" && type.charAt(2) == "t")) return;
		}
		if (this.context && this._isContextMenuVisible() && this.contextAutoHide) {
			this._hideContextMenu();
		} else {
			// if menu unloaded from click event
			if (this._clearAndHide) this._clearAndHide();
		}
	}
	/* onTouchMenu action (select topLevel item), attachEvent added in 0.4 */
	this._doOnTouchMenu = function(id) {
		if (this.menuTouched == false) {
			this.menuTouched = true;
			if (this.checkEvent("onTouch")) {
				this.callEvent("onTouch", [id]);
			}
		}
	}
	// this._onTouchHandler = function(id) { }
	// this._setOnTouchHandler = function(handler) { this._onTouchHandler = function(id) { handler(id); } }
	/* return menu array of all nested objects */
	this._searchMenuNode = function(node, menu) {
		var m = new Array();
		for (var q=0; q<menu.length; q++) {
			if (typeof(menu[q]) == "object") {
				if (menu[q].length == 5) { if (typeof(menu[q][0]) != "object") { if ((menu[q][0].replace(this.idPrefix, "") == node) && (q == 0)) { m = menu; } } }
				var j = this._searchMenuNode(node, menu[q]);
				if (j.length > 0) { m = j; }
			}
		}
		return m;
	}
	/* return array of subitems for single menu object */
	/* modified in version 0.3 */
	this._getMenuNodes = function(node) {
		var m = new Array;
		for (var a in this.itemPull) { if (this.itemPull[a]["parent"] == node) { m[m.length] = a; } }
		return m;
	}
	/* generate random string with specified length */
	this._genStr = function(w) {
		var s = ""; var z = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
		for (var q=0; q<w; q++) s += z.charAt(Math.round(Math.random() * (z.length-1)));
		return s;
	}
	/**
	*	@desc: return item type by id
	*	@param: id
	*	@type: public
	*/
	this.getItemType = function(id) {
		id = this.idPrefix+id;
		if (this.itemPull[id] == null) { return null; }
		return this.itemPull[id]["type"];
	}
	/*
	*	@desc: iterator, calls user-defined handler for each existing item and pass item id into it
	*	@param: handler - user-defined handler
	*	@type: public
	*/
	this.forEachItem = function(handler) {
		for (var a in this.itemPull) { handler(String(a).replace(this.idPrefix, "")); }
	}
	/* clear selection and hide menu on onbody click event, optimized in version 0.3 */
	this._clearAndHide = function() {
		main_self.menuSelected = -1;
		main_self.menuLastClicked = -1;
		while (main_self._openedPolygons.length > 0) { main_self._openedPolygons.pop(); }
		for (var q=0; q<main_self._selectedSubItems.length; q++) {
			var id = main_self._selectedSubItems[q][0];
			// clear all selection
			if (main_self.idPull[id] != null) {
				if (main_self.itemPull[id]["state"] == "enabled") {
					if (main_self.idPull[id].className == "sub_item_selected") main_self.idPull[id].className = "sub_item";
					if (main_self.idPull[id].className == "dhtmlxMenu_"+main_self.skin+"_TopLevel_Item_Selected") {
						// main_self.idPull[id].className = "dhtmlxMenu_"+main_self.skin+"_TopLevel_Item_Normal";
						// custom css
						// console.log(main_self.itemPull[this.id])
						if (main_self.itemPull[id]["cssNormal"] != null) {
							// alert(1)
							main_self.idPull[id].className = main_self.itemPull[id]["cssNormal"];
						} else {
							// default css
							main_self.idPull[id].className = "dhtmlxMenu_"+main_self.skin+"_TopLevel_Item_Normal";
						}
					}
				}
			}
			main_self._hidePolygon(id);
		}
		// added in 0.4
		// main_self._hidePolygon(main_self.idPrefix+main_self.topId);
		main_self.menuTouched = false;
		//
		// hide all contextmenu polygons on mouseout
		if (main_self.context) {
			if (main_self.contextHideAllMode) {
				main_self._hidePolygon(main_self.idPrefix+main_self.topId);
				main_self.zInd = main_self.zIndInit;
			} else {
				main_self.zInd = main_self.zIndInit+main_self.zIndStep;
			}
		}
	}
	/* loading and parsing through xml, optimized in version 0.3 */
	this._doOnLoad = function() {}
	/**
	*   @desc: loads menu data from an xml file and calls onLoadFunction when loading is done
	*   @param: xmlFile - an xml file with webmenu data
	*   @param: onLoadFunction - a function that is called after loading is done
	*   @type: public
	*/
	this.loadXML = function(xmlFile, onLoadFunction) {
		if (onLoadFunction) this._doOnLoad = function() { onLoadFunction(); };
		this.callEvent("onXLS", []);
		this._xmlLoader.loadXML(xmlFile);
	}
	/**
	*   @desc: loads menu data from an xml string and calls onLoadFunction when loading is done
	*   @param: xmlFile - an xml string with webmenu data
	*   @param: onLoadFunction - function that is called after loading is done
	*   @type: public
	*/
	this.loadXMLString = function(xmlString, onLoadFunction) {
		if (onLoadFunction) this._doOnLoad = function() { onLoadFunction(); };
		this._xmlLoader.loadXMLString(xmlString);
	}
	this._buildMenu = function(t, parentId) {
		// if (parentId==null) { parentId = this.topId;}
		var u = 0;
		for (var q=0; q<t.childNodes.length; q++) {
			if (t.childNodes[q].tagName == this.itemTagName) {
				var r = t.childNodes[q];
				var item = {};
				// basic
				item["id"] = this.idPrefix+(r.getAttribute("id")||this._genStr(24));
				item["title"] = r.getAttribute("text")||"";
				// images
				item["imgen"] = r.getAttribute("img")||"";
				item["imgdis"] = r.getAttribute("imgdis")||"";
				item["tip"] = "";
				item["hotkey"] = "";
				// custom css
				if (r.getAttribute("cssNormal") != null) { item["cssNormal"] = r.getAttribute("cssNormal"); }
				// type
				item["type"] = r.getAttribute("type")||"item";
//#menu_checks:06062008{
				if (item["type"] == "checkbox") {
					item["checked"] = (r.getAttribute("checked")!=null);
					// set classname
					item["imgen"] = "chbx_"+(item["checked"]?"1":"0");
					item["imgdis"] = item["imgen"];
				}
//#}
//#menu_radio:06062008{
				if (item["type"] == "radio") {
					item["checked"] = (r.getAttribute("checked")!=null);
					item["imgen"] = "rdbt_"+(item["checked"]?"1":"0");
					item["imgdis"] = item["imgen"];
					item["group"] = r.getAttribute("group")||this._genStr(24);
					if (this.radio[item["group"]]==null) { this.radio[item["group"]] = new Array(); }
					this.radio[item["group"]][this.radio[item["group"]].length] = item["id"];
				}
//#}
				// enable/disable
				item["state"] = (r.getAttribute("enabled")!=null||r.getAttribute("disabled")!=null?(r.getAttribute("enabled")=="false"||r.getAttribute("disabled")=="true"?"disabled":"enabled"):"enabled");
				item["parent"] = (parentId!=null?parentId:this.idPrefix+this.topId);
				// item["complex"] = (((this.dLoad)&&(parentId!=null))?(r.getAttribute("complex")!=null?true:false):(this._buildMenu(r,item["id"])>0));
				item["complex"] = (this.dLoad?(r.getAttribute("complex")!=null?true:false):(this._buildMenu(r,item["id"])>0));
				if (this.dLoad && item["complex"]) { item["loaded"] = "no"; }
				this.itemPull[item["id"]] = item;
				// check for user data
				for (var w=0; w<r.childNodes.length; w++) {
					// added in 0.4
					var tagNm = r.childNodes[w].tagName;
					if (tagNm != null) { tagNm = tagNm.toLowerCase(); }
					//
					if (tagNm == this.userDataTagName) {
						var d = r.childNodes[w];
						if (d.getAttribute("name")!=null) { this.userData[item["id"]+"_"+d.getAttribute("name")] = (d.firstChild!=null&&d.firstChild.nodeValue!=null?d.firstChild.nodeValue:""); }
					}
					// extended text, added in 0.4
					if (tagNm == this.itemTextTagName) { item["title"] = r.childNodes[w].firstChild.nodeValue; }
					// tooltips, added in 0.4
					if (tagNm == this.itemTipTagName) { item["tip"] = r.childNodes[w].firstChild.nodeValue; }
					// hotkeys, added in 0.4
					if (tagNm == this.itemHotKeyTagName) { item["hotkey"] = r.childNodes[w].firstChild.nodeValue; }
					// hrefs
					if (tagNm == this.itemHrefTagName && item["type"] == "item") {
						item["href_link"] = r.childNodes[w].firstChild.nodeValue;
						if (r.childNodes[w].getAttribute("target") != null) { item["href_target"] = r.childNodes[w].getAttribute("target"); }
					}
				}
				u++;
			}
		}
		return u;
	}
	/* parse incoming xml */
	this._xmlParser = function() {
		if (main_self.dLoad) {
			var t = this.getXMLTopNode("menu");
			parentId = (t.getAttribute("parentId")!=null?t.getAttribute("parentId"):null);
			if (parentId == null) {
				// alert(1)
				// main_self.idPrefix = main_self._genStr(12);
				main_self._buildMenu(t, null);
				main_self._initTopLevelMenu();
			} else {
				main_self._buildMenu(t, main_self.idPrefix+parentId);
				main_self._addSubMenuPolygon(main_self.idPrefix+parentId, main_self.idPrefix+parentId);//, main_self.idPull[main_self.idPrefix+parentId]);
				if (main_self.menuSelected == main_self.idPrefix+parentId) {
					var pId = main_self.idPrefix+parentId;
					var isTop = main_self.itemPull[main_self.idPrefix+parentId]["parent"]==main_self.idPrefix+main_self.topId;
					var level = ((isTop&&(!main_self.context))?main_self.dirTopLevel:main_self.dirSubLevel);
					var isShow = false;
					if (isTop && main_self.menuModeTopLevelTimeout && main_self.menuMode == "web" && !main_self.context) {
						var item = main_self.idPull[main_self.idPrefix+parentId];
						if (item._mouseOver == true) {
							var delay = main_self.menuModeTopLevelTimeoutTime - (new Date().getTime()-item._dynLoadTM);
							if (delay > 1) {
								item._menuOpenTM = window.setTimeout(function(){ main_self._showPolygon(pId, level); }, delay);
								isShow = true;
							}
						}
					}
					if (!isShow) { main_self._showPolygon(pId, level); }
				}
				main_self.itemPull[main_self.idPrefix+parentId]["loaded"] = "yes";
				// console.log(main_self.loaderIcon)
				if (main_self.loaderIcon == true) { main_self._updateLoaderIcon(main_self.idPrefix+parentId, false); }
			}
			this.destructor();
			main_self.callEvent("onXLE",[]);
		} else {
			var t = this.getXMLTopNode("menu");
			// alert(3)
			// main_self.idPrefix = main_self._genStr(12);
			main_self._buildMenu(t, null);
			main_self.init();
			main_self.callEvent("onXLE",[]);
			main_self._doOnLoad();
		}
	}
	this._xmlLoader = new dtmlXMLLoaderObject(this._xmlParser, window);
	/* show sublevel item */
	this._showSubLevelItem = function(id,back) {
		if (document.getElementById("arrow_" + this.idPrefix + id) != null) { document.getElementById("arrow_" + this.idPrefix + id).style.display = (back?"none":""); }
		if (document.getElementById("image_" + this.idPrefix + id) != null) { document.getElementById("image_" + this.idPrefix + id).style.display = (back?"none":""); }
		if (document.getElementById(this.idPrefix + id) != null) { document.getElementById(this.idPrefix + id).style.display = (back?"":"none"); }
	}
	/* hide sublevel item */
	this._hideSubLevelItem = function(id) {
		this._showSubLevelItem(id,true)
	}
	// generating id prefix
	this.idPrefix = this._genStr(12);
	
	/* attach body events */
	this._bodyClick = function(e) {
		e = e||event;
		if (e.button == 2 || (_isOpera && e.ctrlKey == true)) return;
		if (main_self.context) {
			if (main_self.contextAutoHide && (!_isOpera || (main_self._isContextMenuVisible() && _isOpera))) main_self._hideContextMenu();
		} else {
			if (main_self._clearAndHide) main_self._clearAndHide();
		}
	}
	this._bodyContext = function(e) {
		e = e||event;
		var t = String((e.srcElement||e.target).className);
		if (t.search("dhtmlxMenu") != -1 && t.search("SubLevelArea") != -1) return;
		var toHide = true;
		var testZone = e.target || e.srcElement;
		while (testZone != null) {
			if (testZone.id != null) if (main_self.isContextZone(testZone.id)) toHide = false;
			if (testZone == document.body) toHide = false;
			testZone = testZone.parentNode;
		}
		if (toHide) main_self.hideContextMenu();
	}
	
	if (typeof(window.addEventListener) != "undefined") {
		window.addEventListener("click", this._bodyClick, false);
		window.addEventListener("contextmenu", this._bodyContext, false);
	} else {
		document.body.attachEvent("onclick", this._bodyClick);
		document.body.attachEvent("oncontextmenu", this._bodyContext);
	}
	
	// add menu to global store
	this._UID = this._genStr(32);
	dhtmlxMenuObjectLiveInstances[this._UID] = this;
	
	/* events */
	dhtmlxEventable(this);
	//
	return this;
}
dhtmlXMenuObject.prototype.init = function() {
	if (this._isInited == true) return;
	if (this.dLoad) {
		this.callEvent("onXLS", []);
		// this._xmlLoader.loadXML(this.dLoadUrl+"?action=loadMenu&parentId="+this.topId+"&topId="+this.topId);
		this._xmlLoader.loadXML(this.dLoadUrl+this.dLoadSign+"action=loadMenu&etc="+new Date().getTime()); // &&parentId=topId&"+this.topId+"&topId="+this.topId);
	} else {
		this._initTopLevelMenu();
		this._isInited = true;
	}
}
dhtmlXMenuObject.prototype._countVisiblePolygonItems = function(id) {
	/*
	var count = 0;
	if ((this.idPull["polygon_"+id] != null) && (this.idPull[id] != null)) {
		for (var q=0; q<this.idPull["polygon_"+id].childNodes.length; q++) {
			var node = this.idPull["polygon_"+id].childNodes[q];
			count += (((node.style.display=="none")||(node.className=="dhtmlxMenu_SubLevelArea_Separator"))?0:1);
		}
	}
	*/
	/* updated in 0.4 */
	var count = 0;
	// console.log(this.idPull)
	for (var a in this.itemPull) {
		//console.log(a)
		var par = this.itemPull[a]["parent"];
		var tp = this.itemPull[a]["type"];
		if (this.idPull[a] != null) {
			// console.log(this.idPull[a])
			// alert(1111)
			if (par == id && (tp == "item" || tp == "radio" || tp == "checkbox") && this.idPull[a].style.display != "none") {
				count++;
			}
		}
	}
	return count;
}
dhtmlXMenuObject.prototype._redefineComplexState = function(id) {
	// alert(id)
	if (this.idPrefix+this.topId == id) { return; }
	if ((this.idPull["polygon_"+id] != null) && (this.idPull[id] != null)) {
		var u = this._countVisiblePolygonItems(id);
		if ((u > 0) && (!this.itemPull[id]["complex"])) { this._updateItemComplexState(id, true, false); }
		if ((u == 0) && (this.itemPull[id]["complex"])) { this._updateItemComplexState(id, false, false); }
	}
}
/* complex arrow manipulations, over added in 0.4 */
dhtmlXMenuObject.prototype._updateItemComplexState = function(id, state, over) {
	// 0.2 FIX :: topLevel's items can have complex items with arrow
	if ((!this.context) && (this._getItemLevelType(id.replace(this.idPrefix,"")) == "TopLevel")) {
		// 30.06.2008 fix > complex state for top level item, state only, no arrow
		this.itemPull[id]["complex"] = state;
		return;
	}
	if ((this.idPull[id] == null) || (this.itemPull[id] == null)) { return; }
	// 0.2 FIX :: end
	this.itemPull[id]["complex"] = state;
	// fixed in 0.4 for context
	if (id == this.idPrefix+this.topId) return;
	// end fix
	// try to retrieve arrow img object
	var arrowObj = null;
	
	
	var item = this.idPull[id].childNodes[this._rtl?0:2];
	if (item.childNodes[0]) if (String(item.childNodes[0].className).search("complex_arrow") === 0) arrowObj = item.childNodes[0];
	
	if (this.itemPull[id]["complex"]) {
		// create arrow
		if (arrowObj == null) {
			arrowObj = document.createElement("DIV");
			arrowObj.className = "complex_arrow";
			arrowObj.id = "arrow_"+id;
			while (item.childNodes.length > 0) item.removeChild(item.childNodes[0]);
			item.appendChild(arrowObj);
		}
		// over state added in 0.4
		
		if (this.dLoad && (this.itemPull[id]["loaded"] == "get") && this.loaderIcon) {
			// change arrow to loader
			if (arrowObj.className != "complex_arrow_loading") arrowObj.className = "complex_arrow_loading";
		} else {
			arrowObj.className = "complex_arrow";
		}
		
		return;
	}
	
	if ((!this.itemPull[id]["complex"]) && (arrowObj!=null)) {
		item.removeChild(arrowObj);
		if (this.itemPull[id]["hotkey_backup"] != null && this.setHotKey) { this.setHotKey(id.replace(this.idPrefix, ""), this.itemPull[id]["hotkey_backup"]); }
	}
	
}

/* return css-part level type */
dhtmlXMenuObject.prototype._getItemLevelType = function(id) {
	return (this.itemPull[this.idPrefix+id]["parent"]==this.idPrefix+this.topId?"TopLevel":"SubLevelArea");
}
/****************************************************************************************************************************************************/
/*								 	"TOPLEVEL" LOW-LEVEL RENDERING						    */
/* redistrib selection in case of top node in real-time mode */
dhtmlXMenuObject.prototype._redistribTopLevelSelection = function(id, parent) {
	// kick polygons and decelect before selected menues
	var i = this._getSubItemToDeselectByPolygon("parent");
	this._removeSubItemFromSelected(-1, -1);
	for (var q=0; q<i.length; q++) {
		if (i[q] != id) { this._hidePolygon(i[q]); }
		if ((this.idPull[i[q]] != null) && (i[q] != id)) { this.idPull[i[q]].className = this.idPull[i[q]].className.replace(/Selected/g, "Normal"); }
	}
	// check if enabled
	if (this.itemPull[this.idPrefix+id]["state"] == "enabled") {
		this.idPull[this.idPrefix+id].className = "dhtmlxMenu_"+this.skin+"_TopLevel_Item_Selected";
		//
		this._addSubItemToSelected(this.idPrefix+id, "parent");
		this.menuSelected = (this.menuMode=="win"?(this.menuSelected!=-1?id:this.menuSelected):id);
		if ((this.itemPull[this.idPrefix+id]["complex"]) && (this.menuSelected != -1)) { this._showPolygon(this.idPrefix+id, this.dirTopLevel); }
	}
}
dhtmlXMenuObject.prototype._initTopLevelMenu = function() {
	// console.log(this.idPull);
	this.dirTopLevel = "bottom";
	this.dirSubLevel = (this._rtl?"left":"right");
	if (this.context) {
		this.idPull[this.idPrefix+this.topId] = new Array(0,0);
		this._addSubMenuPolygon(this.idPrefix+this.topId, this.idPrefix+this.topId);
	} else {
		var m = this._getMenuNodes(this.idPrefix + this.topId);
		for (var q=0; q<m.length; q++) {
			if (this.itemPull[m[q]]["type"] == "item") this._renderToplevelItem(m[q], null);
			if (this.itemPull[m[q]]["type"] == "separator") this._renderSeparator(m[q], null);
		}
	}
}
/* add top menu item, complex define that submenues are in presence */
dhtmlXMenuObject.prototype._renderToplevelItem = function(id, pos) {
	var main_self = this;
	var m = document.createElement("DIV");
	m.id = id;
	// custom css
	if (this.itemPull[id]["state"] == "enabled" && this.itemPull[id]["cssNormal"] != null) {
		m.className = this.itemPull[id]["cssNormal"];
	} else {
		m.className = "dhtmlxMenu_"+this.skin+"_TopLevel_Item_"+(this.itemPull[id]["state"]=="enabled"?"Normal":"Disabled");
	}
	
	// text
	if (this.itemPull[id]["title"] != "") {
		var t1 = document.createElement("DIV");
		t1.className = "top_level_text";
		t1.innerHTML = this.itemPull[id]["title"];
		m.appendChild(t1);
	}
	// tooltip
	if (this.itemPull[id]["tip"].length > 0) m.title = this.itemPull[id]["tip"];
	//
	// image in top level
	if ((this.itemPull[id]["imgen"]!="")||(this.itemPull[id]["imgdis"]!="")) {
		var imgTop=this.itemPull[id][(this.itemPull[id]["state"]=="enabled")?"imgen":"imgdis"];
		if (imgTop) {
			var img = document.createElement("IMG");
			img.border = "0";
			img.id = "image_"+id;
			img.src= this.imagePath+imgTop;
			img.className = "dhtmlxMenu_TopLevel_Item_Icon";
			if (m.childNodes.length > 0 && !this._rtl) m.insertBefore(img, m.childNodes[0]); else m.appendChild(img);
		}
	}
	m.onselectstart = function(e) { e = e || event; e.returnValue = false; return false; }
	m.oncontextmenu = function(e) { e = e || event; e.returnValue = false; return false; }
	// add container for top-level items if not exists yet
	if (!this.cont) {
		this.cont = document.createElement("DIV");
		this.cont.dir = "ltr";
		this.cont.className = (this._align=="right"?"align_right":"align_left");
		this.base.appendChild(this.cont);
	}
	// insert
	/*
	if (pos != null) { pos++; if (pos < 0) pos = 0; if (pos > this.base.childNodes.length - 1) pos = null; }
	if (pos != null) this.base.insertBefore(m, this.base.childNodes[pos]); else this.base.appendChild(m);
	*/
	if (pos != null) { pos++; if (pos < 0) pos = 0; if (pos > this.cont.childNodes.length - 1) pos = null; }
	if (pos != null) this.cont.insertBefore(m, this.cont.childNodes[pos]); else this.cont.appendChild(m);
	
	
	//
	this.idPull[m.id] = m;
	// create submenues
	if (this.itemPull[id]["complex"] && (!this.dLoad)) this._addSubMenuPolygon(this.itemPull[id]["id"], this.itemPull[id]["id"]);
	// events
	m.onmouseover = function() {
		if (main_self.menuMode == "web") { window.clearTimeout(main_self.menuTimeoutHandler); }
		// kick polygons and decelect before selected menues
		var i = main_self._getSubItemToDeselectByPolygon("parent");
		main_self._removeSubItemFromSelected(-1, -1);
		for (var q=0; q<i.length; q++) {
			if (i[q] != this.id) { main_self._hidePolygon(i[q]); }
			if ((main_self.idPull[i[q]] != null) && (i[q] != this.id)) {
				// custom css
				if (main_self.itemPull[i[q]]["cssNormal"] != null) {
					main_self.idPull[i[q]].className = main_self.itemPull[i[q]]["cssNormal"];
				} else {
					if (main_self.idPull[i[q]].className == "sub_item_selected") main_self.idPull[i[q]].className = "sub_item";
					main_self.idPull[i[q]].className = main_self.idPull[i[q]].className.replace(/Selected/g, "Normal");
				}
			}
		}
		// check if enabled
		if (main_self.itemPull[this.id]["state"] == "enabled") {
			this.className = "dhtmlxMenu_"+main_self.skin+"_TopLevel_Item_Selected";
			//
			main_self._addSubItemToSelected(this.id, "parent");
			main_self.menuSelected = (main_self.menuMode=="win"?(main_self.menuSelected!=-1?this.id:main_self.menuSelected):this.id);
			if (main_self.dLoad && (main_self.itemPull[this.id]["loaded"]=="no")) {
				if (main_self.menuModeTopLevelTimeout && main_self.menuMode == "web" && !main_self.context) {
					this._mouseOver = true;
					this._dynLoadTM = new Date().getTime();
				}
				var xmlLoader = new dtmlXMLLoaderObject(main_self._xmlParser, window);
				main_self.itemPull[this.id]["loaded"] = "get";
				main_self.callEvent("onXLS", []);
				xmlLoader.loadXML(main_self.dLoadUrl+main_self.dLoadSign+"action=loadMenu&parentId="+this.id.replace(main_self.idPrefix,"")+"&etc="+new Date().getTime());
			}
			if ((!main_self.dLoad) || (main_self.dLoad && (!main_self.itemPull[this.id]["loaded"] || main_self.itemPull[this.id]["loaded"]=="yes"))) {
				if ((main_self.itemPull[this.id]["complex"]) && (main_self.menuSelected != -1)) {
					if (main_self.menuModeTopLevelTimeout && main_self.menuMode == "web" && !main_self.context) {
						this._mouseOver = true;
						var showItemId = this.id;
						this._menuOpenTM = window.setTimeout(function(){main_self._showPolygon(showItemId, main_self.dirTopLevel);}, main_self.menuModeTopLevelTimeoutTime);
					} else {
						main_self._showPolygon(this.id, main_self.dirTopLevel);
					}
				}
			}
		}
		main_self._doOnTouchMenu(this.id.replace(main_self.idPrefix, ""));
	}
	m.onmouseout = function() {
		if (!((main_self.itemPull[this.id]["complex"]) && (main_self.menuSelected != -1)) && (main_self.itemPull[this.id]["state"]=="enabled")) {
			// custom css
			// console.log(main_self.itemPull[this.id])
			if (main_self.itemPull[this.id]["cssNormal"] != null) {
				// alert(1)
				m.className = main_self.itemPull[this.id]["cssNormal"];
			} else {
				// default css
				m.className = "dhtmlxMenu_"+main_self.skin+"_TopLevel_Item_Normal";
			}
		}
		if (main_self.menuMode == "web") {
			window.clearTimeout(main_self.menuTimeoutHandler);
			main_self.menuTimeoutHandler = window.setTimeout(function(){main_self._clearAndHide();}, main_self.menuTimeoutMsec, "JavaScript");
		}
		if (main_self.menuModeTopLevelTimeout && main_self.menuMode == "web" && !main_self.context) {
			this._mouseOver = false;
			window.clearTimeout(this._menuOpenTM);
		}
	}
	m.onclick = function(e) {
		if (main_self.menuMode == "web") { window.clearTimeout(main_self.menuTimeoutHandler); }
		// fix, added in 0.4
		if (main_self.menuMode != "web" && main_self.itemPull[this.id]["state"] == "disabled") { return; }
		//
		e = e || event;
		e.cancelBubble = true;
		e.returnValue = false;
		
		if (main_self.menuMode == "win") {
			if (main_self.itemPull[this.id]["complex"]) {
				if (main_self.menuSelected == this.id) { main_self.menuSelected = -1; var s = false; } else { main_self.menuSelected = this.id; var s = true; }
				if (s) { main_self._showPolygon(this.id, main_self.dirTopLevel); } else { main_self._hidePolygon(this.id); }
			}
		}
		var tc = (main_self.itemPull[this.id]["complex"]?"c":"-");
		var td = (main_self.itemPull[this.id]["state"]!="enabled"?"d":"-");
		var cas = {"ctrl": e.ctrlKey, "alt": e.altKey, "shift": e.shiftKey};
		main_self._doOnClick(this.id.replace(main_self.idPrefix, ""), tc+td+"t", cas);
		return false;
	}
	
	if (this.skin == "dhx_terrace") {
		this._improveTerraceSkin();
	}
}
/****************************************************************************************************************************************************/
/**
*   @desc: empty function, now more used from 90226
*   @type: public
*/
dhtmlXMenuObject.prototype.setImagePath = function() { /* no more used */ }
/**
*   @desc: defines an url where necessary user embedded icons are located
*   @param: path - url to images
*   @type: public
*/
dhtmlXMenuObject.prototype.setIconsPath = function(path) { this.imagePath = path; }
/**
*   @desc: alias for setIconsPath
*   @type: public
*/
dhtmlXMenuObject.prototype.setIconPath = dhtmlXMenuObject.prototype.setIconsPath;
/* real-time update icon in menu */
dhtmlXMenuObject.prototype._updateItemImage = function(id, levelType) {
	// search existsing image
	
	id = this.idPrefix+id;
	var isTopLevel = (this.itemPull[id]["parent"] == this.idPrefix+this.topId && !this.context);
	
	// search existing image
	var imgObj = null;
	if (isTopLevel) {
		for (var q=0; q<this.idPull[id].childNodes.length; q++) {
			try { if (this.idPull[id].childNodes[q].className == "dhtmlxMenu_TopLevel_Item_Icon") imgObj = this.idPull[id].childNodes[q]; } catch(e) {}
		}
	} else {
		try { var imgObj = this.idPull[id].childNodes[this._rtl?2:0].childNodes[0]; } catch(e) { }
	}
	
	if (this.itemPull[id]["type"] == "radio") {
		var imgSrc = this.itemPull[id][(this.itemPull[id]["state"]=="enabled"?"imgen":"imgdis")];
		// console.log(this.itemPull[this.idPrefix+id])
	} else {
		var imgSrc = this.itemPull[id][(this.itemPull[id]["state"]=="enabled"?"imgen":"imgdis")];
	}
	
	if (imgSrc.length > 0) {
		if (imgObj != null) {
			imgObj.src = this.imagePath+imgSrc;
		} else {
			if (isTopLevel) {
				var imgObj = document.createElement("IMG");
				imgObj.className = "dhtmlxMenu_TopLevel_Item_Icon";
				imgObj.src = this.imagePath+imgSrc;
				imgObj.border = "0";
				imgObj.id = "image_"+id;
				if (!this._rtl && this.idPull[id].childNodes.length > 0) this.idPull[id].insertBefore(imgObj,this.idPull[id].childNodes[0]); else this.idPull[id].appendChild(imgObj);
				
			} else {
				
				var imgObj = document.createElement("IMG");
				imgObj.className = "sub_icon";
				imgObj.src = this.imagePath+imgSrc;
				imgObj.border = "0";
				imgObj.id = "image_"+id;
				var item = this.idPull[id].childNodes[this._rtl?2:0];
				while (item.childNodes.length > 0) item.removeChild(item.childNodes[0]);
				item.appendChild(imgObj);
				
			}
		}
	} else {
		if (imgObj != null) imgObj.parentNode.removeChild(imgObj);
	}
}
/**
*   @desc: removes an item from the menu with all nested sublevels
*   @param: id - id of the item for removing
*   @type: public
*/
dhtmlXMenuObject.prototype.removeItem = function(id, _isTId, _recCall) {
	if (!_isTId) id = this.idPrefix + id;
	
	var pId = null;
	
	if (id != this.idPrefix+this.topId) {
		
		if (this.itemPull[id] == null) return;
		
		// effects
		if (this.idPull["polygon_"+id] && this.idPull["polygon_"+id]._tmShow) window.clearTimeout(this.idPull["polygon_"+id]._tmShow);
		
		// separator top
		var t = this.itemPull[id]["type"];
		
		if (t == "separator") {
			var item = this.idPull["separator_"+id];
			if (this.itemPull[id]["parent"] == this.idPrefix+this.topId) {
				item.onclick = null;
				item.onselectstart = null;
				item.id = null;
				item.parentNode.removeChild(item);
			} else {
				item.childNodes[0].childNodes[0].onclick = null;
				item.childNodes[0].childNodes[0].onselectstart = null;
				item.childNodes[0].childNodes[0].id = null;
				item.childNodes[0].removeChild(item.childNodes[0].childNodes[0]);
				item.removeChild(item.childNodes[0]);
				item.parentNode.removeChild(item);
			}
			this.idPull["separator_"+id] = null;
			this.itemPull[id] = null;
			delete this.idPull["separator_"+id];
			delete this.itemPull[id];
			item = null;
		} else {
			// item checkbox radio
			pId = this.itemPull[id]["parent"];
			var item = this.idPull[id];
			item.onclick = null;
			item.oncontextmenu = null;
			item.onmouseover = null;
			item.onmouseout = null;
			item.onselectstart = null;
			item.id = null;
			while (item.childNodes.length > 0) item.removeChild(item.childNodes[0]);
			item.parentNode.removeChild(item);
			this.idPull[id] = null;
			this.itemPull[id] = null;
			delete this.idPull[id];
			delete this.itemPull[id];
			item = null;
			
		}
		t = null;
	}
	
	// clear nested items
	for (var a in this.itemPull) if (this.itemPull[a]["parent"] == id) this.removeItem(a, true, true);
	
	// check if empty polygon left
	var p2 = new Array(id);
	if (pId != null && !_recCall) {
		if (this.idPull["polygon_"+pId] != null) {
			if (this.idPull["polygon_"+pId].tbd.childNodes.length == 0) {
				p2.push(pId);
				this._updateItemComplexState(pId, false, false);
			}
		}
	}
	
	// delete nested polygons and parent's if any
	for (var q=0; q<p2.length; q++) {
		if (this.idPull["polygon_"+p2[q]]) {
			var p = this.idPull["polygon_"+p2[q]];
			p.onclick = null;
			p.oncontextmenu = null;
			p.tbl.removeChild(p.tbd);
			p.tbd = null;
			p.removeChild(p.tbl);
			p.tbl = null;
			p.id = null;
			p.parentNode.removeChild(p);
			p = null;
			if (this._isIE6) {
				var pc = "polygon_"+p2[q]+"_ie6cover";
				if (this.idPull[pc] != null) { document.body.removeChild(this.idPull[pc]); delete this.idPull[pc]; }
			}
			if (this.idPull["arrowup_"+id] != null && this._removeArrow) this._removeArrow("arrowup_"+id);
			if (this.idPull["arrowdown_"+id] != null && this._removeArrow) this._removeArrow("arrowdown_"+id);
			//
			this.idPull["polygon_"+p2[q]] = null;
			delete this.idPull["polygon_"+p2[q]];
		}
	}
	p2 = null;
	
	// update corners
	if (this.skin == "dhx_terrace" && arguments.length == 1) this._improveTerraceSkin();
	
}
/* collect parents for remove complex item */
dhtmlXMenuObject.prototype._getAllParents = function(id) {
	var parents = new Array();
	for (var a in this.itemPull) {
		if (this.itemPull[a]["parent"] == id) {
			parents[parents.length] = this.itemPull[a]["id"];
			if (this.itemPull[a]["complex"]) {
				var t = this._getAllParents(this.itemPull[a]["id"]);
				for (var q=0; q<t.length; q++) { parents[parents.length] = t[q]; }
			}
		}
	}
	return parents;
}

//#menu_context:06062008{
	
/****************************************************************************************************************************************************/
/*								 	CONTEXT STUFF								    */
/* render dhtmlxMenu as context menu of base object */
/**
*   @desc: renders menu as contextual
*   @type: public
*/
dhtmlXMenuObject.prototype.renderAsContextMenu = function() {
	this.context = true;
	if (this.base._autoSkinUpdate == true) {
		this.base.className = this.base.className.replace("dhtmlxMenu_"+this.skin+"_Middle","");
		this.base._autoSkinUpdate = false;
	}
	if (this.addBaseIdAsContextZone != null) { this.addContextZone(this.addBaseIdAsContextZone); }
}
/**
*   @desc: adds a contextual zone to a contextual menu
*   @param: zoneId - id of the object on page to render as a contextual zone
*   @type: public
*/
dhtmlXMenuObject.prototype.addContextZone = function(zoneId) {
	if (zoneId == document.body) {
		zoneId = "document.body."+this.idPrefix;
		var zone = document.body;
	} else {
		var zone = document.getElementById(zoneId);
	}
	var zoneExists = false;
	for (var a in this.contextZones) { zoneExists = zoneExists || (a == zoneId) || (this.contextZones[a] == zone); }
	if (zoneExists == true) return false;
	this.contextZones[zoneId] = zone;
	var main_self = this;
	if (_isOpera) {
		this.operaContext = function(e){ main_self._doOnContextMenuOpera(e, main_self); }
		zone.addEventListener("mouseup", this.operaContext, false);
		//
	} else {
		if (zone.oncontextmenu != null && !zone._oldContextMenuHandler) zone._oldContextMenuHandler = zone.oncontextmenu;
		zone.oncontextmenu = function(e) {
			// autoclose any other opened context menues
			for (var q in dhtmlxMenuObjectLiveInstances) {
				if (q != main_self._UID) {
					if (dhtmlxMenuObjectLiveInstances[q].context) {
						dhtmlxMenuObjectLiveInstances[q]._hideContextMenu();
					}
				}
			}
			//
			e = e||event;
			e.cancelBubble = true;
			e.returnValue = false;
			main_self._doOnContextBeforeCall(e, this);
			return false;
		}
	}
}
dhtmlXMenuObject.prototype._doOnContextMenuOpera = function(e, main_self) {
	// autoclose any other opened context menues
	for (var q in dhtmlxMenuObjectLiveInstances) {
		if (q != main_self._UID) {
			if (dhtmlxMenuObjectLiveInstances[q].context) {
				dhtmlxMenuObjectLiveInstances[q]._hideContextMenu();
			}
		}
	}
	//
	e.cancelBubble = true;
	e.returnValue = false;
	if (e.button == 0 && e.ctrlKey == true) { main_self._doOnContextBeforeCall(e, this); }
	return false;
}
/**
*   @desc: removes an object from contextual zones list
*   @param: zoneId - id of a contextual zone
*   @type: public
*/
dhtmlXMenuObject.prototype.removeContextZone = function(zoneId) {
	if (!this.isContextZone(zoneId)) return false;
	if (zoneId == document.body) zoneId = "document.body."+this.idPrefix;
	var zone = this.contextZones[zoneId];
	if (_isOpera) {
		zone.removeEventListener("mouseup", this.operaContext, false);
	} else {
		zone.oncontextmenu = (zone._oldContextMenuHandler!=null?zone._oldContextMenuHandler:null);
		zone._oldContextMenuHandler = null;
	}
	try {
		this.contextZones[zoneId] = null;
		delete this.contextZones[zoneId];
 	} catch(e){}
	return true;
}
/**
*   @desc: returns true if an object is used as a contextual zone for the menu
*   @param: zoneId - id of the object to check
*   @type: public
*/
dhtmlXMenuObject.prototype.isContextZone = function(zoneId) {
	if (zoneId == document.body && this.contextZones["document.body."+this.idPrefix] != null) return true;
	var isZone = false;
	if (this.contextZones[zoneId] != null) { if (this.contextZones[zoneId] == document.getElementById(zoneId)) isZone = true; }
	return isZone;
}
dhtmlXMenuObject.prototype._isContextMenuVisible = function() {
	if (this.idPull["polygon_"+this.idPrefix+this.topId] == null) return false;
	return (this.idPull["polygon_"+this.idPrefix+this.topId].style.display == "");
}
dhtmlXMenuObject.prototype._showContextMenu = function(x, y, zoneId) {
	// hide any opened context menu/polygons
	this._clearAndHide();
	// this._hideContextMenu();
	// open
	if (this.idPull["polygon_"+this.idPrefix+this.topId] == null) return false;
	window.clearTimeout(this.menuTimeoutHandler);
	this.idPull[this.idPrefix+this.topId] = new Array(x, y);
	this._showPolygon(this.idPrefix+this.topId, "bottom");
	this.callEvent("onContextMenu", [zoneId]);
}
dhtmlXMenuObject.prototype._hideContextMenu = function() {
	if (this.idPull["polygon_"+this.idPrefix+this.topId] == null) return false;
	this._clearAndHide();
	this._hidePolygon(this.idPrefix+this.topId);
	this.zInd = this.zIndInit;
}
/****************************************************************************************************************************************************/
dhtmlXMenuObject.prototype._doOnContextBeforeCall = function(e, cZone) {
	this.contextMenuZoneId = cZone.id;
	this._clearAndHide();
	this._hideContextMenu();
	
	// scroll settings
	var p = (e.srcElement||e.target);
	var px = (_isIE||_isOpera||_KHTMLrv?e.offsetX:e.layerX);
	var py = (_isIE||_isOpera||_KHTMLrv?e.offsetY:e.layerY);
	var mx = getAbsoluteLeft(p)+px;
	var my = getAbsoluteTop(p)+py;
	
	if (this.checkEvent("onBeforeContextMenu")) {
		if (this.callEvent("onBeforeContextMenu", [cZone.id,e])) {
			if (this.contextAutoShow) {
				this._showContextMenu(mx, my, cZone.id);
				this.callEvent("onAfterContextMenu", [cZone.id,e]);
			}
		}
	} else {
		if (this.contextAutoShow) {
			this._showContextMenu(mx, my, cZone.id);
			this.callEvent("onAfterContextMenu", [cZone.id]);
		}
	}
}
/* public: user call for show/hide context menu */
/**
*   @desc: usercall to show a contextual menu
*   @param: x - position of the menu on x axis
*   @param: y - position of the menu on y axis
*   @type: public
*/
dhtmlXMenuObject.prototype.showContextMenu = function(x, y) {
	this._showContextMenu(x, y, false);
}
/**
*   @desc: usercall to hide a contextual menu
*   @type: public
*/
dhtmlXMenuObject.prototype.hideContextMenu = function() {
	this._hideContextMenu();
}
dhtmlXMenuObject.prototype._autoDetectVisibleArea = function() {
	if (this._isVisibleArea) return;
	//
	this.menuX1 = document.body.scrollLeft;
	this.menuX2 = this.menuX1+(window.innerWidth||document.body.clientWidth);
	this.menuY1 = Math.max((_isIE?document.documentElement:document.getElementsByTagName("html")[0]).scrollTop, document.body.scrollTop);
	// this.menuY2 = this.menuY1+(_isIE?(document.documentElement?Math.max(document.documentElement.clientHeight:document.body.clientHeight):window.innerHeight);
	this.menuY2 = this.menuY1+(_isIE?Math.max(document.documentElement.clientHeight||0,document.documentElement.offsetHeight||0,document.body.clientHeight||0):window.innerHeight);
	
}
/* inner - returns true if prognozided polygon layout off the visible area */
/*dhtmlXMenuObject.prototype._isInVisibleArea = function(x, y, w, h) {
	return ((x >= this.menuX1) && (x+w<=this.menuX2) && (y >= this.menuY1) && (y+h <= this.menuY2));
}*/


//#}

/**
*   @desc: returns item's position in the current polygon
*   @param: id - the item
*   @type: public
*/
dhtmlXMenuObject.prototype.getItemPosition = function(id) {
	id = this.idPrefix+id;
	var pos = -1;
	if (this.itemPull[id] == null) return pos;
	var parent = this.itemPull[id]["parent"];
	// var obj = (this.idPull["polygon_"+parent]!=null?this.idPull["polygon_"+parent].tbd:this.base);
	var obj = (this.idPull["polygon_"+parent]!=null?this.idPull["polygon_"+parent].tbd:this.cont);
	for (var q=0; q<obj.childNodes.length; q++) { if (obj.childNodes[q]==this.idPull["separator_"+id]||obj.childNodes[q]==this.idPull[id]) { pos = q; } }
	return pos;
}

/**
*   @desc: sets new item's position in the current polygon (moves an item inside the single level)
*   @param: id - the item
*   @param: pos - the position (int)
*   @type: public
*/
dhtmlXMenuObject.prototype.setItemPosition = function(id, pos) {
	id = this.idPrefix+id;
	if (this.idPull[id] == null) { return; }
	// added in 0.4
	var isOnTopLevel = (this.itemPull[id]["parent"] == this.idPrefix+this.topId);
	//
	var itemData = this.idPull[id];
	var itemPos = this.getItemPosition(id.replace(this.idPrefix,""));
	var parent = this.itemPull[id]["parent"];
	// var obj = (this.idPull["polygon_"+parent]!=null?this.idPull["polygon_"+parent].tbd:this.base);
	var obj = (this.idPull["polygon_"+parent]!=null?this.idPull["polygon_"+parent].tbd:this.cont);
	obj.removeChild(obj.childNodes[itemPos]);
	if (pos < 0) pos = 0;
	// added in 0.4
	if (isOnTopLevel && pos < 1) { pos = 1; }
	//
	if (pos < obj.childNodes.length) { obj.insertBefore(itemData, obj.childNodes[pos]); } else { obj.appendChild(itemData); }
}

/**
*   @desc: returns parent's id
*   @param: id - the item
*   @type: public
*/
dhtmlXMenuObject.prototype.getParentId = function(id) {
	id = this.idPrefix+id;
	if (this.itemPull[id] == null) { return null; }
	return ((this.itemPull[id]["parent"]!=null?this.itemPull[id]["parent"]:this.topId).replace(this.idPrefix,""));
}
/* public: add item */

/**
*   @desc: adds a new sibling item
*   @param: nextToId - id of the element after which a new one will be inserted
*   @param: itemId - id of a new item
*   @param: itemText - text of a new item
*   @param: disabled - true|false, whether the item is disabled or not
*   @param: img - image for the enabled item
*   @param: imgDis - image for the disabled item
*   @type: public
*/
dhtmlXMenuObject.prototype.addNewSibling = function(nextToId, itemId, itemText, disabled, imgEnabled, imgDisabled) {
	var id = this.idPrefix+(itemId!=null?itemId:this._genStr(24));
	var parentId = this.idPrefix+(nextToId!=null?this.getParentId(nextToId):this.topId);
	// console.log(id, parentId)
	// console.log(id, ",", parentId)
	this._addItemIntoGlobalStrorage(id, parentId, itemText, "item", disabled, imgEnabled, imgDisabled);
	if ((parentId == this.idPrefix+this.topId) && (!this.context)) {
		this._renderToplevelItem(id, this.getItemPosition(nextToId));
	} else {
		this._renderSublevelItem(id, this.getItemPosition(nextToId));
	}
}

/**
*   @desc: adds a new child item
*   @param: parentId - the item which will contain a new item in the sublevel
*   @param: position - the position of a new item
*   @param: itemId - id of a new item
*   @param: itemText - text of a new item
*   @param: disabled - true|false, whether the item is disabled or not
*   @param: img - image for the enabled item
*   @param: imgDis - image for the disabled item
*   @type: public
*/
dhtmlXMenuObject.prototype.addNewChild = function(parentId, pos, itemId, itemText, disabled, imgEnabled, imgDisabled) {
	if (parentId == null) {
		if (this.context) {
			parentId = this.topId;
		} else {
			this.addNewSibling(parentId, itemId, itemText, disabled, imgEnabled, imgDisabled);
			if (pos != null) this.setItemPosition(itemId, pos);
			return;
		}
	}
	itemId = this.idPrefix+(itemId!=null?itemId:this._genStr(24));
	// remove hotkey, added in 0.4
	if (this.setHotKey) this.setHotKey(parentId, "");
	//
	parentId = this.idPrefix+parentId;
	this._addItemIntoGlobalStrorage(itemId, parentId, itemText, "item", disabled, imgEnabled, imgDisabled);
	if (this.idPull["polygon_"+parentId] == null) { this._renderSublevelPolygon(parentId, parentId); }
	this._renderSublevelItem(itemId, pos-1);
	// console.log(parentId)
	this._redefineComplexState(parentId);
}

/* add item to storage */
dhtmlXMenuObject.prototype._addItemIntoGlobalStrorage = function(itemId, itemParentId, itemText, itemType, disabled, img, imgDis) {
	var item = {
		id:	itemId,
		title:	itemText,
		imgen:	(img!=null?img:""),
		imgdis:	(imgDis!=null?imgDis:""),
		type:	itemType,
		state:	(disabled==true?"disabled":"enabled"),
		parent:	itemParentId,
		complex:false,
		hotkey:	"",
		tip:	""};
	this.itemPull[item.id] = item;
}
/* recursively creates and adds submenu polygon */
dhtmlXMenuObject.prototype._addSubMenuPolygon = function(id, parentId) {
	var s = this._renderSublevelPolygon(id, parentId);
	var j = this._getMenuNodes(parentId);
	for (q=0; q<j.length; q++) { if (this.itemPull[j[q]]["type"] == "separator") { this._renderSeparator(j[q], null); } else { this._renderSublevelItem(j[q], null); } }
	if (id == parentId) { var level = "topLevel"; } else { var level = "subLevel"; }
	for (var q=0; q<j.length; q++) { if (this.itemPull[j[q]]["complex"]) { this._addSubMenuPolygon(id, this.itemPull[j[q]]["id"]); } }
}
/* inner: add single subpolygon/item/separator */
dhtmlXMenuObject.prototype._renderSublevelPolygon = function(id, parentId) {
	var s = document.createElement("DIV");
	s.className = "dhtmlxMenu_"+this.skin+"_SubLevelArea_Polygon "+(this._rtl?"dir_right":"");
	s.dir = "ltr";
	s.oncontextmenu = function(e) { e = e||event; e.returnValue = false; e.cancelBubble = true; return false; }
	s.id = "polygon_" + parentId;
	s.onclick = function(e) { e = e || event; e.cancelBubble = true; }
	s.style.display = "none";
	document.body.insertBefore(s, document.body.firstChild);
	//
	var tbl = document.createElement("TABLE");
	tbl.className = "dhtmlxMebu_SubLevelArea_Tbl";
	tbl.cellSpacing = 0;
	tbl.cellPadding = 0;
	tbl.border = 0;
	var tbd = document.createElement("TBODY");
	tbl.appendChild(tbd);
	s.appendChild(tbl);
	s.tbl = tbl;
	s.tbd = tbd;
	// polygon
	this.idPull[s.id] = s;
	if (this.sxDacProc != null) {
		this.idPull["sxDac_" + parentId] = new this.sxDacProc(s, s.className);
		if (_isIE) {
			this.idPull["sxDac_" + parentId]._setSpeed(this.dacSpeedIE);
			this.idPull["sxDac_" + parentId]._setCustomCycle(this.dacCyclesIE);
		} else {
			this.idPull["sxDac_" + parentId]._setSpeed(this.dacSpeed);
			this.idPull["sxDac_" + parentId]._setCustomCycle(this.dacCycles);
		}
	}
	return s;
}
dhtmlXMenuObject.prototype._renderSublevelItem = function(id, pos) {
	var main_self = this;
	
	var tr = document.createElement("TR");
	tr.className = (this.itemPull[id]["state"]=="enabled"?"sub_item":"sub_item_dis");
	
	// icon
	var t1 = document.createElement("TD");
	t1.className = "sub_item_icon";
	var icon = this.itemPull[id][(this.itemPull[id]["state"]=="enabled"?"imgen":"imgdis")];
	if (icon != "") {
		var tp = this.itemPull[id]["type"];
		if (tp=="checkbox"||tp=="radio") {
			var img = document.createElement("DIV");
			img.id = "image_"+this.itemPull[id]["id"];
			img.className = "sub_icon "+icon;
			t1.appendChild(img);
		}
		if (!(tp=="checkbox"||tp=="radio")) {
			var img = document.createElement("IMG");
			img.id = "image_"+this.itemPull[id]["id"];
			img.className = "sub_icon";
			img.src = this.imagePath+icon;
			t1.appendChild(img);
		}
	}
	
	// text
	var t2 = document.createElement("TD");
	t2.className = "sub_item_text";
	if (this.itemPull[id]["title"] != "") {
		var t2t = document.createElement("DIV");
		t2t.className = "sub_item_text";
		t2t.innerHTML = this.itemPull[id]["title"];
		t2.appendChild(t2t);
	} else {
		t2.innerHTML = "&nbsp;";
	}
	
	// hotkey/sublevel arrow
	var t3 = document.createElement("TD");
	t3.className = "sub_item_hk";
	if (this.itemPull[id]["complex"]) {
		
		var arw = document.createElement("DIV");
		arw.className = "complex_arrow";
		arw.id = "arrow_"+this.itemPull[id]["id"];
		t3.appendChild(arw);
		
	} else {
		if (this.itemPull[id]["hotkey"].length > 0 && !this.itemPull[id]["complex"]) {
			var t3t = document.createElement("DIV");
			t3t.className = "sub_item_hk";
			t3t.innerHTML = this.itemPull[id]["hotkey"];
			t3.appendChild(t3t);
		} else {
			t3.innerHTML = "&nbsp;";
		}
	}
	tr.appendChild(this._rtl?t3:t1);
	tr.appendChild(t2);
	tr.appendChild(this._rtl?t1:t3);
	
	
	//
	tr.id = this.itemPull[id]["id"];
	tr.parent = this.itemPull[id]["parent"];
	// tooltip, added in 0.4
	if (this.itemPull[id]["tip"].length > 0) tr.title = this.itemPull[id]["tip"];
	//
	if (!this._hideTMData) this._hideTMData = {};
	
	tr.onselectstart = function(e) { e = e || event; e.returnValue = false; return false; }
	tr.onmouseover = function(e) {
		if (main_self._hideTMData[this.id]) window.clearTimeout(main_self._hideTMData[this.id]);
		if (main_self.menuMode == "web") window.clearTimeout(main_self.menuTimeoutHandler);
		if (!this._visible) main_self._redistribSubLevelSelection(this.id, this.parent); // if not visible
		this._visible = true;
	}
	tr.onmouseout = function() {
		if (main_self.menuMode == "web") {
			if (main_self.menuTimeoutHandler) window.clearTimeout(main_self.menuTimeoutHandler);
			main_self.menuTimeoutHandler = window.setTimeout(function(){if(main_self&&main_self._clearAndHide)main_self._clearAndHide();}, main_self.menuTimeoutMsec, "JavaScript");
		}
		var k = this;
		if (main_self._hideTMData[this.id]) window.clearTimeout(main_self._hideTMData[this.id]);
		main_self._hideTMData[this.id] = window.setTimeout(function(){k._visible=false;}, 50);
	}
	tr.onclick = function(e) {
		// added in 0.4, preven complex closing if user event not defined
		if (!main_self.checkEvent("onClick") && main_self.itemPull[this.id]["complex"]) return;
		//
		e = e || event; e.cancelBubble = true;
		e.returnValue = false;
		tc = (main_self.itemPull[this.id]["complex"]?"c":"-");
		td = (main_self.itemPull[this.id]["state"]=="enabled"?"-":"d");
		var cas = {"ctrl": e.ctrlKey, "alt": e.altKey, "shift": e.shiftKey};
		switch (main_self.itemPull[this.id]["type"]) {
			case "checkbox":
				main_self._checkboxOnClickHandler(this.id.replace(main_self.idPrefix, ""), tc+td+"n", cas);
				break;
			case "radio":
				main_self._radioOnClickHandler(this.id.replace(main_self.idPrefix, ""), tc+td+"n", cas);
				break;
			case "item":
				main_self._doOnClick(this.id.replace(main_self.idPrefix, ""), tc+td+"n", cas);
				break;
		}
		return false;
	}
	// add
	var polygon = this.idPull["polygon_"+this.itemPull[id]["parent"]];
	if (pos != null) { pos++; if (pos < 0) pos = 0; if (pos > polygon.tbd.childNodes.length - 1) pos = null; }
	if (pos != null && polygon.tbd.childNodes[pos] != null) polygon.tbd.insertBefore(tr, polygon.tbd.childNodes[pos]); else polygon.tbd.appendChild(tr);
	this.idPull[tr.id] = tr;
}
/****************************************************************************************************************************************************/
/*								 	SEPARATOR								    */
dhtmlXMenuObject.prototype._renderSeparator = function(id, pos) {
	var level = (this.context?"SubLevelArea":(this.itemPull[id]["parent"]==this.idPrefix+this.topId?"TopLevel":"SubLevelArea"));
	if (level == "TopLevel" && this.context) return;
	
	var main_self = this;
	
	if (level != "TopLevel") {
		var tr = document.createElement("TR");
		tr.className = "sub_sep";
		var td = document.createElement("TD");
		td.colSpan = "3";
		tr.appendChild(td);
	}
	
	var k = document.createElement("DIV");
	k.id = "separator_"+id;
	k.className = (level=="TopLevel"?"top_sep":"sub_sep");
	k.onselectstart = function(e) { e = e || event; e.returnValue = false; }
	k.onclick = function(e) {
		e = e || event; e.cancelBubble = true;
		var cas = {"ctrl": e.ctrlKey, "alt": e.altKey, "shift": e.shiftKey};
		main_self._doOnClick(this.id.replace("separator_" + main_self.idPrefix, ""), "--s", cas);
	}
	if (level == "TopLevel") {
		if (pos != null) {
			pos++; if (pos < 0) { pos = 0; }
			// if (this.base.childNodes[pos] != null) { this.base.insertBefore(k, this.base.childNodes[pos]); } else { this.base.appendChild(k); }
			if (this.cont.childNodes[pos] != null) { this.cont.insertBefore(k, this.cont.childNodes[pos]); } else { this.cont.appendChild(k); }
		} else {
			// add as a last item
			// var last = this.base.childNodes[this.base.childNodes.length-1];
			var last = this.cont.childNodes[this.cont.childNodes.length-1];
			// if (String(last).search("TopLevel_Text") == -1) { this.base.appendChild(k); } else { this.base.insertBefore(k, last); }
			if (String(last).search("TopLevel_Text") == -1) { this.cont.appendChild(k); } else { this.cont.insertBefore(k, last); }
		}
		this.idPull[k.id] = k;
	} else {
		var polygon = this.idPull["polygon_"+this.itemPull[id]["parent"]];
		if (pos != null) { pos++; if (pos < 0) pos = 0; if (pos > polygon.tbd.childNodes.length - 1) pos = null; }
		if (pos != null && polygon.tbd.childNodes[pos] != null) polygon.tbd.insertBefore(tr, polygon.tbd.childNodes[pos]); else polygon.tbd.appendChild(tr);
		td.appendChild(k);
		this.idPull[k.id] = tr;
	}
}
/**
*   @desc: add a new separator
*   @param: nextToId - id of the element after which a new separator will be inserted
*   @param: itemId - id of a new separator
*   @type: public
*/
dhtmlXMenuObject.prototype.addNewSeparator = function(nextToId, itemId) { //, disabled) {
	itemId = this.idPrefix+(itemId!=null?itemId:this._genStr(24));
	var parentId = this.idPrefix+this.getParentId(nextToId);
	// if ((parentId == this.idPrefix+this.topId) && (!this.context)) { return; }
	// this._addItemIntoGlobalStrorage(itemId, parentId, "", "item", disabled, "", "");
	// this._addItemIntoGlobalStrorage(itemId, parentId, "", "item", false, "", "");
	this._addItemIntoGlobalStrorage(itemId, parentId, "", "separator", false, "", "");
	this._renderSeparator(itemId, this.getItemPosition(nextToId));
}
/****************************************************************************************************************************************************/
// hide any opened polygons
/**
*   @desc: hides any open menu polygons
*   @type: public
*/
dhtmlXMenuObject.prototype.hide = function() {
	this._clearAndHide();
}
/**
*   @desc: clear all loaded items
*   @type: public
*/
dhtmlXMenuObject.prototype.clearAll = function() {
	/*
	for (var a in this.itemPull) {
		if (this.itemPull[a]["parent"] == this.idPrefix+this.topId) {
			this.removeItem(String(a).replace(this.idPrefix,""));
		}
	}
	*/
	this.removeItem(this.idPrefix+this.topId, true);
	this._isInited = false;
	this.idPrefix = this._genStr(12);
	this.itemPull = {};
}
/****************************************************************************************************************************************************/
/**
*   @desc: unloads menu from page (destructor)
*   @type: public
*/
dhtmlXMenuObject.prototype.unload = function() {
	
	if (typeof(window.addEventListener) == "function") {
		window.removeEventListener("click", this._bodyClick, false);
		window.removeEventListener("contextmenu", this._bodyContext, false);
	} else {
		document.body.detachEvent("onclick", this._bodyClick);
		document.body.detachEvent("oncontextmenu", this._bodyContext);
	}
	this._bodyClick = null;
	this._bodyContext = null;
	
	// will recursively remove all items
	this.removeItem(this.idPrefix+this.topId, true);
	
	this.itemPull = null;
	this.idPull = null;
	
	// clear context zones
	if (this.context) for (var a in this.contextZones) this.removeContextZone(a);
	
	if (this.cont != null) {
		this.cont.className = "";
		this.cont.parentNode.removeChild(this.cont);
		this.cont = null;
	}
	
	if (this.base != null) {
		this.base.className = "";
		if (!this.context) this.base.oncontextmenu = (this.base._oldContextMenuHandler||null);
		this.base.onselectstart = null;
		this.base = null;
	}
	this.setSkin = null;
	
	this.detachAllEvents();
	
	if (this._xmlLoader) {
		this._xmlLoader.destructor();
		this._xmlLoader = null;
	}
	
	this._align = null;
	this._arrowFFFix = null;
	this._isIE6 = null;
	this._isInited = null;
	this._rtl = null;
	this._scrollDownTMStep = null;
	this._scrollDownTMTime = null;
	this._scrollUpTMStep = null;
	this._scrollUpTMTime = null;
	this._topLevelBottomMargin = null;
	this._topLevelOffsetLeft = null;
	this._topLevelBottomMargin = null;
	this._topLevelRightMargin = null;
	this.addBaseIdAsContextZone = null;
	this.context = null;
	this.contextAutoHide = null;
	this.contextAutoShow = null;
	this.contextHideAllMode = null;
	this.contextMenuZoneId = null;
	this.dLoad = null;
	this.dLoadSign = null;
	this.dLoadUrl = null;
	this.loaderIcon = null;
	this.fixedPosition = null;
	this.dirSubLevel = null;
	this.dirTopLevel = null;
	this.limit = null;
	this.menuSelected = null;
	this.menuLastClicked = null;
	this.idPrefix = null;
	this.imagePath = null;
	this.menuMode = null;
	this.menuModeTopLevelTimeout = null;
	this.menuModeTopLevelTimeoutTime = null;
	this.menuTimeoutHandler = null;
	this.menuTimeoutMsec = null;
	this.menuTouched = null;
	this.isDhtmlxMenuObject = null;
	this.itemHotKeyTagName = null;
	this.itemHrefTagName = null;
	this.itemTagName = null;
	this.itemTextTagName = null;
	this.itemTipTagName = null;
	this.userDataTagName = null;
	this.skin = null;
	this.topId = null;
	this.dacCycles = null;
	this.dacCyclesIE = null;
	this.dacSpeed = null;
	this.dacSpeedIE = null;
	this.zInd = null;
	this.zIndInit = null;
	this.zIndStep = null;
	
	//
	// unload basic methods
	
	this._enableDacSupport = null;
	this._selectedSubItems = null;
	this._openedPolygons = null;
	this._addSubItemToSelected = null;
	this._removeSubItemFromSelected = null;
	this._getSubItemToDeselectByPolygon = null;
	this._hidePolygon = null;
	this._showPolygon = null;
	this._redistribSubLevelSelection = null;
	this._doOnClick = null;
	this._doOnTouchMenu = null;
	this._searchMenuNode = null;
	this._getMenuNodes = null;
	this._genStr = null;
	this._clearAndHide = null;
	this._doOnLoad = null;
	this.getItemType = null;
	this.forEachItem = null;
	this.init = null;
	this.loadXML = null;
	this.loadXMLString = null;
	this._buildMenu = null;
	this._xmlParser = null;
	this._showSubLevelItem = null;
	this._hideSubLevelItem = null;
	this._countVisiblePolygonItems = null;
	this._redefineComplexState = null;
	this._updateItemComplexState = null;
	this._getItemLevelType = null;
	this._redistribTopLevelSelection = null;
	this._initTopLevelMenu = null;
	this._renderToplevelItem = null;
	this.setImagePath = null;
	this.setIconsPath = null;
	this.setIconPath = null;
	this._updateItemImage = null;
	this.removeItem = null;
	this._getAllParents = null;
	this.renderAsContextMenu = null;
	this.addContextZone = null;
	this.removeContextZone = null;
	this.isContextZone = null;
	this._isContextMenuVisible = null;
	this._showContextMenu = null;
	this._doOnContextBeforeCall = null;
	this._autoDetectVisibleArea = null;
	this._addItemIntoGlobalStrorage = null;
	this._addSubMenuPolygon = null;
	this._renderSublevelPolygon = null;
	this._renderSublevelItem = null;
	this._renderSeparator = null;
	this._hideContextMenu = null;
	this.clearAll = null;
	this.getItemPosition = null;
	this.setItemPosition = null;
	this.getParentId = null;
	this.addNewSibling = null;
	this.addNewChild = null;
	this.addNewSeparator = null;
	this.attachEvent = null;
	this.callEvent = null;
	this.checkEvent = null;
	this.eventCatcher = null;
	this.detachEvent = null;
	this.dhx_Event = null;
	this.unload = null;
	this.items = null;
	this.radio = null;
	this.detachAllEvents = null;
	this.hide = null;
	this.showContextMenu = null;
	this.hideContextMenu = null;
	
	
	// unload extended methods
	this._changeItemState = null;
	this._changeItemVisible = null;
	this._updateLoaderIcon = null;
	this._clearAllSelectedSubItemsInPolygon = null;
	this._checkArrowsState = null;
	this._addUpArrow = null;
	this._addDownArrow = null;
	this._removeUpArrow = null;
	this._removeDownArrow = null;
	this._isArrowExists = null;
	this._doScrollUp = null;
	this._doScrollDown = null;
	this._countPolygonItems = null;
	this._getRadioImgObj = null;
	this._setRadioState = null;
	this._radioOnClickHandler = null;
	this._getCheckboxState = null;
	this._setCheckboxState = null;
	this._readLevel = null;
	this._updateCheckboxImage = null;
	this._checkboxOnClickHandler = null;
	this._removeArrow = null;
	this.setItemEnabled = null;
	this.setItemDisabled = null;
	this.isItemEnabled = null;
	this.getItemText = null;
	this.setItemText = null;
	this.loadFromHTML = null;
	this.hideItem = null;
	this.showItem = null;
	this.isItemHidden = null;
	this.setUserData = null;
	this.getUserData = null;
	this.setOpenMode = null;
	this.setWebModeTimeout = null;
	this.enableDynamicLoading = null;
	this.getItemImage = null;
	this.setItemImage = null;
	this.clearItemImage = null;
	this.setAutoShowMode = null;
	this.setAutoHideMode = null;
	this.setContextMenuHideAllMode = null;
	this.getContextMenuHideAllMode = null;
	this.setVisibleArea = null;
	this.setTooltip = null;
	this.getTooltip = null;
	this.setHotKey = null;
	this.getHotKey = null;
	this.setItemSelected = null;
	this.setTopText = null;
	this.setRTL = null;
	this.setAlign = null;
	this.setHref = null;
	this.clearHref = null;
	this.getCircuit = null;
	this.contextZones = null;
	this.setOverflowHeight = null;
	this.userData = null;
	this.getRadioChecked = null;
	this.setRadioChecked = null;
	this.addRadioButton = null;
	this.setCheckboxState = null;
	this.getCheckboxState = null;
	this.addCheckbox = null;
	this.serialize = null;
	
	
	this.extendedModule = null;
	
	// remove menu from global store
	dhtmlxMenuObjectLiveInstances[this._UID] = null;
	try { delete dhtmlxMenuObjectLiveInstances[this._UID]; } catch(e) {}
	this._UID = null;
	
}
// dhtmlxmenu global store
var dhtmlxMenuObjectLiveInstances = {};

dhtmlXMenuObject.prototype.i18n = {
	dhxmenuextalert: "dhtmlxmenu_ext.js required"
};

//menu
(function(){
	dhtmlx.extend_api("dhtmlXMenuObject",{
		_init:function(obj){
			return [obj.parent, obj.skin];
		},
		align:"setAlign",
		top_text:"setTopText",
		context:"renderAsContextMenu",
		icon_path:"setIconsPath",
		open_mode:"setOpenMode",
		rtl:"setRTL",
		skin:"setSkin",
		dynamic:"enableDynamicLoading",
		xml:"loadXML",
		items:"items",
		overflow:"setOverflowHeight"
	},{
		items:function(arr,parent){
			var pos = 100000;
			var lastItemId = null;
			for (var i=0; i < arr.length; i++) {
				var item=arr[i];
				if (item.type == "separator") {
					this.addNewSeparator(lastItemId, pos, item.id);
					lastItemId = item.id;
				} else {
					this.addNewChild(parent, pos, item.id, item.text, item.disabled, item.img, item.img_disabled);
					lastItemId = item.id;
					if (item.items) this.items(item.items,item.id);
				}
			}
		}
	});
})();

// terrace
dhtmlXMenuObject.prototype._improveTerraceSkin = function() {
	
	for (var a in this.itemPull) {
		
		if (this.itemPull[a].parent == this.idPrefix+this.topId && this.idPull[a] != null) { // this.idPull[a] will null for separator
			
			var bl = false;
			var br = false;
			
			// left side, first item, not sep
			if (this.idPull[a].parentNode.firstChild == this.idPull[a]) {
				bl = true;
			}
			
			// right side, last item, not sep
			if (this.idPull[a].parentNode.lastChild == this.idPull[a]) {
				br = true;
			}
			
			// check siblings
			for (var b in this.itemPull) {
				if (this.itemPull[b].type == "separator" && this.itemPull[b].parent == this.idPrefix+this.topId) {
					if (this.idPull[a].nextSibling == this.idPull["separator_"+b]) {
						br = true;
					}
					if (this.idPull[a].previousSibling == this.idPull["separator_"+b]) {
						bl = true;
					}
				}
			}
			
			this.idPull[a].style.borderLeft = (bl?"1px solid #cecece":"0px solid white");
			this.idPull[a].style.borderTopLeftRadius = this.idPull[a].style.borderBottomLeftRadius = (bl?"5px":"0px");
			
			this.idPull[a].style.borderTopRightRadius = this.idPull[a].style.borderBottomRightRadius = (br?"5px":"0px");
			
			this.idPull[a]._bl = bl;
			this.idPull[a]._br = br;
			
		}
	}
	
};

dhtmlXMenuObject.prototype._improveTerraceButton = function(id, state) {
	if (state) {
		this.idPull[id].style.borderBottomLeftRadius = (this.idPull[id]._bl ? "5px" : "0px");
		this.idPull[id].style.borderBottomRightRadius = (this.idPull[id]._br ? "5px" : "0px");
	} else {
		this.idPull[id].style.borderBottomLeftRadius = "0px";
		this.idPull[id].style.borderBottomRightRadius = "0px";
	}
};
//v.3.6 build 131108

/*
Copyright DHTMLX LTD. http://www.dhtmlx.com
To use this component please contact sales@dhtmlx.com to obtain license
*/
/****************************************************************************************************************************************************/
/*								 	EXTENDED MODULE INFO							    */
dhtmlXMenuObject.prototype.extendedModule = "DHXMENUEXT";
/****************************************************************************************************************************************************/
/*								 	ENABLING/DISBLING							    */
/**
*   @desc: enables an item
*   @param: id - item's id to enable
*   @param: state - true|false
*   @type: public
*/
dhtmlXMenuObject.prototype.setItemEnabled = function(id) {
	// modified in 0.4
	this._changeItemState(id, "enabled", this._getItemLevelType(id));
}
/**
*   @desc: disables an item
*   @param: id - item's id to disablei
*   @type: public
*/
dhtmlXMenuObject.prototype.setItemDisabled = function(id) {
	this._changeItemState(id, "disabled", this._getItemLevelType(id));
}
/**
*   @desc: returns true if the item is enabled
*   @param: id - the item to check
*   @type: public
*/
dhtmlXMenuObject.prototype.isItemEnabled = function(id) {
	return (this.itemPull[this.idPrefix+id]!=null?(this.itemPull[this.idPrefix+id]["state"]=="enabled"):false);
}
/* enable/disable sublevel item */
dhtmlXMenuObject.prototype._changeItemState = function(id, newState, levelType) {
	var t = false;
	var j = this.idPrefix + id;
	if ((this.itemPull[j] != null) && (this.idPull[j] != null)) {
		if (this.itemPull[j]["state"] != newState) {
			this.itemPull[j]["state"] = newState;
			if (this.itemPull[j]["parent"] == this.idPrefix+this.topId && !this.context) {
				this.idPull[j].className = "dhtmlxMenu_"+this.skin+"_TopLevel_Item_"+(this.itemPull[j]["state"]=="enabled"?"Normal":"Disabled");
			} else {
				this.idPull[j].className = "sub_item"+(this.itemPull[j]["state"]=="enabled"?"":"_dis");
			}
			
			this._updateItemComplexState(this.idPrefix+id, this.itemPull[this.idPrefix+id]["complex"], false);
			this._updateItemImage(id, levelType);
			// if changeItemState attached to onClick event and changing applies to selected item all selection should be reparsed
			if ((this.idPrefix + this.menuLastClicked == j) && (levelType != "TopLevel")) {
				this._redistribSubLevelSelection(j, this.itemPull[j]["parent"]);
			}
			if (levelType == "TopLevel" && !this.context) { // rebuild style.left and show nested polygons
				// this._redistribTopLevelSelection(id, "parent");
			}
		}
	}
	return t;
}
/****************************************************************************************************************************************************/
/*								 	SET/GET TEXT								    */
/**
*   @desc: returns item's text
*   @param: id - the item
*   @type: public
*/
dhtmlXMenuObject.prototype.getItemText = function(id) {
	return (this.itemPull[this.idPrefix+id]!=null?this.itemPull[this.idPrefix+id]["title"]:"");
}

/**
*   @desc: sets text for the item
*   @param: id - the item
*   @param: text - a new text
*   @type: public
*/
dhtmlXMenuObject.prototype.setItemText = function(id, text) {
	id = this.idPrefix + id;
	if ((this.itemPull[id] != null) && (this.idPull[id] != null)) {
		this._clearAndHide();
		this.itemPull[id]["title"] = text;
		if (this.itemPull[id]["parent"] == this.idPrefix+this.topId && !this.context) {
			// top level
			var tObj = null;
			for (var q=0; q<this.idPull[id].childNodes.length; q++) {
				try { if (this.idPull[id].childNodes[q].className == "top_level_text") tObj = this.idPull[id].childNodes[q]; } catch(e) {}
			}
			if (String(this.itemPull[id]["title"]).length == "" || this.itemPull[id]["title"] == null) {
				if (tObj != null) tObj.parentNode.removeChild(tObj);
			} else {
				if (!tObj) {
					tObj = document.createElement("DIV");
					tObj.className = "top_level_text";
					if (this._rtl && this.idPull[id].childNodes.length > 0) this.idPull[id].insertBefore(tObj,this.idPull[id].childNodes[0]); else this.idPull[id].appendChild(tObj);
				}
				tObj.innerHTML = this.itemPull[id]["title"];
			}
		} else {
			// sub level
			var tObj = null;
			for (var q=0; q<this.idPull[id].childNodes[1].childNodes.length; q++) {
				if (String(this.idPull[id].childNodes[1].childNodes[q].className||"") == "sub_item_text") tObj = this.idPull[id].childNodes[1].childNodes[q];
			}
			if (String(this.itemPull[id]["title"]).length == "" || this.itemPull[id]["title"] == null) {
				if (tObj) {
					tObj.parentNode.removeChild(tObj);
					tObj = null;
					this.idPull[id].childNodes[1].innerHTML = "&nbsp;";
				}
			} else {
				if (!tObj) {
					tObj = document.createElement("DIV");
					tObj.className = "sub_item_text";
					this.idPull[id].childNodes[1].innerHTML = "";
					this.idPull[id].childNodes[1].appendChild(tObj);
				}
				tObj.innerHTML = this.itemPull[id]["title"];
			}
		}
	}
}
/****************************************************************************************************************************************************/
/**
*   @desc: loads menu data from an html and calls onLoadFunction when loading is done
*   @param: object - html data container
*   @param: clearAfterAdd - true|false, removes the container object after the data is loaded
*   @param: onLoadFunction - is called after the data is loaded (but before clearing html content if clear is set to true)
*   @type: public
*/
dhtmlXMenuObject.prototype.loadFromHTML = function(objId, clearAfterAdd, onLoadFunction) {
	//alert(4)
	// this.idPrefix = this._genStr(12);
	this.itemTagName = "DIV";
	if (typeof(objId) == "string") { objId = document.getElementById(objId); }
	this._buildMenu(objId, null);
	this.init();
	if (clearAfterAdd) { objId.parentNode.removeChild(objId); }
	if (onLoadFunction != null) { onLoadFunction(); }
}
/****************************************************************************************************************************************************/
/*								 	SHOW/HIDE								    */
/**
*   @desc: hides an item
*   @param: id - the item to hide
*   @type: public
*/
dhtmlXMenuObject.prototype.hideItem = function(id) {
	this._changeItemVisible(id, false);
}
/**
*   @desc: shows an item
*   @param: id - the item to show
*   @type: public
*/
dhtmlXMenuObject.prototype.showItem = function(id) {
	this._changeItemVisible(id, true);
}
/**
*   @desc: returns true if the item is hidden
*   @param: id - the item to check
*   @type: public
*/
dhtmlXMenuObject.prototype.isItemHidden = function(id) {
	var isHidden = null;
	if (this.idPull[this.idPrefix+id] != null) { isHidden = (this.idPull[this.idPrefix+id].style.display == "none"); }
	return isHidden;
}
/* show/hide item in menu, optimized for version 0.3 */
dhtmlXMenuObject.prototype._changeItemVisible = function(id, visible) {
	var itemId = this.idPrefix+id;
	if (this.itemPull[itemId] == null) return;
	if (this.itemPull[itemId]["type"] == "separator") { itemId = "separator_"+itemId; }
	if (this.idPull[itemId] == null) return;
	this.idPull[itemId].style.display = (visible?"":"none");
	this._redefineComplexState(this.itemPull[this.idPrefix+id]["parent"]);
}
/****************************************************************************************************************************************************/
/*								 	USERDATA								    */
//#menu_userdata:06062008{
/**
*   @desc: sets userdata for an item
*   @param: id - the item
*   @param: name - the name of userdata (string)
*   @param: value - the value of userdata (usually string)
*   @type: public
*/
dhtmlXMenuObject.prototype.setUserData = function(id, name, value) {
	this.userData[this.idPrefix+id+"_"+name] = value;
}

/**
*   @desc: returns item's userdata
*   @param: id - the item
*   @param: name - the name of userdata (string)
*   @type: public
*/
dhtmlXMenuObject.prototype.getUserData = function(id, name) {
	return (this.userData[this.idPrefix+id+"_"+name]!=null?this.userData[this.idPrefix+id+"_"+name]:null);
}
//#}
/****************************************************************************************************************************************************/
/*								 	OPENMODE/TIMEOUT							    */
/**
*   @desc: sets open mode for the menu
*   @param: mode - win|web, the default mode is web, in the win mode a user should click anywhere to hide the menu, in the web mode - just put the mouse pointer out of the menu area
*   @type: public
*/
dhtmlXMenuObject.prototype.setOpenMode = function(mode) {
	if (mode == "win" || mode == "web") this.menuMode = mode; else this.menuMode == "web"; 
}
/**
*   @desc: sets hide menu timeout (web mode only)
*   @param: tm - timeout, ms, 400 default
*   @type: public
*/
dhtmlXMenuObject.prototype.setWebModeTimeout = function(tm) {
	this.menuTimeoutMsec = (!isNaN(tm)?tm:400);
}
/****************************************************************************************************************************************************/
/*								 	DYNAMICAL LOADING							    */
/**
*   @desc: enables dynamic loading of sublevels
*   @param: url - server-side script, transmitted params are action=loadMenu and parentId 
*   @param: icon - true|false, replaces elemet's arrow with loading image while loading
*   @type: public
*/
dhtmlXMenuObject.prototype.enableDynamicLoading = function(url, icon) {
	this.dLoad = true;
	this.dLoadUrl = url;
	this.dLoadSign = (String(this.dLoadUrl).search(/\?/)==-1?"?":"&");
	this.loaderIcon = icon;
	this.init();
}
/* internal, show/hide loader icon */
dhtmlXMenuObject.prototype._updateLoaderIcon = function(id, state) {
	
	if (this.idPull[id] == null) return;
	if (String(this.idPull[id].className).search("TopLevel_Item") >= 0) return;
	// get arrow
	var ind = (this._rtl?0:2);
	if (!this.idPull[id].childNodes[ind]) return;
	if (!this.idPull[id].childNodes[ind].childNodes[0]) return;
	var aNode = this.idPull[id].childNodes[ind].childNodes[0];
	if (String(aNode.className).search("complex_arrow") === 0) aNode.className = "complex_arrow"+(state?"_loading":"");

}
/****************************************************************************************************************************************************/
/*								 	IMAGES									    */
/**
*   @desc: returns item's image - array(img, imgDis)
*   @param: id - the item
*   @type: public
*/
dhtmlXMenuObject.prototype.getItemImage = function(id) {
	var imgs = new Array(null, null);
	id = this.idPrefix+id;
	if (this.itemPull[id]["type"] == "item") {
		imgs[0] = this.itemPull[id]["imgen"];
		imgs[1] = this.itemPull[id]["imgdis"];
	}
	return imgs;
}
/**
*   @desc: sets an image for the item
*   @param: id - the item
*   @param: img - the image for the enabled item (empty string for none)
*   @param: imgDis - the image for the disabled item (empty string for none)
*   @type: public
*/
dhtmlXMenuObject.prototype.setItemImage = function(id, img, imgDis) {
	if (this.itemPull[this.idPrefix+id]["type"] != "item") return;
	this.itemPull[this.idPrefix+id]["imgen"] = img;
	this.itemPull[this.idPrefix+id]["imgdis"] = imgDis;
	this._updateItemImage(id, this._getItemLevelType(id));
}
/**
*   @desc: removes both enabled and disabled item images
*   @param: id - the item
*   @type: public
*/
dhtmlXMenuObject.prototype.clearItemImage = function(id) {
	this.setItemImage(id, "", "");
}
/****************************************************************************************************************************************************/
/*								 	CONTEXT STUFF								    */
/* public: context menu auto open/close enable/disable */
/**
*   @desc: sets to false to prevent showing a contextual menu by a click
*   @param: mode - true/false
*   @type: public
*/
dhtmlXMenuObject.prototype.setAutoShowMode = function(mode) {
	this.contextAutoShow = (mode==true?true:false);
}
/**
*   @desc: sets to false to prevent hiding a contextual menu by a click
*   @param: mode - true/false
*   @type: public
*/
dhtmlXMenuObject.prototype.setAutoHideMode = function(mode) {
	this.contextAutoHide = (mode==true?true:false);
}

/**
*   @desc: sets to true will hide all opened contextual menu polygons on mouseout
*   @param: mode - true/false
*   @type: public
*/
dhtmlXMenuObject.prototype.setContextMenuHideAllMode = function(mode) {
	this.contextHideAllMode = (mode==true?true:false);
}
/**
*   @desc: retutn hide all contextual menu mode
*   @type: public
*/
dhtmlXMenuObject.prototype.getContextMenuHideAllMode = function() {
	return this.contextHideAllMode;
}
/****************************************************************************************************************************************************/
/*								 	VISIBLE AREA								    */
/**
*   @desc: sets the area in which the menu can appear, if the area is not set, the menu will occupy all available visible space
*   @param: x1, x2 - int, leftmost and rightmost coordinates by x axis
*   @param: y1, y2 - int, topmost and bottommost coordinates by y axis
*   @type: public
*/
dhtmlXMenuObject.prototype.setVisibleArea = function(x1, x2, y1, y2) {
	this._isVisibleArea = true;
	this.menuX1 = x1;
	this.menuX2 = x2;
	this.menuY1 = y1;
	this.menuY2 = y2;
}
/****************************************************************************************************************************************************/
/*								 	TOOLTOPS								    */
// tooltips, added in 0.4
/**
*   @desc: sets tooltip for a menu item
*   @param: id - menu item's id
*   @param: tip - tooltip
*   @type: public
*/
dhtmlXMenuObject.prototype.setTooltip = function(id, tip) {
	id = this.idPrefix+id;
	if (!(this.itemPull[id] != null && this.idPull[id] != null)) return;
	this.idPull[id].title = (tip.length > 0 ? tip : null);
	this.itemPull[id]["tip"] = tip;
}
/**
*   @desc: returns tooltip of a menu item
*   @param: id - menu item's id
*   @type: public
*/
dhtmlXMenuObject.prototype.getTooltip = function(id) {
	if (this.itemPull[this.idPrefix+id] == null) return null;
	return this.itemPull[this.idPrefix+id]["tip"];
}
/****************************************************************************************************************************************************/
/*								 	HOTKEYS									    */
//#menu_hotkey:06062008#{
// hot-keys, added in 0.4
/**
*   @desc: sets menu hot-key (just text label)
*   @param: id - menu item's id
*   @param: hkey - hot-key text
*   @type: public
*/
dhtmlXMenuObject.prototype.setHotKey = function(id, hkey) {
	
	id = this.idPrefix+id;
	
	if (!(this.itemPull[id] != null && this.idPull[id] != null)) return;
	if (this.itemPull[id]["parent"] == this.idPrefix+this.topId && !this.context) return;
	if (this.itemPull[id]["complex"]) return;
	var t = this.itemPull[id]["type"];
	if (!(t == "item" || t == "checkbox" || t == "radio")) return;
	
	// retrieve obj
	var hkObj = null;
	try { if (this.idPull[id].childNodes[this._rtl?0:2].childNodes[0].className == "sub_item_hk") hkObj = this.idPull[id].childNodes[this._rtl?0:2].childNodes[0]; } catch(e){}
	
	if (hkey.length == 0) {
		// remove if exists
		this.itemPull[id]["hotkey_backup"] = this.itemPull[id]["hotkey"];
		this.itemPull[id]["hotkey"] = "";
		if (hkObj != null) hkObj.parentNode.removeChild(hkObj);
		
	} else {
		
		// add if needed or change
		this.itemPull[id]["hotkey"] = hkey;
		this.itemPull[id]["hotkey_backup"] = null;
		//
		if (hkObj == null) {
			hkObj = document.createElement("DIV");
			hkObj.className = "sub_item_hk";
			var item = this.idPull[id].childNodes[this._rtl?0:2];
			while (item.childNodes.length > 0) item.removeChild(item.childNodes[0]);
			item.appendChild(hkObj);
		}
		hkObj.innerHTML = hkey;

	}
}
/**
*   @desc: returns item's hot-key (just text label)
*   @param: id - menu item's id
*   @type: public
*/
dhtmlXMenuObject.prototype.getHotKey = function(id) {
	if (this.itemPull[this.idPrefix+id] == null) return null;
	return this.itemPull[this.idPrefix+id]["hotkey"];
}
/****************************************************************************************************************************************************/
/*								 	MISC									    */
//#}
/* set toplevel item selected */
dhtmlXMenuObject.prototype.setItemSelected = function(id) {
	if (this.itemPull[this.idPrefix+id] == null) return null;
	// console.log(this.itemPull[this.idPrefix+id]);
	
}
/**
*   @desc: set top level additional text (in case of usual menubar)
*   @param: text - text
*   @type: public
*/
dhtmlXMenuObject.prototype.setTopText = function(text) {
	if (this.context) return;
	if (this._topText == null) {
		this._topText = document.createElement("DIV");
		this._topText.className = "dhtmlxMenu_TopLevel_Text_"+(this._rtl?"left":(this._align=="left"?"right":"left"));
		this.base.appendChild(this._topText);
	}
	this._topText.innerHTML = text;
}
/**
*   @desc: set top level menu align
*   @param: align - left|right
*   @type: public
*/
dhtmlXMenuObject.prototype.setAlign = function(align) {
	if (this._align == align) return;
	if (align == "left" || align == "right") {
		// if (this.setRTL) this.setRTL(false);
		this._align = align;
		if (this.cont) this.cont.className = (this._align=="right"?"align_right":"align_left");
		if (this._topText != null) this._topText.className = "dhtmlxMenu_TopLevel_Text_"+(this._align=="left"?"right":"left");
	}
}
/**
*   @desc: set href to item, overwrite old if exists
*   @param: itemId
*   @param: href - url to open instead of onClik event handling
*   @param: target - target attribute
*   @type: public
*/
dhtmlXMenuObject.prototype.setHref = function(itemId, href, target) {
	if (this.itemPull[this.idPrefix+itemId] == null) return;
	this.itemPull[this.idPrefix+itemId]["href_link"] = href;
	if (target != null) this.itemPull[this.idPrefix+itemId]["href_target"] = target;
}
/**
*   @desc: clears item href and back item to default onClick behavior
*   @param: itemId
*   @type: public
*/
dhtmlXMenuObject.prototype.clearHref = function(itemId) {
	if (this.itemPull[this.idPrefix+itemId] == null) return;
	delete this.itemPull[this.idPrefix+itemId]["href_link"];
	delete this.itemPull[this.idPrefix+itemId]["href_target"];
}
/*
File [id="file"] -> Open [id="open"] -> Last Save [id="lastsave"]
getCircuit("lastsave") will return Array("file", "open", "lastsave");
*/
/**
*   @desc: return array with ids from topmost parent to chosen item
*   @param: id - chosen item id
*   @type: public
*/
dhtmlXMenuObject.prototype.getCircuit = function(id) {
	var parents = new Array(id);
	while (this.getParentId(id) != this.topId) {
		id = this.getParentId(id);
		parents[parents.length] = id;
	}
	return parents.reverse();
}
/* export to function */
/* WTF?
dhtmlXMenuObject.prototype.generateSQL = function() {
	var sql = "INSERT INTO `dhtmlxmenu_demo` (`itemId`, `itemParentId`, `itemOrder`, `itemText`, `itemType`, `itemEnabled`, `itemChecked`, `itemGroup`, `itemImage`, `itemImageDis`) VALUES ";
	var values = "";
	var q = 0;
	for (var a in this.itemPull) {
		values += (values.length>0?", ":"")+"('"+a.replace(this.idPrefix,"")+"',"+
						     "'"+(this.itemPull[a]["parent"]!=null?this.itemPull[a]["parent"].replace(this.idPrefix,""):"")+"',"+
						     "'"+(q++)+"',"+
						     "'"+this.itemPull[a]["title"]+"',"+
						     "'"+(this.itemPull[a]["type"]!="item"?this.itemPull[a]["type"]:"")+"',"+
						     "'"+(this.itemPull[a]["state"]=="enabled"?"1":"0")+"',"+
						     "'"+(this.itemPull[a]["checked"]!=null?(this.itemPull[a]["checked"]?"1":"0"):"0")+"',"+
						     "'"+(this.itemPull[a]["group"]!=null?this.itemPull[a]["group"]:"")+"',"+
						     "'"+this.itemPull[a]["imgen"]+"',"+
						     "'"+this.itemPull[a]["imgdis"]+"')";
	}
	return sql+values;
}
*/
//#menu_overflow:06062008#{
/****************************************************************************************************************************************************/
/*								 	OVERFLOW								    */
/* clear all selected subitems in polygon, implemented in 0.4 */
dhtmlXMenuObject.prototype._clearAllSelectedSubItemsInPolygon = function(polygon) {
	var subIds = this._getSubItemToDeselectByPolygon(polygon);
	// hide opened polygons and selected items
	for (var q=0; q<this._openedPolygons.length; q++) { if (this._openedPolygons[q] != polygon) { this._hidePolygon(this._openedPolygons[q]); } }
	for (var q=0; q<subIds.length; q++) { if (this.idPull[subIds[q]] != null) { if (this.itemPull[subIds[q]]["state"] == "enabled") { this.idPull[subIds[q]].className = "dhtmlxMenu_"+this.skin+"_SubLevelArea_Item_Normal"; } } }
}
/* define normal/disabled arrows in polygon */
dhtmlXMenuObject.prototype._checkArrowsState = function(id) {
	var polygon = this.idPull["polygon_"+id];
	var arrowUp = this.idPull["arrowup_"+id];
	var arrowDown = this.idPull["arrowdown_"+id];
	if (polygon.scrollTop == 0) {
		arrowUp.className = "dhtmlxMenu_"+this.skin+"_SubLevelArea_ArrowUp_Disabled";
	} else {
		arrowUp.className = "dhtmlxMenu_"+this.skin+"_SubLevelArea_ArrowUp" + (arrowUp.over ? "_Over" : "");
	}
	if (polygon.scrollTop + polygon.offsetHeight < polygon.scrollHeight) {
		arrowDown.className = "dhtmlxMenu_"+this.skin+"_SubLevelArea_ArrowDown" + (arrowDown.over ? "_Over" : "");
	} else {
		arrowDown.className = "dhtmlxMenu_"+this.skin+"_SubLevelArea_ArrowDown_Disabled";
	}
}
/* add up-limit-arrow */
dhtmlXMenuObject.prototype._addUpArrow = function(id) {
	var main_self = this;
	var arrow = document.createElement("DIV");
	arrow.pId = this.idPrefix+id;
	arrow.id = "arrowup_"+this.idPrefix+id;
	arrow.className = "dhtmlxMenu_"+this.skin+"_SubLevelArea_ArrowUp";
	arrow.innerHTML = "<div class='dhtmlxMenu_"+this.skin+"_SubLevelArea_Arrow'><div class='dhtmlxMenu_SubLevelArea_Arrow_Icon'></div></div>";
	arrow.style.display = "none";
	arrow.over = false;
	arrow.onselectstart = function(e) { e = e||event; e.returnValue = false; return false; }
	arrow.oncontextmenu = function(e) { e = e||event; e.returnValue = false; return false; }
	// actions
	arrow.onmouseover = function() {
		if (main_self.menuMode == "web") { window.clearTimeout(main_self.menuTimeoutHandler); }
		main_self._clearAllSelectedSubItemsInPolygon(this.pId);
		if (this.className == "dhtmlxMenu_"+main_self.skin+"_SubLevelArea_ArrowUp_Disabled") return;
		this.className = "dhtmlxMenu_"+main_self.skin+"_SubLevelArea_ArrowUp_Over";
		this.over = true;
		main_self._canScrollUp = true;
		main_self._doScrollUp(this.pId, true);
	}
	arrow.onmouseout = function() {
		if (main_self.menuMode == "web") {
			window.clearTimeout(main_self.menuTimeoutHandler);
			main_self.menuTimeoutHandler = window.setTimeout(function(){main_self._clearAndHide();}, main_self.menuTimeoutMsec, "JavaScript");
		}
		this.over = false;
		main_self._canScrollUp = false;
		if (this.className == "dhtmlxMenu_"+main_self.skin+"_SubLevelArea_ArrowUp_Disabled") return;
		this.className = "dhtmlxMenu_"+main_self.skin+"_SubLevelArea_ArrowUp";
		window.clearTimeout(main_self._scrollUpTM);
	}
	arrow.onclick = function(e) {
		e = e||event;
		e.returnValue = false;
		e.cancelBubble = true;
		return false;
	}
	//
	// var polygon = this.idPull["polygon_"+this.idPrefix+id];
	// polygon.insertBefore(arrow, polygon.childNodes[0]);
	document.body.insertBefore(arrow, document.body.firstChild);
	this.idPull[arrow.id] = arrow;
}
dhtmlXMenuObject.prototype._addDownArrow = function(id) {
	var main_self = this;
	var arrow = document.createElement("DIV");
	arrow.pId = this.idPrefix+id;
	arrow.id = "arrowdown_"+this.idPrefix+id;
	arrow.className = "dhtmlxMenu_"+this.skin+"_SubLevelArea_ArrowDown";
	arrow.innerHTML = "<div class='dhtmlxMenu_"+this.skin+"_SubLevelArea_Arrow'><div class='dhtmlxMenu_SubLevelArea_Arrow_Icon'></div></div>";
	arrow.style.display = "none";
	arrow.over = false;
	arrow.onselectstart = function(e) { e = e||event; e.returnValue = false; return false; }
	arrow.oncontextmenu = function(e) { e = e||event; e.returnValue = false; return false; }
	// actions
	arrow.onmouseover = function() {
		if (main_self.menuMode == "web") { window.clearTimeout(main_self.menuTimeoutHandler); }
		main_self._clearAllSelectedSubItemsInPolygon(this.pId);
		if (this.className == "dhtmlxMenu_"+main_self.skin+"_SubLevelArea_ArrowDown_Disabled") return;
		this.className = "dhtmlxMenu_"+main_self.skin+"_SubLevelArea_ArrowDown_Over";
		this.over = true;
		main_self._canScrollDown = true;
		main_self._doScrollDown(this.pId, true);
	}
	arrow.onmouseout = function() {
		if (main_self.menuMode == "web") {
			window.clearTimeout(main_self.menuTimeoutHandler);
			main_self.menuTimeoutHandler = window.setTimeout(function(){main_self._clearAndHide();}, main_self.menuTimeoutMsec, "JavaScript");
		}
		this.over = false;
		main_self._canScrollDown = false;
		if (this.className == "dhtmlxMenu_"+main_self.skin+"_SubLevelArea_ArrowDown_Disabled") return;
		this.className = "dhtmlxMenu_"+main_self.skin+"_SubLevelArea_ArrowDown";
		window.clearTimeout(main_self._scrollDownTM);
	}
	arrow.onclick = function(e) {
		e = e||event;
		e.returnValue = false;
		e.cancelBubble = true;
		return false;
	}
	document.body.insertBefore(arrow, document.body.firstChild);
	this.idPull[arrow.id] = arrow;
}
dhtmlXMenuObject.prototype._removeUpArrow = function(id) {
	var fullId = "arrowup_"+this.idPrefix+id;
	this._removeArrow(fullId);
}
dhtmlXMenuObject.prototype._removeDownArrow = function(id) {
	var fullId = "arrowdown_"+this.idPrefix+id;
	this._removeArrow(fullId);
}
dhtmlXMenuObject.prototype._removeArrow = function(fullId) {
	var arrow = this.idPull[fullId];
	arrow.onselectstart = null;
	arrow.oncontextmenu = null;
	arrow.onmouseover = null;
	arrow.onmouseout = null;
	arrow.onclick = null;
	if (arrow.parentNode) arrow.parentNode.removeChild(arrow);
	arrow = null;
	this.idPull[fullId] = null;
	try { delete this.idPull[fullId]; } catch(e) {}
}
dhtmlXMenuObject.prototype._isArrowExists = function(id) {
	if (this.idPull["arrowup_"+id] != null && this.idPull["arrowdown_"+id] != null) return true;
	return false;
}
/* scroll down */
dhtmlXMenuObject.prototype._doScrollUp = function(id, checkArrows) {
	var polygon = this.idPull["polygon_"+id];
	if (this._canScrollUp && polygon.scrollTop > 0) {
		var theEnd = false;
		var nextScrollTop = polygon.scrollTop - this._scrollUpTMStep;
		if (nextScrollTop < 0) {
			theEnd = true;
			nextScrollTop = 0;
		}
		polygon.scrollTop = nextScrollTop;
		if (!theEnd) {
			var that = this;
			this._scrollUpTM = window.setTimeout(function() { that._doScrollUp(id, false); }, this._scrollUpTMTime);
		}
	} else {
		this._canScrollUp = false;
		this._checkArrowsState(id);
	}
	if (checkArrows) {
		this._checkArrowsState(id);
	}
}
dhtmlXMenuObject.prototype._doScrollDown = function(id, checkArrows) {
	var polygon = this.idPull["polygon_"+id];
	if (this._canScrollDown && polygon.scrollTop + polygon.offsetHeight <= polygon.scrollHeight) {
		var theEnd = false;
		var nextScrollTop = polygon.scrollTop + this._scrollDownTMStep;
		if (nextScrollTop + polygon.offsetHeight > polygon.scollHeight) {
			theEnd = true;
			nextScrollTop = polygon.scollHeight - polygon.offsetHeight;
		}
		polygon.scrollTop = nextScrollTop;
		if (!theEnd) {
			var that = this;
			this._scrollDownTM = window.setTimeout(function() { that._doScrollDown(id, false); }, this._scrollDownTMTime);
		}
	} else {
		this._canScrollDown
		this._checkArrowsState(id);
	}
	if (checkArrows) {
		this._checkArrowsState(id);
	}
}
//
dhtmlXMenuObject.prototype._countPolygonItems = function(id) {
	var count = 0;
	for (var a in this.itemPull) {
		var par = this.itemPull[a]["parent"];
		var tp = this.itemPull[a]["type"];
		if (par == this.idPrefix+id && (tp == "item" || tp == "radio" || tp == "checkbox")) { count++; }
	}
	return count;
}
/* limit maximum items on single polygon, default - 0 = no limit */
/**
*   @desc: limits the maximum number of visible items in polygons
*   @param: itemsNum - count of the maximum number of visible items
*   @type: public
*/
dhtmlXMenuObject.prototype.setOverflowHeight = function(itemsNum) {
	
	// set auto overflow mode
	if (itemsNum === "auto") {
		this.limit = 0;
		this.autoOverflow = true;
		return;
	}
	
	// no existing limitation, now new limitation
	if (this.limit == 0 && itemsNum <= 0) return;
	
	// hide menu to prevent visible changes
	this._clearAndHide();
	
	// redefine existing limitation, arrows will added automatically with showPlygon
	if (this.limit >= 0 && itemsNum > 0) {
		this.limit = itemsNum;
		return;
	}
	
	// remove existing limitation
	if (this.limit > 0 && itemsNum <= 0) {
		for (var a in this.itemPull) {
			if (this._isArrowExists(a)) {
				var b = String(a).replace(this.idPrefix, "");
				this._removeUpArrow(b);
				this._removeDownArrow(b);
				// remove polygon's height
				this.idPull["polygon_"+a].style.height = "";
			}
		}
		this.limit = 0;
		return;
	}
}
//#}
/****************************************************************************************************************************************************/
/*								 	RADIOBUTTONS								    */
//#menu_radio:06062008{
dhtmlXMenuObject.prototype._getRadioImgObj = function(id) {
	try { var imgObj = this.idPull[this.idPrefix+id].childNodes[(this._rtl?2:0)].childNodes[0] } catch(e) { var imgObj = null; }
	return imgObj;
}
dhtmlXMenuObject.prototype._setRadioState = function(id, state) {
	// if (this.itemPull[this.idPrefix+id]["state"] != "enabled") return;
	var imgObj = this._getRadioImgObj(id);
	if (imgObj != null) {
		// fix, added in 0.4
		var rObj = this.itemPull[this.idPrefix+id];
		rObj["checked"] = state;
		rObj["imgen"] = "rdbt_"+(rObj["checked"]?"1":"0");
		rObj["imgdis"] = rObj["imgen"];
		imgObj.className = "sub_icon "+rObj["imgen"];
	}
}
dhtmlXMenuObject.prototype._radioOnClickHandler = function(id, type, casState) {
	if (type.charAt(1)=="d" || this.itemPull[this.idPrefix+id]["group"]==null) return;
	// deselect all from the same group
	var group = this.itemPull[this.idPrefix+id]["group"];
	if (this.checkEvent("onRadioClick")) {
		if (this.callEvent("onRadioClick", [group, this.getRadioChecked(group), id, this.contextMenuZoneId, casState])) {
			this.setRadioChecked(group, id);
		}
	} else {
		this.setRadioChecked(group, id);
	}
	// call onClick if exists
	if (this.checkEvent("onClick")) this.callEvent("onClick", [id]);
}
/**
*   @desc: returns a checked radio button in the group
*   @param: group - radio button group
*   @type: public
*/
dhtmlXMenuObject.prototype.getRadioChecked = function(group) {
	var id = null;
	for (var q=0; q<this.radio[group].length; q++) {
		var itemId = this.radio[group][q].replace(this.idPrefix, "");
		var imgObj = this._getRadioImgObj(itemId);
		if (imgObj != null) {
			var checked = (imgObj.className).match(/rdbt_1$/gi);
			if (checked != null) id = itemId;
		}
	}
	return id;
}
/**
*   @desc: checks a radio button inside the group
*   @param: group - radio button group
*   @param: id - radio button's id
*   @type: public
*/
dhtmlXMenuObject.prototype.setRadioChecked = function(group, id) {
	if (this.radio[group] == null) return;
	for (var q=0; q<this.radio[group].length; q++) {
		var itemId = this.radio[group][q].replace(this.idPrefix, "");
		this._setRadioState(itemId, (itemId==id));
	}
}
/**
*   @desc: adds a new radio button, sibling|child mode
*   @param: mode - (string) sibling|child
*   @param: nextToId - the item after which the radio button will be added in the "sibling" mode or parent item's id in the "child" mode
*   @param: pos - the item's position in the child mode (null for sibling)
*   @param: itemId - id of a new radio button
*   @param: itemText - text of a new radio button
*   @param: group - radiogroup's id
*   @param: state - checked|unchecked
*   @param: disabled - enabled|disabled
*   @type: public
*/
dhtmlXMenuObject.prototype.addRadioButton = function(mode, nextToId, pos, itemId, itemText, group, state, disabled) {
	// radiobutton
	/*
	if (this.itemPull[this.idPrefix+nextToId] == null) return;
	if (this.itemPull[this.idPrefix+nextToId]["parent"] == this.idPrefix+this.topId) return;
	*/
	if (this.context && nextToId == this.topId) {
		// adding radiobutton as first element to context menu
		// do nothing
	} else {
		if (this.itemPull[this.idPrefix+nextToId] == null) return;
		if (mode == "child" && this.itemPull[this.idPrefix+nextToId]["type"] != "item") return;
		// if (this.itemPull[this.idPrefix+nextToId]["parent"] == this.idPrefix+this.topId && !this.context) return;
	}
	
	//
	//
	var id = this.idPrefix+(itemId!=null?itemId:this._genStr(24));
	var img = "rdbt_"+(state?"1":"0");
	var imgDis = img;
	//
	if (mode == "sibling") {
		var parentId = this.idPrefix+this.getParentId(nextToId);
		this._addItemIntoGlobalStrorage(id, parentId, itemText, "radio", disabled, img, imgDis);
		this._renderSublevelItem(id, this.getItemPosition(nextToId));
	} else {
		var parentId = this.idPrefix+nextToId;
		this._addItemIntoGlobalStrorage(id, parentId, itemText, "radio", disabled, img, imgDis);
		if (this.idPull["polygon_"+parentId] == null) { this._renderSublevelPolygon(parentId, parentId); }
		this._renderSublevelItem(id, pos-1);
		this._redefineComplexState(parentId);
	}
	//
	var gr = (group!=null?group:this._genStr(24));
	this.itemPull[id]["group"] = gr;
	//
	if (this.radio[gr]==null) { this.radio[gr] = new Array(); }
	this.radio[gr][this.radio[gr].length] = id;
	//
	if (state == true) this.setRadioChecked(gr, String(id).replace(this.idPrefix, ""));
}
//#}
/****************************************************************************************************************************************************/
/*								 	CHECKBOXES								    */
//#menu_checks:06062008{
dhtmlXMenuObject.prototype._getCheckboxState = function(id) {
	if (this.itemPull[this.idPrefix+id] == null) return null;
	return this.itemPull[this.idPrefix+id]["checked"];
}
dhtmlXMenuObject.prototype._setCheckboxState = function(id, state) {
	if (this.itemPull[this.idPrefix+id] == null) return;
	this.itemPull[this.idPrefix+id]["checked"] = state;
}
dhtmlXMenuObject.prototype._updateCheckboxImage = function(id) {
	if (this.idPull[this.idPrefix+id] == null) return;
	this.itemPull[this.idPrefix+id]["imgen"] = "chbx_"+(this._getCheckboxState(id)?"1":"0");
	this.itemPull[this.idPrefix+id]["imgdis"] = this.itemPull[this.idPrefix+id]["imgen"];
	try { this.idPull[this.idPrefix+id].childNodes[(this._rtl?2:0)].childNodes[0].className = "sub_icon "+this.itemPull[this.idPrefix+id]["imgen"]; } catch(e){}
}
dhtmlXMenuObject.prototype._checkboxOnClickHandler = function(id, type, casState) {
	if (type.charAt(1)=="d") return;
	if (this.itemPull[this.idPrefix+id] == null) return;
	var state = this._getCheckboxState(id);
	if (this.checkEvent("onCheckboxClick")) {
		if (this.callEvent("onCheckboxClick", [id, state, this.contextMenuZoneId, casState])) {
			this.setCheckboxState(id, !state);
		}
	} else {
		this.setCheckboxState(id, !state);
	}
	// call onClick if exists
	if (this.checkEvent("onClick")) this.callEvent("onClick", [id]);
}
/**
*   @desc: sets checkbox's state
*   @param: id - the item
*   @param: state - a new state (true|false)
*   @type: public
*/
dhtmlXMenuObject.prototype.setCheckboxState = function(id, state) {
	this._setCheckboxState(id, state);
	this._updateCheckboxImage(id);
}
/**
*   @desc: returns current checkbox's state
*   @param: id - the item
*   @type: public
*/
dhtmlXMenuObject.prototype.getCheckboxState = function(id) {
	return this._getCheckboxState(id);
}
/**
*   @desc: adds a new checkbox, sibling|child mode
*   @param: mode - (string) sibling|child
*   @param: nextToId - the item after which the checkbox will be added in the "sibling" mode or parent item's id in the "child" mode
*   @param: pos - item's position in the child mode (null for sibling)
*   @param: itemId - id of a new checkbox
*   @param: itemText - text of a new checkbox
*   @param: state - checked|unchecked
*   @param: disabled - enabled|disabled
*   @type: public
*/
dhtmlXMenuObject.prototype.addCheckbox = function(mode, nextToId, pos, itemId, itemText, state, disabled) {
	// checks
	if (this.context && nextToId == this.topId) {
		// adding checkbox as first element to context menu
		// do nothing
	} else {
		if (this.itemPull[this.idPrefix+nextToId] == null) return;
		if (mode == "child" && this.itemPull[this.idPrefix+nextToId]["type"] != "item") return;
		// if (this.itemPull[this.idPrefix+nextToId]["parent"] == this.idPrefix+this.topId && !this.context) return;
	}
	//
	var img = "chbx_"+(state?"1":"0");
	var imgDis = img;
	//
	
	if (mode == "sibling") {
		
		var id = this.idPrefix+(itemId!=null?itemId:this._genStr(24));
		var parentId = this.idPrefix+this.getParentId(nextToId);
		this._addItemIntoGlobalStrorage(id, parentId, itemText, "checkbox", disabled, img, imgDis);
		this.itemPull[id]["checked"] = state;
		this._renderSublevelItem(id, this.getItemPosition(nextToId));
	} else {
		
		var id = this.idPrefix+(itemId!=null?itemId:this._genStr(24));
		var parentId = this.idPrefix+nextToId;
		this._addItemIntoGlobalStrorage(id, parentId, itemText, "checkbox", disabled, img, imgDis);
		this.itemPull[id]["checked"] = state;
		if (this.idPull["polygon_"+parentId] == null) { this._renderSublevelPolygon(parentId, parentId); }
		this._renderSublevelItem(id, pos-1);
		this._redefineComplexState(parentId);
	}
}
//#}
/****************************************************************************************************************************************************/
/*								 	SERIALIZE								    */
dhtmlXMenuObject.prototype._readLevel = function(parentId) {
	var xml = "";
	for (var a in this.itemPull) {
		if (this.itemPull[a]["parent"] == parentId) {
			var imgEn = "";
			var imgDis = "";
			var hotKey = "";
			var itemId = String(this.itemPull[a]["id"]).replace(this.idPrefix,"");
			var itemType = "";
			var itemText = (this.itemPull[a]["title"]!=""?' text="'+this.itemPull[a]["title"]+'"':"");
			var itemState = "";
			if (this.itemPull[a]["type"] == "item") {
				if (this.itemPull[a]["imgen"] != "") imgEn = ' img="'+this.itemPull[a]["imgen"]+'"';
				if (this.itemPull[a]["imgdis"] != "") imgDis = ' imgdis="'+this.itemPull[a]["imgdis"]+'"';
				if (this.itemPull[a]["hotkey"] != "") hotKey = '<hotkey>'+this.itemPull[a]["hotkey"]+'</hotkey>';
			}
			if (this.itemPull[a]["type"] == "separator") {
				itemType = ' type="separator"';
			} else {
				if (this.itemPull[a]["state"] == "disabled") itemState = ' enabled="false"';
			}
			if (this.itemPull[a]["type"] == "checkbox") {
				itemType = ' type="checkbox"'+(this.itemPull[a]["checked"]?' checked="true"':"");
			}
			if (this.itemPull[a]["type"] == "radio") {
				itemType = ' type="radio" group="'+this.itemPull[a]["group"]+'" '+(this.itemPull[a]["checked"]?' checked="true"':"");
			}
			xml += "<item id='"+itemId+"'"+itemText+itemType+imgEn+imgDis+itemState+">";
			xml += hotKey;
			if (this.itemPull[a]["complex"]) xml += this._readLevel(a);
			xml += "</item>";
		}
	}
	return xml;
}
/**
*   @desc: serialize menu to xml
*   @type: public
*/
dhtmlXMenuObject.prototype.serialize = function() {
	var xml = "<menu>"+this._readLevel(this.idPrefix+this.topId)+"</menu>";
	return xml;
}
/****************************************************************************************************************************************************/

//v.3.6 build 131108

/*
Copyright DHTMLX LTD. http://www.dhtmlx.com
To use this component please contact sales@dhtmlx.com to obtain license
*/
/**
*	@desc: constructor, creates a single window under dhtmlxWindows system
*	@pseudonym: win
*	@type: public
*/
function dhtmlXWindowsSngl(){
 	
}
/**
*	@desc: constructor, creates a button for a window under dhtmlxWindows system
*	@pseudonym: btn
*	@type: public
*/
function dhtmlXWindowsBtn(){
 	
}

/**
*   @desc: constructor, creates a new dhtmlxWindows object
*   @type: public
*/

function dhtmlXWindows() {
	
	if (!window.dhtmlXContainer) {
		alert(this.i18n.dhx);
		return;
	}
	// engine
	this.engine = "dhx";
	// this.engine = "clear";
	var engineFunc = "_"+this.engine+"_Engine";
	if (!this[engineFunc]) {
		alert(this.i18n.noenginealert);
		return;
	} else {
		this[engineFunc]();
	}
	
	this._isIPad = (navigator.userAgent.search(/iPad/gi)>=0);
	
	var that = this;
	// image manipulation
	this.pathPrefix = "dhxwins_";
	this.imagePath = dhtmlx.image_path||"codebase/imgs/";
	/**
	*   @desc: sets path to the directory where used images are located
	*   @param: path - url to the directory where images are located
	*   @type: public
	*/
	this.setImagePath = function(path) {
		this.imagePath = path;
	}
	
	// skins
	this.skin = (typeof(dhtmlx) != "undefined" && typeof(dhtmlx.skin) == "string" ? dhtmlx.skin : "dhx_skyblue");
	this.skinParams = { // dhx
			    "dhx_black"		: { "header_height": 21, "border_left_width": 2, "border_right_width": 2, "border_bottom_height": 2 },
			    "dhx_blue"		: { "header_height": 21, "border_left_width": 2, "border_right_width": 2, "border_bottom_height": 2 },
			    "dhx_skyblue"	: { "header_height": 21, "border_left_width": 2, "border_right_width": 2, "border_bottom_height": 2 }
	};
	/**
	*   @desc: changes window's skin
	*   @param: skin - skin's name
	*   @type: public
	*/
	this.setSkin = function(skin) {
		this.skin = skin;
		this._engineRedrawSkin();
		
		//this.skin = skin;
		//this._redrawSkin();
	}
	/*
	this._redrawSkin = function() {
		
		for (var a in this.wins) {
			var win = this.wins[a];
			var skinParams = (win._skinParams!=null?win._skinParams:this.skinParams[this.skin]);
			//
			win.childNodes[0].className = "dhtmlx_wins_"+this.skin;
			// icon
			win.childNodes[1].className = "dhtmlx_wins_icon_"+this.skin;
			this._restoreWindowIcons(win);
			// title
			win.childNodes[2].className = "dhtmlx_wins_title_"+this.skin;
			// butons
			win.childNodes[3].className = "dhtmlx_wins_buttons_"+this.skin;
			// this._redrawWindow(win);
			// this._engineRedrawWindowSize(win);
			alert("stop PGhNyVSe");
			
		}
		// this._restoreWindowIcons(this.getTopmostWindow());
	}
	*/
	// return true if window with specified id is exists
	/**
	*   @desc: returns true if the window with specified id exists
	*   @param: id
	*   @type: public
	*/
	this.isWindow = function(id) {
		var t = (this.wins[id] != null);
		return t;
	}
//#wind_uber:09062008{
	// return array of handlers finded by text
	/**
	*   @desc: returns array of window handlers found by header text
	*   @param: id
	*   @type: public
	*/
	this.findByText = function(text) {
		var wins = new Array();
		for (var a in this.wins) {
			if (this.wins[a].getText().search(text, "gi") >= 0) {
				wins[wins.length] = this.wins[a];
			}
		}
		return wins;
	}
//#}	
	// return handler by id
	/**
	*   @desc: returns the window handler (dhtmlXWindowSngl object) found by id
	*   @param: id
	*   @type: public
	*/
	this.window = function(id) {
		var win = null;
		if (this.wins[id] != null) { win = this.wins[id]; }
		return win;
	}
//#wind_uber:09062008{
	// iterator
	/**
	*   @desc: iterator - goes through all windows and calls a user handler
	*   @param: hander (user function)
	*   @type: public
	*/
	this.forEachWindow = function(handler) {
		for (var a in this.wins) {
			handler(this.wins[a]);
		}
	}
	
	// return bottommost focused window handler
	/**
	*   @desc: returns the bottommost window
	*   @type: public
	*/
	this.getBottommostWindow = function() {
		var bottommost = this.getTopmostWindow();
		for (var a in this.wins) {
			if (this.wins[a].zi < bottommost.zi) {
				bottommost = this.wins[a];
			}
		}
		return (bottommost.zi != 0 ? bottommost : null);
	}
//#}	

	// return topmost focused window handler
	/**
	*   @desc: returns the topmost window
	*   @type: public
	*/
	this.getTopmostWindow = function(visibleOnly) {
		var topmost = {"zi": 0};
		for (var a in this.wins) {
			
			if (this.wins[a].zi > topmost.zi) {
				if (visibleOnly == true && !this._isWindowHidden(this.wins[a])) {
					topmost = this.wins[a];
				}
				if (visibleOnly != true) {
					topmost = this.wins[a];
				}
			}
		}
		return (topmost.zi != 0 ? topmost : null);
	}
	
	// windows storage
	this.wins = {};
	for (var a in this.wins) delete this.wins[a];
	
	// viewport
	this.autoViewport = true;
	this._createViewport = function() {
		this.vp = document.body;
		this._clearVPCss();
		this.vp._css = (String(this.vp.className).length > 0 ? this.vp.className : "");
		this.vp.className += " dhtmlx_skin_"+this.skin+(this._r?" dhx_wins_rtl":"");
		// modal cover
		this.modalCoverI = document.createElement("IFRAME");
		this.modalCoverI.frameBorder = "0";
		this.modalCoverI.className = "dhx_modal_cover_ifr";
		this.modalCoverI.setAttribute("src","javascript:false;");
		this.modalCoverI.style.display = "none";
		this.modalCoverI.style.zIndex = 0;
		this.vp.appendChild(this.modalCoverI);
		this.modalCoverD = document.createElement("DIV");
		this.modalCoverD.className = "dhx_modal_cover_dv";
		this.modalCoverD.style.display = "none";
		this.modalCoverD.style.zIndex = 0;
		this.vp.appendChild(this.modalCoverD);
		// vp move/resize cover
		this._vpcover = document.createElement("DIV");
		this._vpcover.className = "dhx_content_vp_cover";
		this._vpcover.style.display = "none";
		this.vp.appendChild(this._vpcover);
		// resize/move carcass
		this._carcass = document.createElement("DIV");
		this._carcass.className = "dhx_carcass_resmove";
		this._carcass.style.display = "none";
		if (_isIE) {
			this._carcass.innerHTML = "<iframe border=0 frameborder=0 style='filter: alpha(opacity=0); width: 100%; height:100%; position: absolute; top: 0px; left: 0px; width: 100%; height: 100%; z-index:1;'></iframe>"+
							"<div style='position: absolute; top: 0px; left: 0px; width: 100%; height: 100%;z-index:2;background:white;filter:alpha(opacity=0);opacity:0;'></div>";
			if (navigator.userAgent.indexOf("MSIE 10") >= 0) {
				
			} else {
				this._carcass.childNodes[0].setAttribute("src","javascript:false;");
			}
		}
		this._carcass.onselectstart = function(e) {
			e = e||event;
			e.returnValue = false;
		}
		this.vp.appendChild(this._carcass);
	}
	this._clearVPCss = function(css) {
		this.vp.className = String(this.vp.className).replace(/[a-z_]{1,}/gi,function(t){return({"dhtmlx_skin_dhx_skyblue":1,"dhtmlx_skin_dhx_blue":1,"dhtmlx_skin_dhx_black":1,"dhtmlx_skin_dhx_web":1,"dhtmlx_skin_dhx_terrace":1}[t]==1?"":t);});
	}
	this._autoResizeViewport = function() {
		for (var a in this.wins) {
			if (this.wins[a]._isFullScreened) {
				/*
				this.wins[a]._content.style.width = document.body.offsetWidth-(_isIE?4:0)+"px";
				// doctype fix
				if (document.body.offsetHeight == 0) {
					if (window.innerHeight) {
						this.wins[a]._content.style.height = window.innerHeight+"px";
					} else {
						this.wins[a]._content.style.height = document.body.scrollHeight+"px";
					}
				} else {
					this.wins[a]._content.style.height = document.body.offsetHeight-(_isIE?4:0)+"px";
				}
				// this.wins[a]._content.style.height = document.body.offsetHeight-(_isIE?4:0)+"px";
				if (this.wins[a].layout != null && _isOpera) { this.wins[a].layout._fixCellsContentOpera950(); }
				this.wins[a].updateNestedObjects();
				*/
				this.wins[a].adjustContent(document.body, 0, 0, false, 0);
				this.wins[a].updateNestedObjects();
				
			}
			if (this.wins[a]._isMaximized && this.wins[a].style.display != "none") {
				this._restoreWindow(a);
				this._maximizeWindow(a);
			}
		}
		
		if (this.vp == document.body) return;
		if (this.autoViewport == false) return;
		this.vp.style.width = (_isIE ? document.body.offsetWidth - 4 : window.innerWidth) + "px";
		this.vp.style.height = (_isIE ? document.body.offsetHeight - 4 : window.innerHeight) + "px";
		//
		// check windows out of viewports edge
		for (var a in this.wins) {
			var win = this.wins[a];
			var overX = false;
			var overY = false;
			if (win.x > this.vp.offsetWidth - 10) {
				win.x = this.vp.offsetWidth - 10;
				overX = true;
			}
			var skinParams = (win._skinParams!=null?win._skinParams:this.skinParams[this.skin]);
			if (win.y + skinParams["header_height"] > this.vp.offsetHeight) {
				win.y = this.vp.offsetHeight - skinParams["header_height"];
				overY = true;
			}
			if (overX || overY) {
				// this._redrawWindow(win);
				this._engineRedrawWindowPos(win);
			}
		}
	}
	/**
	*   @desc: if true - allows an object to adjust the viewport automatically to document.body
	*   @param: state - true|false
	*   @type: public
	*/
	this.enableAutoViewport = function(state) {
		
		if (this.vp != document.body) return;
		this.autoViewport = state;
		if (state == false) {
			// clear old vp
			if (this.vp == document.body) document.body.className = this.vp._css;
			this.vp.removeChild(this.modalCoverI);
			this.vp.removeChild(this.modalCoverD);
			this.vp.removeChild(this._vpcover);
			this.vp.removeChild(this._carcass);
			this.vp = null;
			// create a new one
			this.vp = document.createElement("DIV");
			this.vp.autocreated = true;
			this.vp.className = "dhtmlx_winviewport dhtmlx_skin_"+this.skin+(this._r?" dhx_wins_rtl":"");
			this.vp.style.left = "0px";
			this.vp.style.top = "0px";
			document.body.appendChild(this.vp);
			this.vp.ax = 0;
			this.vp.ay = 0;
			this._autoResizeViewport();
			this.vp.appendChild(this.modalCoverI);
			this.vp.appendChild(this.modalCoverD);
			this.vp.appendChild(this._vpcover);
			this.vp.appendChild(this._carcass);
		}
	}
	/**
	*   @desc: attaches a vp to an existing object on page (renders an object as a viewport)
	*   @param: objId - object id
	*   @type: public
	*/
	this.attachViewportTo = function(objId) {
		if (this.autoViewport == false) {
			// clear old vp
			this.vp.removeChild(this.modalCoverI);
			this.vp.removeChild(this.modalCoverD);
			this.vp.removeChild(this._vpcover);
			this.vp.removeChild(this._carcass);
			if (this.vp != document.body) this.vp.parentNode.removeChild(this.vp);
			this.vp = null;
			// create a new one
			this.vp = (typeof(objId)=="string"?document.getElementById(objId):objId);
			this.vp.autocreated = false;
			this._clearVPCss();
			this.vp.className += " dhtmlx_skin_"+this.skin+(this._r?" dhx_wins_rtl":"");
			this.vp.style.position = "relative";
			this.vp.style.overflow = "hidden";
			this.vp.ax = 0;
			this.vp.ay = 0;
			// attach data
			this.vp.appendChild(this.modalCoverI);
			this.vp.appendChild(this.modalCoverD);
			this.vp.appendChild(this._vpcover);
			this.vp.appendChild(this._carcass);
		}
	}
	/**
	*   @desc: sets user-defined viewport if enableAutoViewport(false)
	*   @param: x - top-left viewport corner's X-coordinate
	*   @param: y - top-left viewport corner's Y-coordinate
	*   @param: width - viewport's width
	*   @param: height - viewport's height
	*   @type: public
	*/
	this.setViewport = function(x, y, width, height, parentObj) {
		if (this.autoViewport == false) {
			this.vp.style.left = x + "px";
			this.vp.style.top = y + "px";
			this.vp.style.width = width + "px";
			this.vp.style.height = height + "px";
			// attach to parent
			if (parentObj != null) { parentObj.appendChild(this.vp); }
			this.vp.ax = getAbsoluteLeft(this.vp);
			this.vp.ay = getAbsoluteTop(this.vp);
		}
	}
	// effects
	this._effects = {"move" : false, "resize" : false};
	/**
	*   @desc: sets a visual effect
	*   @param: efName - effect's name
	*   @param: efValue - true/false to enable/disable
	*   @type: public
	*/
	this.setEffect = function(efName, efValue) {
		if ((this._effects[efName] != null) && (typeof(efValue) == "boolean")) {
			this._effects[efName] = efValue;
		}
	}
	/**
	*   @desc: returns true if the effect is enabled
	*   @param: efName - effect's name
	*   @type: public
	*/
	this.getEffect = function(efName) {
		return this._effects[efName];
	}
	// windows
	/**
	*   @desc: creates a new window and returns its handler
	*   @param: id - window's id
	*   @param: x - top-left window corner's X-coordinate
	*   @param: y - top-left window corner's Y-coordinate
	*   @param: width - window's width
	*   @param: height - window's height
	*   @type: public
	*/
	this.createWindow = function(id, x, y, width, height) {
		
		var win = document.createElement("DIV");
		
		// win.className = "dhtmlx_window_inactive";
		win.className = "dhtmlx_window_inactive";
		win.dir = "ltr";
		// move all available windows up
		for (var a in this.wins) {
			this.wins[a].zi += this.zIndexStep;
			this.wins[a].style.zIndex = this.wins[a].zi;
			if (this.iframeMode && this.wins[a].ifr) {
				this.wins[a].ifr.style.zIndex = this.wins[a].style.zIndex-1;
			}
		}
		// bottom, bring on top will at the end of createWindow function
		win.zi = this.zIndexStep;// this._getTopZIndex(true) + this.zIndexStep;
		win.style.zIndex = win.zi;
		//
		win.active = false;
		//
		win._isWindow = true;
		
		win.isWindow = true;
		//
		// win.that = this;
		//
		win.w = Number(width);
		win.h = Number(height);
		win.x = x;
		win.y = y;
		// this._fixWindowPositionInViewport(win);
		this._engineFixWindowPosInViewport(win);
		//
		// win.style.width = win.w + "px";
		// win.style.height = win.h + "px";
		// win.style.left = win.x + "px";
		// win.style.top = win.y + "px";
		win._isModal = false;
		// resize params
		win._allowResize = true;
		win.maxW = "auto"; // occupy all viewport on click or 
		win.maxH = "auto";
		win.minW = 200;
		win.minH = 140;
		win.iconsPresent = true;
		win.icons = new Array(this.imagePath+this.pathPrefix+this.skin+"/active/icon_normal.gif", this.imagePath+this.pathPrefix+this.skin+"/inactive/icon_normal.gif");
		//
		win._allowMove = true;
		win._allowMoveGlobal = true;
		win._allowResizeGlobal = true;
		//
		win._keepInViewport = false;
		//
		var skin = this.skinParams[this.skin];
		win.idd = id;
		//win._midd = "dhxWMNObj_"+this._genStr(12);
		//win._tidd = "dhxWTBObj_"+this._genStr(12);
		//win._sidd = "dhxSTBObj_"+this._genStr(12);
		//
		this.vp.appendChild(win);
		this._engineSetWindowBody(win);
		this._engineRedrawWindowPos(win);
		this._engineRedrawWindowSize(win);
		this._engineUpdateWindowIcon(win, win.icons[0]);
		
		this._engineDiableOnSelectInWindow(win, true);
		//
		this.wins[id] = win;
		//
		dhtmlxEventable(win);
		//
		// this._makeActive(win, true);
		
		// moving
		this._engineGetWindowHeader(win)[this._isIPad?"ontouchstart":"onmousedown"] = function(e) {
			
			e = e||event;
			
			var w = that.wins[this.idd];
			if (!w.isOnTop()) w.bringToTop();
			
			if (that._engineGetWindowHeaderState(w)) return;
			
			if (!that._engineCheckHeaderMouseDown(w, e)) return;
			
			if (!w._allowMove || !w._allowMoveGlobal) return;
			
			that._wasMoved = false;
			//
			w.moveOffsetX = w.x - (that._isIPad?e.touches[0].clientX:e.clientX);
			w.moveOffsetY = w.y - (that._isIPad?e.touches[0].clientY:e.clientY);
			that.movingWin = w;
			
			// carcass
			if (that._effects["move"] == false) {
				that._carcass.x = that.movingWin.x;
				that._carcass.y = that.movingWin.y;
				that._carcass.w = parseInt(that.movingWin.style.width)+(_isIE?0:-2);
				that._carcass.h = parseInt(that.movingWin.style.height)+(_isIE?0:-2);
				that._carcass.style.left = that._carcass.x+"px";
				that._carcass.style.top = that._carcass.y+"px";
				that._carcass.style.width = that._carcass.w+"px";
				that._carcass.style.height = that._carcass.h+"px";
				// that._carcass.style.zIndex = that.movingWin.style.zIndex+that._getTopZIndex()+10;
				that._carcass.style.zIndex = that._getTopZIndex(true)+1;
				// that._carcass.style.cursor = "move";
				that._carcass._keepInViewport = win._keepInViewport;
			}
			that._blockSwitcher(true);
			// cursor
			// that._engineGetWindowHeader(that.movingWin).style.cursor = "move";
			// vpcover
			that._vpcover.style.zIndex = that.movingWin.style.zIndex-1;
			that._vpcover.style.display = "";
			//
			// w = null;
			e.returnValue = false;
			e.cancelBubble = true;
			
			return false;
		}
		/*
		win.ongesturestart = function(e) {
			
			e.preventDefault();
			
			that._carcass.x = this.x;
			that._carcass.y = this.y;
			that._carcass.w = this.w;
			that._carcass.h = this.h;
			
			that._carcass.style.left = that._carcass.x+"px";
			that._carcass.style.top = that._carcass.y+"px";
			that._carcass.style.width = that._carcass.w+"px";
			that._carcass.style.height = that._carcass.h+"px";
			
			that._carcass.style.display = "";
			that._carcass.style.zIndex = this.style.zIndex+1;
			
			
		}
		win.ongesturechange = function(e) {
			
			e.preventDefault();
			
			var scale = e.scale;
			
			var cx = that._carcass.x+that._carcass.w/2;
			var cy = that._carcass.y+that._carcass.h/2;
			
			var nw = that._carcass.w*scale;
			var nh = that._carcass.h*scale;
			
			var ncx = cx-nw/2;
			var ncy = cy-nh/2;
			
			
			that._carcass.style.left = Math.round(ncx)+"px";
			that._carcass.style.top = Math.round(ncy)+"px";
			that._carcass.style.width = Math.round(nw)+"px";
			that._carcass.style.height = Math.round(nh)+"px";
			
			//console.log(e.scale+","+e.rotation)
		}
		
		win.ongestureend = function(e) {
			
			e.preventDefault();
			
			that._carcass.style.display = "none";
			this.setPosition(parseInt(that._carcass.style.left), parseInt(that._carcass.style.top));
			this.setDimension(parseInt(that._carcass.style.width), parseInt(that._carcass.style.height));
		}
		*/
		this._engineGetWindowHeader(win).ondblclick = function(e) {
			
			var w = that.wins[this.idd];
			
			// maximize/minimize
			if (!that._engineCheckHeaderMouseDown(w, e||event)) { return; }
			if (w._allowResizeGlobal && !w._isParked) {
				if (w._isMaximized == true) {
					that._restoreWindow(w.idd);
				} else {
					that._maximizeWindow(w.idd);
				}
			}
			
			// parkup/parkup
			/*
			if (w._isParkedAllowed && w.button("park").isEnabled()) {
				that._parkWindow(w);
			}
			*/
			
			w = null;
			
		}
		
		// set text
		/**
		*   @desc: sets window's header text
		*   @param: text
		*   @type: public
		*/
		win.setText = function(text) {
			that._engineGetWindowLabel(this).innerHTML = text;
		}
		// get text
		/**
		*   @desc: returns window's header text
		*   @type: public
		*/
		win.getText = function() {
			return that._engineGetWindowLabel(this).innerHTML;
		}
		// het id by handler
		/**
		*   @desc: returns window's id
		*   @type: public
		*/
		win.getId = function() {
			return this.idd;
		}
		// show
		/**
		*   @desc: shows a window
		*   @type: public
		*/
		win.show = function() {
			that._showWindow(this);
		}
		// hide
		/**
		*   @desc: hides a window
		*   @type: public
		*/
		win.hide = function() {
			that._hideWindow(this);
		}
		// minimize
		/**
		*   @desc: minimizes a window
		*   @type: public
		*/
		win.minimize = function() {
			that._restoreWindow(this.idd);
		}
		// maximize
		/**
		*   @desc: maximizes a window
		*   @type: public
		*/
		win.maximize = function() {
			that._maximizeWindow(this.idd);
		}
		// close
		/**
		*   @desc: closes a window
		*   @type: public
		*/
		win.close = function() {
			that._closeWindow(this.idd);
		}
		// park
		/**
		*   @desc: parks a window (next action is based on window's current state)
		*   @type: public
		*/
		win.park = function() {
			if (this._isParkedAllowed) {
				that._parkWindow(this.idd);
			}
		}
		// stick/unstick
		/**
		*   @desc: sticks a window
		*   @type: public
		*/
		win.stick = function() {
			that._stickWindow(this.idd);
		}
		/**
		*   @desc: unsticks a window
		*   @type: public
		*/
		win.unstick = function() {
			that._unstickWindow(this.idd);
		}
		/**
		*   @desc: returns true if the window is sticked
		*   @type: public
		*/
		win.isSticked = function() {
			return this._isSticked;
		}
		// set icon
		/**
		*   @desc: sets window's header icon
		*   @param: iconEnabled - url to the icon for the enabled state
		*   @param: iconDisabled - url to the icon for the disabled state
		*   @type: public
		*/
		win.setIcon = function(iconEnabled, iconDisabled) {
			that._setWindowIcon(win, iconEnabled, iconDisabled);
		}
		// return array(iconEnabled, iconDisabled) icons for window
		/**
		*   @desc: returns current window's header icon
		*   @param: text
		*   @type: public
		*/
		win.getIcon = function() {
			return that._getWindowIcon(this);
		}
		// clear icon
		/**
		*   @desc: clears window's header icon
		*   @type: public
		*/
		win.clearIcon = function() {
			that._clearWindowIcons(this);
		}
		// restore default window icon according the loaded skin
		/**
		*   @desc: restores default window's header icon (based on skin)
		*   @type: public
		*/
		win.restoreIcon = function() {
			that._restoreWindowIcons(this);
		}
		//
		/**
		*   @desc: keeps a window within the viewport
		*   @param: state - if true - window is not allowed to be placed outside the viewport
				    if false - window is not allowed to be placed outside the viewport leaving only a small part of its header within the viewport
		*   @type: public
		*/
		win.keepInViewport = function(state) {
			this._keepInViewport = state;
		}
		// ask window be/not be modal
		/**
		*   @desc: makes a window modal/modeless
		*   @param: state - true|false
		*   @type: public
		*/
		win.setModal = function(state) {
			if (state == true) {
				if (that.modalWin != null || that.modalWin == this) return;
				that._setWindowModal(this, true);
			} else {
				if (that.modalWin != this) return;
				that._setWindowModal(this, false);
			}
		}
		// return true if window is modal
		/**
		*   @desc: returns true if the window is modal
		*   @type: public
		*/
		win.isModal = function() {
			return this._isModal;
		}
		// return true if window is hidden
		/**
		*   @desc: returns true if the window is hidden
		*   @type: public
		*/
		win.isHidden = function() {
			return that._isWindowHidden(this);
		}
		// return true if window is maximized
		/**
		*   @desc: returns true if the window is maximized
		*   @type: public
		*/
		win.isMaximized = function() {
			return this._isMaximized;
		}
		// return true if window is parkded
		/**
		*   @desc: returns true if the window is parked
		*   @type: public
		*/
		win.isParked = function() {
			return this._isParked;
		}
		// allow/deny park
		/**
		*   @desc: allows a window to be parked
		*   @type: public
		*/
		win.allowPark = function() {
			that._allowParking(this);
		}
		/**
		*   @desc: denies a window from parking
		*   @type: public
		*/
		win.denyPark = function() {
			that._denyParking(this);
		}
		/**
		*   @desc: returns true if the window is parkable
		*   @type: public
		*/
		win.isParkable = function() {
			return this._isParkedAllowed;
		}
		// allow/deny for allow window to be resized
		/**
		*   @desc: allows a window to be resized
		*   @type: public
		*/
		win.allowResize = function() {
			that._allowReszieGlob(this);
		}
		/**
		*   @desc: denies a window from resizing
		*   @type: public
		*/
		win.denyResize = function() {
			that._denyResize(this);
		}
		// return true if window resizeable
		/**
		*   @desc: returns true if the window is resizable
		*   @type: public
		*/
		win.isResizable = function() {
			return this._allowResizeGlobal;
		}
		// move
		/**
		*   @desc: allows a window to be moved
		*   @type: public
		*/
		win.allowMove = function() {
			if (!this._isMaximized) { this._allowMove = true; }
			this._allowMoveGlobal = true;
		}
		/**
		*   @desc: denies a window from moving
		*   @type: public
		*/
		win.denyMove = function() {
			this._allowMoveGlobal = false;
		}
		/**
		*   @desc: returns true if the window is movable
		*   @type: public
		*/
		win.isMovable = function() {
			return this._allowMoveGlobal;
		}
		// bring window to top and set focus
		/**
		*   @desc: brings/sends a window on top (z-positioning)
		*   @type: public
		*/
		win.bringToTop = function() {
			that._bringOnTop(this);
			that._makeActive(this);
		}
		// bring window to bottom and set focus
		/**
		*   @desc: brings/sends a window to bottom (z-positioning)
		*   @type: public
		*/
		win.bringToBottom = function() {
			that._bringOnBottom(this);
		}
		// return true if window is on top
		/**
		*   @desc: returns true if the window is on top
		*   @type: public
		*/
		win.isOnTop = function() {
			return that._isWindowOnTop(this);
		}
		// return true if window if on bottom
		/**
		*   @desc: returns true if the window is on bottom
		*   @type: public
		*/
		win.isOnBottom = function() {
			return that._isWindowOnBottom(this);
		}
		// set new position for window, if it will outlay the viewport it was moved into it visible area
		/**
		*   @desc: sets window's position (moves a window to the point set by user)
		*   @param: x - x coordinate
		*   @param: y - y coordinate
		*   @type: public
		*/
		win.setPosition = function(x, y) {
			this.x = x;
			this.y = y;
			// that._fixWindowPositionInViewport(this);
			// fixing mozilla artefakts
			/*
			if (_isFF) {
				this.h++;
				that._redrawWindow(this);
				this.h--;
			}
			*/
			that._engineFixWindowPosInViewport(this);
			that._engineRedrawWindowPos(this);
			// that._redrawWindow(this);
		}
		// return array(x, y) with position of window
		/**
		*   @desc: returns current window's position
		*   @type: public
		*/
		win.getPosition = function() {
			return new Array(this.x, this.y);
		}
		// set new dimension for window, if it will outlay the viewport it was moved into it visible area
		/**
		*   @desc: sets window's dimension
		*   @param: width
		*   @param: height
		*   @type: public
		*/
		win.setDimension = function(width, height) {
			// alert(2)
			if (width != null) {
				if (this.maxW != "auto") if (width > this.maxW) width = this.maxW;
				if (width < this.minW) width = this.minW;
				this.w = width;
			}
			if (height != null) {
				if (this.maxH != "auto") if (height > this.maxH) height = this.maxH;
				if (height < this.minH) height = this.minH;
				this.h = height;
			}
			that._fixWindowDimensionInViewport(this);
			// that._fixWindowPositionInViewport(this);
			that._engineFixWindowPosInViewport(this);
			//
			// that._redrawWindow(this);
			that._engineRedrawWindowSize(this);
			//
			this.updateNestedObjects();
		}
		// return array(width, height) with current dimension of window
		/**
		*   @desc: returns current window's dimension
		*   @type: public
		*/
		win.getDimension = function() {
			return new Array(this.w, this.h);
		}
		// set max dimension for window
		/**
		*   @desc: sets max window's dimension
		*   @param: maxWidth
		*   @param: maxHeight
		*   @type: public
		*/
		win.setMaxDimension = function(maxWidth, maxHeight) {
			this.maxW = (isNaN(maxWidth)?"auto":maxWidth);
			this.maxH = (isNaN(maxHeight)?"auto":maxHeight);
			//that._redrawWindow(this);
			that._engineRedrawWindowSize(this);
		}
		// return array(maxWidth, maxheight) with max dimension for window
		/**
		*   @desc: returns current max window's dimension
		*   @type: public
		*/
		win.getMaxDimension = function() {
			return new Array(this.maxW, this.maxH);
		}
		// set min dimensuion for window
		/**
		*   @desc: sets min window's dimension
		*   @param: minWidth
		*   @param: minHeight
		*   @type: public
		*/
		win.setMinDimension = function(minWidth, minHeight) {
			if (minWidth != null) { this.minW = minWidth; }
			if (minHeight != null) { this.minH = minHeight; }
			that._fixWindowDimensionInViewport(this);
			// that._redrawWindow(this);
			that._engineRedrawWindowPos(this);
		}
		// return array(minWidth, minHeight) with min dimension for window
		/**
		*   @desc: returns current min window's dimension
		*   @type: public
		*/
		win.getMinDimension = function() {
			return new Array(this.minW, this.minH);
		}
		
		win._adjustToContent = function(cw, ch) {
			that._engineAdjustWindowToContent(this, cw, ch);
		}
		win._doOnAttachMenu = function() {
			that._engineRedrawWindowSize(this);
			this.updateNestedObjects();
		}
		win._doOnAttachToolbar = function() {
			that._engineRedrawWindowSize(this);
			this.updateNestedObjects();
		}
		win._doOnAttachStatusBar = function() {
			that._engineRedrawWindowSize(this);
			this.updateNestedObjects();
		}
		win._doOnFrameMouseDown = function() {
			this.bringToTop();
		}
		win._doOnFrameContentLoaded = function() {
			that.callEvent("onContentLoaded",[this]);
		}
		/*
		win._doOnAttachURL = function(addIFrameEvents) {
			if (!addIFrameEvents) {
				// just call onContentLoaded
				that.callEvent("onContentLoaded", [this]);
				return;
			}
			// attach events into iframe
			if (_isIE) {
				// ie
				var w = this;
				var f = this._frame;
				f.onreadystatechange = function(a) {
					if (f.readyState == "complete") {
						try{f.contentWindow.document.body.onmousedown = function(){try{w.bringToTop();}catch(e){};};}catch(e){};
						try{that.callEvent("onContentLoaded",[w]);}catch(e){}
					}
				}
			} else {
				// ff, opera, safari
				var w = this;
				var f = this._frame;
				f.onload = function() {
					try {f.contentWindow.onmousedown = function(){try{w.bringToTop();}catch(e){};};}catch(e){};
					that.callEvent("onContentLoaded",[w]);
				}
			}
		}
		*/
//#wind_buttons:09062008{
		// add user button
		/**
		*   @desc: adds a user button
		*   @param: id - button's id
		*   @param: pos - button's position
		*   @param: title - button's tooltip
		*   @param: label - button's name (according to css)
		*   @type: public
		*/
		win.addUserButton = function(id, pos, title, label) {
			var userBtn = that._addUserButton(this, id, pos, title, label);
			return userBtn;
		}
		// remove user button
		/**
		*   @desc: removes a user button
		*   @param: id - button's id
		*   @type: public
		*/
		win.removeUserButton = function(id) {
			id = String(id).toLowerCase();
			if (!((id == "minmax1") || (id == "minmax2") || (id == "park") || (id == "close") || (id == "stick") || (id == "unstick") || (id == "help"))) {
				if (btn != null) { that._removeUserButton(this, id); }
			}
		}
//#}				
		/**
		*   @desc: shows a progress indicator
		*   @type: public
		*/
		win.progressOn = function() {
			that._engineSwitchWindowProgress(this, true);
		}
		/**
		*   @desc: hides a progress indicator
		*   @type: public
		*/
		win.progressOff = function() {
			that._engineSwitchWindowProgress(this, false);
		}
		/**
		*   @desc: sets a window to the fullscreen mode
		*   @param: state - true|false
		*   @type: public
		*/
		win.setToFullScreen = function(state) {
			that._setWindowToFullScreen(this, state);
		}
		/**
		*   @desc: shows window's header
		*   @type: public
		*/
		win.showHeader = function() {
			that._engineSwitchWindowHeader(this, true);
			// that._showWindowHeader(this);
		}
		/**
		*   @desc: hides window's header
		*   @type: public
		*/
		win.hideHeader = function() {
			that._engineSwitchWindowHeader(this, false);
			// that._hideWindowHeader(this);
		}
		//
		win.progressOff();
		// resize cursor modifications and handlers
		win.canStartResize = false;
		
		win.onmousemove = function(e) {
			
			if (_isIE && this._isMaximized) return true;
			e = e || event;
			
			var targetObj = e.target || e.srcElement;
			if (String(targetObj.className).search("dhtmlx_wins_resizer") < 0) targetObj = null;
			
			// resize not allowed
			if (!this._allowResize || this._allowResizeGlobal == false || !targetObj) {
				if (targetObj) { if (targetObj.style.cursor != "default") targetObj.style.cursor = "default"; }
				if (this.style.cursor != "default") this.style.cursor = "default";
				this.canStartResize = false;
				return true; // required to allow selection in IE
			}
			// resize can't be realized
			if (that.resizingWin != null) return;
			if (that.movingWin != null) return;
			if (this._isParked) return;
			// coords
			if (that._isIPad) {
				var px = e.touches[0].clientX;
				var py = e.touches[0].clientY;
			} else {
				var px = (_isIE||_isOpera?e.offsetX:e.layerX);
				var py = (_isIE||_isOpera?e.offsetY:e.layerY);
			}
			
			// direction
			var resDir = that._engineAllowWindowResize(win, targetObj, px, py);
			if (resDir == null) {
				this.canStartResize = false;
				if (targetObj.style.cursor != "default") targetObj.style.cursor = "default";
				if (this.style.cursor != "default") this.style.cursor = "default";
				return;
			}
			// prepare
			that.resizingDirs = resDir;
			var xy = {x:e.clientX,y:e.clientY};
			
			switch (that.resizingDirs) {
				case "border_left":
					targetObj.style.cursor = "w-resize";
					this.resizeOffsetX = this.x - xy.x;
					break;
				case "border_right":
					targetObj.style.cursor = "e-resize";
					this.resizeOffsetXW = this.x + this.w - xy.x;
					break;
				case "border_top":
					targetObj.style.cursor = "n-resize";
					this.resizeOffsetY = this.y - xy.y;
					break;
				case "border_bottom":
					targetObj.style.cursor = "n-resize";
					this.resizeOffsetYH = this.y + this.h - xy.y;
					break;
				case "corner_left":
					targetObj.style.cursor = "sw-resize";
					this.resizeOffsetX = this.x - e.clientX;
					this.resizeOffsetYH = this.y + this.h - xy.y;
					break;
				case "corner_up_left":
					targetObj.style.cursor = "nw-resize";
					this.resizeOffsetY = this.y - xy.y;
					this.resizeOffsetX = this.x - xy.x;
					break;
				case "corner_right":
					targetObj.style.cursor = "nw-resize";
					this.resizeOffsetXW = this.x + this.w - xy.x;
					this.resizeOffsetYH = this.y + this.h - xy.y;
					break;
				case "corner_up_right":
					targetObj.style.cursor = "sw-resize";
					this.resizeOffsetY = this.y - xy.y;
					this.resizeOffsetXW = this.x + this.w - xy.x;
					break;
			}
			this.canStartResize = true;
			this.style.cursor = targetObj.style.cursor;
			
			e.cancelBubble = true;
			e.returnValue = false;
			
			return false;
		}
		win.onmousedown = function(e) {
			
			if (that._getActive() != this) that._makeActive(this);
			that._bringOnTop(this);
			
			if (this.canStartResize) {
				that._blockSwitcher(true);
				that.resizingWin = this;
				if (!that._effects["resize"]) {
					that._carcass.x = that.resizingWin.x;
					that._carcass.y = that.resizingWin.y;
					that._carcass.w = Number(that.resizingWin.w)+(_isIE?0:-2);
					that._carcass.h = Number(that.resizingWin.h)+(_isIE?0:-2);
					that._carcass.style.left = that._carcass.x+"px";
					that._carcass.style.top = that._carcass.y+"px";
					that._carcass.style.width = that._carcass.w+"px";
					that._carcass.style.height = that._carcass.h+"px";
					that._carcass.style.zIndex = that._getTopZIndex(true)+1;
					that._carcass.style.cursor = this.style.cursor;
					that._carcass._keepInViewport = this._keepInViewport;
					that._carcass.style.display = "";
					
				}
				// vpcover
				that._vpcover.style.zIndex = that.resizingWin.style.zIndex-1;
				that._vpcover.style.display = "";
				// updated for 2.6-views
				if (this.vs[this.av].layout) { this.callEvent("_onBeforeTryResize", [this]); }
				e = e||event;
				//e.returnValue = false;
				//e.cancelBubble = true;
				//return false;
			}
			
		}
		// add buttons
		this._addDefaultButtons(win.idd);
		//
//#wind_buttons:09062008{
		// return button handler
		win.button = function(id) {
			id = String(id).toLowerCase();
			var b = null;
			if (this.btns[id] != null) { b = this.btns[id]; }
			return b;
		}
//#}		
		//
		/**
		*   @desc: centers a window in the viewport
		*   @type: public
		*/	
		win.center = function() {
			that._centerWindow(this, false);
		}
		/**
		*   @desc: centers a window on the screen
		*   @type: public
		*/
		win.centerOnScreen = function() {
			that._centerWindow(this, true);
		}
		//
		
		
		win._attachContent("empty", null);
		
		win._redraw = function() {
			that._engineRedrawWindowSize(this);
		}
		
		win.bringToTop();
		this._engineRedrawWindowSize(win);
		//win.setDimension(win.w, win.h);
		//window.setTitemout(function(){win.setDimension(win.w+100, win.h+100);},100);
		//
		return this.wins[id];
	}
	
	this.zIndexStep = 50;
	this._getTopZIndex = function(ignoreSticked) {
		var topZIndex = 0;
		for (var a in this.wins) {
			if (ignoreSticked == true) {
				if (this.wins[a].zi > topZIndex) { topZIndex = this.wins[a].zi; }
			} else {
				if (this.wins[a].zi > topZIndex && !this.wins[a]._isSticked) { topZIndex = this.wins[a].zi; }
			}
		}
		return topZIndex;
	}
	
	this.movingWin = null;
//#wind_move:09062008{
	this._moveWindow = function(e) {
		
		if (this.movingWin != null) {
			//
			if (!this.movingWin._allowMove || !this.movingWin._allowMoveGlobal) { return; }
			if (this._effects["move"] == true) {
				//
				// cursor
				if (this._engineGetWindowHeader(this.movingWin).style.cursor != "move") { this._engineGetWindowHeader(this.movingWin).style.cursor = "move"; }
				//
				this._wasMoved = true;
				//
				this.movingWin.x = (this._isIPad?e.touches[0].clientX:e.clientX) + this.movingWin.moveOffsetX;
				this.movingWin.y = (this._isIPad?e.touches[0].clientY:e.clientY) + this.movingWin.moveOffsetY;
				//
				// check out of viewport
				// this._fixWindowPositionInViewport(this.movingWin);
				this._engineFixWindowPosInViewport(this.movingWin);
				//
				// this._redrawWindow(this.movingWin);
				this._engineRedrawWindowPos(this.movingWin);
				
			} else {
				
				if (this._carcass.style.display != "") { this._carcass.style.display = ""; }
				// cursor
				if (this._carcass.style.cursor != "move") { this._carcass.style.cursor = "move"; }
				if (this._engineGetWindowHeader(this.movingWin).style.cursor != "move") { this._engineGetWindowHeader(this.movingWin).style.cursor = "move"; }
				//
				this._carcass.x = (this._isIPad?e.touches[0].clientX:e.clientX) + this.movingWin.moveOffsetX;
				this._carcass.y = (this._isIPad?e.touches[0].clientY:e.clientY) + this.movingWin.moveOffsetY;
				
				this._wasMoved = true;
				
				// this._fixWindowPositionInViewport(this._carcass);
				
				this._engineFixWindowPosInViewport(this._carcass);
				this._carcass.style.left = this._carcass.x+"px";
				this._carcass.style.top = this._carcass.y+"px";
				
			}
		}
		
		if (this.resizingWin != null) {
			//
			
			if (!this.resizingWin._allowResize) { return; }
			//
			
			// resize through left border
			var xy = {x:e.clientX,y:e.clientY};
			
			if (this.resizingDirs == "border_left" || this.resizingDirs == "corner_left" || this.resizingDirs == "corner_up_left") {
				if (this._effects["resize"]) {
					var ofs = xy.x + this.resizingWin.resizeOffsetX;
					var sign = (ofs > this.resizingWin.x ? -1 : 1);
					newW = this.resizingWin.w + Math.abs(ofs - this.resizingWin.x)*sign;
					if ((newW < this.resizingWin.minW) && (sign < 0)) {
						this.resizingWin.x = this.resizingWin.x + this.resizingWin.w - this.resizingWin.minW;
						this.resizingWin.w = this.resizingWin.minW;
					} else {
						this.resizingWin.w = newW;
						this.resizingWin.x = ofs;
					}
					this._engineRedrawWindowPos(this.resizingWin);
					this._engineRedrawWindowSize(this.resizingWin);
				} else {
					var ofs = xy.x + this.resizingWin.resizeOffsetX;
					var sign = (ofs > this._carcass.x ? -1 : 1);
					newW = this._carcass.w + Math.abs(ofs - this._carcass.x)*sign;
					if (newW > this.resizingWin.maxW) {
						newW = this.resizingWin.maxW;
						ofs = this._carcass.x + this._carcass.w - this.resizingWin.maxW;
					}
					if ((newW < this.resizingWin.minW) && (sign < 0)) {
						this._carcass.x = this._carcass.x + this._carcass.w - this.resizingWin.minW;
						this._carcass.w = this.resizingWin.minW;
					} else {
						this._carcass.w = newW;
						this._carcass.x = ofs;
					}
					this._carcass.style.left = this._carcass.x+"px";
					this._carcass.style.width = this._carcass.w+"px";
					
				}
			}
			// resize through right border
			if (this.resizingDirs == "border_right" || this.resizingDirs == "corner_right" || this.resizingDirs == "corner_up_right") {
				if (this._effects["resize"]) {
					var ofs = xy.x - (this.resizingWin.x + this.resizingWin.w) + this.resizingWin.resizeOffsetXW;
					newW = this.resizingWin.w + ofs;
					if (newW < this.resizingWin.minW) { newW = this.resizingWin.minW; }
					this.resizingWin.w = newW;
					this._engineRedrawWindowPos(this.resizingWin);
					this._engineRedrawWindowSize(this.resizingWin);
				} else {
					var ofs = xy.x - (this._carcass.x + this._carcass.w) + this.resizingWin.resizeOffsetXW;
					newW = this._carcass.w + ofs;
					if (newW < this.resizingWin.minW) newW = this.resizingWin.minW;
					if (this.resizingWin.maxW != "auto") if (newW > this.resizingWin.maxW) newW = this.resizingWin.maxW;
					this._carcass.w = newW;
					this._carcass.style.width = this._carcass.w+"px";
				}
			}
			// resize through bottom border
			if (this.resizingDirs == "border_bottom" || this.resizingDirs == "corner_left" || this.resizingDirs == "corner_right") {
				if (this._effects["resize"]) {
					var ofs = xy.y - (this.resizingWin.y + this.resizingWin.h) + this.resizingWin.resizeOffsetYH;
					newH = this.resizingWin.h + ofs;
					if (newH < this.resizingWin.minH) newH = this.resizingWin.minH;
					this.resizingWin.h = newH;
					this._engineRedrawWindowPos(this.resizingWin);
					this._engineRedrawWindowSize(this.resizingWin);
				} else {
					var ofs = xy.y - (this._carcass.y + this._carcass.h) + this.resizingWin.resizeOffsetYH;
					newH = this._carcass.h + ofs;
					if (newH < this.resizingWin.minH) newH = this.resizingWin.minH;
					if (newH > this.resizingWin.maxH) newH = this.resizingWin.maxH;
					this._carcass.h = newH;
					this._carcass.style.height = this._carcass.h+"px";
				}
			}
			if (this.resizingDirs == "border_top" || this.resizingDirs == "corner_up_right" || this.resizingDirs == "corner_up_left") {
				if (this._effects["resize"]) {
					
				} else {
					var ofs = xy.y + this.resizingWin.resizeOffsetY;
					var sign = (ofs > this.resizingWin.y ? -1 : 1);
					newH = this.resizingWin.h + Math.abs(ofs - this.resizingWin.y)*sign;
					if (newH > this.resizingWin.maxH) {
						newH = this.resizingWin.maxH;
						ofs = this.resizingWin.y + this.resizingWin.h - this.resizingWin.maxH;
					}
					if ((newH < this.resizingWin.minH) && (sign < 0)) {
						this._carcass.y = this._carcass.y + this._carcass.h - this.resizingWin.minH;
						this._carcass.h = this.resizingWin.minH;
					} else {
						this._carcass.h = newH+(_isIE?0:-2);
						this._carcass.y = ofs;
					}
					this._carcass.style.top = this._carcass.y+"px";
					this._carcass.style.height = this._carcass.h+"px";
				}
			}
		}
	}
	
	this._stopMove = function() {
		if (this.movingWin != null) {
			if (this._effects["move"]) {
				var win = this.movingWin;
				this.movingWin = null;
				this._blockSwitcher(false);
				// cursor
				// win.childNodes[0].childNodes[0].childNodes[0].childNodes[0].childNodes[0].childNodes[0].childNodes[0].childNodes[1].style.cursor = "";
				// win.childNodes[2].style.cursor = "";
				this._engineGetWindowHeader(win).style.cursor = "";
				// fixing mozilla artefakts
				if (_isFF) {
					win.h++;
					// this._redrawWindow(win);
					that._engineRedrawWindowPos(win);
					win.h--;
					// this._redrawWindow(win);
					that._engineRedrawWindowPos(win);
				}
			} else {
				this._carcass.style.cursor = "";
				this._carcass.style.display = "none";
				var win = this.movingWin;
				this._engineGetWindowHeader(win).style.cursor = "";
				this.movingWin = null;
				this._blockSwitcher(false);
				win.setPosition(parseInt(this._carcass.style.left), parseInt(this._carcass.style.top));
			}
			// vpcover
			this._vpcover.style.display = "none";
			// events
			if (this._wasMoved) {
				//
				if (win.checkEvent("onMoveFinish")) {
					win.callEvent("onMoveFinish",[win]);
				} else {
					this.callEvent("onMoveFinish",[win]);
				}
			}
			this._wasMoved = false;
		}
		if (this.resizingWin != null) {
			var win = this.resizingWin;
			this.resizingWin = null;
			this._blockSwitcher(false);
			if (!this._effects["resize"]) {
				this._carcass.style.display = "none";
				win.setDimension(this._carcass.w+(_isIE?0:2), this._carcass.h+(_isIE?0:2));
				win.setPosition(this._carcass.x, this._carcass.y);
			} else {
				// sizes in attached components
				win.updateNestedObjects();
			}
			// event in layout
			if (win.vs[win.av].layout) { win.vs[win.av].layout.callEvent("onResize", []); }
			// opera fix
			/*
			if (_isOpera) {
				win._content.childNodes[2].style.border="#FFFFFF 0px solid";
				var w = win._content.childNodes[2];
				window.setTimeout(function(){ w.style.border="none"; }, 1);
			}
			*/
			// vpcover
			this._vpcover.style.display = "none";
			// events
			if (win.checkEvent("onResizeFinish")) {
				win.callEvent("onResizeFinish",[win]);
			} else {
				this.callEvent("onResizeFinish",[win]);
			}
		}
	}
//#}	
	
	// check viewport overflow
	/*
	this._fixWindowPositionInViewport = function(win) {
		
		return;
		
		var skin = (win._skinParams!=null?win._skinParams:this.skinParams[this.skin]);
		if (win._keepInViewport) { // keep strongly in viewport
			if (win.x < 0) { win.x = 0; }
			if (win.x + win.w > this.vp.offsetWidth) { win.x = this.vp.offsetWidth - win.w; }
			// if (win.y < 0) { win.y = 0; }
			if (win.y + win.h > this.vp.offsetHeight) { win.y = this.vp.offsetHeight - win.h; }
			if (win.y < 0) { win.y = 0; }
		} else {
			// if (win.y < 0) { win.y = 0; }
			if (win.y + skin["header_height"] > this.vp.offsetHeight) { win.y = this.vp.offsetHeight - skin["header_height"]; }
			if (win.y < 0) { win.y = 0; }
			if (win.x + win.w - 10 < 0) { win.x = 10 - win.w; }
			if (win.x > this.vp.offsetWidth - 10) { win.x = this.vp.offsetWidth - 10; }
		}
	}
	*/
	
	// check and correct window dimensions
	this._fixWindowDimensionInViewport = function(win) {
		if (win.w < win.minW) { win.w = win.minW; }
		if (win._isParked) return;
		if (win.h < win.minH) { win.h = win.minH; }
	}
	
	this._bringOnTop = function(win) {
		var cZIndex = win.zi;
		var topZIndex = this._getTopZIndex(win._isSticked);
		for (var a in this.wins) {
			if (this.wins[a] != win) {
				if (win._isSticked || (!win._isSticked && !this.wins[a]._isSticked)) {
					if (this.wins[a].zi > cZIndex) {
						this.wins[a].zi = this.wins[a].zi - this.zIndexStep;
						this.wins[a].style.zIndex = this.wins[a].zi;
						if (this.iframeMode && this.wins[a].ifr) {
							this.wins[a].ifr.style.zIndex = this.wins[a].style.zIndex-1;
						}
					}
				}
			}
		}
		win.zi = topZIndex;
		win.style.zIndex = win.zi;
        if (this.iframeMode && win.ifr) {
            win.ifr.style.zIndex = topZIndex-1;
        }
	}
	
	this._makeActive = function(win, ignoreFocusEvent) {
		for (var a in this.wins) {
			if (this.wins[a] == win) {
				var needEvent = false;
				if (this.wins[a].className != "dhtmlx_window_active" && !ignoreFocusEvent) { needEvent = true; }
				this.wins[a].className = "dhtmlx_window_active";
				this._engineUpdateWindowIcon(this.wins[a], this.wins[a].icons[0]);
				if (needEvent == true) {
					if (win.checkEvent("onFocus")) {
						win.callEvent("onFocus",[win]);
					} else {
						this.callEvent("onFocus",[win]);
					}
				}
			} else {
				this.wins[a].className = "dhtmlx_window_inactive";
				this._engineUpdateWindowIcon(this.wins[a], this.wins[a].icons[1]);
			}
		}
	}
	
	this._getActive = function() {
		var win = null;
		for (var a in this.wins) {
			if (this.wins[a].className == "dhtmlx_window_active") {
				win = this.wins[a];
			}
		}
		return win;
	}
	
	this._centerWindow = function(win, onScreen) {
		if (win._isMaximized == true) return;
		// if (win._isParked == true) return;
		if (onScreen == true) {
			var vpw = (_isIE?document.body.offsetWidth:window.innerWidth);
			var vph = (_isIE?document.body.offsetHeight:window.innerHeight);
		} else {
			var vpw = (this.vp==document.body?document.body.offsetWidth:(Number(parseInt(this.vp.style.width))&&String(this.vp.style.width).search("%")==-1?parseInt(this.vp.style.width):this.vp.offsetWidth));
			var vph = (this.vp==document.body?document.body.offsetHeight:(Number(parseInt(this.vp.style.height))&&String(this.vp.style.height).search("%")==-1?parseInt(this.vp.style.height):this.vp.offsetHeight));
		}
		var newX = Math.round((vpw/2) - (win.w/2));
		var newY = Math.round((vph/2) - (win.h/2));
		win.x = newX;
		win.y = newY;
		// this._fixWindowPositionInViewport(win);
		this._engineFixWindowPosInViewport(win);
		// this._redrawWindow(win);
		this._engineRedrawWindowPos(win);
	}
	
	this._addDefaultButtons = function(winId) {
//#wind_buttons:09062008{
		
		var win = this.wins[winId];
		
		// stick
		var btnStick = this._engineGetWindowButton(win, "stick");
		btnStick.title = this.i18n.stick;
		btnStick.isVisible = false;
		btnStick.style.display = "none";
		btnStick._isEnabled = true;
		btnStick.isPressed = false;
		btnStick.label = "stick";
		btnStick._doOnClick = function() {
			this.isPressed = true;
			that._stickWindow(this.winId);
		}
		
		// sticked
		var btnSticked = this._engineGetWindowButton(win, "sticked");
		btnSticked.title = this.i18n.unstick;
		btnSticked.isVisible = false;
		btnSticked.style.display = "none";
		btnSticked._isEnabled = true;
		btnSticked.isPressed = false;
		btnSticked.label = "sticked";
		btnSticked._doOnClick = function() {
			this.isPressed = false;
			that._unstickWindow(this.winId);
		}
		
		// help
		var btnHelp = this._engineGetWindowButton(win, "help");
		btnHelp.title = this.i18n.help;
		btnHelp.isVisible = false;
		btnHelp.style.display = "none";
		btnHelp._isEnabled = true;
		btnHelp.isPressed = false;
		btnHelp.label = "help";
		btnHelp._doOnClick = function() { that._needHelp(this.winId); }
		
		// park
		var btnPark = this._engineGetWindowButton(win, "park");
		btnPark.titleIfParked = this.i18n.parkdown;
		btnPark.titleIfNotParked = this.i18n.parkup;
		btnPark.title = btnPark.titleIfNotParked;
		btnPark.isVisible = true;
		btnPark._isEnabled = true;
		btnPark.isPressed = false;
		btnPark.label = "park";
		btnPark._doOnClick = function() { that._parkWindow(this.winId); }
		
		// minmax maximize
		var btnMinMax1 = this._engineGetWindowButton(win, "minmax1");
		btnMinMax1.title = this.i18n.maximize;
		btnMinMax1.isVisible = true;
		btnMinMax1._isEnabled = true;
		btnMinMax1.isPressed = false;
		btnMinMax1.label = "minmax1";
		btnMinMax1._doOnClick = function() { that._maximizeWindow(this.winId); }
		
		// minmax restore
		var btnMinMax2 = this._engineGetWindowButton(win, "minmax2");
		btnMinMax2.title = this.i18n.restore;
		btnMinMax2.isVisible = false;
		btnMinMax2.style.display = "none";
		btnMinMax2._isEnabled = true;
		btnMinMax2.isPressed = false;
		btnMinMax2.label = "minmax2";
		btnMinMax2._doOnClick = function() { that._restoreWindow(this.winId); }
		
		// close
		var btnClose = this._engineGetWindowButton(win, "close");
		btnClose.title = this.i18n.close;
		btnClose.isVisible = true;
		btnClose._isEnabled = true;
		btnClose.isPressed = false;
		btnClose.label = "close";
		btnClose._doOnClick = function() { that._closeWindow(this.winId); }
		
		// dock
		var btnDock = this._engineGetWindowButton(win, "dock");
		btnDock.title = this.i18n.dock;
		btnDock.style.display = "none";
		btnDock.isVisible = false;
		btnDock._isEnabled = true;
		btnDock.isPressed = false;
		btnDock.label = "dock";
		btnDock._doOnClick = function() {
			
			// that._closeWindow(win);
		}
		
		//
		win._isSticked = false;
		win._isParked = false;
		win._isParkedAllowed = true;
		win._isMaximized = false;
		win._isDocked = false;
		
		//
		win.btns = {};
		win.btns["stick"] = btnStick;
		win.btns["sticked"] = btnSticked;
		win.btns["help"] = btnHelp;
		win.btns["park"] = btnPark;
		win.btns["minmax1"] = btnMinMax1;
		win.btns["minmax2"] = btnMinMax2;
		win.btns["close"] = btnClose;
		win.btns["dock"] = btnDock;
		
		// events
		for (var a in win.btns) {
			win.btns[a].winId = win.idd;
			this._attachEventsOnButton(win.idd, a);
		}
		
		win = btnStick = btnSticked = btnHelp = btnPark = btnMinMax1 = btnMinMax2 = btnClose = btnDock = null;
		//*/
//#}		
	}
//#wind_buttons:09062008{
	this._attachEventsOnButton = function(winId, btnId) {
		
		var btn = this.wins[winId].btns[btnId];
		
		// add events
		if (!this._isIPad) {
			
			btn.onmouseover = function() {
				if (this._isEnabled) {
					this.className = "dhtmlx_wins_btns_button dhtmlx_button_"+this.label+"_over_"+(this.isPressed?"pressed":"default");
				} else {
					this.className = "dhtmlx_wins_btns_button dhtmlx_button_"+this.label+"_disabled";
				}
			}
			btn.onmouseout = function() {
				if (this._isEnabled) {
					this.isPressed = false;
					this.className = "dhtmlx_wins_btns_button dhtmlx_button_"+this.label+"_default";
				} else {
					this.className = "dhtmlx_wins_btns_button dhtmlx_button_"+this.label+"_disabled";
				}
			}
			btn.onmousedown = function() {
				if (this._isEnabled) {
					this.isPressed = true;
					this.className = "dhtmlx_wins_btns_button dhtmlx_button_"+this.label+"_over_pressed";
				} else {
					this.className = "dhtmlx_wins_btns_button dhtmlx_button_"+this.label+"_disabled";
				}
			}
			btn.onmouseup = function() {
				if (this._isEnabled) {
					var wasPressed = this.isPressed;
					this.isPressed = false;
					this.className = "dhtmlx_wins_btns_button dhtmlx_button_"+this.label+"_over_default";
					if (wasPressed) {
						// events
						if (this.checkEvent("onClick")) {
							this.callEvent("onClick", [that.wins[this.winId], this]);
						} else {
							this._doOnClick();
						}
					}
				} else {
					this.className = "dhtmlx_wins_btns_button dhtmlx_button_"+this.label+"_disabled";
				}
			}
			
		} else {
			
			btn.ontouchstart = function(e) {
				e.cancelBubble = true;
				e.returnValue = false;
				return false;
			}
			btn.ontouchend = function(e) {
				e.cancelBubble = true;
				e.returnValue = false;
				if (!this._isEnabled) return false;
				
				// events
				if (this.checkEvent("onClick")) {
					this.callEvent("onClick", [that.wins[this.winId], this]);
				} else {
					this._doOnClick();
				}
				
				
				return false;
			}
			
		}
	
/**
*   @desc: shows a button
*   @type:  public
*/
		btn.show = function() {
			that._showButton(that.wins[this.winId], this.label, true);
		}
/**
*   @desc: hides a button
*   @type:  public
*/
		btn.hide = function() {
			that._hideButton(that.wins[this.winId], this.label, true);
		}
/**
*   @desc: enables a button
*   @type:  public
*/

		btn.enable = function() {
			that._enableButton(that.wins[this.winId], this.label);
		}

/**
*   @desc: disables a button
*   @type:  public
*/
		btn.disable = function() {
			that._disableButton(that.wins[this.winId], this.label);
		}
/**
*   @desc: checks if a button is enabled
*	@returns: true if enabled, otherwise - false
*   @type:  public
*/
		btn.isEnabled = function() {
			return this._isEnabled;
		}

/**
*   @desc: checks  if a button is hidden
*	@returns: true if hidden, otherwise - false
*   @type:  public
*/
		btn.isHidden = function() {
			return (!this.isVisible);
		}
		
		dhtmlxEventable(btn);
		
		btn = null;
	}
//#}	
//#wind_park:09062008{
	this._parkWindow = function(winId, parkBeforeMinMax) {
		var win = this.wins[winId];
		if (!win._isParkedAllowed && !parkBeforeMinMax) return;
		if (this.enableParkEffect && win.parkBusy) return;
		if (win._isParked) {
			// park down
			if (this.enableParkEffect && !parkBeforeMinMax) {
				// effect
				win.parkBusy = true;
				this._doParkDown(win);
			} else {
				// no effect
				win.h = win.lastParkH;
				this._engineRedrawWindowSize(win);
				this._engineDoOnWindowParkDown(win);
				win.updateNestedObjects();
				win.btns["park"].title = win.btns["park"].titleIfNotParked;
				if (win._allowResizeGlobal == true) {
					this._enableButton(win, "minmax1");
					this._enableButton(win, "minmax2");
				}
				win._isParked = false;
				// onParkDown event
				if (!parkBeforeMinMax) if (win.checkEvent("onParkDown")) win.callEvent("onParkDown", [win]); else this.callEvent("onParkDown", [win]);
			}
		} else {
			// park up
			if (this.enableParkEffect && !parkBeforeMinMax) {
				win.lastParkH = (String(win.h).search(/\%$/)==-1?win.h:win.offsetHeight);
				if (win._allowResizeGlobal == true) {
					this._disableButton(win, "minmax1");
					this._disableButton(win, "minmax2");
				}
				if (this.enableParkEffect) {
					win.parkBusy = true;
					this._doParkUp(win);
				} else {
					var skinParams = (win._skinParams!=null?win._skinParams:this.skinParams[this.skin]);
					win.h = skinParams["header_height"] + skinParams["border_bottom_height"];
					win.btns["park"].title = win.btns["park"].titleIfParked;
				}
			} else {
				win.lastParkH = (String(win.h).search(/\%$/)==-1?win.h:win.offsetHeight);
				win.h = this._engineGetWindowParkedHeight(win);
				this._engineRedrawWindowSize(win);
				this._engineDoOnWindowParkUp(win);
				win.btns["park"].title = win.btns["park"].titleIfParked;
				win._isParked = true;
				// onParkUp event
				if (!parkBeforeMinMax) if (win.checkEvent("onParkUp")) win.callEvent("onParkUp", [win]); else this.callEvent("onParkUp", [win]);
			}
		}
		win = null;
	}
	
	this._allowParking = function(win) {
		win._isParkedAllowed = true;
		this._enableButton(win, "park");
	}
	this._denyParking = function(win) {
		win._isParkedAllowed = false;
		this._disableButton(win, "park");
	}
	
	// park with effects
	this.enableParkEffect = false;
	this.parkStartSpeed = 80;
	this.parkSpeed = this.parkStartSpeed;
	this.parkTM = null;
	this.parkTMTime = 5;
	
	this._doParkUp = function(win) {
		if (String(win.h).search(/\%$/) != -1) { win.h = win.offsetHeight; }
		win.h -= this.parkSpeed;
		var hh = this._engineGetWindowParkedHeight(win);
		if (win.h <= hh) {
			// end purkUp
			win.h = hh;
			this._engineGetWindowButton(win, "park").title = this._engineGetWindowButton(win, "park").titleIfParked;
			win._isParked = true;
			win.parkBusy = false;
			this._engineRedrawWindowSize(win);
			this._engineDoOnWindowParkUp(win);
			if (win.checkEvent("onParkUp")) win.callEvent("onParkUp", [win]); else this.callEvent("onParkUp", [win]);
		} else {
			// continue purkUp
			this._engineRedrawWindowSize(win);
			this.parkTM = window.setTimeout(function(){that._doParkUp(win);}, this.parkTMTime);
		}
	}
	
	this._doParkDown = function(win) {
		win.h += this.parkSpeed;
		if (win.h >= win.lastParkH) {
			win.h = win.lastParkH;
			this._engineGetWindowButton(win, "park").title = this._engineGetWindowButton(win, "park").titleIfNotParked;
			if (win._allowResizeGlobal == true) {
				this._enableButton(win, "minmax1");
				this._enableButton(win, "minmax2");
			}
			win._isParked = false;
			win.parkBusy = false;
			this._engineRedrawWindowSize(win);
			win.updateNestedObjects();
			this._engineDoOnWindowParkDown(win);
			if (win.checkEvent("onParkDown")) win.callEvent("onParkDown", [win]); else this.callEvent("onParkDown", [win]);
		} else {
			// continue purkDown
			this._engineRedrawWindowSize(win);
			this.parkTM = window.setTimeout(function(){that._doParkDown(win);}, this.parkTMTime);
		}
	}
//#}
//#wind_buttons:09062008{
	this._enableButton = function(win, btn) {
		var button = this._engineGetWindowButton(win, btn);
		if (!button) return;
		button._isEnabled = true;
		button.className = "dhtmlx_wins_btns_button dhtmlx_button_"+button.label+"_default";
		button = null;
	}
	
	this._disableButton = function(win, btn) {
		var button = this._engineGetWindowButton(win, btn);
		if (!button) return;
		button._isEnabled = false;
		button.className = "dhtmlx_wins_btns_button dhtmlx_button_"+win.btns[btn].label+"_disabled";
		button = null;
	}
//#}
	// resize
	this._allowReszieGlob = function(win) {
		win._allowResizeGlobal = true;
		this._enableButton(win, "minmax1");
		this._enableButton(win, "minmax2");
	}
	
	this._denyResize = function(win) {
		win._allowResizeGlobal = false;
		this._disableButton(win, "minmax1");
		this._disableButton(win, "minmax2");
	}
	
	this._maximizeWindow = function(winId) {
		
		var win = this.wins[winId];
		
		if (win._allowResizeGlobal == false) return;
		
		var isParkedBeforeMinMax = win._isParked;
		if (isParkedBeforeMinMax) this._parkWindow(win.idd, true);
		
		win.lastMaximizeX = win.x;
		win.lastMaximizeY = win.y;
		win.lastMaximizeW = win.w;
		win.lastMaximizeH = win.h;
		// put window into top/left corner if complete maximize or center new maximized window if maxDimension set
		if (win.maxW != "auto" && win.maxW != "auto") {
			win.x = Math.round(win.x+(win.w-win.maxW)/2);
			win.y = Math.round(win.y+(win.h-win.maxH)/2);
			win._allowMove = true;
		} else {
			win.x = 0;
			win.y = 0;
			win._allowMove = false;
		}
		win._isMaximized = true;
		win._allowResize = false;
		// win.w = (win.maxW == "auto" ? (this.vp == document.body ? document.body.offsetWidth:parseInt(this.vp.style.width)) : win.maxW);
		// win.h = (win.maxH == "auto" ? (this.vp == document.body ? document.body.offsetHeight:parseInt(this.vp.style.height)) : win.maxH);
		//
		win.w = (win.maxW == "auto" ? (this.vp == document.body ? "100%" : (this.vp.style.width != "" && String(this.vp.style.width).search("%") == -1 ? parseInt(this.vp.style.width) : this.vp.offsetWidth)) : win.maxW);
		win.h = (win.maxH == "auto" ? (this.vp == document.body ? "100%" : (this.vp.style.height != "" && String(this.vp.style.width).search("%") == -1 ? parseInt(this.vp.style.height) : this.vp.offsetHeight)) : win.maxH);
		
		//
		this._hideButton(win, "minmax1");
		this._showButton(win, "minmax2");
		this._engineRedrawWindowPos(win);
		
		if (isParkedBeforeMinMax) {
			this._parkWindow(win.idd, true);
		} else {
			this._engineRedrawWindowSize(win);
			win.updateNestedObjects();
		}
		// event
		if (win.checkEvent("onMaximize")) win.callEvent("onMaximize", [win]); else this.callEvent("onMaximize", [win]);
		win = null;
	}
	
	this._restoreWindow = function(winId) {
		var win = this.wins[winId];
		if (win._allowResizeGlobal == false) return;
		if (win.layout) win.layout._defineWindowMinDimension(win);
		
		var isParkedBeforeMinMax = win._isParked;
		if (isParkedBeforeMinMax) this._parkWindow(win.idd, true);
		
		// put window to prev place if auto max dimension or center
		if (win.maxW != "auto" && win.maxW != "auto") {
			win.x = Math.round(win.x+(win.w-win.lastMaximizeW)/2);
			win.y = Math.round(win.y+(win.h-win.lastMaximizeH)/2);
		} else {
			win.x = win.lastMaximizeX;
			win.y = win.lastMaximizeY;
		}
		win.w = win.lastMaximizeW;
		win.h = win.lastMaximizeH;
		win._isMaximized = false;
		win._allowMove = win._allowMoveGlobal;
		win._allowResize = true;
		this._fixWindowDimensionInViewport(win);
		this._hideButton(win, "minmax2");
		this._showButton(win, "minmax1");
		this._engineRedrawWindowPos(win);
		
		if (isParkedBeforeMinMax) {
			this._parkWindow(win.idd, true);
		} else {
			this._engineRedrawWindowSize(win);
			win.updateNestedObjects();
		}
		// events
		if (win.checkEvent("onMinimize")) win.callEvent("onMinimize", [win]); else this.callEvent("onMinimize", [win]);
		win = null;
	}
//#wind_buttons:09062008{	
	this._showButton = function(win, btn, userShow) {
		var button = this._engineGetWindowButton(win, btn);
		if (!button) return;
		if ((!userShow && button._userHide) || button.isVisible === true) return;
		button.isVisible = true;
		button.style.display = "";
		button.style.visibility = "visible";
		button._userHide = !(userShow==true);
		this._engineRedrawWindowTitle(win);
		button = null;
	}
	
	this._hideButton = function(win, btn, userHide) {
		var button = this._engineGetWindowButton(win, btn);
		if (!button || (!userHide && button.isVisible === false)) return;
		button.isVisible = false;
		button.style.display = "none";
		button.style.visibility = "hidden";
		button._userHide = (userHide==true);
		this._engineRedrawWindowTitle(win);
		button = null;
	}
//#}	
	this._showWindow = function(win) {
		win.style.display = "";
		// event
		if (win.checkEvent("onShow")) {
			win.callEvent("onShow", [win]);
		} else {
			this.callEvent("onShow", [win]);
		}
		// fixed 24.03.2008
		var w = this._getActive();
		if (w == null) {
			this._bringOnTop(win);
			this._makeActive(win);
		} else if (this._isWindowHidden(w)) {
			this._bringOnTop(win);
			this._makeActive(win);
		}
		if (this.iframeMode && win.ifr) win.ifr.style.display = "";
	}
	
	this._hideWindow = function(win) {
		win.style.display = "none";
		// event
		if (win.checkEvent("onHide")) {
			win.callEvent("onHide", [win]);
		} else {
			this.callEvent("onHide", [win]);
		}
		// fixed 24.03.2008
		var w = this.getTopmostWindow(true);
		if (w != null) {
			this._bringOnTop(w);
			this._makeActive(w);
		}
		if (this.iframeMode && win.ifr) win.ifr.style.display = "none";
	}
	
	this._isWindowHidden = function(win) {
		var isHidden = (win.style.display == "none");
		return isHidden;
	}
	
	this._closeWindow = function(winId) {
		
		var win = this.wins[winId];
		
		// ie focus fix
		if (this._focusFixIE) {
			this._focusFixIE.style.top = (this.vp==document.body?0:getAbsoluteTop(this.vp))+Number(win.y)+"px";
			this._focusFixIE.focus();
		}
		
		// event
		if (win.checkEvent("onClose")) {
			if (!win.callEvent("onClose", [win])) return;
		} else {
			if(!this.callEvent("onClose", [win])) return;
		}
		
		// closing
		// for (var a in win.btns) { this._removeButtonGlobal(win, a, win.btns[a]); }
		
		win = null;
		
		this._removeWindowGlobal(winId);
		
		/*
		this.vp.removeChild(win);
		delete this.wins[win.idd];
		// make active latest window
		*/
		
		var latest = { "zi": 0 };
		for (var a in this.wins) { if (this.wins[a].zi > latest.zi) { latest = this.wins[a]; } }
		if (latest != null) { this._makeActive(latest); }
		
		/*
		// toolbar clicks events, temporary removed
		if (_isFF && this.vp != document.body) {
			this.vp.style.display = "none";
			var vp = this.vp;
			window.setTimeout(function(){vp.style.display="";},1);
		}
		*/
	}
	
	this._needHelp = function(winId) {
		// event only
		var win = this.wins[winId];
		if (win.checkEvent("onHelp")) {
			win.callEvent("onHelp", [win]);
		} else {
			this.callEvent("onHelp", [win]);
		}
		win = null;
	}
	this._setWindowIcon = function(win, iconEnabled, iconDisabled) {
		win.iconsPresent = true;
		win.icons[0] = this.imagePath + iconEnabled;
		win.icons[1] = this.imagePath + iconDisabled;
		this._engineUpdateWindowIcon(win, win.icons[win.isOnTop()?0:1]);
	}
	
	this._getWindowIcon = function(win) {
		if (win.iconsPresent) {
			return new Array(win.icons[0], win.icons[1]);
		} else {
			return new Array(null, null);
		}
	}
	
	this._clearWindowIcons = function(win) {
		win.iconsPresent = false;
		win.icons[0] = this.imagePath + this.pathPrefix + this.skin + "/active/icon_blank.gif";
		win.icons[1] = this.imagePath + this.pathPrefix + this.skin + "/inactive/icon_blank.gif";
		this._engineUpdateWindowIcon(win, win.icons[win.isOnTop()?0:1]);
	}
	
	this._restoreWindowIcons = function(win) {
		win.iconsPresent = true;
		win.icons[0] = this.imagePath + this.pathPrefix + this.skin + "/active/icon_normal.gif";
		win.icons[1] = this.imagePath + this.pathPrefix + this.skin + "/inactive/icon_normal.gif";
		this._engineUpdateWindowIcon(win, win.icons[win.className=="dhtmlx_window_active"?0:1]);
	}
	
	this._attachWindowContentTo = function(win, obj, w, h) {
		
		var data = this._engineGetWindowContent(win).parentNode;
		data.parentNode.removeChild(data);
		win.hide();
		data.style.left = "0px";
		data.style.top = "0px";
		data.style.width = (w!=null?w:obj.offsetWidth)+"px";
		data.style.height = (h!=null?h:obj.offsetHeight)+"px";
		data.style.position = "relative";
		//
		obj.appendChild(data);
		this._engineGetWindowContent(win).style.width = data.style.width;
		this._engineGetWindowContent(win).style.height = data.style.height;
		/*
		
		var data = win._content;
		data.parentNode.removeChild(data);
		win.hide();
		//
		data.style.left = "0px";
		data.style.top = "0px";
		data.style.width = (w!=null?w:obj.offsetWidth)+"px";
		data.style.height = (h!=null?h:obj.offsetHeight)+"px";
		data.style.position = "relative";
		//
		obj.appendChild(data);
		
		*/
		
	}
	
	this._setWindowToFullScreen = function(win, state) {
		
		if (state == true && !win._isFullScreened) {
			//
			win._p1 = win.vs[win.av].dhxcont.nextSibling;
			win._p1.parentNode.removeChild(win.vs[win.av].dhxcont);
			win.hide();
			win._isFullScreened = true;
			
			win._FSoffsetHeight = win._offsetHeight;
			win._FSoffsetHeightSaved = win._offsetHeightSaved;
			win._FSoffsetLeft = win._offsetLeft;
			win._FSoffsetWidth = win._offsetWidth;
			
			win._offsetHeight = 0;
			win._offsetHeightSaved = 0;
			win._offsetLeft = 0;
			win._offsetWidth = 0;
			
			win.vs[win.av].dhxcont.style.position = "absolute";
			document.body.appendChild(win.vs[win.av].dhxcont);
			win.adjustContent(document.body, 0, 0, false, 0);
			win.updateNestedObjects();
		}
		
		if (state == false && win._isFullScreened) {
			
			win._p1.parentNode.insertBefore(win.vs[win.av].dhxcont, win._p1);
			win._p1 = null;
			win._isFullScreened = false;
			
			win._offsetHeight = win._FSoffsetHeight;
			win._offsetHeightSaved = win._FSoffsetHeightSaved;
			win._offsetLeft = win._FSoffsetLeft;
			win._offsetWidth = win._FSoffsetWidth;
			
			win._FSoffsetHeight = win._FSoffsetHeightSaved = win._FSoffsetLeft = win._FSoffsetWidth = null;
			
			win.show();
			win.setDimension(win.w, win.h);
			
			win.bringToTop();
			
		}
		
	}
	
	this._isWindowOnTop = function(win) {
		var state = (this.getTopmostWindow() == win);
		return state;
	}
	
	this._bringOnBottom = function(win) {
		for (var a in this.wins) {
			if (this.wins[a].zi < win.zi) {
				this.wins[a].zi += this.zIndexStep;
				this.wins[a].style.zIndex = this.wins[a].zi;
			}
		}
		win.zi = 50;
		win.style.zIndex = win.zi;
		//
		this._makeActive(this.getTopmostWindow());
	}
	
	this._isWindowOnBottom = function(win) {
		var state = true;
		for (var a in this.wins) {
			if (this.wins[a] != win) {
				state = state && (this.wins[a].zi > win.zi);
			}
		}
		return state;
	}
	
	this._stickWindow = function(winId) {
		var win = this.wins[winId];
		win._isSticked = true;
		this._hideButton(win, "stick");
		this._showButton(win, "sticked");
		this._bringOnTop(win);
		win = null;
	}
	
	this._unstickWindow = function(winId) {
		var win = this.wins[winId];
		win._isSticked = false;
		this._hideButton(win, "sticked");
		this._showButton(win, "stick");
		this._bringOnTopAnyStickedWindows();
		win = null;
	}
//#wind_buttons:09062008{
	// add user button
	this._addUserButton = function(win, id, pos, title) {
		id = String(id).toLowerCase();
		var userButton = this._engineAddUserButton(win, id, pos);
		userButton.title = title;
		userButton.isVisible = true;
		userButton._isEnabled = true;
		userButton.isPressed = false;
		userButton.label = id;
		win.btns[id] = userButton;
		win.btns[id].winId = win.idd
		win.btns[id]._doOnClick = function(){};
		// attach events
		this._attachEventsOnButton(win.idd, id);
		userButton = null;
	}
	
	// remove user button
	this._removeUserButton = function(win, buttonId) {
		this._removeButtonGlobal(win, buttonId);
	}
//#}	
	// add iframe blockers before drag and resize
	this._blockSwitcher = function(state) {
		for (var a in this.wins) {
			if (state == true) {
				this.wins[a].showCoverBlocker();
			} else {
				this.wins[a].hideCoverBlocker();
			}
		}
	}
	
	this.resizingWin = null;
	this.modalWin = null;
	this.resizingDirs = "none";
	
	// init functions
	
	// focus fix ie case
	if (_isIE) {
		this._focusFixIE = document.createElement("INPUT");
		this._focusFixIE.className = "dhx_windows_ieonclosefocusfix";
		this._focusFixIE.style.position = "absolute";
		this._focusFixIE.style.width = "1px";
		this._focusFixIE.style.height = "1px";
		this._focusFixIE.style.border = "none";
		this._focusFixIE.style.background = "none";
		this._focusFixIE.style.left = "-10px";
		this._focusFixIE.style.fontSize = "1px";
		document.body.appendChild(this._focusFixIE);
	}
	
	this._createViewport();
//#wind_move:09062008{	
	this._doOnMouseUp = function() {
		if (that != null) that._stopMove();
	}
	this._doOnMoseMove = function(e) {
		e = e||event;
		if (that != null) that._moveWindow(e);
	}
//#}	
	this._resizeTM = null;
	this._resizeTMTime = 200;
	this._lw = null;
	this._doOnResize = function() {
		if (that._lw != document.documentElement.clientHeight) {
			window.clearTimeout(that._resizeTM);
			that._resizeTM = window.setTimeout(function(){that._autoResizeViewport();}, that._resizeTMTime);
		}
		that._lw = document.documentElement.clientHeight;
	}
	this._doOnUnload = function() {
		that.unload();
	}
	this._doOnSelectStart = function(e) {
		e = e||event;
		if (that.movingWin != null || that.resizingWin != null) e.returnValue = false;
	}
	if (_isIE) {
		if (typeof(window.addEventListener) != "undefined") {
			document.body.addEventListener("selectstart", this._doOnSelectStart, false);
		} else {
			document.body.attachEvent("onselectstart", this._doOnSelectStart);
		}
	}
	
	dhtmlxEvent(window, "resize", this._doOnResize);
	dhtmlxEvent(document.body, "unload", this._doOnUnload);
	
	if (this._isIPad) {
		document.addEventListener("touchmove", this._doOnMoseMove, false);
		document.addEventListener("touchend", this._doOnMouseUp, false);
	} else {
//#wind_move:09062008{		
		dhtmlxEvent(document.body, "mouseup", this._doOnMouseUp);
		dhtmlxEvent(this.vp, "mousemove", this._doOnMoseMove);
		dhtmlxEvent(this.vp, "mouseup", this._doOnMouseUp);
//#}
	}
	
	
	this._setWindowModal = function(win, state) {
		
		if (state == true) {
			
			this._makeActive(win);
			this._bringOnTop(win);
			this.modalWin = win;
			win._isModal = true;
			//
			this.modalCoverI.style.zIndex = win.zi - 2;
			this.modalCoverI.style.display = "";
			//
			this.modalCoverD.style.zIndex = win.zi - 2;
			this.modalCoverD.style.display = "";
		} else {
			this.modalWin = null;
			win._isModal = false;
			//
			this.modalCoverI.style.zIndex = 0;
			this.modalCoverI.style.display = "none";
			//
			this.modalCoverD.style.zIndex = 0;
			this.modalCoverD.style.display = "none";
		}
	}
	
	this._bringOnTopAnyStickedWindows = function() {
		var wins = new Array();
		for (var a in this.wins) { if (this.wins[a]._isSticked) { wins[wins.length] = this.wins[a]; } }
		for (var q=0; q<wins.length; q++) { this._bringOnTop(wins[q]); }
		// if no more sticked search any non-top active and move them on top
		if (wins.length == 0) {
			for (var a in this.wins) {
				if (this.wins[a].className == "dhtmlx_window_active") { this._bringOnTop(this.wins[a]); }
			}
		}
	}
	
	/**
	*   @desc: unloads an object and clears memory
	*   @param: id - button's id
	*   @type: public
	*/
	this.unload = function() {
		this._clearAll();
	}
	
	this._removeButtonGlobal = function(winId, buttonId) {
//#wind_buttons:09062008{
		//
		if (!this.wins[winId]) return;
		if (!this.wins[winId].btns[buttonId]) return;
		
		var btn = this.wins[winId].btns[buttonId];
		
		btn.title = null;
		btn.isVisible = null;
		btn._isEnabled = null;
		btn.isPressed = null;
		btn.label = null;
		
		btn._doOnClick = null;
		
		btn.detachAllEvents();
		
		btn.attachEvent = null;
		btn.callEvent = null;
		btn.checkEvent = null;
		btn.detachEvent = null;
		btn.detachAllEvents = null;
		btn.disable = null;
		btn.enable = null;
		btn.eventCatcher = null;
		btn.hide = null;
		btn.isEnabled = null;
		btn.isHidden = null;
		btn.show = null;
		
		btn.onmousedown = null;
		btn.onmouseout = null;
		btn.onmouseover = null;
		btn.onmouseup = null;
		btn.ontouchstart = null;
		btn.ontouchend = null;
		
		if (btn.parentNode) btn.parentNode.removeChild(btn);
		btn = null;
		
		this.wins[winId].btns[buttonId] = null;
		delete this.wins[winId].btns[buttonId];
//#}
	}
	
	
	this._removeWindowGlobal = function(winId) {
		
		var win = this.wins[winId];
		
		// modal check
		if (this.modalWin == win) this._setWindowModal(win, false);
		
		if (this.iframeMode && win.ifr) {
			win.ifr.parentNode.removeChild(win.ifr);
			win.ifr = null;
		}
		
		// clear attached frame events
		/*
		if (win._frame) {
			if (_isIE) {
				try {
					win._frame.onreadystatechange = null;
					win._frame.contentWindow.document.body.onmousedown = null;
					win._frame.onload = null;
				} catch(e) {}
			} else {
				try {
					win._frame.contentWindow.onmousedown = null;
					win._frame.onload = null;
				} catch(e) {}
			}
		}
		*/
		// clear cover events
		var t = win.coverBlocker();
		t.onselectstart = null;
		t = null;
		
		// remove onselect event
		this._engineDiableOnSelectInWindow(win, false);
		
		// remove dhxcont
		win._dhxContDestruct();
		
		// remove header events
		this._engineGetWindowHeader(win).onmousedown = null;
		this._engineGetWindowHeader(win).ondblclick = null;
		
		// clear links
		this.movingWin = null;
		this.resizingWin = null;
		
		// clearing buttons
		for (var a in win.btns) this._removeButtonGlobal(win, a);
		win.btns = null;
		
		win.detachAllEvents();
		
		// clear win other events
		win._adjustToContent = null;
		win._doOnAttachMenu = null;
		win._doOnAttachStatusBar = null;
		win._doOnAttachToolbar = null;
		win._doOnFrameMouseDown = null;
		win._doOnFrameContentLoaded = null;
		//
		win._redraw = null;
		win.addUserButton = null;
		win.allowMove = null;
		win.allowPark = null;
		win.allowResize = null;
		win.attachEvent = null;
		win.bringToBottom = null;
		win.bringToTop = null;
		win.callEvent = null;
		win.center = null;
		win.centerOnScreen = null;
		win.checkEvent = null;
		win.clearIcon = null;
		win.close = null;
		win.denyMove = null;
		win.denyPark = null;
		win.denyResize = null;
		win.detachEvent = null;
		win.detachAllEvents = null;
		win.eventCatcher = null;
		win.getDimension = null;
		win.getIcon = null;
		win.getId = null;
		win.getMaxDimension = null;
		win.getMinDimension = null;
		win.getPosition = null;
		win.getText = null;
		win.hide = null;
		win.hideHeader = null;
		win.isHidden = null;
		win.isMaximized = null;
		win.isModal = null;
		win.isMovable = null;
		win.isOnBottom = null;
		win.isOnTop = null;
		win.isParkable = null;
		win.isParked = null;
		win.isResizable = null;
		win.isSticked = null;
		win.keepInViewport = null;
		win.maximize = null;
		win.minimize = null;
		win.park = null;
		win.progressOff = null;
		win.progressOn = null;
		win.removeUserButton = null;
		win.restoreIcon = null;
		win.setDimension = null;
		win.setIcon = null;
		win.setMaxDimension = null;
		win.setMinDimension = null;
		win.setModal = null;
		win.setPosition = null;
		win.setText = null;
		win.setToFullScreen = null;
		win.show = null;
		win.showHeader = null;
		win.stick = null;
		win.unstick = null;
		
		win.onmousemove = null;
		win.onmousedown = null;
		
		win.icons = null;
		win.button = null;
		
		win._dhxContDestruct = null;
		
		win.dhxContGlobal.obj = null;
		win.dhxContGlobal.setContent = null;
		win.dhxContGlobal.dhxcont = null;
		win.dhxContGlobal = null;
		
		// frame
		if (win._frame) {
			while (win._frame.childNodes.length > 0) win._frame.removeChild(win._frame.childNodes[0]);
			win._frame = null;
		}
		
		// clear functions
		this._parseNestedForEvents(win);
		
		// remove from page
		win._content = null;
		win.innerHTML = "";
		win.parentNode.removeChild(win);
		
		win = null;
		
		this.wins[winId] = null;
		delete this.wins[winId];
		
	}
	
	this._removeEvents = function(obj) {
		obj.onmouseover = null;
		obj.onmouseout = null;
		obj.onmousemove = null;
		obj.onclick = null;
		obj.ondblclick = null;
		obj.onmouseenter = null;
		obj.onmouseleave = null;
		obj.onmouseup = null;
		obj.onmousewheel = null;
		obj.onmousedown = null;
		obj.onselectstart = null;
		obj.onfocus = null;
		obj.style.display = "";
		obj = null;
	}
	this._parseNestedForEvents = function(obj) {
		this._removeEvents(obj);
		for (var q=0; q<obj.childNodes.length; q++) {
			if (obj.childNodes[q].tagName != null) { this._parseNestedForEvents(obj.childNodes[q]); }
		}
		obj = null;
	}
	
	this._clearAll = function() {
		
		// remove events attached to document.body/window/viewport
		this._clearDocumentEvents();
		
		// remove windows
		for (var a in this.wins) this._removeWindowGlobal(a);
		this.wins = null;
		
		// remove carcass
		this._parseNestedForEvents(this._carcass);
		while (this._carcass.childNodes.length > 0) this._carcass.removeChild(this._carcass.childNodes[0]);
		this._carcass.onselectstart = null;
		this._carcass.parentNode.removeChild(this._carcass);
		this._carcass = null;
		
		// remove viewport cover
		this._parseNestedForEvents(this._vpcover);
		this._vpcover.parentNode.removeChild(this._vpcover);
		this._vpcover = null;
		
		// remove modal covers
		this._parseNestedForEvents(this.modalCoverD);
		this.modalCoverD.parentNode.removeChild(this.modalCoverD);
		this.modalCoverD = null;
		this._parseNestedForEvents(this.modalCoverI);
		this.modalCoverI.parentNode.removeChild(this.modalCoverI);
		this.modalCoverI = null;
		
		
		// remove viewport
		// this.vp.className = String(this.vp.className).replace(/[a-z_]{1,}/gi,function(t){return({"dhtmlx_skin_dhx_skyblue":1,"dhtmlx_skin_dhx_blue":1,"dhtmlx_skin_dhx_black":1,"dhtmlx_skin_dhx_web":1}[t]==1?"":t);});
		if (this.vp.autocreated == true) this.vp.parentNode.removeChild(this.vp);
		this.vp = null;
		
		// skin params
		for (var a in this.skinParams) { delete this.skinParams[a]; }
		this.skinParams = null;
		
		this._effects = null;
		this._engineSkinParams = null;
		
		this._addDefaultButtons = null;
		this._addUserButton = null;
		this._allowParking = null;
		this._allowReszieGlob = null;
		this._attachEventsOnButton = null;
		this._attachWindowContentTo = null;
		this._autoResizeViewport = null;
		this._blockSwitcher = null;
		this._bringOnBottom = null;
		this._bringOnTop = null;
		this._bringOnTopAnyStickedWindows = null;
		this._centerWindow = null;
		this._clearAll = null;
		this._clearDocumentEvents = null;
		this._clearWindowIcons = null;
		this._closeWindow = null;
		this._createViewport = null;
		this._denyParking = null;
		this._denyResize = null;
		this._dhx_Engine = null;
		this._disableButton = null;
		this._doOnMoseMove = null;
		this._doOnMouseUp = null;
		this._doOnResize = null;
		this._doOnSelectStart = null;
		this._doOnUnload = null;
		this._doParkDown = null;
		this._doParkUp = null;
		this._enableButton = null;
		this._engineAddUserButton = null;
		this._engineAdjustWindowToContent = null;
		this._engineAllowWindowResize = null;
		this._engineCheckHeaderMouseDown = null;
		this._engineDiableOnSelectInWindow = null;
		this._engineDoOnWindowParkDown = null;
		this._engineDoOnWindowParkUp = null;
		this._engineFixWindowPosInViewport = null;
		this._engineGetWindowButton = null;
		this._engineGetWindowContent = null;
		this._engineGetWindowHeader = null;
		this._engineGetWindowHeaderState = null;
		this._engineGetWindowLabel = null;
		this._engineGetWindowParkedHeight = null;
		this._engineRedrawSkin = null;
		this._engineRedrawWindowPos = null;
		this._engineRedrawWindowSize = null;
		this._engineRedrawWindowTitle = null;
		this._engineSetWindowBody = null;
		this._engineSwitchWindowHeader = null;
		this._engineSwitchWindowProgress = null;
		this._engineUpdateWindowIcon = null;
		this._fixWindowDimensionInViewport = null;
		this._genStr = null;
		this._getActive = null;
		this._getTopZIndex = null;
		this._getWindowIcon = null;
		this._hideButton = null;
		this._hideWindow = null;
		this._isWindowHidden = null;
		this._isWindowOnBottom = null;
		this._isWindowOnTop = null;
		this._makeActive = null;
		this._maximizeWindow = null;
		this._moveWindow = null;
		this._needHelp = null;
		this._parkWindow = null;
		this._parseNestedForEvents = null;
		this._removeButtonGlobal = null;
		this._removeEvents = null;
		this._removeUserButton = null;
		this._removeWindowGlobal = null;
		this._restoreWindow = null;
		this._restoreWindowIcons = null;
		this._setWindowIcon = null;
		this._setWindowModal = null;
		this._setWindowToFullScreen = null;
		this._showButton = null;
		this._showWindow = null;
		this._stickWindow = null;
		this._stopMove = null;
		this._unstickWindow = null;
		
		this.attachEvent = null;
		this.attachViewportTo = null;
		this.callEvent = null;
		this.checkEvent = null;
		this.createWindow = null;
		this.detachEvent = null;
		this.enableAutoViewport = null;
		this.eventCatcher = null;
		this.findByText = null;
		this.forEachWindow = null;
		this.getBottommostWindow = null;
		this.getEffect = null;
		this.getTopmostWindow = null;
		this.isWindow = null;
		this.setEffect = null;
		this.setImagePath = null;
		this.setSkin = null;
		this.setViewport = null;
		this.unload = null;
		this.window = null;
		
		that = null;
	}
	
	this._clearDocumentEvents = function() {
		if (typeof(window.addEventListener) == "function") {
			window.removeEventListener("resize", this._doOnResize, false);
			document.body.removeEventListener("mouseup", this._doOnMouseUp, false);
			document.body.removeEventListener("unload", this._doOnUnload, false);
			this.vp.removeEventListener("mousemove", this._doOnMoseMove, false);
			this.vp.removeEventListener("mouseup", this._doOnMouseUp, false);
		} else {
			window.detachEvent("onresize", this._doOnResize);
			document.body.detachEvent("onselectstart", this._doOnSelectStart);
			document.body.detachEvent("onmouseup", this._doOnMouseUp);
			document.body.detachEvent("onunload", this._doOnUnload);
			this.vp.detachEvent("onmousemove", this._doOnMoseMove);
			this.vp.detachEvent("onmouseup", this._doOnMouseUp);
		}
	}
	
	/* additional features */
	/*
	if (this._enableStatusBar != null) { this._enableStatusBar(); }
	if (this._enableWebMenu != null) { this._enableWebMenu(); }
	if (this._enableWebToolbar != null) { this._enableWebToolbar(); }
	*/
	
	this._genStr = function(w) {
		var s = ""; var z = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
		for (var q=0; q<w; q++) s += z.charAt(Math.round(Math.random() * (z.length-1)));
		return s;
	}
	
	dhtmlxEventable(this);
	return this;
};
dhtmlXWindows.prototype._dhx_Engine = function() {
	
	// engine init params
	this._engineEnabled = true;
	this._engineName = "dhx";
	
	// skin params
	// mh = menu height
	// th = toolbar height
	// sh = statusbar height
	this._engineSkinParams = {dhx_blue:	{"hh": 21, "lbw": 2, "rbw": 2, "lch": 2, "lcw": 14, "rch": 14, "rcw": 14, "bbh": 2, "mnh": 23, "tbh": 25, "sbh": 20, "noh_t": null, "noh_h": null},
				  dhx_black:	{"hh": 21, "lbw": 2, "rbw": 2, "lch": 2, "lcw": 14, "rch": 14, "rcw": 14, "bbh": 2, "mnh": 23, "tbh": 25, "sbh": 20, "noh_t": null, "noh_h": null},
				  dhx_skyblue:	{"hh": 29, "lbw": 2, "rbw": 2, "lch": 2, "lcw": 14, "rch": 14, "rcw": 14, "bbh": 2, "mnh": 23, "tbh": 25, "sbh": 20, "noh_t": 5, "noh_h": -10},
				  dhx_web:	{"hh": 27, "lbw": 5, "rbw": 5, "lch": 5, "lcw": 14, "rch": 14, "rcw": 14, "bbh": 5, "mnh": 23, "tbh": 25, "sbh": 20, "noh_t": 5, "noh_h": -10},
				  dhx_terrace:	{"hh": 37, "lbw": 5, "rbw": 5, "lch": 5, "lcw": 14, "rch": 14, "rcw": 14, "bbh": 5, "mnh": 23, "tbh": 25, "sbh": 20, "noh_t": 5, "noh_h": -10}
	};
	
	this._isIE6 = false;
	if (_isIE) this._isIE6 = (window.XMLHttpRequest==null?true:false);
	
	// forms window html
	this._engineSetWindowBody = function(win) {
		win.innerHTML = "<div iswin='1' class='dhtmlx_wins_body_outer' style='position: relative;'>"+
					(this._isIE6?"<iframe src='javascript:false;' frameborder='0' class='dhtmlx_wins_ie6_cover_fix' onload='this.contentWindow.document.body.style.overflow=\"hidden\";'></iframe>":"")+
					"<div class='dhtmlx_wins_icon'></div>"+
					"<div class='dhtmlx_wins_progress'></div>"+
					"<div class='dhtmlx_wins_title'>dhtmlxWindow</div>"+
					"<div class='dhtmlx_wins_btns'>"+
						"<div class='dhtmlx_wins_btns_button dhtmlx_button_sticked_default'></div>"+
						"<div class='dhtmlx_wins_btns_button dhtmlx_button_stick_default'></div>"+
						"<div class='dhtmlx_wins_btns_button dhtmlx_button_help_default'></div>"+
						"<div class='dhtmlx_wins_btns_button dhtmlx_button_park_default'></div>"+
						"<div class='dhtmlx_wins_btns_button dhtmlx_button_minmax2_default'></div>"+
						"<div class='dhtmlx_wins_btns_button dhtmlx_button_minmax1_default'></div>"+
						"<div class='dhtmlx_wins_btns_button dhtmlx_button_close_default'></div>"+
						"<div class='dhtmlx_wins_btns_button dhtmlx_button_dock_default'></div>"+
					"</div>"+
					"<div class='dhtmlx_wins_body_inner'></div>"+
					"<div winResT='yes' class='dhtmlx_wins_resizer_t' style='display:none;'></div>"+
					"<div winResL='yes' class='dhtmlx_wins_resizer_l'></div>"+
					"<div winResR='yes' class='dhtmlx_wins_resizer_r'></div>"+
					"<div winResB='yes' class='dhtmlx_wins_resizer_b'></div>"+
					"<div class='white_line'></div>"+
					"<div class='white_line2'></div>"+
				"</div>";
		
		// dhxCont(win);
		win.dhxContGlobal = new dhtmlXContainer(win);
		if (this.skin == "dhx_skyblue") {
			win.dhxContGlobal.obj._offsetWidth = -10;
			win.dhxContGlobal.obj._offsetHeight = -5;
			win.dhxContGlobal.obj._offsetLeft = 5;
			win.dhxContGlobal.obj._offsetHeightSaved = win.dhxContGlobal.obj._offsetHeight;
		}
		if (this.skin == "dhx_web") {
			win.dhxContGlobal.obj._offsetWidth = -10;
			win.dhxContGlobal.obj._offsetHeight = -5;
			win.dhxContGlobal.obj._offsetLeft = 5;
			win.dhxContGlobal.obj._offsetHeightSaved = win.dhxContGlobal.obj._offsetHeight;
		}
		win.skin = this.skin;
		win.dhxContGlobal.setContent(win.childNodes[0].childNodes[(this._isIE6?5:4)]);
		
		var t = win.coverBlocker();
		t.onselectstart = function(e) {
			e = e||event;
			e.returnValue = false;
			e.cancelBubble = true;
		}
		t = null;
		
		if (this.iframeMode) {
			win.ifr = document.createElement("IFRAME");
			win.ifr.style.position = "absolute";
			win.ifr.style.left = win.style.left;
			win.ifr.style.top = win.style.top;
			win.ifr.style.width = win.style.width;
			win.ifr.style.height = win.style.height;
			win.ifr.style.zIndex = win.style.zIndex-1;
			win.ifr.style.backgroundColor = "white";
			win.ifr.frameBorder = 0;
			win.ifr.setAttribute("src","javascript:false;");
			win.parentNode.appendChild(win.ifr);
		}
	}
	
	// block selection
	this._engineDiableOnSelectInWindow = function(win, state) {
		var data = new Array();
		data[0] = win.childNodes[0].childNodes[(this._isIE6?1:0)];
		data[1] = win.childNodes[0].childNodes[(this._isIE6?2:1)];
		data[2] = win.childNodes[0].childNodes[(this._isIE6?3:2)];
		data[3] = win.childNodes[0].childNodes[(this._isIE6?4:3)];
		// resizers
		data[4] = win.childNodes[0].childNodes[(this._isIE6?6:5)];
		data[5] = win.childNodes[0].childNodes[(this._isIE6?7:6)];
		data[6] = win.childNodes[0].childNodes[(this._isIE6?8:7)];
		data[7] = win.childNodes[0].childNodes[(this._isIE6?9:8)];
		for (var q=0; q<data.length; q++) {
			//console.log(data[q])
			data[q].onselectstart = (state?function(e){e=e||event;e.returnValue=false;return false;}:null);
			data[q] = null;
		}
		data = null;
	}
	
	// return window header
	this._engineGetWindowHeader = function(win) {
		win.childNodes[0].idd = win.idd;
		return win.childNodes[0];
	}
	
	// setting correct size for window
	this._engineRedrawWindowSize = function(win) {
		
		win.style.width = (String(win.w).search("%")==-1?win.w+"px":win.w);
		win.style.height = (String(win.h).search("%")==-1?win.h+"px":win.h);
		
		var body = win.childNodes[0];
		
		body.style.width = win.clientWidth+"px";
		body.style.height = win.clientHeight+"px";
		
		if (body.offsetWidth > win.clientWidth) { body.style.width = win.clientWidth*2-body.offsetWidth+"px"; }
		if (body.offsetHeight > win.clientHeight) {
			// park check
			var px = win.clientHeight*2-body.offsetHeight;
			if (px < 0) px = 0;
			//
			body.style.height = px+"px";
		}
		
		var hh = (win._noHeader==true?win._hdrSize:this._engineSkinParams[this.skin]["hh"]);
		
		if (this.iframeMode && win.ifr) {
			win.ifr.style.width = win.style.width;
			win.ifr.style.height = win.style.height;
		}
		
		// header
		this._engineRedrawWindowTitle(win);
		
		win.adjustContent(body, hh);
		// this.updateNestedObjects();
	}
	
	// redraw window position
	this._engineRedrawWindowPos = function(win) {
		
		if (win._isFullScreened) return;
		win.style.left = win.x + "px";
		win.style.top = win.y + "px";
		
		if (this.iframeMode && win.ifr) {
			win.ifr.style.top = win.style.top;
			win.ifr.style.left = win.style.left;
		}
		
	}
	
	// fixing window position in viewport
	this._engineFixWindowPosInViewport = function(win) {
		
		// var hh = this._engineSkinParams[this.skin]["hh"];
		var hh = (win._noHeader==true?win._hdrSize:this._engineSkinParams[this.skin]["hh"]);
		if (win._keepInViewport) { // keep strongly in viewport
			if (win.x < 0) { win.x = 0; }
			if (win.x + win.w > this.vp.offsetWidth) { win.x = this.vp.offsetWidth - win.w; }
			// if (win.y < 0) { win.y = 0; }
			if (win.y + win.h > this.vp.offsetHeight) { win.y = this.vp.offsetHeight - win.h; }
			if (win.y < 0) { win.y = 0; }
		} else {
			// if (win.y < 0) { win.y = 0; }
			if (win.y + hh > this.vp.offsetHeight) { win.y = this.vp.offsetHeight - hh; }
			if (win.y < 0) { win.y = 0; }
			if (win.x + win.w - 10 < 0) { win.x = 10 - win.w; }
			if (win.x > this.vp.offsetWidth - 10) { win.x = this.vp.offsetWidth - 10; }
		}
		
	}
	
	// check is header in onmousedown
	this._engineCheckHeaderMouseDown = function(win, ev) {
		if (this._isIPad) {
			var x = ev.touches[0].clientX;
			var y = ev.touches[0].clientY;
			var obj = ev.target||ev.srcElement;
			if (obj == win.childNodes[0] || obj == win.childNodes[0].childNodes[0] || obj == win.childNodes[0].childNodes[2] || obj == win.childNodes[0].childNodes[3]) return true;
			return false;
		} else {
			var x = (_isIE||_isOpera?ev.offsetX:ev.layerX);
			var y = (_isIE||_isOpera?ev.offsetY:ev.layerY);
			var obj = ev.target||ev.srcElement;
		}
		
		var hh = (win._noHeader==true?win._hdrSize:this._engineSkinParams[this.skin]["hh"]);
		if (y <= hh && (obj == win.childNodes[0] || obj == win.childNodes[0].childNodes[(this._isIE6?1:0)] || obj == win.childNodes[0].childNodes[(this._isIE6?3:2)] || obj == win.childNodes[0].childNodes[(this._isIE6?4:3)])) return true;
		return false;
	}
	
	// return window content
	this._engineGetWindowContent = function(win) {
		alert("_engineGetWindowContent");
		/*
		var contObj = null;
		var contPoly = win.childNodes[0].childNodes[(this._isIE6?5:4)];
		for (var q=0; q<contPoly.childNodes.length; q++) { if (contPoly.childNodes[q].getAttribute("iscont") != null) { if (contPoly.childNodes[q].getAttribute("iscont") === "1") { contObj = contPoly.childNodes[q]; } } }
		if (contObj != null) {
			win._contObj = contObj;
		} else {
			if (win._contObj != null) {
				contObj = win._contObj;
			}
		}
		return contObj; //.childNodes[0];
		*/
	}
	
	// return window button
	this._engineGetWindowButton = function(win, buttonName) {
		buttonName = String(buttonName).toLowerCase();
		var buttonObj = null;
		var buttonStyle = "dhtmlx_button_"+buttonName+"_";
		for (var q=0; q<win.childNodes[0].childNodes[(this._isIE6?4:3)].childNodes.length; q++) {
			var buttonTemp = win.childNodes[0].childNodes[(this._isIE6?4:3)].childNodes[q];
			if (String(buttonTemp.className).search(buttonStyle) != -1) { buttonObj = buttonTemp; }
			buttonTemp = null;
		}
		return buttonObj;
	}
	
	// adding user button
	this._engineAddUserButton = function(win, buttonName, buttonPos) {
		if (isNaN(buttonPos)) buttonPos = 0;
		var button = document.createElement("DIV");
		button.className = "dhtmlx_wins_btns_button dhtmlx_button_"+buttonName+"_default";
		var buttonPoly = win.childNodes[0].childNodes[(this._isIE6?4:3)];
		buttonPos = buttonPoly.childNodes.length - buttonPos;
		if (buttonPos < 0) buttonPos = 0;
		if (buttonPos >= buttonPoly.childNodes.length) {
			buttonPoly.appendChild(button);
		} else {
			buttonPoly.insertBefore(button, buttonPoly.childNodes[buttonPos]);
		}
		this._engineRedrawWindowTitle(win);
		return button;
	}
	
	// return min park height
	this._engineGetWindowParkedHeight = function(win) {
		return this._engineSkinParams[this.skin]["hh"]+1;
	}
	
	// do on window park down
	this._engineDoOnWindowParkDown = function(win) {
		// console.log(1)
		win.childNodes[0].childNodes[(this._isIE6?6:5)].style.display = (win._noHeader==true?"":"none");
		win.childNodes[0].childNodes[(this._isIE6?7:6)].style.display = "";
		win.childNodes[0].childNodes[(this._isIE6?8:7)].style.display = "";
		win.childNodes[0].childNodes[(this._isIE6?9:8)].style.display = "";
	}
	
	// do on window park up
	this._engineDoOnWindowParkUp = function(win) {
		win.childNodes[0].childNodes[(this._isIE6?6:5)].style.display = "none";
		win.childNodes[0].childNodes[(this._isIE6?7:6)].style.display = "none";
		win.childNodes[0].childNodes[(this._isIE6?8:7)].style.display = "none";
		win.childNodes[0].childNodes[(this._isIE6?9:8)].style.display = "none";
	}
	
	// update window's icon
	this._engineUpdateWindowIcon = function(win, icon) {
		win.childNodes[0].childNodes[(this._isIE6?1:0)].style.backgroundImage = "url('"+icon+"')";
		
	}
	
	// check is targetObj a windows node and is resize allowed
	this._engineAllowWindowResize = function(win, targetObj, mouseX, mouseY) {
		 // IE fix for disabled input
		if (!targetObj.getAttribute) return;
		//
		var sk = this._engineSkinParams[this.skin];
		var hh = (win._noHeader==true?win._hdrSize:this._engineSkinParams[this.skin]["hh"]);
		if (targetObj.getAttribute("winResL") != null) {
			if (targetObj.getAttribute("winResL") == "yes") {
				if (mouseY >= hh) {
					if (mouseY >= win.h - sk["lch"]) return "corner_left";
					if (mouseY <= sk["lch"] && win._noHeader == true) return "corner_up_left";
					return "border_left";
				}
			}
		}
		if (targetObj.getAttribute("winResR") != null) {
			if (targetObj.getAttribute("winResR") == "yes") {
				if (mouseY >= hh) {
					if (mouseY >= win.h - sk["rch"]) return "corner_right";
					if (mouseY <= sk["rch"] && win._noHeader == true) return "corner_up_right";
					 return "border_right";
				}
			}
		}
		if (targetObj.getAttribute("winResT") != null) {
			if (targetObj.getAttribute("winResT") == "yes" && win._noHeader == true) {
				if (mouseX <= sk["lcw"]) return "corner_up_left";
				if (mouseX >= win.w - sk["rcw"]) return "corner_up_right";
				return "border_top";
			}
		}
		if (targetObj.getAttribute("winResB") != null) {
			if (targetObj.getAttribute("winResB") == "yes") {
				if (mouseX <= sk["lcw"]) return "corner_left";
				if (mouseX >= win.w - sk["rcw"]) return "corner_right";
				return "border_bottom";
			}
		}
		return null;
	}
	
	// adjusting window to content size
	this._engineAdjustWindowToContent = function(win, w, h) {
		var newW = w+win.w-win.vs[win.av].dhxcont.clientWidth;
		var newH = h+win.h-win.vs[win.av].dhxcont.clientHeight;
		win.setDimension(newW, newH);
	}
	
	// redraw windows skin
	this._engineRedrawSkin = function() {
		this.vp.className = (this.vp==document.body&&this.vp._css?this.vp._css+" ":"")+"dhtmlx_winviewport dhtmlx_skin_"+this.skin+(this._r?" dhx_wins_rtl":"");
		var sk = this._engineSkinParams[this.skin];
		for (var a in this.wins) {
			if (this.skin == "dhx_skyblue") {
				this.wins[a].dhxContGlobal.obj._offsetTop = (this.wins[a]._noHeader?sk["noh_t"]:null);
				this.wins[a].dhxContGlobal.obj._offsetWidth = -10;
				this.wins[a].dhxContGlobal.obj._offsetHeight = (this.wins[a]._noHeader?sk["noh_h"]:-5);
				this.wins[a].dhxContGlobal.obj._offsetLeft = 5;
				this.wins[a].dhxContGlobal.obj._offsetHeightSaved = -5;
			} else {
				this.wins[a].dhxContGlobal.obj._offsetWidth = null;
				this.wins[a].dhxContGlobal.obj._offsetHeight = null;
				this.wins[a].dhxContGlobal.obj._offsetLeft = null;
				this.wins[a].dhxContGlobal.obj._offsetTop = null;
				this.wins[a].dhxContGlobal.obj._offsetHeightSaved = null;
			}
			this.wins[a].skin = this.skin;
			this._restoreWindowIcons(this.wins[a]);
			this._engineRedrawWindowSize(this.wins[a]);
		}
	}
	
	// enable/disable window loader
	this._engineSwitchWindowProgress = function(win, state) {
		if (state == true) {
			win.childNodes[0].childNodes[(this._isIE6?1:0)].style.display = "none";
			win.childNodes[0].childNodes[(this._isIE6?2:1)].style.display = "";
		} else {
			win.childNodes[0].childNodes[(this._isIE6?2:1)].style.display = "none";
			win.childNodes[0].childNodes[(this._isIE6?1:0)].style.display = "";
		}
	}
	
	// show/hide window header
	this._engineSwitchWindowHeader = function(win, state) {
		if (!win._noHeader) win._noHeader = false;
		if (state != win._noHeader) return;
		//
		win._noHeader = (state==true?false:true);
		win._hdrSize = 0;
		win.childNodes[0].childNodes[(this._isIE6?5:4)].className = "dhtmlx_wins_body_inner"+(win._noHeader?" dhtmlx_wins_no_header":"");
		win.childNodes[0].childNodes[(this._isIE6?6:5)].style.display = (win._noHeader?"":"none");
		win.childNodes[0].childNodes[(this._isIE6?1:0)].style.display = (win._noHeader?"none":"");
		// title
		win.childNodes[0].childNodes[(this._isIE6?3:2)].style.display = (win._noHeader?"none":"");
		// buttons
		win.childNodes[0].childNodes[(this._isIE6?4:3)].style.display = (win._noHeader?"none":"");
		//
		var sk = this._engineSkinParams[this.skin];
		if (win._noHeader) {
			win.dhxContGlobal.obj._offsetHeightSaved = win.dhxContGlobal.obj._offsetHeight;
			win.dhxContGlobal.obj._offsetHeight = sk["noh_h"];
			win.dhxContGlobal.obj._offsetTop = sk["noh_t"];
		} else {
			win.dhxContGlobal.obj._offsetHeight = win.dhxContGlobal.obj._offsetHeightSaved;
			win.dhxContGlobal.obj._offsetTop = null;
		}
		this._engineRedrawWindowSize(win);
	}
	
	// return true if header is visible
	this._engineGetWindowHeaderState = function(win) {
		return (win._noHeader?true:false);
	}
	
	// return window label
	this._engineGetWindowLabel = function(win) {
		return win.childNodes[0].childNodes[(this._isIE6?3:2)];
	}
	
	// redraw window's header text
	this._engineRedrawWindowTitle = function(win) {
		if (win._noHeader!==true) {
			var p2 = win.childNodes[0].childNodes[(this._isIE6?1:0)].offsetWidth; // icon
			var p3 = win.childNodes[0].childNodes[(this._isIE6?4:3)].offsetWidth; // buttons
			var newW = win.offsetWidth-p2-p3-24;
			if (newW < 0) newW = "100%"; else newW += "px";
			win.childNodes[0].childNodes[(this._isIE6?3:2)].style.width = newW;
			/*
				var p1 = win.childNodes[0].childNodes[(this._isIE6?3:2)].offsetLeft;
				var p2 = win.childNodes[0].childNodes[(this._isIE6?4:3)].offsetWidth;
				var newW = win.offsetWidth-p1-p2-16;
				if (newW < 0) { newW = "100%"; } else { newW += "px"; }
				win.childNodes[0].childNodes[(this._isIE6?3:2)].style.width = newW;
			*/
		}
	}
	
};

dhtmlXWindows.prototype.i18n = {
	dhxcontaler: "dhtmlxcontainer.js is missed on the page",
	noenginealert: "No dhtmlxWindows engine was found.",
	stick: "Stick",
	unstick: "Unstick",
	help: "Help",
	parkdown: "Park Down",
	parkup: "Park Up",
	maximize: "Maximize",
	restore: "Restore",
	close: "Close",
	dock: "Dock"
};

(function(){
	
	dhtmlx.extend_api("dhtmlXWindows",{
		_init:function(obj){
			return [];
		},
		_patch:function(obj){
			obj.old_createWindow=obj.createWindow;
			obj.createWindow=function(obj){
				if (arguments.length>1) return this.old_createWindow.apply(this,arguments);
				var res = this.old_createWindow(obj.id,(obj.x||obj.left),(obj.y||obj.top),obj.width,obj.height);
				
				res.allowMoveA=function(mode){
					if (mode) this.allowMove();
					else this.denyMove();
				}
				res.allowParkA=function(mode){
					if (mode) this.allowPark();
					else this.denyPark();
				}
				res.allowResizeA=function(mode){
					if (mode) this.allowResize();
					else this.denyResize();
				}
				
				//local settings
				for (var a in obj){
					if (map[a]) res[map[a]](obj[a]);
					else if (a.indexOf("on")==0){
						res.attachEvent(a,obj[a]);
					}
				}
				return res;
			}
		},
		animation:"setEffect",
		image_path:"setImagePath",
		skin:"setSkin",
		viewport:"_viewport",
		wins:"_wins"
	},{
		_viewport:function(data){
			if (data.object) {
				this.enableAutoViewport(false);
				this.attachViewportTo(data.object);
			} else {
				this.enableAutoViewport(false);
				this.setViewport(data.left, data.top, data.width, data.height, data.parent);
			}
		},
		_wins:function(arr){
			for (var q=0; q<arr.length; q++) {
				var win = arr[q];
				this.createWindow(win.id, win.left, win.top, win.width, win.height);
				if (win.text) this.window(win.id).setText(win.text);
				if (win.keep_in_viewport) this.window(win.id).keepInViewport(true);
				if (win.deny_resize) this.window(win.id).denyResize();
				if (win.deny_park) this.window(win.id).denyPark();
				if (win.deny_move) this.window(win.id).denyMove();
			}
		}
	});
	
	var map={
		move:"allowMoveA",
		park:"allowParkA",
		resize:"allowResizeA",
		center:"center",
		modal:"setModal",
		caption:"setText",
		header:"showHeader"
	};
})();
function dhtmlXContainer(obj) {
	
	var that = this;
	
	this.obj = obj;
	obj = null;
	
	this.obj._padding = true;
	
	this.dhxcont = null;
	
	this.st = document.createElement("DIV");
	this.st.style.position = "absolute";
	this.st.style.left = "-200px";
	this.st.style.top = "0px";
	this.st.style.width = "100px";
	this.st.style.height = "1px";
	this.st.style.visibility = "hidden";
	this.st.style.overflow = "hidden";
	document.body.insertBefore(this.st, document.body.childNodes[0]);
	
	this.obj._getSt = function() {
		// return this.st object, needed for content moving
		return that.st;
	}
	
	this.obj.dv = "def"; // default
	this.obj.av = this.obj.dv; // active for usage
	this.obj.cv = this.obj.av; // current opened
	this.obj.vs = {}; // all
	this.obj.vs[this.obj.av] = {};
	
	this.obj.view = function(name) {
		
		if (!this.vs[name]) {
			
			this.vs[name] = {};
			this.vs[name].dhxcont = this.vs[this.dv].dhxcont;
			
			var mainCont = document.createElement("DIV");
			mainCont.style.position = "relative";
			mainCont.style.left = "0px";
			mainCont.style.width = "200px";
			mainCont.style.height = "200px";
			mainCont.style.overflow = "hidden";
			mainCont.style.visibility = "";
			that.st.appendChild(mainCont);
			
			this.vs[name].dhxcont.mainCont[name] = mainCont;
			mainCont = null;
			
		}
		
		this.avt = this.av;
		this.av = name;
		
		return this;
		
	}
	
	this.obj.setActive = function() {
		
		if (!this.vs[this.av]) return;
		
		this.cv = this.av;
		
		// detach current content
		
		if (this.vs[this.avt].dhxcont == this.vs[this.avt].dhxcont.mainCont[this.avt].parentNode) {
			
			that.st.appendChild(this.vs[this.avt].dhxcont.mainCont[this.avt]);
			
			if (this.vs[this.avt].menu) that.st.appendChild(document.getElementById(this.vs[this.avt].menuId));
			if (this.vs[this.avt].toolbar) {
				that.st.appendChild(document.getElementById(this.vs[this.avt].toolbarId));
				var tb = this.vs[this.avt].toolbar;
				tb.forEachItem(function(id){
					var obj = tb.objPull[tb.idPrefix+id].obj;
					if (obj != null && typeof(obj._doOnMouseOut) == "function") obj._doOnMouseOut();
					obj = null;
				});
				tb = null;
			}
			if (this.vs[this.avt].sb) that.st.appendChild(document.getElementById(this.vs[this.avt].sbId));
			
		}
		
		// adjust content
		if (this._isCell) {
			//this.adjustContent(this.childNodes[0], (this._noHeader?0:this.skinParams[this.skin]["cpanel_height"]));
		}
		//this.vs[this.av].dhxcont.mainCont[this.av].style.width = this.vs[this.av].dhxcont.mainCont[this.avt].style.width;
		//this.vs[this.av].dhxcont.mainCont[this.av].style.height = this.vs[this.av].dhxcont.mainCont[this.avt].style.height;
		
		if (this.vs[this.av].dhxcont != this.vs[this.av].dhxcont.mainCont[this.av].parentNode) {
			
			this.vs[this.av].dhxcont.insertBefore(this.vs[this.av].dhxcont.mainCont[this.av],this.vs[this.av].dhxcont.childNodes[this.vs[this.av].dhxcont.childNodes.length-1]);
			
			if (this.vs[this.av].menu) this.vs[this.av].dhxcont.insertBefore(document.getElementById(this.vs[this.av].menuId), this.vs[this.av].dhxcont.childNodes[0]);
			if (this.vs[this.av].toolbar) this.vs[this.av].dhxcont.insertBefore(document.getElementById(this.vs[this.av].toolbarId), this.vs[this.av].dhxcont.childNodes[(this.vs[this.av].menu?1:0)]);
			if (this.vs[this.av].sb) this.vs[this.av].dhxcont.insertBefore(document.getElementById(this.vs[this.av].sbId), this.vs[this.av].dhxcont.childNodes[this.vs[this.av].dhxcont.childNodes.length-1]);
			
		}

		if (this._doOnResize) this._doOnResize();
		
		if (this._isWindow) this.updateNestedObjects();
		
		this.avt = null;
	}
	
	this.obj._viewRestore = function() {
		var t = this.av;
		if (this.avt) { this.av = this.avt; this.avt = null; }
		return t;
	}
	
	this.setContent = function(data) {
		/*
		this.dhxcont = data;
		this.dhxcont.innerHTML = "<div style='position: relative; left: 0px; top: 0px; overflow: hidden;'></div>"+
					 "<div class='dhxcont_content_blocker' style='display: none;'></div>";
		this.dhxcont.mainCont = this.dhxcont.childNodes[0];
		this.obj.vs[this.obj.av].dhxcont = this.dhxcont;
		*/
		
		this.obj.vs[this.obj.av].dhxcont = data;
		this.obj._init();
		data = null;
	}
	
	this.obj._init = function() {
		
		this.vs[this.av].dhxcont.innerHTML = "<div ida='dhxMainCont' style='position: relative; left: 0px; top: 0px; overflow: hidden;'></div>"+
							"<div class='dhxcont_content_blocker' style='display: none;'></div>";
		
		this.vs[this.av].dhxcont.mainCont = {};
		this.vs[this.av].dhxcont.mainCont[this.av] = this.vs[this.av].dhxcont.childNodes[0];
		
	}
	
	this.obj._genStr = function(w) {
		var s = ""; var z = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
		for (var q=0; q<w; q++) s += z.charAt(Math.round(Math.random() * (z.length-1)));
		return s;
	}
	
	this.obj.setMinContentSize = function(w, h) {
		this.vs[this.av]._minDataSizeW = w;
		this.vs[this.av]._minDataSizeH = h;
	}
	
	this.obj._setPadding = function(p, altCss) {
		
		if (typeof(p) == "object") {
			this._offsetTop = p[0];
			this._offsetLeft = p[1];
			this._offsetWidth = p[2];
			this._offsetHeight = p[3];
			p = null;
		} else {
			this._offsetTop = p;
			this._offsetLeft = p;
			this._offsetWidth = -p*2;
			this._offsetHeight = -p*2;
		}
		this.vs[this.av].dhxcont.className = "dhxcont_global_content_area "+(altCss||"");
		
	}
	
	this.obj.moveContentTo = function(cont) {
		
		
		// move dhtmlx components
		
		for (var a in this.vs) {
			
			cont.view(a).setActive();
			
			var pref = null;
			if (this.vs[a].grid) pref = "grid";
			if (this.vs[a].tree) pref = "tree";
			if (this.vs[a].tabbar) pref = "tabbar";
			if (this.vs[a].folders) pref = "folders";
			if (this.vs[a].layout) pref = "layout";
			
			if (pref != null) {
				
				
				cont.view(a).attachObject(this.vs[a][pref+"Id"], false, true, false);
				cont.vs[a][pref] = this.vs[a][pref];
				cont.vs[a][pref+"Id"] = this.vs[a][pref+"Id"];
				cont.vs[a][pref+"Obj"] = this.vs[a][pref+"Obj"];
				
				this.vs[a][pref] = null;
				this.vs[a][pref+"Id"] = null;
				this.vs[a][pref+"Obj"] = null;
				
			}
			
			if (this.vs[a]._frame) {
				cont.vs[a]._frame = this.vs[a]._frame;
				this.vs[a]._frame = null;
			}
			
			if (this.vs[a].menu != null) {
				
				if (cont.cv == cont.av) {
					cont.vs[cont.av].dhxcont.insertBefore(document.getElementById(this.vs[a].menuId), cont.vs[cont.av].dhxcont.childNodes[0]);
				} else {
					var st = cont._getSt();
					st.appendChild(document.getElementById(this.vs[a].menuId));
					st = null;
				}
				cont.vs[a].menu = this.vs[a].menu;
				cont.vs[a].menuId = this.vs[a].menuId;
				cont.vs[a].menuHeight = this.vs[a].menuHeight;
				this.vs[a].menu = null;
				this.vs[a].menuId = null;
				this.vs[a].menuHeight = null;
				
				if (this.cv == this.av && this._doOnAttachMenu) this._doOnAttachMenu("unload");
				if (cont.cv == cont.av && cont._doOnAttachMenu) cont._doOnAttachMenu("move");
				
			}
				
			if (this.vs[a].toolbar != null) {
				
				if (cont.cv == cont.av) {
					cont.vs[cont.av].dhxcont.insertBefore(document.getElementById(this.vs[a].toolbarId), cont.vs[cont.av].dhxcont.childNodes[(cont.vs[cont.av].menu!=null?1:0)]);
				} else {
					var st = cont._getSt();
					st.appendChild(document.getElementById(this.vs[a].toolbarId));
					st = null;
				}
				
				cont.vs[a].toolbar = this.vs[a].toolbar;
				cont.vs[a].toolbarId = this.vs[a].toolbarId;
				cont.vs[a].toolbarHeight = this.vs[a].toolbarHeight;
				this.vs[a].toolbar = null;
				this.vs[a].toolbarId = null;
				this.vs[a].toolbarHeight = null;
				
				if (this.cv == this.av && this._doOnAttachToolbar) this._doOnAttachToolbar("unload");
				if (cont.cv == cont.av && cont._doOnAttachToolbar) cont._doOnAttachToolbar("move");
			}
			
			if (this.vs[a].sb != null) {
				
				if (cont.cv == cont.av) {
					cont.vs[cont.av].dhxcont.insertBefore(document.getElementById(this.vs[a].sbId), cont.vs[cont.av].dhxcont.childNodes[cont.vs[cont.av].dhxcont.childNodes.length-1]);
				} else {
					var st = cont._getSt();
					st.appendChild(document.getElementById(this.vs[a].sbId));
					return st;
				}
				
				cont.vs[a].sb = this.vs[a].sb;
				cont.vs[a].sbId = this.vs[a].sbId;
				cont.vs[a].sbHeight = this.vs[a].sbHeight;
				this.vs[a].sb = null;
				this.vs[a].sbId = null;
				this.vs[a].sbHeight = null;
				if (this.cv == this.av && this._doOnAttachStatusBar) this._doOnAttachStatusBar("unload");
				if (cont.cv == cont.av && cont._doOnAttachStatusBar) cont._doOnAttachStatusBar("move");
			}
			
			
			var objA = this.vs[a].dhxcont.mainCont[a];
			var objB = cont.vs[a].dhxcont.mainCont[a];
			while (objA.childNodes.length > 0) objB.appendChild(objA.childNodes[0]);
		
			//this.vs[a] = null;
			
			
		}
		
		cont.view(this.av).setActive();
		
		cont = null;
		
	}
	
	this.obj.adjustContent = function(parentObj, offsetTop, marginTop, notCalcWidth, offsetBottom) {
		
		var dhxcont = this.vs[this.av].dhxcont;
		var mainCont = dhxcont.mainCont[this.av];
		
		dhxcont.style.left = (this._offsetLeft||0)+"px";
		dhxcont.style.top = (this._offsetTop||0)+offsetTop+"px";
		//
		var cw = parentObj.clientWidth+(this._offsetWidth||0);
		if (notCalcWidth !== true) dhxcont.style.width = Math.max(0, cw)+"px";
		if (notCalcWidth !== true) if (dhxcont.offsetWidth > cw) dhxcont.style.width = Math.max(0, cw*2-dhxcont.offsetWidth)+"px";
		//
		var ch = parentObj.clientHeight+(this._offsetHeight||0);
		dhxcont.style.height = Math.max(0, ch-offsetTop)+(marginTop!=null?marginTop:0)+"px";
		if (dhxcont.offsetHeight > ch - offsetTop) dhxcont.style.height = Math.max(0, (ch-offsetTop)*2-dhxcont.offsetHeight)+"px";
		if (offsetBottom) if (!isNaN(offsetBottom)) dhxcont.style.height = Math.max(0, parseInt(dhxcont.style.height)-offsetBottom)+"px";
		
		// main window content
		if (this.vs[this.av]._minDataSizeH != null) {
			// height for menu/toolbar/status bar should be included
			if (parseInt(dhxcont.style.height) < this.vs[this.av]._minDataSizeH) dhxcont.style.height = this.vs[this.av]._minDataSizeH+"px";
		}
		if (this.vs[this.av]._minDataSizeW != null) {
			if (parseInt(dhxcont.style.width) < this.vs[this.av]._minDataSizeW) dhxcont.style.width = this.vs[this.av]._minDataSizeW+"px";
		}
		
		if (notCalcWidth !== true) {
			mainCont.style.width = dhxcont.clientWidth+"px";
			// allow border to this.dhxcont.mainCont
			if (mainCont.offsetWidth > dhxcont.clientWidth) mainCont.style.width = Math.max(0, dhxcont.clientWidth*2-mainCont.offsetWidth)+"px";
		}
		
		var menuOffset = (this.vs[this.av].menu!=null?(!this.vs[this.av].menuHidden?this.vs[this.av].menuHeight:0):0);
		var toolbarOffset = (this.vs[this.av].toolbar!=null?(!this.vs[this.av].toolbarHidden?this.vs[this.av].toolbarHeight:0):0);
		var statusOffset = (this.vs[this.av].sb!=null?(!this.vs[this.av].sbHidden?this.vs[this.av].sbHeight:0):0);
		
		// allow border to this.dhxcont.mainCont
		mainCont.style.height = dhxcont.clientHeight+"px";
		if (mainCont.offsetHeight > dhxcont.clientHeight) mainCont.style.height = Math.max(0, dhxcont.clientHeight*2-mainCont.offsetHeight)+"px";
		mainCont.style.height = Math.max(0, parseInt(mainCont.style.height)-menuOffset-toolbarOffset-statusOffset)+"px";
		
		mainCont = null;
		dhxcont = null;
		parentObj = null;
		
	}
	this.obj.coverBlocker = function() {
		return this.vs[this.av].dhxcont.childNodes[this.vs[this.av].dhxcont.childNodes.length-1];
	}
	this.obj.showCoverBlocker = function() {
		var t = this.coverBlocker();
		t.style.display = "";
		t = null;
	}
	this.obj.hideCoverBlocker = function() {
		var t = this.coverBlocker();
		t.style.display = "none";
		t = null;
	}
	this.obj.updateNestedObjects = function(fromInit) {

		if (this.skin == "dhx_terrace") {
			
			var mtAttached = (this.vs[this.av].menu != null || this.vs[this.av].toolbar != null);
			
			if (this.vs[this.av].grid) {
				
				var gTop = (mtAttached||this._isWindow?14:0);
				var gBottom = (this._isWindow?14:0); // padding in window only
				var gLeft = (this._isWindow?14:0); // padding in window only
				
				if (fromInit) {
					// init conf
					if (!this._isWindow) {
						this.vs[this.av].grid.entBox.style.border = "0px solid white";
						this.vs[this.av].grid.skin_h_correction = -2;
					}
					
					this.vs[this.av].grid.dontSetSizes = true;
					//
					this.vs[this.av].gridObj.style.position = "absolute";
					
				}
				
				this.vs[this.av].gridObj.style.top = gTop+"px";
				this.vs[this.av].gridObj.style.height = parseInt(this.vs[this.av].dhxcont.mainCont[this.av].style.height)-gTop-gBottom+"px";
				
				this.vs[this.av].gridObj.style.left = gLeft+"px";
				this.vs[this.av].gridObj.style.width = parseInt(this.vs[this.av].dhxcont.mainCont[this.av].style.width)-(gLeft*2)+"px";
				
				this.vs[this.av].grid.setSizes();
			}
			
			if (this.vs[this.av].tree) {
				
				var gTop = (mtAttached||this._isWindow?14:0);
				var gBottom = (this._isWindow?14:0); // padding in window only
				var gLeft = (this._isWindow?14:0); // padding in window only
				
				if (fromInit) {
					this.vs[this.av].treeObj.style.position = "absolute";
				}
				
				this.vs[this.av].treeObj.style.top = gTop+"px";
				this.vs[this.av].treeObj.style.height = parseInt(this.vs[this.av].dhxcont.mainCont[this.av].style.height)-gTop-gBottom+"px";
				
				this.vs[this.av].treeObj.style.left = gLeft+"px";
				this.vs[this.av].treeObj.style.width = parseInt(this.vs[this.av].dhxcont.mainCont[this.av].style.width)-(gLeft*2)+"px";
				
			}
			
			if (this.vs[this.av].form) {
				
				var gTop = (mtAttached||this._isWindow?14:0);
				var gBottom = (this._isWindow?14:0); // padding in window only
				var gLeft = (this._isWindow?14:0); // padding in window only
				
				if (fromInit) {
					this.vs[this.av].formObj.style.position = "absolute";
				}
				
				this.vs[this.av].formObj.style.top = gTop+"px";
				this.vs[this.av].formObj.style.height = parseInt(this.vs[this.av].dhxcont.mainCont[this.av].style.height)-gTop-gBottom+"px";
				
				this.vs[this.av].formObj.style.left = gLeft+"px";
				this.vs[this.av].formObj.style.width = parseInt(this.vs[this.av].dhxcont.mainCont[this.av].style.width)-(gLeft*2)+"px";
				
				this.vs[this.av].form.setSizes();
				
			}
			
			if (this.vs[this.av].layout) {
				
				if (fromInit) {
					// hide cells' borders
					if (!this._isWindow && !this._isCell) this.vs[this.av].layout._hideBorders();
				}
				
				/*
				var gTop = 14; // always
				var gLeft = 14; // always
				*/
				var gTop = (this._isCell&&this._noHeader&&!mtAttached?0:14); // if layout's cell w/o hdr and w/o mt - 0, otherwise always
				var gBottom = (this._isCell&&this._noHeader?0:14)
				var gLeft = (this._isCell&&this._noHeader?0:14); 
				
				
				this.vs[this.av].layoutObj.style.top = gTop+"px";
				this.vs[this.av].layoutObj.style.height = parseInt(this.vs[this.av].dhxcont.mainCont[this.av].style.height)-gTop-gBottom+"px";
				
				this.vs[this.av].layoutObj.style.left = gLeft+"px";
				this.vs[this.av].layoutObj.style.width = parseInt(this.vs[this.av].dhxcont.mainCont[this.av].style.width)-(gLeft*2)+"px";
				
				this.vs[this.av].layout.setSizes();
			}
			
			if (this.vs[this.av].accordion) {
				
				if (fromInit) {
					// hide cells' borders
					this.vs[this.av].accordion._hideBorders = true;
				}
				
				var gTop = (this._isCell&&this._noHeader&&!mtAttached?0:14); // if layout's cell w/o hdr and w/o mt - 0, otherwise always
				var gBottom = (this._isCell&&this._noHeader?0:14)
				var gLeft = (this._isCell&&this._noHeader?0:14); 
				
				this.vs[this.av].accordionObj.style.top = gTop+"px";
				this.vs[this.av].accordionObj.style.height = parseInt(this.vs[this.av].dhxcont.mainCont[this.av].style.height)-gTop-gBottom+"px";
				
				this.vs[this.av].accordionObj.style.left = gLeft+"px";
				this.vs[this.av].accordionObj.style.width = parseInt(this.vs[this.av].dhxcont.mainCont[this.av].style.width)-(gLeft*2)+"px";
				
				this.vs[this.av].accordion.setSizes();
			}
			
			
			if (this.vs[this.av].tabbar != null) {
				
				var gTop = (!mtAttached && this._isCell && this._noHeader ? 0:14); // set to 0 only if no menu/toolbar and in layout w/o hdr
				var gBottom = (this._isCell && this._noHeader ? gTop : 28);
				var gLeft = (this._isCell && this._noHeader ? 0 : 14); // set to 0 only if in layout w/o hdr
				
				this.vs[this.av].tabbarObj.style.top = gTop+"px";
				this.vs[this.av].tabbarObj.style.height = parseInt(this.vs[this.av].dhxcont.mainCont[this.av].style.height)-gBottom+"px";
				
				this.vs[this.av].tabbarObj.style.left = gLeft+"px";
				this.vs[this.av].tabbarObj.style.width = parseInt(this.vs[this.av].dhxcont.mainCont[this.av].style.width)-(gLeft*2)+"px";
				
				this.vs[this.av].tabbar.adjustOuterSize();
			}
			
			if (this.vs[this.av].editor) {
				
				if (fromInit) {
					// hide cells' borders
					//if (this._isWindow) this.vs[this.av].editorObj.style.border = "1px solid #cecece";
					
					if (this.vs[this.av].editor.tb != null && this.vs[this.av].editor.tb instanceof dhtmlXToolbarObject) {
						//this.vs[this.av].editor.tb.cont.style.margin = "0px";
						
					}
					
				}
				
				var gTop = 14; // always
				var gLeft = 14; // always
				
				this.vs[this.av].editorObj.style.top = gTop+"px";
				this.vs[this.av].editorObj.style.height = parseInt(this.vs[this.av].dhxcont.mainCont[this.av].style.height)-(gTop*2)+"px";
				
				this.vs[this.av].editorObj.style.left = gLeft+"px";
				this.vs[this.av].editorObj.style.width = parseInt(this.vs[this.av].dhxcont.mainCont[this.av].style.width)-(gLeft*2)+"px";
				
				if (!_isIE) this.vs[this.av].editor._prepareContent(true);
				this.vs[this.av].editor.setSizes();
				
			}
			
			if (this.vs[this.av].sched) { this.vs[this.av].sched.setSizes(); }	
			
			if (this.vs[this.av].dockedCell) { this.vs[this.av].dockedCell.updateNestedObjects(); }
			
			return;
		}
		if (this.vs[this.av].grid) { this.vs[this.av].grid.setSizes(); }
		if (this.vs[this.av].sched) { this.vs[this.av].sched.setSizes(); }
		if (this.vs[this.av].tabbar) { this.vs[this.av].tabbar.adjustOuterSize(); }
		if (this.vs[this.av].folders) { this.vs[this.av].folders.setSizes(); }
		if (this.vs[this.av].editor) {
			if (!_isIE) this.vs[this.av].editor._prepareContent(true);
			this.vs[this.av].editor.setSizes();
			
		}
		
		//if (_isOpera) { var t = this; window.setTimeout(function(){t.editor.adjustSize();},10); } else { this.vs[this.av].editor.adjustSize(); } }
		if (this.vs[this.av].layout) {
			if ((this._isAcc || this._isTabbarCell) && this.skin == "dhx_skyblue") {
				this.vs[this.av].layoutObj.style.width = parseInt(this.vs[this.av].dhxcont.mainCont[this.av].style.width)+2+"px";
				this.vs[this.av].layoutObj.style.height = parseInt(this.vs[this.av].dhxcont.mainCont[this.av].style.height)+2+"px";
			} else {
				this.vs[this.av].layoutObj.style.width = this.vs[this.av].dhxcont.mainCont[this.av].style.width;
				this.vs[this.av].layoutObj.style.height = this.vs[this.av].dhxcont.mainCont[this.av].style.height;
			}
			this.vs[this.av].layout.setSizes();
		}
		
		if (this.vs[this.av].accordion != null) {
			
			if (this.skin == "dhx_web") {
				this.vs[this.av].accordionObj.style.width = parseInt(this.vs[this.av].dhxcont.mainCont[this.av].style.width)+"px";
				this.vs[this.av].accordionObj.style.height = parseInt(this.vs[this.av].dhxcont.mainCont[this.av].style.height)+"px";
			} else {
				this.vs[this.av].accordionObj.style.width = parseInt(this.vs[this.av].dhxcont.mainCont[this.av].style.width)+2+"px";
				this.vs[this.av].accordionObj.style.height = parseInt(this.vs[this.av].dhxcont.mainCont[this.av].style.height)+2+"px";
			}
			this.vs[this.av].accordion.setSizes();
		}
		// docked layout's cell
		if (this.vs[this.av].dockedCell) { this.vs[this.av].dockedCell.updateNestedObjects(); }
		/*
		if (win.accordion != null) { win.accordion.setSizes(); }
		if (win.layout != null) { win.layout.setSizes(win); }
		*/
		if (this.vs[this.av].form) this.vs[this.av].form.setSizes();
		
		// temp?
		if (this.vs[this.av].carousel) this.vs[this.av].carousel.setSizes();
	}
	/**
	*   @desc: attaches a status bar to a window
	*   @type: public
	*/
	this.obj.attachStatusBar = function() {
		
		if (this.vs[this.av].sb) return;
		
		var sbObj = document.createElement("DIV");
		
		if (this._isCell) {
			sbObj.className = "dhxcont_sb_container_layoutcell";
		} else {
			sbObj.className = "dhxcont_sb_container";
		}
		sbObj.id = "sbobj_"+this._genStr(12);
		sbObj.innerHTML = "<div class='dhxcont_statusbar'></div>";
		
		if (this.cv == this.av) this.vs[this.av].dhxcont.insertBefore(sbObj, this.vs[this.av].dhxcont.childNodes[this.vs[this.av].dhxcont.childNodes.length-1]); else that.st.appendChild(sbObj);
		
		sbObj.setText = function(text) { this.childNodes[0].innerHTML = text; }
		sbObj.getText = function() { return this.childNodes[0].innerHTML; }
		sbObj.onselectstart = function(e) { e=e||event; e.returnValue=false; return false; }
		
		this.vs[this.av].sb = sbObj;
		this.vs[this.av].sbHeight = (this.skin=="dhx_web"?41:(this.skin=="dhx_skyblue"?23:sbObj.offsetHeight));
		this.vs[this.av].sbId = sbObj.id;
		
		if (this._doOnAttachStatusBar) this._doOnAttachStatusBar("init");
		this.adjust();
		
		return this.vs[this._viewRestore()].sb;
	}
	/**
	*   @desc: detaches a status bar from a window
	*   @type: public
	*/
	this.obj.detachStatusBar = function(destruct) {
		if (!this.vs[this.av].sb) return;
		this.vs[this.av].sb.setText = null;
		this.vs[this.av].sb.getText = null;
		this.vs[this.av].sb.onselectstart = null;
		this.vs[this.av].sb.parentNode.removeChild(this.vs[this.av].sb);
		this.vs[this.av].sb = null;
		this.vs[this.av].sbHeight = null;
		this.vs[this.av].sbId = null;
		this._viewRestore();
		if (this._doOnAttachStatusBar && !destruct) this._doOnAttachStatusBar("unload");
	}
	
	this.obj.getFrame = function(){
		return this.getView()._frame;
	};
	
	this.obj.getView = function(name){
		return this.vs[name||this.av];
	};
	
	
	/**
	*   @desc: attaches a dhtmlxMenu to a window
	*   @type: public
	*/
	this.obj.attachMenu = function(skin) {
		
		if (this.vs[this.av].menu) return;
		
		var menuObj = document.createElement("DIV");
		menuObj.style.position = "relative";
		menuObj.style.overflow = "hidden";
		menuObj.id = "dhxmenu_"+this._genStr(12);
		
		if (this.cv == this.av) this.vs[this.av].dhxcont.insertBefore(menuObj, this.vs[this.av].dhxcont.childNodes[0]); else that.st.appendChild(menuObj);
		
		if (typeof(skin) != "object") {
			this.vs[this.av].menu = new dhtmlXMenuObject(menuObj.id, (skin||this.skin));
		} else {
			skin.parent = menuObj.id;
			this.vs[this.av].menu = new dhtmlXMenuObject(skin);
		}
		this.vs[this.av].menuHeight = (this.skin=="dhx_web"?29:menuObj.offsetHeight);
		this.vs[this.av].menuId = menuObj.id;
		
		if (this._doOnAttachMenu) this._doOnAttachMenu("init");
		this.adjust();
		
		return this.vs[this._viewRestore()].menu;
	}
	/**
	*   @desc: detaches a dhtmlxMenu from a window
	*   @type: public
	*/
	this.obj.detachMenu = function(destruct) {
		if (!this.vs[this.av].menu) return;
		var menuObj = document.getElementById(this.vs[this.av].menuId);
		this.vs[this.av].menu.unload();
		this.vs[this.av].menu = null;
		this.vs[this.av].menuId = null;
		this.vs[this.av].menuHeight = null;
		if (menuObj) menuObj.parentNode.removeChild(menuObj);
		menuObj = null;
		this._viewRestore();
		if (this._doOnAttachMenu && !destruct) this._doOnAttachMenu("unload");
	}
	/**
	*   @desc: attaches a dhtmlxToolbar to a window
	*   @type: public
	*/
	this.obj.attachToolbar = function(skin) {
		
		if (this.vs[this.av].toolbar) return;
		
		var toolbarObj = document.createElement("DIV");
		toolbarObj.style.position = "relative";
		toolbarObj.style.overflow = "hidden";
		toolbarObj.id = "dhxtoolbar_"+this._genStr(12);
		
		if (this.cv == this.av) this.vs[this.av].dhxcont.insertBefore(toolbarObj, this.vs[this.av].dhxcont.childNodes[(this.vs[this.av].menu!=null?1:0)]); else that.st.appendChild(toolbarObj);
      
		if (typeof(skin) != "object") {
			this.vs[this.av].toolbar = new dhtmlXToolbarObject(toolbarObj.id, (skin||this.skin));
		} else {
			skin.parent = toolbarObj.id;
			this.vs[this.av].toolbar = new dhtmlXToolbarObject(skin);
		}
		this.vs[this.av].toolbarHeight = toolbarObj.offsetHeight;//(this.skin=="dhx_web"?41:toolbarObj.offsetHeight+(this._isLayout&&this.skin=="dhx_skyblue"?2:0));
		this.vs[this.av].toolbarId = toolbarObj.id;
		
		if (this._doOnAttachToolbar) this._doOnAttachToolbar("init");
		this.adjust();
		
		var t = this;
		this.vs[this.av].toolbar.attachEvent("_onIconSizeChange",function(size){
				
			t.vs[t.av].toolbarHeight = this.cont.offsetHeight;
			t.vs[t.av].toolbarId = this.cont.id;
			t.adjust();
			if (t._doOnAttachToolbar) t._doOnAttachToolbar("iconSizeChange");
			
		});
		if (this.skin != "dhx_terrace") this.vs[this.av].toolbar.callEvent("_onIconSizeChange",[]);
		
		return this.vs[this._viewRestore()].toolbar;
	}
	/**
	*   @desc: detaches a dhtmlxToolbar from a window
	*   @type: public
	*/
	this.obj.detachToolbar = function(destruct) {
		if (!this.vs[this.av].toolbar) return;
		var toolbarObj = document.getElementById(this.vs[this.av].toolbarId);
		this.vs[this.av].toolbar.unload();
		this.vs[this.av].toolbar = null;
		this.vs[this.av].toolbarId = null;
		this.vs[this.av].toolbarHeight = null;
		if (toolbarObj) toolbarObj.parentNode.removeChild(toolbarObj);
		toolbarObj = null;
		this._viewRestore();
		if (this._doOnAttachToolbar && !destruct) this._doOnAttachToolbar("unload");
	}
	/**
	*   @desc: attaches a dhtmlxGrid to a window
	*   @type: public
	*/
	this.obj.attachGrid = function() {
		
		if (this._isWindow && this.skin == "dhx_skyblue") {
			this.vs[this.av].dhxcont.mainCont[this.av].style.border = "#a4bed4 1px solid";
			this._redraw();
		}
		
		var obj = document.createElement("DIV");
		obj.id = "dhxGridObj_"+this._genStr(12);
		obj.style.width = "100%";
		obj.style.height = "100%";
		obj.cmp = "grid";
		document.body.appendChild(obj);
		this.attachObject(obj.id, false, true, false);
		
		this.vs[this.av].grid = new dhtmlXGridObject(obj.id);
		this.vs[this.av].grid.setSkin(this.skin);
		
		if (this.skin == "dhx_skyblue" || this.skin == "dhx_black" || this.skin == "dhx_blue") {
			this.vs[this.av].grid.entBox.style.border = "0px solid white";
			this.vs[this.av].grid._sizeFix = 2;
		}
		this.vs[this.av].gridId = obj.id;
		this.vs[this.av].gridObj = obj;
		
		if (this.skin == "dhx_terrace") {
			this.adjust();
			this.updateNestedObjects(true);
		}
		
		return this.vs[this._viewRestore()].grid;
	}
	/**
	*   @desc: attaches a dhtmlxScheduler to a window
	*   @type: public
	*/	
	this.obj.attachScheduler = function(day,mode,cont_id,scheduler) {
		scheduler = scheduler || window.scheduler;

		var ready = 0;
		if (cont_id){
			obj = document.getElementById(cont_id);
			if (obj) 
				ready = 1;
		}
		if (!ready){
			var tabs = cont_id || '<div class="dhx_cal_tab" name="day_tab" style="right:204px;"></div><div class="dhx_cal_tab" name="week_tab" style="right:140px;"></div><div class="dhx_cal_tab" name="month_tab" style="right:76px;"></div>';
			var obj = document.createElement("DIV");
			obj.id = "dhxSchedObj_"+this._genStr(12);
			obj.innerHTML = '<div id="'+obj.id+'" class="dhx_cal_container" style="width:100%; height:100%;"><div class="dhx_cal_navline"><div class="dhx_cal_prev_button">&nbsp;</div><div class="dhx_cal_next_button">&nbsp;</div><div class="dhx_cal_today_button"></div><div class="dhx_cal_date"></div>'+tabs+'</div><div class="dhx_cal_header"></div><div class="dhx_cal_data"></div></div>';
			document.body.appendChild(obj.firstChild);
		}
		
		this.attachObject(obj.id, false, true, false);
		
		this.vs[this.av].sched = scheduler;
		this.vs[this.av].schedId = obj.id;
		scheduler.setSizes = scheduler.update_view;
		scheduler.destructor=function(){};
		scheduler.init(obj.id,day,mode);
		
		return this.vs[this._viewRestore()].sched;
	}	
	/**
	*   @desc: attaches a dhtmlxTree to a window
	*   @param: rootId - not mandatory, tree super root, see dhtmlxTree documentation for details
	*   @type: public
	*/
	this.obj.attachTree = function(rootId) {
		if (this._isWindow && this.skin == "dhx_skyblue") {
			this.vs[this.av].dhxcont.mainCont[this.av].style.border = "#a4bed4 1px solid";
			this._redraw();
		}
		
		var obj = document.createElement("DIV");
		obj.id = "dhxTreeObj_"+this._genStr(12);
		obj.style.width = "100%";
		obj.style.height = "100%";
		obj.cmp = "tree";
		document.body.appendChild(obj);
		
		this.attachObject(obj.id, false, true, false);
		this.vs[this.av].tree = new dhtmlXTreeObject(obj.id, "100%", "100%", (rootId||0));
		this.vs[this.av].tree.setSkin(this.skin);
		// this.tree.allTree.style.paddingTop = "2px";
		this.vs[this.av].tree.allTree.childNodes[0].style.marginTop = "2px";
		this.vs[this.av].tree.allTree.childNodes[0].style.marginBottom = "2px";
		
		this.vs[this.av].treeId = obj.id;
		this.vs[this.av].treeObj = obj;
		
		if (this.skin == "dhx_terrace") {
			this.adjust();
			this.updateNestedObjects(true);
		}
		
		return this.vs[this._viewRestore()].tree;
	}
	/**
	*   @desc: attaches a dhtmlxTabbar to a window
	*   @type: public
	*/
	this.obj.attachTabbar = function(mode) {
		
		if (this._isWindow && this.skin == "dhx_skyblue") {
			this.vs[this.av].dhxcont.style.border = "none";
			this.setDimension(this.w, this.h);
		}
		
		var obj = document.createElement("DIV");
		obj.id = "dhxTabbarObj_"+this._genStr(12);
		obj.style.width = "100%";
		obj.style.height = "100%";
		obj.style.overflow = "hidden";
		obj.cmp = "tabbar";
		if (!this._isWindow) obj._hideBorders = true;
		document.body.appendChild(obj);
		this.attachObject(obj.id, false, true, false);
		
		// manage dockcell if exists
		if (this._isCell) {
			this.hideHeader();
			obj._hideBorders = false;
			this._padding = false;
		}
		
		this.vs[this.av].tabbar = new dhtmlXTabBar(obj.id, mode||"top", (this.skin=="dhx_terrace"?null:20));
		if (!this._isWindow && this.skin != "dhx_terrace") this.vs[this.av].tabbar._s.expand = true;
		this.vs[this.av].tabbar.setSkin(this.skin);
		this.vs[this.av].tabbar.adjustOuterSize();
		this.vs[this.av].tabbarId = obj.id;
		this.vs[this.av].tabbarObj = obj;
		
		if (this.skin == "dhx_terrace") {
			this.adjust();
			this.updateNestedObjects(true);
		}
		
		return this.vs[this._viewRestore()].tabbar;
	}
	/**
	*   @desc: attaches a dhtmlxFolders to a window
	*   @type: public
	*/
	this.obj.attachFolders = function() {
		if (this._isWindow && this.skin == "dhx_skyblue") {
			this.vs[this.av].dhxcont.mainCont[this.av].style.border = "#a4bed4 1px solid";
			this._redraw();
		}
		var obj = document.createElement("DIV");
		obj.id = "dhxFoldersObj_"+this._genStr(12);
		obj.style.width = "100%";
		obj.style.height = "100%";
		obj.style.overflow = "hidden";
		obj.cmp = "folders";
		document.body.appendChild(obj);
		this.attachObject(obj.id, false, true, false);
		this.vs[this.av].folders = new dhtmlxFolders(obj.id);
		this.vs[this.av].folders.setSizes();
		
		this.vs[this.av].foldersId = obj.id;
		this.vs[this.av].foldersObj = obj;
		
		return this.vs[this._viewRestore()].folders;
	}
	/**
	*   @desc: attaches a dhtmlxAccordion to a window
	*   @type: public
	*/
	this.obj.attachAccordion = function() {
		if (this._isWindow && this.skin == "dhx_skyblue") {
			this.vs[this.av].dhxcont.mainCont[this.av].style.border = "#a4bed4 1px solid";
			this._redraw();
		}
		
		var obj = document.createElement("DIV");
		obj.id = "dhxAccordionObj_"+this._genStr(12);
		
		this._padding = true;
		
		if (this.skin == "dhx_web") {
			obj.style.left = "0px";
			obj.style.top = "0px";
			obj.style.width = parseInt(this.vs[this.av].dhxcont.mainCont[this.av].style.width)+"px";
			obj.style.height = parseInt(this.vs[this.av].dhxcont.mainCont[this.av].style.height)+"px";
		} else if (this.skin != "dhx_terrace") {
			obj.style.left = "-1px";
			obj.style.top = "-1px";
			obj.style.width = parseInt(this.vs[this.av].dhxcont.mainCont[this.av].style.width)+2+"px";
			obj.style.height = parseInt(this.vs[this.av].dhxcont.mainCont[this.av].style.height)+2+"px";
		}
		
		//
		obj.style.position = "relative";
		obj.cmp = "accordion";
		document.body.appendChild(obj);
		this.attachObject(obj.id, false, true, false);
		
		this.vs[this.av].accordion = new dhtmlXAccordion(obj.id, this.skin);
		this.vs[this.av].accordion.setSizes();
		this.vs[this.av].accordionId = obj.id;
		this.vs[this.av].accordionObj = obj;
		
		if (this.skin == "dhx_terrace") {
			this.adjust();
			this.updateNestedObjects(true);
		}
		
		return this.vs[this._viewRestore()].accordion;
	}
	/**
	*   @desc: attaches a dhtmlxLayout to a window
	*   @param: view - layout's pattern
	*   @param: skin - layout's skin
	*   @type: public
	*/
	this.obj.attachLayout = function(view, skin) {
		
		// attach layout to layout
		if (this._isCell && this.skin == "dhx_skyblue") {
			this.hideHeader();
			this.vs[this.av].dhxcont.style.border = "0px solid white";
			this.adjustContent(this.childNodes[0], 0);
		}
		
		if (this._isCell && this.skin == "dhx_web") {
			this.hideHeader();
		}
		
		this._padding = true;
		
		var obj = document.createElement("DIV");
		obj.id = "dhxLayoutObj_"+this._genStr(12);
		obj.style.overflow = "hidden";
		obj.style.position = "absolute";
		
		obj.style.left = "0px";
		obj.style.top = "0px";
		obj.style.width = parseInt(this.vs[this.av].dhxcont.mainCont[this.av].style.width)+"px";
		obj.style.height = parseInt(this.vs[this.av].dhxcont.mainCont[this.av].style.height)+"px";
		
		if ((this._isTabbarCell || this._isAcc) && (this.skin == "dhx_skyblue")) {
			obj.style.left = "-1px";
			obj.style.top = "-1px";
			obj.style.width = parseInt(this.vs[this.av].dhxcont.mainCont[this.av].style.width)+2+"px";
			obj.style.height = parseInt(this.vs[this.av].dhxcont.mainCont[this.av].style.height)+2+"px";
		}
		
		// needed for layout's init
		obj.dhxContExists = true;
		obj.cmp = "layout";
		document.body.appendChild(obj);
		this.attachObject(obj.id, false, true, false);
		
		this.vs[this.av].layout = new dhtmlXLayoutObject(obj, view, (skin||this.skin));
		
		
		// window/layout events configuration
		if (this._isWindow) this.attachEvent("_onBeforeTryResize", this.vs[this.av].layout._defineWindowMinDimension);
		
		this.vs[this.av].layoutId = obj.id;
		this.vs[this.av].layoutObj = obj;
		
		if (this.skin == "dhx_terrace") {
			if (this._isCell) {
				//debugger
				this.style.backgroundColor = "transparent";
				this.vs[this.av].dhxcont.style.backgroundColor = "transparent";
				this.hideHeader();
			}
			this.adjust();
			this.updateNestedObjects(true);
			
		}
		
		return this.vs[this._viewRestore()].layout;
	}
	/**
	*   @desc: attaches a dhtmlxEditor to a window
	*   @param: skin - not mandatory, editor's skin
	*   @type: public
	*/
	this.obj.attachEditor = function(skin) {
		
		if (this._isWindow && this.skin == "dhx_skyblue") {
			this.vs[this.av].dhxcont.mainCont[this.av].style.border = "#a4bed4 1px solid";
			this._redraw();
		}
		
		var obj = document.createElement("DIV");
		obj.id = "dhxEditorObj_"+this._genStr(12);
		obj.style.position = "relative";
		obj.style.display = "none";
		obj.style.overflow = "hidden";
		obj.style.width = "100%";
		obj.style.height = "100%";
		obj.cmp = "editor";
		document.body.appendChild(obj);
		
		if (this.skin == "dhx_terrace") obj._attached = true;
		
		//
		this.attachObject(obj.id, false, true, false);
		//
		this.vs[this.av].editor = new dhtmlXEditor(obj.id, skin||this.skin);
		
		this.vs[this.av].editorId = obj.id;
		this.vs[this.av].editorObj = obj;
		
		
		if (this.skin == "dhx_terrace") {
			this.adjust();
			this.updateNestedObjects(true);
		}
		
		return this.vs[this._viewRestore()].editor;
		
	}
	
	this.obj.attachMap = function(opts) {
		
		var obj = document.createElement("DIV");
		obj.id = "GMapsObj_"+this._genStr(12);
		obj.style.position = "relative";
		obj.style.display = "none";
		obj.style.overflow = "hidden";
		obj.style.width = "100%";
		obj.style.height = "100%";
		obj.cmp = "gmaps";
		document.body.appendChild(obj);
		
		this.attachObject(obj.id, false, true, true);
		
		if (!opts) opts = {center: new google.maps.LatLng(40.719837,-73.992348), zoom: 11, mapTypeId: google.maps.MapTypeId.ROADMAP};
		this.vs[this.av].gmaps = new google.maps.Map(obj, opts);
		
		return this.vs[this.av].gmaps;
		
	}
	
	/**
	*   @desc: attaches an object into a window
	*   @param: obj - object or object id
	*   @param: autoSize - set true to adjust a window to object's dimension
	*   @type: public
	*/
	this.obj.attachObject = function(obj, autoSize, localCall, adjustMT) {
		if (typeof(obj) == "string") obj = document.getElementById(obj);
		if (autoSize) {
			obj.style.visibility = "hidden";
			obj.style.display = "";
			var objW = obj.offsetWidth;
			var objH = obj.offsetHeight;
		}
		this._attachContent("obj", obj);
		if (autoSize && this._isWindow) {
			obj.style.visibility = "";
			this._adjustToContent(objW, objH);
			/* this._engineAdjustWindowToContent(this, objW, objH); */
		}
		
		if (this.skin == "dhx_terrace") {
			if (this.vs[this.av].menu != null || this.vs[this.av].toolbar != null) {
				this.adjust(typeof(adjustMT)=="undefined"||adjustMT==true);
				this.updateNestedObjects(true);
			}
		}
		if (!localCall) {
			this._viewRestore();
		}
		
	}
	/**
	*
	*
	*/
	this.obj.detachObject = function(remove, moveTo) {
		
		// detach dhtmlx components
		
		var p = null;
		var pObj = null;
		
		var t = ["tree","grid","layout","tabbar","accordion","folders","form"];
		for (var q=0; q<t.length; q++) {
			if (this.vs[this.av][t[q]]) {
				p = this.vs[this.av][t[q]];
				pObj = this.vs[this.av][t[q]+"Obj"];
				if (remove) {
					if (p.unload) p.unload();
					if (p.destructor) p.destructor();
					while (pObj.childNodes.length > 0) pObj.removeChild(pObj.childNodes[0]);
					pObj.parentNode.removeChild(pObj);
					pObj = null;
					p = null;
				} else {
					document.body.appendChild(pObj);
					pObj.style.display = "none";
				}
				this.vs[this.av][t[q]] = null;
				this.vs[this.av][t[q]+"Id"] = null;
				this.vs[this.av][t[q]+"Obj"] = null;
			}
		}
		
		if (p != null && pObj != null) return new Array(p, pObj);
		
		// detach any other content
		if (remove && this.vs[this.av]._frame) {
			this._detachURLEvents();
			this.vs[this.av]._frame = null;
		}
		
		var objA = this.vs[this.av].dhxcont.mainCont[this.av];
		while (objA.childNodes.length > 0) {
			if (remove == true) {
				// add frame events removing
				objA.removeChild(objA.childNodes[0]);
			} else {
				var obj = objA.childNodes[0];
				if (moveTo != null) {
					if (typeof(moveTo) != "object") moveTo = document.getElementById(moveTo);
					moveTo.appendChild(obj);
				} else {
					document.body.appendChild(obj);
				}
				obj.style.display = "none";
			}
		}
		
		objA = moveTo = null;
	}
	
	/**
	*   @desc: appends an object into a window
	*   @param: obj - object or object id
	*   @type: public
	*/
	this.obj.appendObject = function(obj) {
		if (typeof(obj) == "string") { obj = document.getElementById(obj); }
		this._attachContent("obj", obj, true);
	}
	/**
	*   @desc: attaches an html string as an object into a window
	*   @param: str - html string
	*   @type: public
	*/
	this.obj.attachHTMLString = function(str) {
		this._attachContent("str", str);
		var z=str.match(/<script[^>]*>[^\f]*?<\/script>/g)||[];
		for (var i=0; i<z.length; i++){
			var s=z[i].replace(/<([\/]{0,1})script[^>]*>/g,"")
			if (s){
				if (window.execScript) window.execScript(s);
				else window.eval(s);	
			}
		}
	}
	/**
	*   @desc: attaches an url into a window
	*   @param: url
	*   @param: ajax - loads an url with ajax
	*   @type: public
	*/
	this.obj.attachURL = function(url, ajax) {
		this._attachContent((ajax==true?"urlajax":"url"), url, false);
		if (this.skin == "dhx_terrace") {
			if (this.vs[this.av].menu != null || this.vs[this.av].toolbar != null) {
				this.adjust(true);
				this.updateNestedObjects(true);
			}
		}		
		this._viewRestore();
	}
	this.obj.adjust = function(adjustMT) {
		if (this.skin == "dhx_skyblue") {
			if (this.vs[this.av].menu) {
				if (this._isWindow || this._isLayout) {
					this.vs[this.av].menu._topLevelOffsetLeft = 0;
					document.getElementById(this.vs[this.av].menuId).style.height = "26px";
					this.vs[this.av].menuHeight = document.getElementById(this.vs[this.av].menuId).offsetHeight;
					if (this._doOnAttachMenu) this._doOnAttachMenu("show");
				}
				if (this._isCell) {
					document.getElementById(this.vs[this.av].menuId).className += " in_layoutcell";
					this.vs[this.av].menuHeight = 25;
				}
				if (this._isAcc) {
					document.getElementById(this.vs[this.av].menuId).className += " in_acccell";
					this.vs[this.av].menuHeight = 25;
				}
				if (this._doOnAttachMenu) this._doOnAttachMenu("adjust");
			}
			if (this.vs[this.av].toolbar) {
				if (this._isWindow) {
					document.getElementById(this.vs[this.av].toolbarId).className += " in_window";
				}
				if (this._isLayout) {
					document.getElementById(this.vs[this.av].toolbarId).className += " in_layout";
				}
				if (this._isCell) {
					document.getElementById(this.vs[this.av].toolbarId).className += " in_layoutcell";
				}
				if (this._isAcc) {
					document.getElementById(this.vs[this.av].toolbarId).className += " in_acccell";
				}
				if (this._isTabbarCell) {
					document.getElementById(this.vs[this.av].toolbarId).className += " in_tabbarcell";
				}
			}
		}
		
		if (this.skin == "dhx_web") {
			if (this.vs[this.av].toolbar) {
				if (this._isWindow) {
					document.getElementById(this.vs[this.av].toolbarId).className += " in_window";
				}
				if (this._isLayout) {
					//this.vs[this.av].toolbarHeight = document.getElementById(this.vs[this.av].toolbarId).offsetHeight+9;
					document.getElementById(this.vs[this.av].toolbarId).className += " in_layout";
				}
				if (this._isCell) {
					document.getElementById(this.vs[this.av].toolbarId).className += " in_layoutcell";
				}
				if (this._isAcc) {
					document.getElementById(this.vs[this.av].toolbarId).className += " in_acccell";
				}
				if (this._isTabbarCell) {
					document.getElementById(this.vs[this.av].toolbarId).className += " in_tabbarcell";
				}
			}
		}
		
		if (this.skin == "dhx_terrace") {
			
			// menu/toolbar paddings
			var mtLRPad = 0;
			if (this._isWindow || this._isCell || this._isAcc || this._isTabbarCell) mtLRPad = 14;
			if (this._isCell && this._noHeader) mtLRPad = 0;
			
			// menu/toolbar top padding
			var mtTPad = 0;
			if (this._isWindow || this._isCell || this._isAcc || this._isTabbarCell) mtTPad = 14;
			if (this._isCell && this._noHeader) mtTPad = 0; // attached to layout w/o border (tabbar mode)
			
			// menu/toolbar bottom padding - only if url or object attached,
			// layout's top
			var mBPad = ((adjustMT == true && !this.vs[this.av].toolbar) || this._isLayout ? 14 : 0);
			var tBPad = (adjustMT == true || this._isLayout ? 14 : 0);
			
			var mtAttached = false;
			
			if (this.vs[this.av].menu) {
				
				document.getElementById(this.vs[this.av].menuId).style.marginLeft = mtLRPad+"px";
				document.getElementById(this.vs[this.av].menuId).style.marginRight = mtLRPad+"px";
				document.getElementById(this.vs[this.av].menuId).style.marginTop = mtTPad+"px";
				document.getElementById(this.vs[this.av].menuId).style.marginBottom = mBPad+"px";
				
				this.vs[this.av].menuHeight = 32+mtTPad+mBPad;
				
				if (this._doOnAttachMenu) this._doOnAttachMenu("show");
				
				mtAttached = true;
			}
			
			if (this.vs[this.av].toolbar) {
				
				if (mtTPad == 0 && this.vs[this.av].menu != null & this._isCell) mtTPad = 14; // if tabbar and menu attached and no header
				
				document.getElementById(this.vs[this.av].toolbarId).style.marginLeft = mtLRPad+"px";
				document.getElementById(this.vs[this.av].toolbarId).style.marginRight = mtLRPad+"px";
				document.getElementById(this.vs[this.av].toolbarId).style.marginTop = mtTPad+"px";
				document.getElementById(this.vs[this.av].toolbarId).style.marginBottom = tBPad+"px";
				
				//this.vs[this.av].toolbarHeight = 32+mtTPad+tBPad;
				this.vs[this.av].toolbarHeight = this.vs[this.av].toolbar.cont.offsetHeight+mtTPad+tBPad;
				
				if (this._doOnAttachToolbar) this._doOnAttachToolbar("show");
				
				mtAttached = true;
				
			}
		}
	}
	
	// attach content obj|url
	this.obj._attachContent = function(type, obj, append) {
		// clear old content
		if (append !== true) {
			if (this.vs[this.av]._frame) {
				this._detachURLEvents();
				this.vs[this.av]._frame = null;
			}
			while (this.vs[this.av].dhxcont.mainCont[this.av].childNodes.length > 0) this.vs[this.av].dhxcont.mainCont[this.av].removeChild(this.vs[this.av].dhxcont.mainCont[this.av].childNodes[0]);
		}
		// attach
		if (type == "url") {
			if (this._isWindow && obj.cmp == null && this.skin == "dhx_skyblue") {
				this.vs[this.av].dhxcont.mainCont[this.av].style.border = "#a4bed4 1px solid";
				this._redraw();
			}
			var fr = document.createElement("IFRAME");
			fr.frameBorder = 0;
			fr.border = 0;
			fr.style.width = "100%";
			fr.style.height = "100%";
			fr.setAttribute("src","javascript:false;");
			this.vs[this.av].dhxcont.mainCont[this.av].appendChild(fr);
			fr.src = obj;
			
			// ?? this._frame = fr;
			this.vs[this.av]._frame = fr;
			this._attachURLEvents();
			
		} else if (type == "urlajax") {
			
			if (this._isWindow && obj.cmp == null && this.skin == "dhx_skyblue") {
				this.vs[this.av].dhxcont.mainCont[this.av].style.border = "#a4bed4 1px solid";
				this.vs[this.av].dhxcont.mainCont[this.av].style.backgroundColor = "#FFFFFF";
				this._redraw();
			}
			var t = this;
			var tav = String(this.av).valueOf();
			var xmlParser = function(){
				var tmp = t.av;
				t.av = tav;
				t.attachHTMLString(this.xmlDoc.responseText, this);
				t.av = tmp;
				//if (t._doOnAttachURL) t._doOnAttachURL(false);
				if (t._doOnFrameContentLoaded) t._doOnFrameContentLoaded();
				this.destructor();
			}
			var xmlLoader = new dtmlXMLLoaderObject(xmlParser, window);
			xmlLoader.dhxWindowObject = this;
			xmlLoader.loadXML(obj);
			
		} else if (type == "obj") {
			
			if (this._isWindow && obj.cmp == null && this.skin == "dhx_skyblue") {
				this.vs[this.av].dhxcont.mainCont[this.av].style.border = "#a4bed4 1px solid";
				this.vs[this.av].dhxcont.mainCont[this.av].style.backgroundColor = "#FFFFFF";
				this._redraw();
			}
			this.vs[this.av].dhxcont._frame = null;
			this.vs[this.av].dhxcont.mainCont[this.av].appendChild(obj);
			// this._engineGetWindowContent(win).style.overflow = (append===true?"auto":"hidden");
			// win._content.childNodes[2].appendChild(obj);
			this.vs[this.av].dhxcont.mainCont[this.av].style.overflow = (append===true?"auto":"hidden");
			obj.style.display = "";
			
		} else if (type == "str") {
			
			if (this._isWindow && obj.cmp == null && this.skin == "dhx_skyblue") {
				this.vs[this.av].dhxcont.mainCont[this.av].style.border = "#a4bed4 1px solid";
				this.vs[this.av].dhxcont.mainCont[this.av].style.backgroundColor = "#FFFFFF";
				this._redraw();
			}
			this.vs[this.av].dhxcont._frame = null;
			this.vs[this.av].dhxcont.mainCont[this.av].innerHTML = obj;
		}
	}
	
	this.obj._attachURLEvents = function() {
		var t = this;
		var fr = this.vs[this.av]._frame;
		if (_isIE) {
			fr.onreadystatechange = function(a) {
				if (fr.readyState == "complete") {
					try {fr.contentWindow.document.body.onmousedown=function(){if(t._doOnFrameMouseDown)t._doOnFrameMouseDown();};}catch(e){};
					try{if(t._doOnFrameContentLoaded)t._doOnFrameContentLoaded();}catch(e){};
				}
			}
		} else {
			fr.onload = function() {
				try{fr.contentWindow.onmousedown=function(){if(t._doOnFrameMouseDown)t._doOnFrameMouseDown();};}catch(e){};
				try{if(t._doOnFrameContentLoaded)t._doOnFrameContentLoaded();}catch(e){};
			}
		}
	}
	
	this.obj._detachURLEvents = function() {
		if (_isIE) {
			try {
				this.vs[this.av]._frame.onreadystatechange = null;
				this.vs[this.av]._frame.contentWindow.document.body.onmousedown = null;
				this.vs[this.av]._frame.onload = null;
			} catch(e) {};
		} else {
			try {
				this.vs[this.av]._frame.contentWindow.onmousedown = null;
				this.vs[this.av]._frame.onload = null;
			} catch(e) {};
		}
	}
	
	this.obj.showMenu = function() {
		if (!(this.vs[this.av].menu && this.vs[this.av].menuId)) return;
		if (document.getElementById(this.vs[this.av].menuId).style.display != "none") return;
		this.vs[this.av].menuHidden = false;
		if (this._doOnAttachMenu) this._doOnAttachMenu("show");
		document.getElementById(this.vs[this.av].menuId).style.display = "";
		this._viewRestore();
	}
	
	this.obj.hideMenu = function() {
		if (!(this.vs[this.av].menu && this.vs[this.av].menuId)) return;
		if (document.getElementById(this.vs[this.av].menuId).style.display == "none") return;
		document.getElementById(this.vs[this.av].menuId).style.display = "none";
		this.vs[this.av].menuHidden = true;
		if (this._doOnAttachMenu) this._doOnAttachMenu("hide");
		this._viewRestore();
	}
	
	this.obj.showToolbar = function() {
		if (!(this.vs[this.av].toolbar && this.vs[this.av].toolbarId)) return;
		if (document.getElementById(this.vs[this.av].toolbarId).style.display != "none") return;
		this.vs[this.av].toolbarHidden = false;
		if (this._doOnAttachToolbar) this._doOnAttachToolbar("show");
		document.getElementById(this.vs[this.av].toolbarId).style.display = "";
		this._viewRestore();
	}
	
	this.obj.hideToolbar = function() {
		if (!(this.vs[this.av].toolbar && this.vs[this.av].toolbarId)) return;
		if (document.getElementById(this.vs[this.av].toolbarId).style.display == "none") return;
		this.vs[this.av].toolbarHidden = true;
		document.getElementById(this.vs[this.av].toolbarId).style.display = "none";
		if (this._doOnAttachToolbar) this._doOnAttachToolbar("hide");
		this._viewRestore();
	}
	
	this.obj.showStatusBar = function() {
		if (!(this.vs[this.av].sb && this.vs[this.av].sbId)) return;
		if (document.getElementById(this.vs[this.av].sbId).style.display != "none") return;
		this.vs[this.av].sbHidden = false;
		if (this._doOnAttachStatusBar) this._doOnAttachStatusBar("show");
		document.getElementById(this.vs[this.av].sbId).style.display = "";
		this._viewRestore();
	}
	
	this.obj.hideStatusBar = function() {
		if (!(this.vs[this.av].sb && this.vs[this.av].sbId)) return;
		if (document.getElementById(this.vs[this.av].sbId).style.display == "none") return;
		this.vs[this.av].sbHidden = true;
		document.getElementById(this.vs[this.av].sbId).style.display = "none";
		if (this._doOnAttachStatusBar) this._doOnAttachStatusBar("hide");
		this._viewRestore();
	}
	
	this.obj._dhxContDestruct = function() {
		
		// clear attached objects
		
		var av = this.av;
		for (var a in this.vs) {
			
			this.av = a;
			
			// menu, toolbar, status
			this.detachMenu(true);
			this.detachToolbar(true);
			this.detachStatusBar(true);
			
			// remove any attached object or dhtmlx component
			this.detachObject(true);
			
			this.vs[a].dhxcont.mainCont[a] = null;
		}
		
		for (var a in this.vs) {
			this.vs[a].dhxcont.mainCont = null;
			this.vs[a].dhxcont.innerHTML = "";
			this.vs[a].dhxcont = null;
			this.vs[a] = null;
		}
		this.vs = null;
		
		this.attachMenu = null;
		this.attachToolbar = null;
		this.attachStatusBar = null;
		this.detachMenu = null;
		this.detachToolbar = null;
		this.detachStatusBar = null;
		this.showMenu = null;
		this.showToolbar = null;
		this.showStatusBar = null;
		this.hideMenu = null;
		this.hideToolbar = null;
		this.hideStatusBar = null;
		
		this.attachGrid = null;
		this.attachScheduler = null;
		this.attachTree = null;
		this.attachTabbar = null;
		this.attachFolders = null;
		this.attachAccordion = null;
		this.attachLayout = null;
		this.attachEditor = null;
		this.attachObject = null;
		this.detachObject = null;
		this.appendObject = null;
		this.attachHTMLString = null;
		this.attachURL = null;
		this.attachMap = null;
		
		this.view = null;
		this.show = null;
		this.adjust = null;
		this.setMinContentSize = null;
		this.moveContentTo = null;
		this.adjustContent = null;
		this.coverBlocker = null;
		this.showCoverBlocker = null;
		this.hideCoverBlocker = null;
		this.updateNestedObjects = null;
		
		this._attachContent = null;
		this._attachURLEvents = null;
		this._detachURLEvents = null;
		this._viewRestore = null;
		this._setPadding = null;
		this._init = null;
		this._genStr = null;
		this._dhxContDestruct = null;
		
		this._getSt = null;
		this.getFrame = null;
		this.getView = null;
		this.setActive = null;
		
		that.st.innerHTML = "";
		that.st.parentNode.removeChild(that.st);
		that.st = null;
		
		that.setContent = null;
		that.dhxcont = null; // no more used at all?
		that.obj = null;
		that = null;
		
		// remove attached components
		/*
		for (var a in this.vs) {
		
			if (this.vs[a].layout) this.vs[a].layout.unlaod();
			if (this.vs[a].accordion) this.vs[a].accordion.unlaod();
			if (this.vs[a].sched) this.vs[a].sched.destructor();
			
			this.vs[a].layout = null;
			this.vs[a].accordion = null;
			this.vs[a].sched = null;
			
		}
		*/
		// extended functionality
		if (dhtmlx.detaches) for (var a in dhtmlx.detaches) dhtmlx.detaches[a](this);
		
	}
	
	// extended functionality
	if (dhtmlx.attaches) for (var a in dhtmlx.attaches) this.obj[a] = dhtmlx.attaches[a];
	
	return this;
	
}

//v.3.6 build 131108

/*
Copyright DHTMLX LTD. http://www.dhtmlx.com
To use this component please contact sales@dhtmlx.com to obtain license
*/
function dhtmlXCalendarObject(inps, skin) {
	
	// parse inputs
	this.i = {};
	
	this.uid = function() {
		if (!this.uidd) this.uidd = new Date().getTime();
		return this.uidd++;
	}
	
	var p = null;
	if (typeof(inps) == "string") {
		var t0 = document.getElementById(inps);
	} else {
		var t0 = inps;
	}
	if (t0 && typeof(t0) == "object" && t0.tagName && String(t0.tagName).toLowerCase() != "input") p = t0;
	t0 = null;
	
	// single param
	if (typeof(inps) != "object" || !inps.length) inps = [inps];
	for (var q=0; q<inps.length; q++) {
		if (typeof(inps[q]) == "string") inps[q] = (document.getElementById(inps[q])||null);
		if (inps[q] != null && inps[q].tagName && String(inps[q].tagName).toLowerCase() == "input") {
			this.i[this.uid()] = {input: inps[q]};
		} else {
			if (!(inps[q] instanceof Array) && inps[q] instanceof Object && (inps[q].input != null || inps[q].button != null)) {
				if (inps[q].input != null && typeof(inps[q].input) == "string") inps[q].input = document.getElementById(inps[q].input);
				if (inps[q].button != null && typeof(inps[q].button) == "string") inps[q].button = document.getElementById(inps[q].button);
				this.i[this.uid()] = inps[q];
			}
		}
		inps[q] = null;
	}
	
	this.skinDetect = function() {
		var t = document.createElement("DIV");
		t.className = "dhtmlxcalendar_skin_detect";
		if (document.body.firstChild) document.body.insertBefore(t, document.body.firstChild); else document.body.appendChild(t);
		var w = t.offsetWidth;
		t.parentNode.removeChild(t);
		t = null;
		return {10:"dhx_skyblue",20:"dhx_web",30:"dhx_terrace",40:"dhx_blue",50:"dhx_black",60:"omega"}[w]||null;
	}
	
	this.skin = (skin != null ? skin : (typeof(dhtmlx) != "undefined" && typeof(dhtmlx.skin) == "string" ? dhtmlx.skin : (this.skinDetect()||"dhx_skyblue")));
	
	this.setSkin = function(skin, force) {
		if (this.skin == skin && !force) return;
		this.skin = skin;
		this.base.className = "dhtmlxcalendar_container dhtmlxcalendar_skin_"+this.skin;
		this._ifrSize();
	}
	
	// create base
	this.base = document.createElement("DIV");
	this.base.className = "dhtmlxcalendar_container";
	this.base.style.display = "none";
	this.base.appendChild(document.createElement("DIV"));
	
	if (p != null) {
		this._hasParent = true;
		p.appendChild(this.base);
		p = null;
	} else { 
		document.body.appendChild(this.base);
	}
	
	this.setParent = function(p) {
		if (this._hasParent) {
			if (typeof(p) == "object") {
				p.appendChild(this.base);
			} else if (typeof(p) == "string") {
				document.getElementById(p).appendChild(this.base);
			}
		}
	}
	
	this.setSkin(this.skin, true);
	
	this.base.onclick = function(e) {
		e = e||event;
		e.cancelBubble = true;
	}
	this.base.onmousedown = function() {
		return false;
	}
	
	this.loadUserLanguage = function(lang) {
		if (!this.langData[lang]) return;
		this.lang = lang;
		this.setWeekStartDay(this.langData[this.lang].weekstart);
		this.setDateFormat(this.langData[this.lang].dateformat||"%Y-%m-%d");
		// month selector
		if (this.msCont) {
			var e = 0;
			for (var q=0; q<this.msCont.childNodes.length; q++) {
				for (var w=0; w<this.msCont.childNodes[q].childNodes.length; w++) {
					this.msCont.childNodes[q].childNodes[w].innerHTML = this.langData[this.lang].monthesSNames[e++];
				}
			}
		}
	}
	
	// build month and year header
	this.contMonth = document.createElement("DIV");
	this.contMonth.className = "dhtmlxcalendar_month_cont";
	this.contMonth.onselectstart = function(e){e=e||event;e.cancelBubble=true;e.returnValue=false;return false;}
	this.base.firstChild.appendChild(this.contMonth);
	
	var ul = document.createElement("UL");
	ul.className = "dhtmlxcalendar_line";
	this.contMonth.appendChild(ul);
	
	var li = document.createElement("LI");
	li.className = "dhtmlxcalendar_cell dhtmlxcalendar_month_hdr";
	li.innerHTML = "<div class='dhtmlxcalendar_month_arrow dhtmlxcalendar_month_arrow_left' onmouseover='this.className=\"dhtmlxcalendar_month_arrow dhtmlxcalendar_month_arrow_left_hover\";' onmouseout='this.className=\"dhtmlxcalendar_month_arrow dhtmlxcalendar_month_arrow_left\";'></div>"+
			"<span class='dhtmlxcalendar_month_label_month'>Month</span><span class='dhtmlxcalendar_month_label_year'>Year</span>"+
			"<div class='dhtmlxcalendar_month_arrow dhtmlxcalendar_month_arrow_right' onmouseover='this.className=\"dhtmlxcalendar_month_arrow dhtmlxcalendar_month_arrow_right_hover\";' onmouseout='this.className=\"dhtmlxcalendar_month_arrow dhtmlxcalendar_month_arrow_right\";'></div>";
	ul.appendChild(li);
	
	var that = this;
	li.onclick = function(e) {
		e = e||event;
		var t = (e.target||e.srcElement);
		// change month by clicking left-right arrows
		if (t.className && t.className.indexOf("dhtmlxcalendar_month_arrow") === 0) {
			that._hideSelector();
			var ind = (t.parentNode.firstChild==t?-1:1);
			var k0 = new Date(that._activeMonth);
			that._drawMonth(new Date(that._activeMonth.getFullYear(), that._activeMonth.getMonth()+ind, 1, 0, 0, 0, 0));
			that.callEvent("onArrowClick", [k0, new Date(that._activeMonth)]);
			return;
		}
		// show month selector
		if (t.className && t.className == "dhtmlxcalendar_month_label_month") {
			e.cancelBubble = true;
			that._showSelector("month",31,21,"selector_month",true);
			return;
		}
		// show year selector
		if (t.className && t.className == "dhtmlxcalendar_month_label_year") {
			e.cancelBubble = true;
			that._showSelector("year",42,21,"selector_year",true);
			return;
		}
		// hide selector if it visible
		that._hideSelector();
	}
	
	// build days names
	this.contDays = document.createElement("DIV");
	this.contDays.className = "dhtmlxcalendar_days_cont";
	this.base.firstChild.appendChild(this.contDays);
	
	this.setWeekStartDay = function(ind) {
		// 1..7 = Mo-Su, also 0 = Su
		if (ind == 0) ind = 7;
		this._wStart = Math.min(Math.max((isNaN(ind)?1:ind),1),7);
		this._drawDaysOfWeek();
	}
	
	this._drawDaysOfWeek = function() {
		if (this.contDays.childNodes.length == 0) {
			var ul = document.createElement("UL");
			ul.className = "dhtmlxcalendar_line";
			this.contDays.appendChild(ul);
		} else {
			var ul = this.contDays.firstChild;
		}
		
		var w = this._wStart;
		var k = this.langData[this.lang].daysSNames;
		k.push(String(this.langData[this.lang].daysSNames[0]).valueOf());
		
		for (var q=0; q<8; q++) {
			if (ul.childNodes[q] == null) {
				var li = document.createElement("LI");
				ul.appendChild(li);
			} else {
				var li = ul.childNodes[q];
			}
			if (q == 0) {
				li.className = "dhtmlxcalendar_cell_wn";
				li.innerHTML = "<div class='dhtmlxcalendar_label'>"+(this.langData[this.lang].weekname||"w")+"</div>";
			} else {
				li.className = "dhtmlxcalendar_cell"+(w>=6?" dhtmlxcalendar_day_weekday_cell":"")+(q==1?"_first":"");
				li.innerHTML = k[w];
				if (++w > 7) w = 1;
			}
		}
		if (this._activeMonth != null) this._drawMonth(this._activeMonth);
	}
	
	this._wStart = this.langData[this.lang].weekstart;
	this.setWeekStartDay(this._wStart);
	
	// dates container
	this.contDates = document.createElement("DIV");
	this.contDates.className = "dhtmlxcalendar_dates_cont";
	this.base.firstChild.appendChild(this.contDates);
	
	this.contDates.onclick = function(e){
		e = e||event;
		var t = (e.target||e.srcElement);
		if (t.parentNode != null && t.parentNode._date != null) t = t.parentNode;
		if (t._date != null && !t._css_dis) {
			
			var t1 = that._activeDate.getHours();
			var t2 = that._activeDate.getMinutes();
			var d0 = t._date;
			
			// cjeck if allow to modify input
			if (that.checkEvent("onBeforeChange")) {
				if (!that.callEvent("onBeforeChange",[new Date(t._date.getFullYear(),t._date.getMonth(),t._date.getDate(),t1,t2)])) return;
			}
			
			if (that._activeDateCell != null) {
				that._activeDateCell._css_date = false;
				that._updateCellStyle(that._activeDateCell._q, that._activeDateCell._w);
			}
			
			// update month if day from prev/next month clicked
			var refreshView = (/*that._hasParent &&*/ that._activeDate.getFullYear()+"_"+that._activeDate.getMonth() != d0.getFullYear()+"_"+d0.getMonth());
			
			that._nullDate = false;
			that._activeDate = new Date(d0.getFullYear(),d0.getMonth(),d0.getDate(),t1,t2);
			
			that._activeDateCell = t;
			that._activeDateCell._css_date = true;
			that._activeDateCell._css_hover = false;
			that._updateCellStyle(that._activeDateCell._q, that._activeDateCell._w);
			
			if (refreshView) that._drawMonth(that._activeDate);
			
			// update date in input if any
			if (that._activeInp && that.i[that._activeInp] && that.i[that._activeInp].input != null) {
				that.i[that._activeInp].input.value = that._dateToStr(new Date(that._activeDate.getTime()));
			}
			// hide
			if (!that._hasParent) that._hide();
			//
			that.callEvent("onClick",[new Date(that._activeDate.getTime())]);
			
		}
	}
	
	this.contDates.onmouseover = function(e) {
		e = e||event;
		var t = (e.target||e.srcElement);
		if (t.parentNode != null && t.parentNode._date != null) t = t.parentNode;
		if (t._date != null) { // && t != that._activeDateCell) { // skip hover for selected date
			if (that._lastHover == t || t._css_hover) return;
			t._css_hover = true;
			that._updateCellStyle(t._q, t._w);
			that._lastHover = t;
			that.callEvent("onMouseOver", [new Date(t._date.getFullYear(),t._date.getMonth(),t._date.getDate(),0,0,0,0),e]);
			t = null;
		}
	}
	this.contDates.onmouseout = function(e) {
		that._clearDayHover(e||event);
	}
	
	this._lastHover = null;
	this._clearDayHover = function(ev) {
		//if (!this._lastHover || !this._lastHover._css_hover) return;
		if (!this._lastHover) return;
		this._lastHover._css_hover = false;
		this._updateCellStyle(this._lastHover._q, this._lastHover._w);
		that.callEvent("onMouseOut", [new Date(this._lastHover._date.getFullYear(),this._lastHover._date.getMonth(),this._lastHover._date.getDate(),0,0,0,0),ev]);
		this._lastHover = null;
	}
	
	// build cells
	for (var q=0; q<6; q++) {
		var ul = document.createElement("UL");
		ul.className = "dhtmlxcalendar_line";
		this.contDates.appendChild(ul);
		for (var w=0; w<=7; w++) {
			var li = document.createElement("LI");
			if (w == 0) {
				// week number
				li.className = "dhtmlxcalendar_cell_wn";
			} else {
				li.className = "dhtmlxcalendar_cell";
			}
			ul.appendChild(li);
		}
	}
	
	
	// timepicker
	this.contTime = document.createElement("DIV");
	this.contTime.className = "dhtmlxcalendar_time_cont";
	this.base.firstChild.appendChild(this.contTime);
	
	// bottom border
	var t = document.createElement("DIV");
	t.className = "dhtmlxcalendar_bottom";
	this.base.firstChild.appendChild(t);
	t = null;
	
	this.showTime = function() {
		this.contTime.style.display = "";
		this._ifrSize();
	}
	
	this.hideTime = function() {
		this.contTime.style.display = "none";
		this._ifrSize();
	}
	
	var ul = document.createElement("UL");
	ul.className = "dhtmlxcalendar_line";
	this.contTime.appendChild(ul);
	
	var li = document.createElement("LI");
	li.className = "dhtmlxcalendar_cell dhtmlxcalendar_time_hdr";
	li.innerHTML = "<div class='dhtmlxcalendar_time_label'></div><span class='dhtmlxcalendar_label_hours'></span><span class='dhtmlxcalendar_label_colon'>:</span><span class='dhtmlxcalendar_label_minutes'></span>";
	ul.appendChild(li);
	
	li.onclick = function(e) {
		e = e||event;
		var t = (e.target||e.srcElement);
		if (t.tagName != null && t.tagName.toLowerCase() == "span" && t._par == true && t.parentNode != null) {
			console.log("span-click")
			t = t.parentNode;
		}
		// show hours selector
		if (t.className && t.className == "dhtmlxcalendar_label_hours") {
			e.cancelBubble = true;
			that._showSelector("hours",3,115,"selector_hours",true);
			return;
		}
		// show minutes selector
		if (t.className && t.className == "dhtmlxcalendar_label_minutes") {
			e.cancelBubble = true;
			var x = 59;
			var y = 115;
			if (that._minutesInterval == 1) {
				var d = that.getFormatedDate("%i");
				t.innerHTML = "<span class='dhtmlxcalendar_selected_date'>"+d.charAt(0)+"</span>"+d.charAt(1);
				t.firstChild._par = true;
				that._selectorMode = 1; // select hour
				y = 149;
			}
			if (that._minutesInterval == 10) y = 149;
			if (that._minutesInterval == 15) {
				x = 46;
				y = 165;
			}
			that._showSelector("minutes",x,y,"selector_minutes",true);
			return;
		}
		// hide selector if it visible
		that._hideSelector();
	}
	
	
	this._activeMonth = null;
	
	this._activeDate = new Date();
	this._activeDateCell = null;
	
	this.setDate = function(d) {
		
		this._nullDate = (typeof(d) == "undefined" || d === "" || !d);
		
		if (!(d instanceof Date)) {
			d = this._strToDate(String(d||""));
			if (d == "Invalid Date") d = new Date();
		}
		
		var time = d.getTime();
		
		// out of range
		if (this._isOutOfRange(time)) return;
		
		this._activeDate = new Date(time);
		this._drawMonth(this._nullDate?new Date():this._activeDate);
		this._updateVisibleHours();
		this._updateVisibleMinutes();
	}
	
	this.getDate = function(formated) {
		if (this._nullDate) return null;
		var t = new Date(this._activeDate.getTime());
		if (formated) return this._dateToStr(t);
		return t;
	}
	
	this._drawMonth = function(d) {
		
		if (!(d instanceof Date)) return;
		if (isNaN(d.getFullYear())) d = new Date(this._activeMonth.getFullYear(), this._activeMonth.getMonth(), 1, 0, 0, 0, 0);
		
		this._activeMonth = new Date(d.getFullYear(), d.getMonth(), 1, 0, 0, 0, 0);
		
		this._activeDateCell = null;
		
		var first = new Date(this._activeMonth.getTime());
		var d0 = first.getDay();
		
		var e0 = d0-this._wStart;
		if (e0 < 0) e0 = e0+7;
		first.setDate(first.getDate()-e0);
		
		var mx = d.getMonth();
		var dx = new Date(this._activeDate.getFullYear(), this._activeDate.getMonth(), this._activeDate.getDate(), 0, 0, 0, 0).getTime();
		var i = 0;
		for (var q=0; q<6; q++) {
			var ws = this._wStart;
			for (var w=0; w<=7; w++) {
				if (w == 0) {
					var wn = this.getWeekNumber(new Date(first.getFullYear(), first.getMonth(), first.getDate()+i, 0, 0, 0, 0));
					this.contDates.childNodes[q].childNodes[w].innerHTML = "<div class='dhtmlxcalendar_label'>"+wn+"</div>";
				} else {
					
					var d2 = new Date(first.getFullYear(), first.getMonth(), first.getDate()+i, 0, 0, 0, 0);
					var day = d2.getDay();
					var time = d2.getTime();
					
					var label_css = "dhtmlxcalendar_label";
					if (this._tipData[time] != null) {
						if (this._tipData[time].usePopup && typeof(window.dhtmlXPopup) == "function") {
							this.contDates.childNodes[q].childNodes[w].removeAttribute("title");
							this._initTooltipPopup();
						} else {
							this.contDates.childNodes[q].childNodes[w].setAttribute("title", this._tipData[time].text);
						}
						if (this._tipData[time].showIcon) label_css += " dhtmlxcalendar_label_title";
					} else {
						this.contDates.childNodes[q].childNodes[w].removeAttribute("title");
						
					}
					
					this.contDates.childNodes[q].childNodes[w].innerHTML = "<div class='"+label_css+"'>"+d2.getDate()+"</div>";
					
					this.contDates.childNodes[q].childNodes[w]._date = new Date(time);
					this.contDates.childNodes[q].childNodes[w]._q = q;
					this.contDates.childNodes[q].childNodes[w]._w = w;
					this.contDates.childNodes[q].childNodes[w]._css_month = (d2.getMonth()==mx);
					this.contDates.childNodes[q].childNodes[w]._css_date = (!this._nullDate&&time==dx);
					this.contDates.childNodes[q].childNodes[w]._css_weekend = (ws>=6);
					this.contDates.childNodes[q].childNodes[w]._css_dis = this._isOutOfRange(time);
					this.contDates.childNodes[q].childNodes[w]._css_holiday = (this._holidays[time] == true);
					
					this._updateCellStyle(q, w);
					
					if (time==dx) this._activeDateCell = this.contDates.childNodes[q].childNodes[w];
					
					if (++ws > 7) ws = 1;
					i++;
				}
				
			}
		}
		
		this.contMonth.firstChild.firstChild.childNodes[1].innerHTML = this.langData[this.lang].monthesFNames[d.getMonth()];
		this.contMonth.firstChild.firstChild.childNodes[2].innerHTML = d.getFullYear();
		
	}
	
	this._updateCellStyle = function(q, w) {
		
		var r = this.contDates.childNodes[q].childNodes[w];
		
		var s = "dhtmlxcalendar_cell dhtmlxcalendar_cell";
		
		// this/another month
		s += (r._css_month ? "_month" : "");
		
		// selected date
		s += (r._css_date ? "_date" : "");
		
		// is weekend
		s += (r._css_weekend ? "_weekend" : "");
		
		// is holiday
		s += (r._css_holiday ? "_holiday" : "");
		
		// is cell disabled
		s += (r._css_dis ? "_dis" : "");
		
		// is cell hover (only if not disabled)
		s += (r._css_hover && !r._css_dis ? "_hover" : "");
		
		r.className = s;
		r = null;
		
	}
	
	/* global selector obj */
	
	this._minutesInterval = 5; // default
	
	this._initSelector = function(type,css) {
		
		if (!this._selCover) {
			this._selCover = document.createElement("DIV");
			this._selCover.className = "dhtmlxcalendar_selector_cover";
			this.base.firstChild.appendChild(this._selCover);
		}

		if (!this._sel) {
			
			this._sel = document.createElement("DIV");
			this._sel.className = "dhtmlxcalendar_selector_obj";
			this.base.firstChild.appendChild(this._sel);
			
			this._sel.appendChild(document.createElement("TABLE"));
			this._sel.firstChild.className = "dhtmlxcalendar_selector_table";
			this._sel.firstChild.cellSpacing = 0;
			this._sel.firstChild.cellPadding = 0;
			this._sel.firstChild.border = 0;
			this._sel.firstChild.appendChild(document.createElement("TBODY"));
			this._sel.firstChild.firstChild.appendChild(document.createElement("TR"));
			
			this._sel.firstChild.firstChild.firstChild.appendChild(document.createElement("TD"));
			this._sel.firstChild.firstChild.firstChild.appendChild(document.createElement("TD"));
			this._sel.firstChild.firstChild.firstChild.appendChild(document.createElement("TD"));
			
			this._sel.firstChild.firstChild.firstChild.childNodes[0].className = "dhtmlxcalendar_selector_cell_left";
			this._sel.firstChild.firstChild.firstChild.childNodes[1].className = "dhtmlxcalendar_selector_cell_middle";
			this._sel.firstChild.firstChild.firstChild.childNodes[2].className = "dhtmlxcalendar_selector_cell_right";
			this._sel.firstChild.firstChild.firstChild.childNodes[0].innerHTML = "&nbsp;";
			this._sel.firstChild.firstChild.firstChild.childNodes[2].innerHTML = "&nbsp;";
			
			this._sel.firstChild.firstChild.firstChild.childNodes[0].onmouseover = function(){
				this.className = "dhtmlxcalendar_selector_cell_left dhtmlxcalendar_selector_cell_left_hover";
			}
			this._sel.firstChild.firstChild.firstChild.childNodes[0].onmouseout = function(){
				this.className = "dhtmlxcalendar_selector_cell_left";
			}
			
			this._sel.firstChild.firstChild.firstChild.childNodes[2].onmouseover = function(){
				this.className = "dhtmlxcalendar_selector_cell_right dhtmlxcalendar_selector_cell_right_hover";
			}
			this._sel.firstChild.firstChild.firstChild.childNodes[2].onmouseout = function(){
				this.className = "dhtmlxcalendar_selector_cell_right";
			}
			
			this._sel.firstChild.firstChild.firstChild.childNodes[0].onclick = function(e){
				e = e||event;
				e.cancelBubble = true;
				that._scrollYears(-1);
			}
			
			this._sel.firstChild.firstChild.firstChild.childNodes[2].onclick = function(e){
				e = e||event;
				e.cancelBubble = true;
				that._scrollYears(1);
			}
			
			this._sel._ta = {};
			
			this._selHover = null;
			
			this._sel.onmouseover = function(e) {
				e = e||event;
				var t = (e.target||e.srcElement);
				if (t._cell === true) {
					if (that._selHover != t) that._clearSelHover();
					if (String(t.className).match(/^\s{0,}dhtmlxcalendar_selector_cell\s{0,}$/gi) !=null) {
						t.className += " dhtmlxcalendar_selector_cell_hover";
						that._selHover = t;
					}
				}
			}
			
			this._sel.onmouseout = function() {
				that._clearSelHover();
			}
			
			this._sel.appendChild(document.createElement("DIV"));
			this._sel.lastChild.className = "dhtmlxcalendar_selector_obj_arrow";
		}
		
		// check if already inited
		if (this._sel._ta[type] == true) return;
		
		// init month
		if (type == "month") {
			
			this._msCells = {};
			
			this.msCont = document.createElement("DIV");
			this.msCont.className = "dhtmlxcalendar_area_"+css;
			this._sel.firstChild.firstChild.firstChild.childNodes[1].appendChild(this.msCont);
			
			var i = 0;
			for (var q=0; q<4; q++) {
				var ul = document.createElement("UL");
				ul.className = "dhtmlxcalendar_selector_line";
				this.msCont.appendChild(ul);
				for (var w=0; w<3; w++) {
					var li = document.createElement("LI");
					li.innerHTML = this.langData[this.lang].monthesSNames[i];
					li.className = "dhtmlxcalendar_selector_cell";
					ul.appendChild(li);
					li._month = i;
					li._cell = true;
					this._msCells[i++] = li;
				}
			}
			
			this.msCont.onclick = function(e) {
				e = e||event;
				e.cancelBubble = true;
				var t = (e.target||e.srcElement);
				if (t._month != null) {
					that._hideSelector();
					that._updateActiveMonth();
					that._drawMonth(new Date(that._activeMonth.getFullYear(), t._month, 1, 0, 0, 0, 0));
					that._doOnSelectorChange();
				}
			}
			
		}
		
		// init year
		if (type == "year") {
			
			this._ysCells = {};
			
			this.ysCont = document.createElement("DIV");
			this.ysCont.className = "dhtmlxcalendar_area_"+css;
			this._sel.firstChild.firstChild.firstChild.childNodes[1].appendChild(this.ysCont);
			
			for (var q=0; q<4; q++) {
				var ul = document.createElement("UL");
				ul.className = "dhtmlxcalendar_selector_line";
				this.ysCont.appendChild(ul);
				for (var w=0; w<3; w++) {
					var li = document.createElement("LI");
					li.className = "dhtmlxcalendar_selector_cell";
					li._cell = true;
					ul.appendChild(li);
				}
			}
			
			this.ysCont.onclick = function(e) {
				e = e||event;
				e.cancelBubble = true;
				var t = (e.target||e.srcElement);
				if (t._year != null) {
					that._hideSelector();
					that._drawMonth(new Date(t._year, that._activeMonth.getMonth(), 1, 0, 0, 0, 0));
					that._doOnSelectorChange();
				}
			}
			
		}
		
		// init hours
		if (type == "hours") {
			
			this._hsCells = {};
			
			this.hsCont = document.createElement("DIV");
			this.hsCont.className = "dhtmlxcalendar_area_"+css;
			this._sel.firstChild.firstChild.firstChild.childNodes[1].appendChild(this.hsCont);
			
			var i = 0;
			for (var q=0; q<4; q++) {
				var ul = document.createElement("UL");
				ul.className = "dhtmlxcalendar_selector_line";
				this.hsCont.appendChild(ul);
				for (var w=0; w<6; w++) {
					var li = document.createElement("LI");
					li.innerHTML = this._fixLength(i,2);
					li.className = "dhtmlxcalendar_selector_cell";
					ul.appendChild(li);
					li._hours = i;
					li._cell = true;
					this._hsCells[i++] = li;
				}
			}
			
			this.hsCont.onclick = function(e) {
				e = e||event;
				e.cancelBubble = true;
				var t = (e.target||e.srcElement);
				if (t._hours != null) {
					that._hideSelector();
					that._activeDate.setHours(t._hours);
					that._updateActiveHours();
					that._updateVisibleHours();
					that._doOnSelectorChange();
				}
			}
			
		}
		
		// init minutes
		if (type == "minutes") {
			
			// _minutesInterval = 5, def
			
			var q1 = 4;
			var w1 = 3;
			var len = 2; // leading zero
			
			if (this._minutesInterval == 1) {
				if (this._selectorMode == 1) {
					q1 = 2;
					w1 = 3;
					len = 1;
				} else {
					q1 = 2;
					w1 = 5;
					len = 1;
					css += "5";
				}
			}
			if (this._minutesInterval == 10) q1 = 2;
			if (this._minutesInterval == 15) {
				q1 = 1;
				w1 = 4;
				css += "4";
			}
			
			this._rsCells = {};
			
			this.rsCont = document.createElement("DIV");
			this.rsCont.className = "dhtmlxcalendar_area_"+css;
			this._sel.firstChild.firstChild.firstChild.childNodes[1].appendChild(this.rsCont);
			
			var i = 0;
			for (var q=0; q<q1; q++) {
				var ul = document.createElement("UL");
				ul.className = "dhtmlxcalendar_selector_line";
				this.rsCont.appendChild(ul);
				for (var w=0; w<w1; w++) {
					var li = document.createElement("LI");
					li.innerHTML = (len>1?this._fixLength(i,len):i);
					li.className = "dhtmlxcalendar_selector_cell";
					ul.appendChild(li);
					li._minutes = i;
					li._cell = true;
					this._rsCells[i] = li;
					i += this._minutesInterval;
				}
			}
			
			this.rsCont.onclick = function(e) {
				e = e||event;
				e.cancelBubble = true;
				var t = (e.target||e.srcElement);
				if (t._minutes != null) {
					if (that._minutesInterval == 1) {
						
						var m = that.getFormatedDate("%i");
						if (that._selectorMode == 1) {
							m = t._minutes.toString()+m.charAt(1);
						} else {
							m = m.charAt(0)+t._minutes.toString();
						}
						that._activeDate.setMinutes(Number(m));
						
						that._hideSelector(); // will unload
						
						if (that._selectorMode == 1) {
							// show 2nd
							
							that._updateVisibleMinutes(true);
							that._selectorMode = 2;
							that._showSelector("minutes",32,149,"selector_minutes",true);
							that._updateActiveMinutes();
							return;
						} else {
							that._selectorMode = 1;
						}
					} else {
						that._hideSelector();
						that._activeDate.setMinutes(t._minutes);
						that._updateActiveMinutes();
					}
					that._updateVisibleMinutes();
					that._doOnSelectorChange();
				}
			}
			
		}
		
		// mark that selector of current type is inited
		this._sel._ta[type] = true;
	}
	
	this._showSelector = function(type,x,y,css,autoHide) {
		
		if (autoHide === true && this._sel != null && this._isSelectorVisible() && type == this._sel._t) {
			this._hideSelector();
			return;
		}
		
		if (this.skin == "dhx_terrace") {
			x += {month: 14, year:27, hours: 19, minutes: 24}[type];
			y += {month:  8, year: 8, hours: 14, minutes: 14}[type];
		}
		
		if (!this._sel || !this._sel._ta[type]) this._initSelector(type,css);
		
		// show selector cover
		this._selCover.style.display = "";
		
		// show selector
		this._sel._t = type;
		this._sel.style.left = x+"px";
		this._sel.style.top = y+"px";
		this._sel.style.display = "";
		this._sel.className = "dhtmlxcalendar_selector_obj dhtmlxcalendar_"+css;
		
		// arrow width for IE
		this._sel.childNodes[0].firstChild.firstChild.childNodes[0].style.display = this._sel.childNodes[0].firstChild.firstChild.childNodes[2].style.display = (type=="year"?"":"none");
		this._sel.childNodes[1].style.width = this._sel.childNodes[0].offsetWidth+"px";
		
		
		// callbacks
		this._doOnSelectorShow(type);
	}
	
	this._doOnSelectorShow = function(type) {
		if (type == "month") this._updateActiveMonth();
		if (type == "year") this._updateYearsList(this._activeMonth);
		if (type == "hours") this._updateActiveHours();
		if (type == "minutes") this._updateActiveMinutes();
	}
	
	this._hideSelector = function(selMode) {
		if (!this._sel) return;
		this._sel.style.display = "none";
		this._selCover.style.display = "none";
		//
		if (this._sel._t == "minutes" && this._minutesInterval == 1) {
			this.contTime.firstChild.firstChild.childNodes[3].innerHTML = this.getFormatedDate("%i");
			this._unloadSelector("minutes");
		}
	}
	
	this._isSelectorVisible = function() {
		if (!this._sel) return false;
		return (this._sel.style.display != "none");
	}
	
	this._doOnSelectorChange = function(state) {
		this.callEvent("onChange",[new Date(this._activeMonth.getFullYear(), this._activeMonth.getMonth(), this._activeDate.getDate(), this._activeDate.getHours(), this._activeDate.getMinutes(), this._activeDate.getSeconds()),state===true]);
	}
	
	this._clearSelHover = function() {
		if (!this._selHover) return;
		this._selHover.className = String(this._selHover.className.replace(/dhtmlxcalendar_selector_cell_hover/gi,""));
		this._selHover = null;
	}
	
	this._unloadSelector = function(type) {
		if (!this._sel) return;
		if (!this._sel._ta[type]) return;
		
		// month selector
		if (type == "month") {
			
			this.msCont.onclick = null;
			this._msActive = null;
			
			// li
			for (var a in this._msCells) {
				this._msCells[a]._cell = null;
				this._msCells[a]._month = null;
				this._msCells[a].parentNode.removeChild(this._msCells[a]);
				this._msCells[a] = null;
			}
			this._msCells = null;
			
			// ul
			while (this.msCont.childNodes.length > 0) this.msCont.removeChild(this.msCont.lastChild);
			
			// div
			this.msCont.parentNode.removeChild(this.msCont);
			this.msCont = null;
			
		}
		
		// years selector
		if (type == "year") {
			
			this.ysCont.onclick = null;
			
			// li
			for (var a in this._ysCells) {
				this._ysCells[a]._cell = null;
				this._ysCells[a]._year = null;
				this._ysCells[a].parentNode.removeChild(this._ysCells[a]);
				this._ysCells[a] = null;
			}
			this._ysCells = null;
			
			// ul
			while (this.ysCont.childNodes.length > 0) this.ysCont.removeChild(this.ysCont.lastChild);
			
			// div
			this.ysCont.parentNode.removeChild(this.ysCont);
			this.ysCont = null;
			
		}
		
		// hours selector
		if (type == "hours") {
			
			this.hsCont.onclick = null;
			this._hsActive = null;
			
			// li
			for (var a in this._hsCells) {
				this._hsCells[a]._cell = null;
				this._hsCells[a]._hours = null;
				this._hsCells[a].parentNode.removeChild(this._hsCells[a]);
				this._hsCells[a] = null;
			}
			this._hsCells = null;
			
			// ul
			while (this.hsCont.childNodes.length > 0) this.hsCont.removeChild(this.hsCont.lastChild);
			
			// div
			this.hsCont.parentNode.removeChild(this.hsCont);
			this.hsCont = null;
			
		}
		
		// minutes selector
		if (type == "minutes") {
			
			this.rsCont.onclick = null;
			this._rsActive = null;
			
			// li
			for (var a in this._rsCells) {
				this._rsCells[a]._cell = null;
				this._rsCells[a]._minutes = null;
				this._rsCells[a].parentNode.removeChild(this._rsCells[a]);
				this._rsCells[a] = null;
			}
			this._rsCells = null;
			
			// ul
			while (this.rsCont.childNodes.length > 0) this.rsCont.removeChild(this.rsCont.lastChild);
			
			// div
			this.rsCont.parentNode.removeChild(this.rsCont);
			this.rsCont = null;
			
		}
		
		
		this._sel._ta[type] = null;
	}
	
	this.setMinutesInterval = function(d) {
		if (!(d == 1 || d == 5 || d == 10 || d == 15)) return;
		this._minutesInterval = d;
		this._unloadSelector("minutes");
	}
	
	
	/* month selector */
	
	this._updateActiveMonth = function() {
		if (typeof(this._msActive) != "undefined" && typeof(this._msCells[this._msActive]) != "undefined") this._msCells[this._msActive].className = "dhtmlxcalendar_selector_cell";
		this._msActive = this._activeMonth.getMonth();
		this._msCells[this._msActive].className = "dhtmlxcalendar_selector_cell dhtmlxcalendar_selector_cell_active";
	}
	
	/* year selector */
	
	this._updateActiveYear = function() {
		var i = this._activeMonth.getFullYear();
		if (this._ysCells[i]) this._ysCells[i].className = "dhtmlxcalendar_selector_cell dhtmlxcalendar_selector_cell_active";
	}
	
	this._updateYearsList = function(d) {
		for (var a in this._ysCells) {
			this._ysCells[a] = null;
			delete this._ysCells[a];
		}
		//
		var i = 12*Math.floor(d.getFullYear()/12);
		for (var q=0; q<4; q++) {
			for (var w=0; w<3; w++) {
				this.ysCont.childNodes[q].childNodes[w].innerHTML = i;
				this.ysCont.childNodes[q].childNodes[w]._year = i;
				this.ysCont.childNodes[q].childNodes[w].className = "dhtmlxcalendar_selector_cell";
				this._ysCells[i++] = this.ysCont.childNodes[q].childNodes[w];
			}
		}
		this._updateActiveYear();
	}
	
	this._scrollYears = function(i) {
		var y = (i<0?this.ysCont.firstChild.firstChild._year:this.ysCont.lastChild.lastChild._year)+i;
		var d = new Date(y, this._activeMonth.getMonth(), 1, 0, 0, 0, 0);
		this._updateYearsList(d);
	}
	
	/* hours selector */
	
	// update hours in selector
	this._updateActiveHours = function() {
		if (typeof(this._hsActive) != "undefined" && typeof(this._hsCells[this._hsActive]) != "undefined") this._hsCells[this._hsActive].className = "dhtmlxcalendar_selector_cell";
		this._hsActive = this._activeDate.getHours();
		this._hsCells[this._hsActive].className = "dhtmlxcalendar_selector_cell dhtmlxcalendar_selector_cell_active";
	}
	
	// update hours in calendar
	this._updateVisibleHours = function() {
		this.contTime.firstChild.firstChild.childNodes[1].innerHTML = this._fixLength(this._activeDate.getHours(),2);
	}
	
	/* minutes selector */
	
	// update minutes in selector
	this._updateActiveMinutes = function() {
		if (this._rsActive != null && typeof(this._rsActive) != "undefined" && typeof(this._rsCells[this._rsActive]) != "undefined") this._rsCells[this._rsActive].className = "dhtmlxcalendar_selector_cell";
		if (this._minutesInterval == 1) {
			this._rsActive = (this.getFormatedDate("%i").toString()).charAt(this._selectorMode==1?0:1);
		} else {
			this._rsActive = this._activeDate.getMinutes();
		}
		if (typeof(this._rsCells[this._rsActive]) != "undefined") this._rsCells[this._rsActive].className = "dhtmlxcalendar_selector_cell dhtmlxcalendar_selector_cell_active";
	}
	
	// update minutes in calendar
	this._updateVisibleMinutes = function(h) {
		var t = this._fixLength(this._activeDate.getMinutes(),2).toString();
		if (h == true) t = t.charAt(0)+"<span class='dhtmlxcalendar_selected_date'>"+t.charAt(1)+"</span>";
		this.contTime.firstChild.firstChild.childNodes[3].innerHTML = t;
		if (h == true) this.contTime.firstChild.firstChild.childNodes[3].lastChild._par = true;
	}
	
	/* some common functionality */
	
	this._fixLength = function(t, r) {
		while (String(t).length < r) t = "0"+String(t);
		return t;
	}
	
	this._dateFormat = "";
	this._dateFormatRE = null;
	
	this.setDateFormat = function(format) {
		this._dateFormat = format;
		this._dateFormatRE = new RegExp(String(this._dateFormat).replace(/%[a-zA-Z]+/g,function(t){
			var t2 = t.replace(/%/,"");
			switch (t2) {
				case "n":
				case "h":
				case "j":
				case "g":
				case "G":
					return "\\d{1,2}";
				case "m":
				case "d":
				case "H":
				case "i":
				case "s":
				case "y":
					return "\\d{2}";
				case "Y":
					return "\\d{4}";
				case "M":
					return "("+that.langData[that.lang].monthesSNames.join("|").toLowerCase()+"){1,}";
				case "F":
					return "("+that.langData[that.lang].monthesFNames.join("|").toLowerCase()+"){1,}";
				case "D":
					return "[a-z]{2}";
				case "a":
				case "A":
					return "AM|PM";
			}
			return t;
		}),"i");
	}
	
	this.setDateFormat(this.langData[this.lang].dateformat||"%Y-%m-%d");
	
	// get index by value
	this._getInd = function(val,ar) {
		for (var q=0; q<ar.length; q++) if (ar[q].toLowerCase() == val) return q;
		return -1;
	}
	
	this._strToDate = function(val, format) {
		
		format = (format||this._dateFormat);
		
		
		var v = val.match(/[a-z0-9\u0430-\u044F\u0451]{1,}/gi);
		var f = format.match(/%[a-zA-Z]/g);
		
		if (!v || v.length != f.length) return "Invalid Date";
		
		// sorting
		/*
		Year	y,Y	1
		Month	n,m,M,F	2
		Day	d,j	3
		AM/PM	a,A	4
		Hours	H,G,h,g	5
		Minutes	i	6
		Seconds	s	7
		*/
		
		var p = {"%y":1,"%Y":1,"%n":2,"%m":2,"%M":2,"%F":2,"%d":3,"%j":3,"%a":4,"%A":4,"%H":5,"%G":5,"%h":5,"%g":5,"%i":6,"%s":7};
		var v2 = {};
		var f2 = {};
		for (var q=0; q<f.length; q++) {
			if (typeof(p[f[q]]) != "undefined") {
				var ind = p[f[q]];
				if (!v2[ind]){v2[ind]=[];f2[ind]=[];}
				v2[ind].push(v[q]);
				f2[ind].push(f[q]);
			}
		}
		v = [];
		f = [];
		for (var q=1; q<=7; q++) {
			if (v2[q] != null) {
				for (var w=0; w<v2[q].length; w++) {
					v.push(v2[q][w]);
					f.push(f2[q][w]);
				}
			}
		}
		
		// parsing date
		var r = new Date();
		r.setDate(1); // fix for 31th
		r.setMinutes(0);
		r.setSeconds(0);
		
		for (var q=0; q<v.length; q++) {
			
			switch (f[q]) {
				case "%d":
				case "%j":
				case "%n":
				case "%m":
				case "%Y":
				case "%H":
				case "%G":
				case "%i":
				case "%s":
					if (!isNaN(v[q])) r[{"%d":"setDate","%j":"setDate","%n":"setMonth","%m":"setMonth","%Y":"setFullYear","%H":"setHours","%G":"setHours","%i":"setMinutes","%s":"setSeconds"}[f[q]]](Number(v[q])+(f[q]=="%m"||f[q]=="%n"?-1:0));
					break;
				case "%M":
				case "%F":
					var k = this._getInd(v[q].toLowerCase(),that.langData[that.lang][{"%M":"monthesSNames","%F":"monthesFNames"}[f[q]]]);
					if (k >= 0) r.setMonth(k);
					break;
				case "%y":
					if (!isNaN(v[q])) {
						var v0 = Number(v[q]);
						r.setFullYear(v0+(v0>50?1900:2000));
					}
					break;
				case "%g":
				case "%h":
					if (!isNaN(v[q])) {
						var v0 = Number(v[q]);
						if (v0 <= 12 && v0 >= 0) {
							// 12:00 AM -> midnight
							// 12:00 PM -> noon
							r.setHours(v0+(this._getInd("pm",v)>=0?(v0==12?0:12):(v0==12?-12:0)));
						}
					}
					break;

			}
			
		}
		
		return r;
	}
	
	this._dateToStr = function(val, format) {
		
		if (val instanceof Date) {
			var z = function(t) {
				return (String(t).length==1?"0"+String(t):t);
			}
			var k = function(t) {
				switch(t) {
					case "%d": return z(val.getDate());
					case "%j": return val.getDate();
					case "%D": return that.langData[that.lang].daysSNames[val.getDay()];
					case "%l": return that.langData[that.lang].daysFNames[val.getDay()];
					// %W - ISO-8601 week number of year, weeks starting on Monday; 1)
					case "%m": return z(val.getMonth()+1);
					case "%n": return val.getMonth()+1;
					case "%M": return that.langData[that.lang].monthesSNames[val.getMonth()];
					case "%F": return that.langData[that.lang].monthesFNames[val.getMonth()];
					case "%y": return z(val.getYear()%100);
					case "%Y": return val.getFullYear();
					case "%g": return (val.getHours()+11)%12+1;
					case "%h": return z((val.getHours()+11)%12+1);
					case "%G": return val.getHours();
					case "%H": return z(val.getHours());
					case "%i": return z(val.getMinutes());
					case "%s": return z(val.getSeconds());
					case "%a": return (val.getHours()>11?"pm":"am");
					case "%A": return (val.getHours()>11?"PM":"AM");
					case "%%": "%";
					default: return t;
				}
			}
			var t = String(format||this._dateFormat).replace(/%[a-zA-Z]/g, k);
		}
		
		return (t||String(val));
	}
	
	this._updateDateStr = function(str) {
		// check if valid str
		if (!this._dateFormatRE || !str.match(this._dateFormatRE)) return;
		
		// input was not updated
		if (str == this.getFormatedDate()) return;
		
		var r = this._strToDate(str);
		if (!(r instanceof Date)) return;
		
		// cjeck if allow to modify input
		if (this.checkEvent("onBeforeChange")) {
			if (!this.callEvent("onBeforeChange",[new Date(r.getFullYear(),r.getMonth(),r.getDate(),r.getHours(),r.getMinutes(),r.getSeconds())])) {
				// revert value
				if (this.i != null && this._activeInp != null && this.i[this._activeInp] != null && this.i[this._activeInp].input != null) {
					this.i[this._activeInp].input.value = this.getFormatedDate();
				}
				return;
			}
		}
		
		this._nullDate = false;
		this._activeDate = r;
		this._drawMonth(this._nullDate?new Date():this._activeDate);
		
		this._updateVisibleMinutes();
		this._updateVisibleHours();
		
		if (this._sel && this._isSelectorVisible()) this._doOnSelectorShow(this._sel._t);
		this._doOnSelectorChange(true);
		
	}
	
	this.showMonth = function(d) {
		if (typeof(d) == "string") d = this._strToDate(d);
		if (!(d instanceof Date)) return;
		this._drawMonth(d);
	}
	
	this.setFormatedDate = function(format, str, a, return_only) {
		var date = this._strToDate(str, format);
		if (return_only) return date;
		this.setDate(date);
	}

	this.getFormatedDate = function(format, date){
		if (!(date && date instanceof Date)){
			if (this._nullDate) return ""; 
			date = new Date(this._activeDate);
		}
		return this._dateToStr(date, format);
	}
	
	/* week numbers */
	this.getWeekNumber = function(dateX) {
		
		if (typeof(dateX) == "string") dateX = this._strToDate(dateX);
		if (!(dateX instanceof Date)) return "Invalid Date";
		
		if (typeof(this._ftDay) == "undefined") this._ftDay = 4;
		
		var ws = this._wStart; // 1..7 = Mo-Su
		var we = ws+7;
		
		var ft = 4; // first thursday
		
		
		var x1_date = new Date(dateX.getFullYear(), 0, 1, 0, 0, 0, 0);// day-of-week, jan first
		var x1 = x1_date.getDay();
		if (x1 == 0) x1 = 7;
		
		// offset
		if (ft < ws) {
			ft += 7;
			x1 += 7;
		}
		
		// detect date of 1st week
		
		var i = 0; // week offset
		if (x1 >= ws && x1 <= ft) {
			// x1 belong 1st week
		} else {
			// x1 belong 2nd week
			i = 1;
		}
		var k = x1-ws;
		var w1 = new Date(dateX.getFullYear(), 0, 1-k+i*7, 0, 0, 0, 0);// 1st week start date
		
		// console.log("1st week of "+x.getFullYear()+" year starts from "+this.getFormatedDate("%M %d, %Y",w1));
		
		var d7 = 604800000; // 7 days in ms, 60*60*24*7*1000
		var x2 = new Date(dateX.getFullYear(), dateX.getMonth(), dateX.getDate()+1, 0, 0, 0, 0); // 2nd day to get interval
		
		var wn = Math.ceil((x2.getTime()-w1.getTime())/d7);
		
		return wn;
		
	}
	
	this.showWeekNumbers = function() {
		this.base.firstChild.className = "dhtmlxcalendar_wn";
	}
	
	this.hideWeekNumbers = function() {
		this.base.firstChild.className = "";
	}
	
	/* show/hide calendar */
	
	// public show/hide
	
	this.show = function(id) {
		// if id not set - try show in container
		if (!id && this._hasParent) {
			this._show();
			return;
		}
		// if input id not specified show near first found
		// if nothing found - do not show
		if (typeof(id) == "object" && typeof(id._dhtmlxcalendar_uid) != "undefined" && this.i[id._dhtmlxcalendar_uid] == id) {
			this._show(id._dhtmlxcalendar_uid);
			return;
		}
		if (typeof(id) == "undefined") { for (var a in this.i) if (!id) id = a; }
		if (!id) return;
		this._show(id);
	}
	
	this.hide = function() {
		if (this._isVisible()) this._hide();
	}
	
	this.isVisible = function() {
		return this._isVisible();
	}
	
	
	this.draw = function() {
		// deprecated
		this.show();
	}
	
	this.close = function() {
		// deprecated
		this.hide();
	}
	
	// private show/hide
	
	this._activeInp = null;
	
	this.pos = "bottom";
	this.setPosition = function(x, y) {
		this._px = null;
		this._py = null;
		if (x == "right" || x == "bottom") {
			this.pos = x;
		} else {
			this.pos = "int";
			if (typeof(x) != "undefined" && !isNaN(x)) {
				this.base.style.left = x+"px";
				this._px = x;
			}
			if (typeof(y) != "undefined" && !isNaN(y)) {
				this.base.style.top = y+"px";
				this._py = y;
			}
			this._ifrSize();
		}
	}
	
	this._show = function(inpId, autoHide) {
		if (autoHide === true && this._activeInp == inpId && this._isVisible()) {
			this._hide();
			return;
		}
		this.base.style.visibility = "hidden";
		this.base.style.display = "";
		if (!inpId) {
			if (this._px && this._py) {
				this.base.style.left = this._px+"px";
				this.base.style.top = this._py+"px";
			} else {
				this.base.style.left = "0px";
				this.base.style.top = "0px";
			}
		} else {
			var i = (this.i[inpId].input||this.i[inpId].button);
			var _isIE = (navigator.appVersion.indexOf("MSIE")!=-1);
			var y1 = Math.max((_isIE?document.documentElement:document.getElementsByTagName("html")[0]).scrollTop, document.body.scrollTop);
			var y2 = y1+(_isIE?Math.max(document.documentElement.clientHeight||0,document.documentElement.offsetHeight||0,document.body.clientHeight||0):window.innerHeight);
			if (this.pos == "right") {
				this.base.style.left = this._getLeft(i)+i.offsetWidth-1+"px";
				this.base.style.top = Math.min(this._getTop(i),y2-this.base.offsetHeight)+"px";
				
			} else if (this.pos == "bottom") {
				this.base.style.left = this._getLeft(i)+"px";
				this.base.style.top = this._getTop(i)+i.offsetHeight+1+"px";
			} else {
				this.base.style.left = (this._px||0)+"px";
				this.base.style.top = (this._py||0)+"px";
			}
			this._activeInp = inpId;
			i = null;
		}
		this._hideSelector();
		this.base.style.visibility = "visible";
		this._ifrSize();
		if (this._ifr) this._ifr.style.display = "";
		this.callEvent("onShow",[]);
	}
	
	this._hide = function() {
		this._hideSelector();
		this.base.style.display = "none";
		this._activeInp = null;
		if (this._ifr) this._ifr.style.display = "none";
		this.callEvent("onHide",[]);
	}
	
	this._isVisible = function() {
		return (this.base.style.display!="none");
	}
		
	this._getLeft = function(obj) {
		return this._posGetOffset(obj).left;
	}
	
	this._getTop = function(obj) {
		return this._posGetOffset(obj).top;
	}
	
	this._posGetOffsetSum = function(elem) {
		var top=0, left=0;
		while(elem) {
			top = top + parseInt(elem.offsetTop);
			left = left + parseInt(elem.offsetLeft);
			elem = elem.offsetParent;
		}
		return {top: top, left: left};
	}
	this._posGetOffsetRect = function(elem) {
		var box = elem.getBoundingClientRect();
		var body = document.body;
		var docElem = document.documentElement;
		var scrollTop = window.pageYOffset || docElem.scrollTop || body.scrollTop;
		var scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft;
		var clientTop = docElem.clientTop || body.clientTop || 0;
		var clientLeft = docElem.clientLeft || body.clientLeft || 0;
		var top  = box.top +  scrollTop - clientTop;
		var left = box.left + scrollLeft - clientLeft;
		return { top: Math.round(top), left: Math.round(left) };                                 
	}
	this._posGetOffset = function(elem) {
		return this[elem.getBoundingClientRect?"_posGetOffsetRect":"_posGetOffsetSum"](elem);
	}
	
	this._rangeActive = false;
	this._rangeFrom = null;
	this._rangeTo = null;
	this._rangeSet = {};
	
	this.setInsensitiveDays = function(d) {
		
		// !works in append mode
		var t = this._extractDates(d);
		for (var q=0; q<t.length; q++) this._rangeSet[new Date(t[q].getFullYear(),t[q].getMonth(),t[q].getDate(),0,0,0,0).getTime()] = true;
		
		this._drawMonth(this._activeMonth);
		
	}
	
	this.clearInsensitiveDays = function() {
		this._clearRangeSet();
		this._drawMonth(this._activeMonth);
	}
	
	this._holidays = {};
	this.setHolidays = function(r) {
		if (r == null) {
			this._clearHolidays();
		} else if (r != null) {
			var t = this._extractDates(r);
			for (var q=0; q<t.length; q++) this._holidays[new Date(t[q].getFullYear(),t[q].getMonth(),t[q].getDate(),0,0,0,0).getTime()] = true;
		}
		this._drawMonth(this._activeMonth);
	}
	
	this._extractDates = function(r) {
		// r = array of dates or comma-separated string list
		// return array with dates
		if (typeof(r) == "string" || r instanceof Date) r = [r];
		var t = [];
		for (var q=0; q<r.length; q++) {
			if (typeof(r[q]) == "string") {
				var e = r[q].split(",");
				for (var w=0; w<e.length; w++) t.push(this._strToDate(e[w]));
			} else if (r[q] instanceof Date) {
				t.push(r[q]);
			}
		}
		return t;
	}
	
	this._clearRange = function() {
		this._rangeActive = false;
		this._rangeType = null;
		this._rangeFrom = null;
		this._rangeTo = null;
	}
	
	this._clearRangeSet = function() {
		for (var a in this._rangeSet) {
			this._rangeSet[a] = null;
			delete this._rangeSet[a];
		}
	}
	
	this._clearHolidays = function() {
		for (var a in this._holidays) {
			this._holidays[a] = null;
			delete this._holidays[a];
		}
	}
	
	this._isOutOfRange = function(time) {
		
		if (this._rangeSet[time] == true) return true;
		
		if (this._rangeActive) {
			
			if (this._rangeType == "in" && (time<this._rangeFrom || time>this._rangeTo)) return true;
			if (this._rangeType == "out" && (time>=this._rangeFrom && time<=this._rangeTo)) return true;
			if (this._rangeType == "from" && time<this._rangeFrom)return true;
			if (this._rangeType == "to" && time>this._rangeTo) return true;
		}
		
		var t0 = new Date(time);
		
		if (this._rangeWeek) {
			if (this._rangeWeekData[t0.getDay()] === true) return true;
		}
		
		if (this._rangeMonth) {
			if (this._rangeMonthData[t0.getDate()] === true) return true;
		}
		
		if (this._rangeYear) {
			if (this._rangeYearData[t0.getMonth()+"_"+t0.getDate()] === true) return true;
		}
		
		return false;
		
	}
	
	this.clearSensitiveRange = function() {
		this._clearRange();
		this._drawMonth(this._activeMonth);
	}
	
	this.setSensitiveRange = function(from, to, ins) {
		
		var f = false;
		
		// set range
		if (from != null && to != null) {
			
			if (!(from instanceof Date)) from = this._strToDate(from);
			if (!(to instanceof Date)) to = this._strToDate(to);
			
			if (from.getTime() > to.getTime()) return;
			
			this._rangeFrom = new Date(from.getFullYear(),from.getMonth(),from.getDate(),0,0,0,0).getTime();
			this._rangeTo = new Date(to.getFullYear(),to.getMonth(),to.getDate(),0,0,0,0).getTime();
			this._rangeActive = true;
			this._rangeType = "in";
			
			f = true;
		}
		
		// set range "from date"
		if (!f && from != null && to == null) {
			
			if (!(from instanceof Date)) from = this._strToDate(from);
			this._rangeFrom = new Date(from.getFullYear(),from.getMonth(),from.getDate(),0,0,0,0).getTime();
			this._rangeTo = null;
			
			if (ins === true) this._rangeFrom++;
			
			this._rangeActive = true;
			this._rangeType = "from";
			
			f = true;
			
		}
		
		// set range "to date"
		if (!f && from == null && to != null) {
			
			if (!(to instanceof Date)) to = this._strToDate(to);
			this._rangeFrom = null;
			this._rangeTo = new Date(to.getFullYear(),to.getMonth(),to.getDate(),0,0,0,0).getTime();
			
			if (ins === true) this._rangeTo--;
			
			this._rangeActive = true;
			this._rangeType = "to";
			
			f = true;
			
		}
		
		if (f) this._drawMonth(this._activeMonth);
	}
	
	this.setInsensitiveRange = function(from, to) {
		
		if (from != null && to != null) {
			
			if (!(from instanceof Date)) from = this._strToDate(from);
			if (!(to instanceof Date)) to = this._strToDate(to);
			
			if (from.getTime() > to.getTime()) return;
			
			this._rangeFrom = new Date(from.getFullYear(),from.getMonth(),from.getDate(),0,0,0,0).getTime();
			this._rangeTo = new Date(to.getFullYear(),to.getMonth(),to.getDate(),0,0,0,0).getTime();
			this._rangeActive = true;
			this._rangeType = "out";
			
			this._drawMonth(this._activeMonth);
			return;
		}
		
		if (from != null && to == null) {
			this.setSensitiveRange(null, from, true);
			return;
		}
		
		if (from == null && to != null) {
			this.setSensitiveRange(to, null, true);
			return;
		}
		
	}
	
	//
	this.disableDays = function(mode, d) {
		
		if (mode == "week") {
			
			// !! works in replace mode
			
			if (typeof(d) != "object" && typeof(d.length) == "undefined") d = [d];
			
			if (!this._rangeWeekData) this._rangeWeekData = {};
			for (var a in this._rangeWeekData) {
				this._rangeWeekData[a] = false;
				delete this._rangeWeekData[a];
			}
			
			for (var q=0; q<d.length; q++) {
				this._rangeWeekData[d[q]] = true;
				if (d[q] == 7) this._rangeWeekData[0] = true;
			}
			this._rangeWeek = true;
		}
		
		if (mode == "month") {
			
			// !! works in replace mode
			
			if (typeof(d) != "object" && typeof(d.length) == "undefined") d = [d];
			
			if (!this._rangeMonthData) this._rangeMonthData = {};
			for (var a in this._rangeMonthData) {
				this._rangeMonthData[a] = false;
				delete this._rangeMonthData[a];
			}
			for (var q=0; q<d.length; q++) this._rangeMonthData[d[q]] = true;
			
			this._rangeMonth = true;
		}
		
		if (mode == "year") {
			
			// !! works in replace mode
			
			var t = this._extractDates(d);
			
			if (!this._rangeYearData) this._rangeYearData = {};
			for (var a in this._rangeYearData) {
				this._rangeYearData[a] = false;
				delete this._rangeYearData[a];
			}
			for (var q=0; q<t.length; q++) this._rangeYearData[t[q].getMonth()+"_"+t[q].getDate()] = true;
			
			this._rangeYear = true;
		}
		
		this._drawMonth(this._activeMonth);
	}
	
	this.enableDays = function(mode) {
		
		if (mode == "week") {
			this._rangeWeek = false;
		}
		
		if (mode == "month") {
			this._rangeMonth = false;
		}
		
		if (mode == "year") {
			this._rangeYear = false;
		}
		
		this._drawMonth(this._activeMonth);
	}
	
	
	/* tooltips */
	
	this._tipData = {};
	this._tipTM = null;
	this._tipTMTime = 400;
	this._tipEvs = false;
	this._tipPopup = null;
	this._tipCellDate = null;
	this._tipCellDim = null;
	
	this.setTooltip = function(dateX, text, showIcon, usePopup) {
		
		var t = this._extractDates(dateX);
		for (var q=0; q<t.length; q++) {
			var k = new Date(t[q].getFullYear(),t[q].getMonth(),t[q].getDate(),0,0,0,0).getTime();
			this._tipData[k] = { text: text, showIcon: showIcon, usePopup: usePopup };
		}
		this._drawMonth(this._activeMonth);
	}
	
	this.clearTooltip = function(dateX) {
		
		var t = this._extractDates(dateX);
		for (var q=0; q<t.length; q++) {
			var k = new Date(t[q].getFullYear(),t[q].getMonth(),t[q].getDate(),0,0,0,0).getTime();
			this._tipData[k] = null;
			delete this._tipData[k];
		}
		this._drawMonth(this._activeMonth);
	}
	
	this._initTooltipPopup = function() {
		
		if (this._tipEvs) return;
		
		this.attachEvent("onMouseOver", function(d){
			var k = new Date(d.getFullYear(),d.getMonth(),d.getDate(),0,0,0,0).getTime();
			if (this._tipData[k] != null) {
				if (this._tipTM) window.clearTimeout(this._tipTM);
				this._tipCellDate = d;
				this._tipCellDim = this.getCellDimension(d);
				this._tipText = this._tipData[k].text;
				this._tipTM = window.setTimeout(this._showTooltipPopup,this._tipTMTime);
			}
		});
		
		this.attachEvent("onMouseOut", this._hideTooltipPopup);
		
		this._tipEvs = true;
	}
	this._showTooltipPopup = function(text,x,y,w,h) {
		if (!that._tipPopup) that._tipPopup = new dhtmlXPopup({mode:"top"});
		that._tipPopup.attachHTML(that._tipText);
		that._tipPopup.show(that._tipCellDim.x, that._tipCellDim.y, that._tipCellDim.w, that._tipCellDim.h);
		that.callEvent("onPopupShow",[that._tipCellDate]);
	}
	
	this._hideTooltipPopup = function() {
		if (this._tipTM) window.clearTimeout(this._tipTM);
		if (this._tipPopup != null && this._tipPopup.isVisible()) {
			this._tipPopup.hide();
			this.callEvent("onPopupHide",[this._tipCellDate]);
		}
	}
	
	this.getPopup = function() {
		return this._tipPopup;
	}
	
	this.getCellDimension = function(dateX) {
		
		if (typeof(dateX) == "string") dateX = this._strToDate(dateX);
		if (!(dateX instanceof Date)) return null;
		
		var t = new Date(dateX.getFullYear(),dateX.getMonth(),dateX.getDate(),0,0,0,0).getTime();
		
		var k = null;
		
		for (var q=0; q<this.contDates.childNodes.length; q++) {
			for (var w=0; w<this.contDates.childNodes[q].childNodes.length; w++) {
				var p = this.contDates.childNodes[q].childNodes[w];
				if (p._date != null && p._date.getTime() == t) k = { x: this._getLeft(p), y: this._getTop(p), w: p.offsetWidth, h: p.offsetHeight };
				p = null;
			}
		}
		
		return k;
	}
	
	/* other */
	this._updateFromInput = function(t) {
		if (this._nullInInput && ((t.value).replace(/\s/g,"")).length == 0) {
			if (this.checkEvent("onBeforeChange")) {
				if (!this.callEvent("onBeforeChange",[null])) {
					// revert value
					if (this.i != null && this._activeInp != null && this.i[this._activeInp] != null && this.i[this._activeInp].input != null) {
						this.i[this._activeInp].input.value = this.getFormatedDate();
					}
					return;
				}
			}
			this.setDate(null);
		} else {
			this._updateDateStr(t.value);
		}
		t = null;
	}
	
	// global events
	this._doOnClick = function(e) {
		e = e||event;
		var t = (e.target||e.srcElement);
		// completely close alien calendar (both selector and container) inly if any assigned input clicked
		// otherwise hide selector and container separately
		if (t._dhtmlxcalendar_uid && t._dhtmlxcalendar_uid != that._activeInp && that._isVisible()&&that._activeInp) {
			that._hide();
			return;
		}
		if (!t._dhtmlxcalendar_uid || !that.i[t._dhtmlxcalendar_uid]) { // !that.i[t._dhtmlxcalendar_uid] means alien input, for several calendar instances
			if (that._isSelectorVisible()) that._hideSelector(); else if (!that._hasParent && that._isVisible()) that._hide();
		}
	}
	
	this._doOnKeyDown = function(e) {
		e = e||event;
		if (e.keyCode == 27 || e.keyCode == 13) {
			if (that._isSelectorVisible()) that._hideSelector(); else if (that._isVisible() && !that._hasParent) that._hide();
		}
	}
	
	// inputs events
	this._doOnInpClick = function(e) {
		e = e||event;
		var t = (e.target||e.srcElement);
		if (!t._dhtmlxcalendar_uid) return;
		if (!that._listenerEnabled) {
			that._updateFromInput(t);
		}
		that._show(t._dhtmlxcalendar_uid, true);
	}
	
	this._doOnInpKeyUp = function(e) {
		e = e||event;
		var t = (e.target||e.srcElement);
		if (e.keyCode == 13 || !t._dhtmlxcalendar_uid) return;  // do nothing on esc key
		// otherwise try to update calendar's date
		if (!that._listenerEnabled) that._updateFromInput(t);
	}
	
	this._doOnBtnClick = function(e) {
		e = e||event;
		var t = (e.target||e.srcElement);
		if (!t._dhtmlxcalendar_uid) return;
		if (that.i[t._dhtmlxcalendar_uid].input != null) that._updateFromInput(that.i[t._dhtmlxcalendar_uid].input);
		that._show(t._dhtmlxcalendar_uid, true);
	}
	
	this._doOnUnload = function() {
		if (that && that.unload) that.unload();
	}
	
	if (window.addEventListener) {
		document.body.addEventListener("click", that._doOnClick, false);
		window.addEventListener("keydown", that._doOnKeyDown, false);
		window.addEventListener("unload", that._doOnUnload, false);
	} else {
		document.body.attachEvent("onclick", that._doOnClick);
		document.body.attachEvent("onkeydown", that._doOnKeyDown);
		window.attachEvent("onunload", that._doOnUnload);
	}
	
	this.attachObj = function(obj) {
		if (typeof(obj) == "string") obj = document.getElementById(obj);
		var a = this.uid();
		this.i[a] = obj;
		this._attachEventsToObject(a);
	}
	
	this.detachObj = function(obj) {
		if (typeof(obj) == "string") obj = document.getElementById(obj);
		var a = obj._dhtmlxcalendar_uid;
		if (this.i[a] != null) {
			this._detachEventsFromObject(a);
			this.i[a]._dhtmlxcalendar_uid = null;
			this.i[a] = null;
			delete this.i[a];
		}
	}
	
	this._attachEventsToObject = function(a) {
		if (this.i[a].button != null) {
			this.i[a].button._dhtmlxcalendar_uid = a;
			if (window.addEventListener) {
				this.i[a].button.addEventListener("click", that._doOnBtnClick, false);
			} else {
				this.i[a].button.attachEvent("onclick", that._doOnBtnClick);
			}
		} else if (this.i[a].input != null) {
			this.i[a].input._dhtmlxcalendar_uid = a;
			if (window.addEventListener) {
				this.i[a].input.addEventListener("click", that._doOnInpClick, false);
				this.i[a].input.addEventListener("keyup", that._doOnInpKeyUp, false);
			} else {
				this.i[a].input.attachEvent("onclick", that._doOnInpClick);
				this.i[a].input.attachEvent("onkeyup", that._doOnInpKeyUp);
			}
		}
	}
	
	// listener
	this.enableListener = function(t) {
		if (!t) return;
		if (window.addEventListener) {
			t.addEventListener("focus", that._listenerEvFocus, false);
			t.addEventListener("blur", that._listenerEvBlur, false);
		} else {
			t.attachEvent("onfocus", that._listenerEvFocus);
			t.attachEvent("onblur", that._listenerEvBlur);
		}
		t = null;
	}
	
	this.disableListener = function(t) {
		if (!t) return;
		t._f0 = false;
		if (this._tmListener) window.clearTimeout(this._tmListener);
		if (window.addEventListener) {
			t.removeEventListener("focus", that._listenerEvFocus, false);
			t.removeEventListener("blur", that._listenerEvBlur, false);
		} else {
			t.detachEvent("onfocus", that._listenerEvFocus);
			t.detachEvent("onblur", that._listenerEvBlur);
		}
		t = null;
	}
	
	this._startListener = function(t) {
		if (this._tmListener) window.clearTimeout(this._tmListener);
		if (typeof(t._v1) == "undefined") t._v1 = t.value;
		if (t._v1 != t.value) {
			this._updateFromInput(t);
			t._v1 = t.value;
		}
		if (t._f0) this._tmListener = window.setTimeout(function(){that._startListener(t);},100);
	}
	
	this._listenerEvFocus = function(e) {
		e = e||event;
		var t = e.target||e.srcElement;
		t._f0 = true;
		that._startListener(t)
		t = null;
	}
	this._listenerEvBlur = function(e) {
		e = e||event;
		var t = e.target||e.srcElement;
		t._f0 = false;
		t = null;
	}
	
	
	//
	this._detachEventsFromObject = function(a) {
		if (this.i[a].button != null) {
			if (window.addEventListener) {
				this.i[a].button.removeEventListener("click", that._doOnBtnClick, false);
			} else {
				this.i[a].button.detachEvent("onclick", that._doOnBtnClick);
			}
		} else if (this.i[a].input != null) {
			if (window.addEventListener) {
				this.i[a].input.removeEventListener("click", that._doOnInpClick, false);
				this.i[a].input.removeEventListener("keyup", that._doOnInpKeyUp, false);
			} else {
				this.i[a].input.detachEvent("onclick", that._doOnInpClick);
				this.i[a].input.detachEvent("onkeyup", that._doOnInpKeyUp);
			}
		}
	}
	
	for (var a in this.i) this._attachEventsToObject(a);
	
	/* internal events */
	
	this.evs = {};
	this.attachEvent = function(name, func) {
		var eId = this.uid();
		this.evs[eId] = {name: String(name).toLowerCase(), func: func};
		return eId;
	}
	this.detachEvent = function(id) {
		if (this.evs[id]) {
			this.evs[id].name = null;
			this.evs[id].func = null;
			this.evs[id] = null;
			delete this.evs[id];
		}
	}
	this.callEvent = function(name, params) {
		var u = true;
		var n = String(name).toLowerCase();
		params = (params||[]);
		for (var a in this.evs) {
			if (this.evs[a].name == n) {
				var r = this.evs[a].func.apply(this,params);
				u = (u && r);
			}
		}
		return u;
	}
	this.checkEvent = function(name) {
		var u = false;
		var n = String(name).toLowerCase();
		for (var a in this.evs) u = (u || this.evs[a].name == n);
		return u;
	}
	
	/* unload */
	
	this.unload = function() {
		
		this._activeDate = null;
		this._activeDateCell = null;
		this._activeInp = null;
		this._activeMonth = null;
		this._dateFormat = null;
		this._dateFormatRE = null;
		this._lastHover = null;
		
		this.uid = null;
		this.uidd = null;
		
		if (this._tmListener) window.clearTimeout(this._tmListener);
		this._tmListener = null;
		
		/* main events */
		
		if (window.addEventListener) {
			document.body.removeEventListener("click", that._doOnClick, false);
			window.removeEventListener("keydown", that._doOnKeyDown, false);
			window.removeEventListener("unload", that._doOnUnload, false);
		} else {
			document.body.detachEvent("onclick", that._doOnClick);
			document.body.detachEvent("onkeydown", that._doOnKeyDown);
			window.detachEvent("onunload", that._doOnKeyDown);
		}
		
		this._doOnClick = null;
		this._doOnKeyDown = null;
		this._doOnUnload = null;
		
		/* assigned inputs */
		
		for (var a in this.i) {
			// marker
			this.i[a]._dhtmlxcalendar_uid = null;
			
			// events
			this._detachEventsFromObject(a);
			this.disableListener(this.i[a].input);
			
			this.i[a] = null;
			delete this.i[a];
			
		}
		
		this.i = null;
		
		this._doOnInpClick = null;
		this._doOnInpKeyUp = null;
		
		/* obj events */
		
		for (var a in this.evs) this.detachEvent(a);
		this.evs = null;
		
		this.attachEvent = null;
		this.detachEvent = null;
		this.checkEvent = null;
		this.callEvent = null;
		
		/* months */
		
		this.contMonth.onselectstart = null;
		
		// li
		this.contMonth.firstChild.firstChild.onclick = null;
		
		// arrows
		this.contMonth.firstChild.firstChild.firstChild.onmouseover = null;
		this.contMonth.firstChild.firstChild.firstChild.onmouseout = null;
		this.contMonth.firstChild.firstChild.lastChild.onmouseover = null;
		this.contMonth.firstChild.firstChild.lastChild.onmouseout = null;
		
		while (this.contMonth.firstChild.firstChild.childNodes.length > 0) this.contMonth.firstChild.firstChild.removeChild(this.contMonth.firstChild.firstChild.lastChild);
		
		// li
		this.contMonth.firstChild.removeChild(this.contMonth.firstChild.firstChild);
		
		// ul
		this.contMonth.removeChild(this.contMonth.firstChild);
		
		// div
		this.contMonth.parentNode.removeChild(this.contMonth);
		this.contMonth = null;
		
		/* days */
		
		// li
		while (this.contDays.firstChild.childNodes.length > 0) this.contDays.firstChild.removeChild(this.contDays.firstChild.lastChild);
		
		// ul
		this.contDays.removeChild(this.contDays.firstChild);
		
		// div
		this.contDays.parentNode.removeChild(this.contDays);
		this.contDays = null;
		
		/* dates */
		
		this.contDates.onclick = null;
		this.contDates.onmouseover = null;
		this.contDates.onmouseout = null;
		
		while (this.contDates.childNodes.length > 0) {
			while (this.contDates.lastChild.childNodes.length > 0) {
				// li
				this.contDates.lastChild.lastChild._css_date = null;
				this.contDates.lastChild.lastChild._css_month = null;
				this.contDates.lastChild.lastChild._css_weekend = null;
				this.contDates.lastChild.lastChild._css_hover = null;
				this.contDates.lastChild.lastChild._date = null;
				this.contDates.lastChild.lastChild._q = null;
				this.contDates.lastChild.lastChild._w = null;
				this.contDates.lastChild.removeChild(this.contDates.lastChild.lastChild);
			}
			// ul
			this.contDates.removeChild(this.contDates.lastChild);
		}
		
		// div
		this.contDates.parentNode.removeChild(this.contDates);
		this.contDates = null;
		
		/* time */
		
		this.contTime.firstChild.firstChild.onclick = null;
		
		// labels
		while (this.contTime.firstChild.firstChild.childNodes.length > 0) this.contTime.firstChild.firstChild.removeChild(this.contTime.firstChild.firstChild.lastChild);
		
		// li
		this.contTime.firstChild.removeChild(this.contTime.firstChild.firstChild);
		
		// ul
		this.contTime.removeChild(this.contTime.firstChild);
		
		// div
		this.contTime.parentNode.removeChild(this.contTime);
		this.contTime = null;
		
		
		this._lastHover = null;
		
		/* selector */
		
		this._unloadSelector("month");
		this._unloadSelector("year");
		this._unloadSelector("hours");
		this._unloadSelector("minutes");
		
		// selector cover
		if (this._selCover) {
			this._selCover.parentNode.removeChild(this._selCover);
			this._selCover = null;
		}
		
		// selector object
		if (this._sel) {
			
			for (var a in this._sel._ta) this._sel._ta[a] = null;
			this._sel._ta = null;
			this._sel._t = null;
			
			this._sel.onmouseover = null;
			this._sel.onmouseout = null;
			
			// td
			while (this._sel.firstChild.firstChild.firstChild.childNodes.length > 0) {
				this._sel.firstChild.firstChild.firstChild.lastChild.onclick = null;
				this._sel.firstChild.firstChild.firstChild.lastChild.onmouseover = null;
				this._sel.firstChild.firstChild.firstChild.lastChild.onmouseout = null;
				this._sel.firstChild.firstChild.firstChild.removeChild(this._sel.firstChild.firstChild.firstChild.lastChild);
			}
			
			// tr
			this._sel.firstChild.firstChild.removeChild(this._sel.firstChild.firstChild.firstChild);
			
			// tbody
			this._sel.firstChild.removeChild(this._sel.firstChild.firstChild);
			
			// table and arrow div
			while (this._sel.childNodes.length > 0) this._sel.removeChild(this._sel.lastChild);
			
			// object
			this._sel.parentNode.removeChild(this._sel);
			this._sel = null;
		}
		
		
		/* base */
		
		this.base.onclick = null;
		this.base.onmouseout = null;
		this.base.parentNode.removeChild(this.base);
		this.base = null;
		
		/* methods */
		
		this._clearDayHover = null;
		this._clearSelHover = null;
		this._doOnSelectorChange = null;
		this._doOnSelectorShow = null;
		this._drawMonth = null;
		this._fixLength = null;
		this._getLeft = null;
		this._getTop = null;
		this._ifrSize = null;
		this._hide = null;
		this._hideSelector = null;
		this._initSelector = null;
		this._isSelectorVisible = null;
		this._isVisible = null;
		this._posGetOffset = null;
		this._posGetOffsetRect = null;
		this._posGetOffsetSum = null;
		this._scrollYears = null;
		this._show = null;
		this._showSelector = null;
		this._strToDate = null;
		this._updateActiveHours = null;
		this._updateActiveMinutes = null;
		this._updateActiveMonth = null;
		this._updateActiveYear = null;
		this._updateCellStyle = null;
		this._updateDateStr = null;
		this._updateVisibleHours = null;
		this._updateVisibleMinutes = null;
		this._updateYearsList = null;
		this.enableIframe = null;
		this.hide = null;
		this.hideTime = null;
		this.setDate = null;
		this.setDateFormat = null;
		this.setYearsRange = null;
		this.show = null;
		this.showTime = null;
		this.unload = null;
		
		/* popup */
		if (this._tipPopup != null) {
			this._tipPopup.unload();
			this._tipPopup = null;
		}
		
		for (var a in this) delete this[a];
		
		a = that = null;
		
	}
	
	
	// set init date
	this.setDate(this._activeDate);
	
	return this;
};

dhtmlXCalendarObject.prototype.setYearsRange = function(){}; // deprecated

dhtmlXCalendarObject.prototype.lang = "en";
dhtmlXCalendarObject.prototype.langData = {
	"en": {
		dateformat: "%Y-%m-%d",
		monthesFNames: ["January","February","March","April","May","June","July","August","September","October","November","December"],
		monthesSNames: ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],
		daysFNames: ["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],
		daysSNames: ["Su","Mo","Tu","We","Th","Fr","Sa"],
		weekstart: 1,
		weekname: "w"
	}
};

dhtmlXCalendarObject.prototype.enableIframe = function(mode) {
	if (mode == true) {
		if (!this._ifr) {
			this._ifr = document.createElement("IFRAME");
			this._ifr.frameBorder = 0;
			this._ifr.border = 0;
			this._ifr.setAttribute("src","javascript:false;");
			this._ifr.className = "dhtmlxcalendar_ifr";
			this._ifr.onload = function(){
				this.onload = null;
				this.contentWindow.document.open("text/html", "replace");
				this.contentWindow.document.write("<html><head><style>html,body{width:100%;height:100%;overflow:hidden;margin:0px;}</style></head><body</body></html>");
			}
			this.base.parentNode.insertBefore(this._ifr, this.base);
			this._ifrSize();
		}
	} else {
		if (this._ifr) {
			this._ifr.parentNode.removeChild(this._ifr);
			this._ifr = null;
		}
	}
};

dhtmlXCalendarObject.prototype._ifrSize = function() {
	if (this._ifr) {
		this._ifr.style.left = this.base.style.left;
		this._ifr.style.top = this.base.style.top;
		this._ifr.style.width = this.base.offsetWidth+"px";
		this._ifr.style.height = this.base.offsetHeight+"px";
	}
};

dhtmlxCalendarObject = dhtmlXCalendarObject;

//v.3.6 build 131108

/*
Copyright DHTMLX LTD. http://www.dhtmlx.com
To use this component please contact sales@dhtmlx.com to obtain license
*/

/*_TOPICS_
@0:Initialization
@1:Selection control
@2:Add/delete
@3:Reserved
@4:Methods of Option object
*/

/**
*  Build combobox from existing select control.
*
*
*  @param   parent      {string} id of existing select control
*  @param   size      {int } size of control, optional
*  @return            {object} combobox object
*  @type   public
*  @topic   0
*
*/

function dhtmlXComboFromSelect(parent,size){
   if (typeof(parent)=="string")
      parent=document.getElementById(parent);
   
   
   size=size||parent.getAttribute("width")||(window.getComputedStyle?window.getComputedStyle(parent,null)["width"]:(parent.currentStyle?parent.currentStyle["width"]:0));
   if ((!size)||(size=="auto")||size.indexOf("em")!=-1)
   		size=parent.offsetWidth||100;

   var z=document.createElement("SPAN");
   
	
  
   parent.parentNode.insertBefore(z,parent);
   parent.style.display='none';

    var s_type = parent.getAttribute('opt_type');
	
   var w= new dhtmlXCombo(z,parent.name,size,s_type,parent.tabIndex);
   
   var x=new Array();
   var sel=-1;
   for (var i=0; i<parent.options.length; i++){
      if (parent.options[i].selected) sel=i;
      var label=parent.options[i].innerHTML;
      var val=parent.options[i].getAttribute("value");
      if ((typeof(val)=="undefined")||(val===null)) val=label;
      x[i]={value:val,text:label,img_src:parent.options[i].getAttribute("img_src")};
   }
    if(x.length)
    w.addOption(x);
   
   
	parent.parentNode.removeChild(parent);
	if (sel>=0){
		w._skipFocus = true;
		w.selectOption(sel,null,true);
	}
	if (parent.onchange) 
		w.attachEvent("onChange",parent.onchange);
   		
   	if(parent.style.direction=="rtl" && w.setRTL) 
   		w.setRTL(true);
   	
   return w;
}

var dhtmlXCombo_optionTypes = [];
/**
*     @desc: build combobox
*     @param: parent - (string) id of existing object which will be used as container
*     @param: name - (string) name of combobox - will be used in FORM
*     @param: width - (int) size of combobox
*     @param: tabIndex - (int) tab index, optional
*     @type: public
*     @topic: 0
*/
function dhtmlXCombo(parent,name,width,optionType,tabIndex){
      if (typeof(parent)=="string")
         parent=document.getElementById(parent);

      this.dhx_Event();
      this.optionType = (optionType != window.undefined && dhtmlXCombo_optionTypes[optionType]) ? optionType : 'default';
      this._optionObject = dhtmlXCombo_optionTypes[this.optionType];

      this._disabled = false;
	  this.readonlyDelay = 750;
      this.filterEntities = ["[","]","{","}","(",")","+","*","\\","?",".","$","^"];
	  if (!window.dhx_glbSelectAr){
          window.dhx_glbSelectAr=new Array();
          window.dhx_openedSelect=null;
          window.dhx_SelectId=1;
          dhtmlxEvent(document.body,"click",this.closeAll);
          dhtmlxEvent(document.body,"keydown",function(e){ try { if ((e||event).keyCode==9)  window.dhx_glbSelectAr[0].closeAll(); } catch(e) {} return true; } );
      }
		
     if (parent.tagName=="SELECT")
         return dhtmlXComboFromSelect(parent);
      else
         this._createSelf(parent,name,width,tabIndex);
      dhx_glbSelectAr.push(this);
}

/**
*     @desc: change control size
*     @param: new_size - (int) new size value
*     @type: public
*     @topic: 0
*/
   dhtmlXCombo.prototype.setSize = function(new_size){
      this.DOMlist.style.width=new_size+"px";
      if (this.DOMlistF) this.DOMlistF.style.width=new_size+"px";
      this.DOMelem.style.width=new_size+"px";
      this.DOMelem_input.style.width = Math.max(0,(new_size-19))+'px';
   }      
/**
*     @desc: switch between combobox and auto-filter modes
*     @param: mode - (boolean) enable filtering mode
*     @param: url - (string) url for filtering from XML, optional
*     @param: cache - (boolean) XML caching, optional
*     @param: autosubload - (boolean) enable auto load additional suggestions on selecting last loaded option
*     @type: public
*     @topic: 0
*/
   dhtmlXCombo.prototype.enableFilteringMode = function(mode,url,cache,autosubload){
      if(mode=="between"){
          this._filter= true;
          this._anyPosition = true;
          this._autoDisabled = true;
      }
      else
        this._filter=convertStringToBoolean(mode);

      if (url){
         this._xml=url;
         this._autoxml=convertStringToBoolean(autosubload);
      }
      if (convertStringToBoolean(cache)) this._xmlCache=[];
      //this.DOMelem_button.style.display=(this._filter?"none":"");
   }
   
   dhtmlXCombo.prototype.setFilteringParam=function(name,value){
   		if (!this._prs) this._prs=[];
   		this._prs.push([name,value]);
   }
/**
*     @desc: disable combobox
*     @param: mode - (boolean) disable combobox
*     @type: public
*     @topic: 1
*/
   dhtmlXCombo.prototype.disable = function(mode){
      var z=convertStringToBoolean(mode);
      if (this._disabled==z) return;
      this.DOMelem_input.disabled=z;
      this._disabled=z;
   }
/**
*     @desc: switch to readonly mode
*     @param: mode - (boolean) readonly mode
*     @param: autosearch - (boolean) true by default 
*     @type: public
*     @topic: 1
*/
   dhtmlXCombo.prototype.readonly = function(mode,autosearch){
        this.DOMelem_input.readOnly=mode ? true : false;
		if(autosearch===false || mode===false){
			this.DOMelem.onkeyup=function(ev){ }
		} else {
			var that = this;
			this.DOMelem.onkeyup=function(ev){ 
				ev=ev||window.event;
                if(that._searchTimeout)
                    window.clearTimeout(that._searchTimeout);
				if (ev.keyCode!=9) ev.cancelBubble=true;
				if((ev.keyCode >= 48 && ev.keyCode <= 57)||(ev.keyCode >= 65 && ev.keyCode <= 90)){
                    if (!that._searchText)
                        that._searchText="";
                    that._searchText += String.fromCharCode(ev.keyCode);
					for(var i=0; i<that.optionsArr.length; i++){
						var text = that.optionsArr[i].text;
						if(text.toString().toUpperCase().indexOf(that._searchText) == 0){
								that.selectOption(i);
								break;
						}
					}
                    that._searchTimeout=window.setTimeout(function() {that._searchText="";}, that.readonlyDelay);
					ev.cancelBubble=true;
				}
			}
		}
	}	
   
/**
*     @desc: get Option by value
*     @param: value - (string) value of option in question
*     @type: public
*     @return: option object
*     @topic: 2
*/
   dhtmlXCombo.prototype.getOption = function(value)
   {
      for(var i=0; i<this.optionsArr.length; i++)
         if(this.optionsArr[i].value==value)
            return this.optionsArr[i];
      return null;
   }
/**
*     @desc: get Option by label
*     @param: label - (string) label of option in question
*     @type: public
*     @return: option object
*     @topic: 2
*/
   dhtmlXCombo.prototype.getOptionByLabel = function(value)
   {
	  //value=value.replace(/&/g,"&amp;")
      for(var i=0; i<this.optionsArr.length; i++)
         if(this.optionsArr[i].text==value || this.optionsArr[i]._ctext==value)
            return this.optionsArr[i];
      return null;
   }
/**
*     @desc: get Option by index
*     @param: ind - (int) index of option in question
*     @type: public
*     @return: option object
*     @topic: 2
*/
   dhtmlXCombo.prototype.getOptionByIndex = function(ind){
      return this.optionsArr[ind];
   }
/**
*     @desc: clear all options from combobox
*     @type: public
*     @param: value - (bool) clear current value as well
*     @topic: 2
*/
   dhtmlXCombo.prototype.clearAll = function(all)
   {
		if (all) this.setComboText("");
        this.optionsArr=new Array();
        this.redrawOptions();
        if (all){
            if(this._selOption)
                this._selOption.RedrawHeader(this,true);
            this._confirmSelection();
        }
   }
/**
*     @desc: delete option by value
*     @param: value - (string) value of option in question
*     @type: public
*     @topic: 2
*/
   dhtmlXCombo.prototype.deleteOption = function(value)
   {
        var ind=this.getIndexByValue(value);
      if(ind<0) return;                            
      if (this.optionsArr[ind]==this._selOption) this._selOption=null;
      this.optionsArr.splice(ind, 1);
      this.redrawOptions();
   }

/**
*     @desc: enable/disable immideatly rendering after changes in combobox
*     @param: mode - (boolean) enable/disable
*     @type: private
*     @topic: 1
*/
   dhtmlXCombo.prototype.render=function(mode){
      this._skiprender=(!convertStringToBoolean(mode));
      this.redrawOptions();
   }

/**
*     @desc: update option in combobox
*     @param: oldvalue - (string) index of option in question
*     @param: avalue - (variable)
*     @type: public
*     @topic: 2
*/
   dhtmlXCombo.prototype.updateOption = function(oldvalue, avalue, atext, acss)
   {
      var dOpt=this.getOption(oldvalue);
      if (typeof(avalue)!="object") avalue={text:atext,value:avalue,css:acss};
      dOpt.setValue(avalue);
        this.redrawOptions();
   }
/**
*     @desc: add new option
*     @param: value - (variable) - different input for different kinds of options - please refer to examples
*     @type: public
*     @topic: 2
*/
   dhtmlXCombo.prototype.addOption = function(options)
   {
      if (!arguments[0].length || typeof(arguments[0])!="object")
         args = [arguments];
      else
         args = options;

      this.render(false);
        for (var i=0; i<args.length; i++) {
            var attr = args[i];
         if (attr.length){
               attr.value = attr[0]||"";
               attr.text = attr[1]||"";
               attr.css = attr[2]||"";
         }
            this._addOption(attr);
        }
      this.render(true);
   }

   dhtmlXCombo.prototype._addOption = function(attr)
   {
         dOpt = new this._optionObject();
         this.optionsArr.push(dOpt);
         dOpt.setValue.apply(dOpt,[attr]);
         this.redrawOptions();
   }


/**
*     @desc: return index of item by value
*     @param: value - (string) value of option in question
*     @type: public
*     @return: option index
*     @topic: 2
*/
   dhtmlXCombo.prototype.getIndexByValue = function(val){
      for(var i=0; i<this.optionsArr.length; i++)
         if(this.optionsArr[i].value == val) return i;
      return -1;
   }
/**
*     @desc: get value of selected item
*     @type: public
*     @return: option value
*     @topic: 2 
*/
   dhtmlXCombo.prototype.getSelectedValue = function(){
      return (this._selOption?this._selOption.value:null);
   }
/**
*     @desc: get current text in combobox
*     @type: public
*     @return: combobox text
*     @topic: 2
*/
   dhtmlXCombo.prototype.getComboText = function(){
      return this.DOMelem_input.value;
   }
/**
*     @desc: set text in covmbobox
*     @param: text - (string) new text label
*     @type: public
*     @topic: 2
*/
   dhtmlXCombo.prototype.setComboText = function(text){
      this.DOMelem_input.value=text;
   }
   
/**
*     @desc: set text in covmbobox
*     @param: text - (string) new text label
*     @type: public
*     @topic: 2
*/
   dhtmlXCombo.prototype.setComboValue = function(text){
      this.setComboText(text);
	  for(var i=0; i<this.optionsArr.length; i++)
         if (this.optionsArr[i].data()[0]==text){
	         this._skipFocus = true;
	         return this.selectOption(i,null,true);
         }
      this.DOMelem_hidden_input.value=text;
   }

/**
*     @desc: get value which will be sent with form
*     @type: public
*     @return: combobox value
*     @topic: 2
*/
   dhtmlXCombo.prototype.getActualValue = function(){
      return this.DOMelem_hidden_input.value;
   }
/**
*     @desc: get text of selected option
*     @type: public
*     @return: text of option
*     @topic: 2
*/
   dhtmlXCombo.prototype.getSelectedText = function(){
      return (this._selOption?this._selOption.text:"");
   }
/**
*     @desc: get index of selected option
*     @type: public
*     @return: option index
*     @topic: 2
*/
   dhtmlXCombo.prototype.getSelectedIndex = function(){
      for(var i=0; i<this.optionsArr.length; i++)
         if(this.optionsArr[i] == this._selOption) return i;
      return -1;
   }
/**
*     @desc: set name used while form submit
*     @param: name - (string) new combobox name
*     @type: public
*     @topic: 2
*/
   dhtmlXCombo.prototype.setName = function(name){  
        this.DOMelem_hidden_input.name = name;
        this.DOMelem_hidden_input2 = name.replace(/(\]?)$/, "_new_value$1");

        this.name = name;
   }
/**
*     @desc: show combox ( reversion to hide command )
*     @param: mode - (boolean) enable/disable
*     @type: public
*     @topic: 1
*/
   dhtmlXCombo.prototype.show = function(mode){
      if (convertStringToBoolean(mode))
         this.DOMelem.style.display = "";
      else
         this.DOMelem.style.display = "none";
   }

/**
*     @desc: destroy object and any related HTML elements
*     @type: public
*     @topic: 0
*/
   dhtmlXCombo.prototype.destructor = function()
   {
      this.DOMParent.removeChild(this.DOMelem);
      this.DOMlist.parentNode.removeChild(this.DOMlist);
      if(this.DOMlistF)
      this.DOMlistF.parentNode.removeChild(this.DOMlistF);
      var s=dhx_glbSelectAr;
      this.DOMParent=this.DOMlist=this.DOMlistF=this.DOMelem=0;
      this.DOMlist.combo=this.DOMelem.combo=0;
      for(var i=0; i<s.length; i++)
      {
         if(s[i] == this)
         {
            s[i] = null;
            s.splice(i,1);
            return;
         }
      }
   }

/**
*     @desc: create self HTML
*     @type: private
*     @topic: 0
*/
      dhtmlXCombo.prototype._createSelf = function(selParent, name, width, tab)
      {
         if (width.toString().indexOf("%")!=-1){ 
            var self = this;
            var resWidht=parseInt(width)/100;
            window.setInterval(function(){ 
               if (!selParent.parentNode) return;
               var ts=selParent.parentNode.offsetWidth*resWidht-2;
               if (ts<0) return;
               if (ts==self._lastTs) return;
               self.setSize(self._lastTs=ts);},500);
            var width=parseInt(selParent.offsetWidth); //mm
         }

         var width=parseInt(width||100); //mm
         this.ListPosition = "Bottom"; //set optionlist positioning
         this.DOMParent = selParent;
         this._inID = null;
         this.name = name;

         this._selOption = null; //selected option object pointer
         this.optionsArr = Array();

            var opt = new this._optionObject();
            opt.DrawHeader(this,name, width,tab);
         //HTML select part 2 - options list DIV element
         this.DOMlist = document.createElement("DIV");
         this.DOMlist.className = 'dhx_combo_list '+(dhtmlx.skin?dhtmlx.skin+"_list":"");
         this.DOMlist.style.width=width-(_isIE?0:0)+"px";
		 if (_isOpera || _isKHTML ) 
		 		this.DOMlist.style.overflow="auto";      
         this.DOMlist.style.display = "none";
         document.body.insertBefore(this.DOMlist,document.body.firstChild);         
         if (_isIE)    {
            this.DOMlistF = document.createElement("IFRAME");
            this.DOMlistF.style.border="0px";
            this.DOMlistF.className = 'dhx_combo_list';
            this.DOMlistF.style.width=width-(_isIE?0:0)+"px";
            this.DOMlistF.style.display = "none";
            this.DOMlistF.src="javascript:false;"; 
            document.body.insertBefore(this.DOMlistF,document.body.firstChild);
            }



         this.DOMlist.combo=this.DOMelem.combo=this;

         this.DOMelem_input.onkeydown = this._onKey;
          this.DOMelem_input.onkeypress = this._onKeyF;
         this.DOMelem_input.onblur = this._onBlur;
         this.DOMelem.onclick = this._toggleSelect;
         this.DOMlist.onclick = this._selectOption;
         this.DOMlist.onmousedown = function(){
         	this._skipBlur=true;
     	 }
         
         this.DOMlist.onkeydown = function(e){
         	//this.combo.DOMelem_input.focus();
         	(e||event).cancelBubble=true;
         	this.combo.DOMelem_input.onkeydown(e)
     	 }
		  this.DOMlist.onmouseover = this._listOver;
     	 
      }

      dhtmlXCombo.prototype._listOver = function(e)
      { 
         e = e||event;
         e.cancelBubble = true;
         var node = (_isIE?event.srcElement:e.target);
         var that = this.combo;
         if ( node.parentNode == that.DOMlist ) {
            if(that._selOption) that._selOption.deselect(); 
			if(that._tempSel) that._tempSel.deselect();
           
		    var i=0;
            for (i; i<that.DOMlist.childNodes.length; i++) {
               if (that.DOMlist.childNodes[i]==node) break;
            }
            var z=that.optionsArr[i];
           that._tempSel=z;
           that._tempSel.select();
        	  
			if ((that._autoxml)&&((i+1)==that._lastLength)){
				that._fetchOptions(i+1,that._lasttext||""); 
            }           
         }

      }

/**
*     @desc: place option list in necessary place on screen
*     @type: private
*     @topic: 0
*/
      dhtmlXCombo.prototype._positList = function()
      {
	  	//if(this.ListAutoPosit) this.enableOptionAutoPositioning(true); //mm auto posit
         var pos=this.getPosition(this.DOMelem);
         if(this.ListPosition == 'Bottom'){
            this.DOMlist.style.top = pos[1]+this.DOMelem.offsetHeight-1+"px";
            this.DOMlist.style.left = pos[0]+"px";
         }
         else if(this.ListPosition == 'Top'){ //mm
				this.DOMlist.style.top = pos[1] - this.DOMlist.offsetHeight+"px";
            	
				this.DOMlist.style.left = pos[0]+"px"; //mm
         }
		 else{
			this.DOMlist.style.top = pos[1]+"px";
            this.DOMlist.style.left = pos[0]+this.DOMelem.offsetWidth+"px";
         }
      }
	  
	dhtmlXCombo.prototype.getPosition = function(oNode,pNode){
		if (_isIE && _isIE<8){ 
			if(!pNode)
		        pNode = document.body;
			var oCurrentNode=oNode;
			var iLeft=0;
			var iTop=0;
			while ((oCurrentNode)&&(oCurrentNode!=pNode)){
				iLeft+=oCurrentNode.offsetLeft-oCurrentNode.scrollLeft+oCurrentNode.clientLeft;
				iTop+=oCurrentNode.offsetTop-oCurrentNode.scrollTop+oCurrentNode.clientTop;
				oCurrentNode=oCurrentNode.offsetParent;
			}

            if (document.documentElement.scrollTop){
                iTop+=document.documentElement.scrollTop;
            }
            if (document.documentElement.scrollLeft){
                iLeft+=document.documentElement.scrollLeft;
            }
			return new Array(iLeft,iTop);
		}
		var pos = getOffset(oNode);
        return [pos.left, pos.top];
        
	}
/**
*     @desc: correct current selection ( move it to first visible option )
*     @type: private
*     @topic: 2
*/
      dhtmlXCombo.prototype._correctSelection = function(){
		 if (this.getComboText()!="")
         for (var i=0; i<this.optionsArr.length; i++)
            if (!this.optionsArr[i].isHidden()){
               return this.selectOption(i,true,false);
           }
         this.unSelectOption();
      }
/**
*     @desc: select next option in combobox
*     @param: step - (int) step size
*     @type: private
*     @topic: 2
*/
      dhtmlXCombo.prototype.selectNext = function(step){
         var z=this.getSelectedIndex()+step;
         while (this.optionsArr[z]){
            if (!this.optionsArr[z].isHidden())
               return this.selectOption(z,false,false);
            z+=step;
         }
      }
/**
*     @desc: on keypressed handler
*     @type: private
*     @topic: 0
*/
      dhtmlXCombo.prototype._onKeyF = function(e){
         var that=this.parentNode.combo;
         var ev=e||event;
         ev.cancelBubble=true;
         if (ev.keyCode=="13" || ev.keyCode=="9" ){
         	that._confirmSelection();
         	that.closeAll();
     	} else
        if (ev.keyCode=="27" ){
         	that._resetSelection();
         	that.closeAll();
     	} else that._activeMode=true;
         if (ev.keyCode=="13" || ev.keyCode=="27" ){ //enter
            that.callEvent("onKeyPressed",[ev.keyCode])
            return false;
         }
         return true;
      }
/**
*     @desc: on keyup handler
*     @type: private
*     @topic: 0
*/
      dhtmlXCombo.prototype._onKey = function(e){
         var that=this.parentNode.combo;
         (e||event).cancelBubble=true;
         var ev=(e||event).keyCode;
         if (ev>15 && ev<19) return true; //shift,alt,ctrl
        if (ev==27) return true;
        if ((that.DOMlist.style.display!="block")&&(ev!="13")&&(ev!="9")&&((!that._filter)||(that._filterAny)))
            that.DOMelem.onclick(e||event);
       
		if ((ev!="13")&&(ev!="9")){
         	window.setTimeout(function(){ that._onKeyB(ev); },1);
         	if (ev=="40" || ev=="38")
         		return false;
     	}
         else if (ev==9){
		 	that._confirmSelection();
         	that.closeAll();
         	(e||event).cancelBubble=false;
         }
      }
      dhtmlXCombo.prototype._onKeyB = function(ev)
      {
         if (ev=="40"){  //down
            var z=this.selectNext(1);
         } else if (ev=="38"){ //up
            this.selectNext(-1);
         } else{
            this.callEvent("onKeyPressed",[ev])
            if (this._filter) return this.filterSelf((ev==8)||(ev==46));
            for(var i=0; i<this.optionsArr.length; i++)
               if (this.optionsArr[i].data()[1]==this.DOMelem_input.value){
//                  ev.cancelBubble=true;
                  this.selectOption(i,false,false);
                  return false;
                  }
            this.unSelectOption();
         }
         return true;
      }


/**
*     @desc: on data change handler
*     @type: private
*     @topic: 0
*/
      dhtmlXCombo.prototype._onBlur = function()
      {
          var self = this.parentNode._self;
          window.setTimeout(function(){
          	if (self.DOMlist._skipBlur) return !(self.DOMlist._skipBlur=false);
			self._skipFocus = true;
          	self._confirmSelection();        
          	self.callEvent("onBlur",[]);
          },100)
          
      }
/**
*     @desc: redraw combobox options
*     @type: private
*     @topic: 2
*/
      dhtmlXCombo.prototype.redrawOptions = function(){
         if (this._skiprender) return;
         for(var i=this.DOMlist.childNodes.length-1; i>=0; i--)
            this.DOMlist.removeChild(this.DOMlist.childNodes[i]);
         for(var i=0; i<this.optionsArr.length; i++)
            this.DOMlist.appendChild(this.optionsArr[i].render());
			
		
		
						

      }
/**
*     @desc: load list of options from XML
*     @param: url - (string) xml url
*     @type: public
*     @topic: 0
*/
      dhtmlXCombo.prototype.loadXML = function(url,afterCall){
         this._load=true;
         this.callEvent("onXLS",[]);
		 if (this._prs)
           	for (var i=0; i<this._prs.length; i++)
           		url+=[getUrlSymbol(url),escape(this._prs[i][0]),"=",escape(this._prs[i][1])].join("");         
         if ((this._xmlCache)&&(this._xmlCache[url])){
            this._fillFromXML(this,null,null,null,this._xmlCache[url]);
            if (afterCall) afterCall();
        }
         else{
            var xml=(new dtmlXMLLoaderObject(this._fillFromXML,this,true,true));
            if (afterCall) xml.waitCall=afterCall;
            xml._cPath=url;
            xml.loadXML(url);
         }
      }

/**
*     @desc: load list of options from XML string
*     @param: astring - (string) xml string
*     @type: public
*     @topic: 0
*/
      dhtmlXCombo.prototype.loadXMLString = function(astring){
         var xml=(new dtmlXMLLoaderObject(this._fillFromXML,this,true,true));
         xml.loadXMLString(astring);
      }

/**
*     @desc: on XML load handler
*     @type: private
*     @topic: 0
*/
      dhtmlXCombo.prototype._fillFromXML = function(obj,b,c,d,xml){
         if (obj._xmlCache) obj._xmlCache[xml._cPath]=xml;

         //check that XML is correct 
         var toptag=xml.getXMLTopNode("complete");
         if (toptag.tagName!="complete"){
		 	 obj._load=false;
			 return;
         }
		 var top=xml.doXPath("//complete");
         var options=xml.doXPath("//option");
         
         var add = false;
         
         obj.render(false);
         if ((!top[0])||(!top[0].getAttribute("add"))){
            obj.clearAll();
            obj._lastLength=options.length;
	         if (obj._xml){
	         if ((!options) || (!options.length)) 
	         	obj.closeAll();
	         else {
	         		if (obj._activeMode){
	         			obj._positList();
	        			obj.DOMlist.style.display="block";
	         			if (_isIE) obj._IEFix(true);
         			}
	     	 }}            
         } else {
            obj._lastLength+=options.length||Infinity;
	        add = true;
        }

         for (var i=0; i<options.length; i++) {
            var attr = new Object();
            attr.text = options[i].firstChild?options[i].firstChild.nodeValue:"";
            for (var j=0; j<options[i].attributes.length; j++) {
               var a = options[i].attributes[j];
               if (a)
                  attr[a.nodeName] = a.nodeValue;
            }
            obj._addOption(attr);
         }
         obj.render(add!=true || (!!options.length));
         	
         if ((obj._load)&&(obj._load!==true))
            obj.loadXML(obj._load);
         else{
            obj._load=false;

             if ((!obj._lkmode)&&(obj._filter)&&!obj._autoDisabled) {
                 obj._correctSelection();
             }

            }

         var selected=xml.doXPath("//option[@selected]");
         if (selected.length){
	         obj._skipFocus = true;
	         obj.selectOption(obj.getIndexByValue(selected[0].getAttribute("value")),false,true);
         }

         obj.callEvent("onXLE",[]);

      }
/**
*     @desc: deselect option
*     @type: public
*     @topic: 1
*/
      dhtmlXCombo.prototype.unSelectOption = function(){
         if (this._selOption) this._selOption.deselect();
         if(this._tempSel) this._tempSel.deselect();
         this._tempSel=this._selOption=null;
      }
	  
/**
*     @desc: confirms combo value (recommended to be called on form submit)
*     @type: public
*     @topic: 1
*/
	 dhtmlXCombo.prototype.confirmValue = function(){
         this._confirmSelection();
	 }
	  
	  
      dhtmlXCombo.prototype._confirmSelection = function(data,status){
        var text = this.getComboText();
        this.setComboText("");
        this.setComboText(text);
      	if(arguments.length==0){
      	    var z=this.getOptionByLabel(this.DOMelem_input.value);
          	data = z?z.value:this.DOMelem_input.value;
          	status = (z==null);
          	if (data==this.getActualValue()) return this._skipFocus = false;
      	}
		if(!this._skipFocus&&!this._disabled){
        	try{
                this.DOMelem_input.focus();
            }
            catch(err){};
        }

      	this._skipFocus = false;
		this.DOMelem_hidden_input.value=data;
        this.DOMelem_hidden_input2.value = (status?"true":"false");
      	this.callEvent("onChange",[]);
      	this._activeMode=false;
  	  }
      dhtmlXCombo.prototype._resetSelection = function(data,status){
      		var z=this.getOption(this.DOMelem_hidden_input.value);
      		this.setComboValue(z?z.data()[0]:this.DOMelem_hidden_input.value)
      		this.setComboText(z?z.data()[1]:this.DOMelem_hidden_input.value)
  	  }  	  
  	  
/**
*     @desc: select option
*     @param: ind - (int) index of option in question
*     @param: filter - (boolean) enable autocomplit range, optional
*     @param: conf - (boolean) true for real selection, false for pre-selection
*     @type: public
*     @topic: 1
*/
      dhtmlXCombo.prototype.selectOption = function(ind,filter,conf){
      	 if (arguments.length<3) conf=true;
         this.unSelectOption();
         var z=this.optionsArr[ind];
         if (!z)  return;
         this._selOption=z;
         this._selOption.select();

         var corr=this._selOption.content.offsetTop+this._selOption.content.offsetHeight-this.DOMlist.scrollTop-this.DOMlist.offsetHeight;
         if (corr>0) this.DOMlist.scrollTop+=corr;
            corr=this.DOMlist.scrollTop-this._selOption.content.offsetTop;
         if (corr>0) this.DOMlist.scrollTop-=corr;
         var data=this._selOption.data();

	 	 if (conf){
	 	 	this.setComboText(data[1]);
      this._confirmSelection(data[0],false);
      }		 
         if ((this._autoxml)&&((ind+1)==this._lastLength))
            this._fetchOptions(ind+1,this._lasttext||"");

         if (filter){
            var text=this.getComboText();
            if (text!=data[1]){
               this.setComboText(data[1]);
               dhtmlXRange(this.DOMelem_input,text.length+1,data[1].length);
            }
         }
         else
            this.setComboText(data[1]);
         this._selOption.RedrawHeader(this);

         /*Event*/
         this.callEvent("onSelectionChange",[]);
      }
/**
*     @desc: option on select handler
*     @type: private
*     @topic: 2
*/
      dhtmlXCombo.prototype._selectOption = function(e)
      {
         (e||event).cancelBubble = true;
         var node=(_isIE?event.srcElement:e.target);
         var that=this.combo;
         while (!node._self) {
            node = node.parentNode;
            if (!node)
               return;
         }

         var i=0;
         for (i; i<that.DOMlist.childNodes.length; i++) {
            if (that.DOMlist.childNodes[i]==node) break;
         }
         that.selectOption(i,false,true);
         that.closeAll();
         that.callEvent("onBlur",[])
         that._activeMode=false;
      }
/**
*     @desc: open list of options 
*     @type: public
*     @topic: 2
*/
   dhtmlXCombo.prototype.openSelect = function(){ 
   	


	  if (this._disabled) return;
      this.closeAll();

      this.DOMlist.style.display="block";
      this._positList();
      this.callEvent("onOpen",[]);
	  if(this._tempSel) this._tempSel.deselect();
	  if(this._selOption) this._selOption.select();
	  if(this._selOption){
	 	var corr=this._selOption.content.offsetTop+this._selOption.content.offsetHeight-this.DOMlist.scrollTop-this.DOMlist.offsetHeight;
         if (corr>0) this.DOMlist.scrollTop+=corr;
            corr=this.DOMlist.scrollTop-this._selOption.content.offsetTop;
         if (corr>0) this.DOMlist.scrollTop-=corr;
	  }
	  
		
		      
      if (_isIE) this._IEFix(true);
      this.DOMelem_input.focus();
	
      if (this._filter) this.filterSelf();
   }
/**
*     @desc: open(close) list
*     @type: private
*     @topic: 2
*/
   dhtmlXCombo.prototype._toggleSelect = function(e)
   {
      var that=this.combo;
      if ( that.DOMlist.style.display == "block" ) {
      that.closeAll();
      } else {
         that.openSelect();
      }
      (e||event).cancelBubble = true;
   }

    dhtmlXCombo.prototype._fetchOptions=function(ind,text){
         if (text=="") { this.closeAll();  return this.clearAll();   }
         var url=this._xml+((this._xml.indexOf("?")!=-1)?"&":"?")+"pos="+ind+"&mask="+encodeURIComponent(text);
         this._lasttext=text;
         if (this._load) this._load=url;
         else {
			if (!this.callEvent("onDynXLS",[text,ind])) return;
			this.loadXML(url);
     	 }
    };
    /**
     *     @desc: disables autocomplete in filtering mode
     *     @type: public
     *     @topic: 2
     */
    dhtmlXCombo.prototype.disableAutocomplete = function()
    {
        this._autoDisabled = true;
    };
/**
*     @desc: filter list of options
*     @type: private
*     @topic: 2
*/
    dhtmlXCombo.prototype.filterSelf = function(mode)
   {
      var text=this.getComboText();
      if (this._xml){
         this._lkmode=mode;
         this._fetchOptions(0,text);
      }
      var escapeExp = new RegExp("(["+this.filterEntities.join("\\")+"])","g");
      text = text.replace(escapeExp,"\\$1");
      var filterExp = (this._anyPosition?"":"^")+text;
      var filter=new RegExp(filterExp,"i");
      this.filterAny=false;
      for(var i=0; i<this.optionsArr.length; i++){
      	  var z=filter.test(this.optionsArr[i].content?this.optionsArr[i].data()[1]:this.optionsArr[i].text);
	      this.filterAny|=z;
	     var _safariFix = (typeof z); //safari OS X fix
	     this.optionsArr[i].hide(!z);
      }
      if (!this.filterAny) {
		  this.closeAll();
		  this._activeMode=true;
	  }
     else {
          if (this.DOMlist.style.display!="block")
			      this.openSelect();
		  if (_isIE) this._IEFix(true);
      }
         
       if (!mode&&!this._autoDisabled){
           this._correctSelection();
       }
        else this.unSelectOption();
   }
 
 


/**
*     @desc: set hidden iframe for IE
*     @type: private
*     @topic: 2
*/
   dhtmlXCombo.prototype._IEFix = function(mode){
       this.DOMlistF.style.display=(mode?"block":"none");
       this.DOMlistF.style.top=this.DOMlist.style.top;
       this.DOMlistF.style.left=this.DOMlist.style.left;
       this.DOMlistF.style.width=this.DOMlist.offsetWidth+"px";
       this.DOMlistF.style.height=this.DOMlist.offsetHeight+"px";
   };
/**
*     @desc: close opened combobox list
*     @type: public
*     @topic: 1
*/
   dhtmlXCombo.prototype.closeAll = function()
   {
      if(window.dhx_glbSelectAr)
         for (var i=0; i<dhx_glbSelectAr.length; i++){
            if (dhx_glbSelectAr[i].DOMlist.style.display=="block") {
               dhx_glbSelectAr[i].DOMlist.style.display = "none";
               if (_isIE) dhx_glbSelectAr[i]._IEFix(false);
            }
            dhx_glbSelectAr[i]._activeMode=false;
        }
   }
   dhtmlXCombo.prototype.changeOptionId = function(oldId,newId){
        (this.getOption(oldId)||{}).value = newId;
   };
 
		
/**
*     @desc: create selection range in input control
*     @param: InputId - (string) id of input ( object can be used as well )
*     @param: Start - (int) start selection position
*     @param: End - (int) end selection position
*     @type: public
*     @topic: 0
*/
function dhtmlXRange(InputId, Start, End)
{
   var Input = typeof(InputId)=='object' ? InputId : document.getElementById(InputId);
   try{    Input.focus();   } catch(e){};
   var Length = Input.value.length;
   Start--;
   if (Start < 0 || Start > End || Start > Length)
      Start = 0;
   if (End > Length)
      End = Length;
   if (Start==End) return;
   if (Input.setSelectionRange) {
      Input.setSelectionRange(Start, End);
   } else if (Input.createTextRange) {
      var range = Input.createTextRange();
      range.moveStart('character', Start);
      range.moveEnd('character', End-Length);
	  try{
         range.select();
	  }
	  catch(e){
	  }
   }
}
/**
*     @desc: combobox option object constructor
*     @type: public
*     @topic: 0
*/
      dhtmlXCombo_defaultOption = function(){
         this.init();
      }
/**
*     @desc: option initialization function
*     @type: private
*     @topic: 4
*/
      dhtmlXCombo_defaultOption.prototype.init = function(){
         this.value = null;
         this.text = "";
         this.selected = false;
         this.css = "";
      }
/**
*     @desc: mark option as selected
*     @type: public
*     @topic: 4
*/
      dhtmlXCombo_defaultOption.prototype.select = function(){
         if (this.content){
            this.content.className="dhx_selected_option"+(dhtmlx.skin?" combo_"+dhtmlx.skin+"_sel":"");
		}
      }
/**
*     @desc: hide option
*     @param: mode - (boolean)
*     @type: public
*     @topic: 4
*/
      dhtmlXCombo_defaultOption.prototype.hide = function(mode){
	      this.render().style.display=mode?"none":"";
      }
/**
*     @desc: return hide state of option
*     @type: public
*     @return: hide state of option
*     @topic: 4
*/
      dhtmlXCombo_defaultOption.prototype.isHidden = function(){
         return (this.render().style.display=="none");
      }
/**
*     @desc: mark option as not selected
*     @type: public
*     @topic: 4
*/
      dhtmlXCombo_defaultOption.prototype.deselect = function(){
         if (this.content) this.render();
            this.content.className="";
      }
/**
*     @desc: set value of option
*     @param: value - (string) value
*     @param: text - (string) text
*     @param: css - (string) css style string
*     @type: public
*     @topic: 4
*/
dhtmlXCombo_defaultOption.prototype.setValue = function(attr){
    this.value = attr.value||"";
    this.text = attr.text||"";
    this.css = attr.css||"";
   this.content=null;
}

				
/**
*     @desc: render option
*     @type: private
*     @topic: 4
*/
      dhtmlXCombo_defaultOption.prototype.render = function(){
         if (!this.content){
            this.content=document.createElement("DIV");
        this.content._self = this;

            this.content.style.cssText='width:100%; overflow:hidden;'+this.css;
            if (_isOpera || _isKHTML ) this.content.style.padding="2px 0px 2px 0px";
            this.content.innerHTML=this.text;
            this._ctext=(typeof this.content.textContent!="undefined")?this.content.textContent:this.content.innerText;
         }
         return this.content;
      }
/**
*     @desc: return option data
*     @type: public
*     @return: array of data related to option
*     @topic: 4
*/
      dhtmlXCombo_defaultOption.prototype.data = function(){
         if (this.content)
            return [this.value,this._ctext ? this._ctext : this.text];
      }

dhtmlXCombo_defaultOption.prototype.DrawHeader = function(self, name, width, tab)
{
    var z=document.createElement("DIV");
    z.style.width = width+"px";
    z.className = 'dhx_combo_box '+(dhtmlx.skin||"");
    z._self = self;
	self.DOMelem = z;
   	this._DrawHeaderInput(self, name, width,tab);
	this._DrawHeaderButton(self, name, width);
    self.DOMParent.appendChild(self.DOMelem);
}

dhtmlXCombo_defaultOption.prototype._DrawHeaderInput = function(self, name, width,tab)
{

	var z=document.createElement('input');
	z.setAttribute("autocomplete","off"); 
	z.type = 'text';
	z.className = 'dhx_combo_input';

   if (tab) z.tabIndex=tab;
   z.style.width = width-19-(document.compatMode=="BackCompat"?0:3)+'px';
   self.DOMelem.appendChild(z);
   self.DOMelem_input = z;

   z = document.createElement('input');
   z.type = 'hidden';
   z.name = name;
   self.DOMelem.appendChild(z);
   self.DOMelem_hidden_input = z;

   z = document.createElement('input');
   z.type = 'hidden';
   z.name = (name||"").replace(/(\]?)$/, "_new_value$1");
   z.value="true";
   self.DOMelem.appendChild(z);
   self.DOMelem_hidden_input2 = z;
}

dhtmlXCombo_defaultOption.prototype._DrawHeaderButton = function(self, name, width)
{
   var z=document.createElement('img');
   z.className = 'dhx_combo_img';
  if(dhtmlx.image_path) dhx_globalImgPath = dhtmlx.image_path;
   z.src = (window.dhx_globalImgPath?dhx_globalImgPath:"")+'combo_select'+(dhtmlx.skin?"_"+dhtmlx.skin:"")+'.gif';
   self.DOMelem.appendChild(z);
   self.DOMelem_button=z;
}

dhtmlXCombo_defaultOption.prototype.RedrawHeader = function(self)
{
}


dhtmlXCombo_optionTypes['default'] = dhtmlXCombo_defaultOption;

dhtmlXCombo.prototype.dhx_Event=function()
{
   this.dhx_SeverCatcherPath="";

   this.attachEvent = function(original, catcher, CallObj)
   {
      CallObj = CallObj||this;
      original = 'ev_'+original;
       if ( ( !this[original] ) || ( !this[original].addEvent ) ) {
           var z = new this.eventCatcher(CallObj);
           z.addEvent( this[original] );
           this[original] = z;
       }
       return ( original + ':' + this[original].addEvent(catcher) );   //return ID (event name & event ID)
   }
   this.callEvent=function(name,arg0){
         if (this["ev_"+name]) return this["ev_"+name].apply(this,arg0);
       return true;
   }
   this.checkEvent=function(name){
         if (this["ev_"+name]) return true;
       return false;
   }

   this.eventCatcher = function(obj)
   {
       var dhx_catch = new Array();
       var m_obj = obj;
       var func_server = function(catcher,rpc)
                         {
                           catcher = catcher.split(":");
                     var postVar="";
                     var postVar2="";
                           var target=catcher[1];
                     if (catcher[1]=="rpc"){
                           postVar='<?xml version="1.0"?><methodCall><methodName>'+catcher[2]+'</methodName><params>';
                        postVar2="</params></methodCall>";
                        target=rpc;
                     }
                           var z = function() {
                                   }
                           return z;
                         }
       var z = function()
             {
                   if (dhx_catch)
                      var res=true;
                   for (var i=0; i<dhx_catch.length; i++) {
                      if (dhx_catch[i] != null) {
                           var zr = dhx_catch[i].apply( m_obj, arguments );
                           res = res && zr;
                      }
                   }
                   return res;
                }
       z.addEvent = function(ev)
                {
                       if ( typeof(ev) != "function" )
                           if (ev && ev.indexOf && ev.indexOf("server:") == 0)
                               ev = new func_server(ev,m_obj.rpcServer);
                           else
                               ev = eval(ev);
                       if (ev)
                           return dhx_catch.push( ev ) - 1;
                       return false;
                }
       z.removeEvent = function(id)
                   {
                     dhx_catch[id] = null;
                   }
       return z;
   }

   this.detachEvent = function(id)
   {
      if (id != false) {
         var list = id.split(':');            //get EventName and ID
         this[ list[0] ].removeEvent( list[1] );   //remove event
      }
   }
};


//combo
(function(){
	dhtmlx.extend_api("dhtmlXCombo",{
		_init:function(obj){
			if (obj.image_path) 
				dhx_globalImgPath=obj.image_path;
			return [obj.parent, obj.name, (obj.width||"100%"), obj.type, obj.index ];
		},
		filter:"filter_command",
		auto_height:"enableOptionAutoHeight",
		auto_position:"enableOptionAutoPositioning",
		auto_width:"enableOptionAutoWidth",
		xml:"loadXML",
		readonly:"readonly",
		items:"addOption"
	},{
		filter_command:function(data){
			if (typeof data == "string")
				this.enableFilteringMode(true,data);
			else
				this.enableFilteringMode(data);
		}
	});
})();


//(c)dhtmlx ltd. www.dhtmlx.com

//v.3.6 build 131108

/*
Copyright DHTMLX LTD. http://www.dhtmlx.com
To use this component please contact sales@dhtmlx.com to obtain license
*/
/*_TOPICS_
@0:Initialization
@1:Visual appearence
@3:Event Handlers
*/


/**
*   @desc:  TabBar Object
*   @param: parentObject - parent html object or id of parent html object
*   @param: mode - tabbar mode - top.bottom,left,right; top is default
*   @param: height - height of tab (basis size)
*   @type: public
*   @topic: 0
*/
function dhtmlXTabBar(parentObject,mode,height){
	mode=mode||"top"
	dhtmlxEventable(this);
	
	this._hrefs = {}; //compatibility with 2.0
	
	this._s={};
	this._c={};
	
	this._s.mode=mode;
	this._s.scrolls=true;
	this._custom_height = height;
	this._s.line_height=(parseInt(height)||20)+3;//+3 to be compatible with 1.x sizes 
	this._s.skin_line = 1;
	this._s.tab_margin = 0;
	this._s.expand = 0;
	this._s.ext_border = 2;
	
	this._s._bMode=(mode=="right"||mode=="bottom")?1:0;
	this._s._vMode=(mode=="right"||mode=="left")?1:0;
	
	this._dx=this._s._vMode?"height":"width";
	this._dy=this._s._vMode?"width":"height";
	
	switch(mode){
		case "top":
			this._py="top"; this._px="left"; this._pxc="right";
		break;
		case "bottom":
			this._py="bottom"; this._px="left"; this._pxc="right";
		break;
		case "right":
			this._py="right"; this._px="top"; this._pxc="bottom";
		break;
		case "left":
			this._py="left"; this._px="top"; this._pxc="bottom";
		break;
	}
	
	
	this._active= null;
    this._tabs = {};
    this._content = {};
    this._href={}
	this._rows=[];
	
	this._s._tabSize=150;
	
	this._styles={
		"default":{ left:3, right:3, select_shift:3, select_top:2, margin:1, offset:5, tab_color:"#F4F3EE", data_color:"#F0F8FF" },
		"winbiscarf":{ left:18, right:18, select_shift:3, select_top:2, margin:1, offset:5},
		"winscarf":{ left:18, right:4, select_shift:3, select_top:2, margin:5, offset:5},
		"modern":{ left:5, right:5, select_shift:3, select_top:2, margin:1, offset:5, tab_color:"#F4F3EE", data_color:"#F0F8FF" },
		"silver":{ left:7, right:7, select_shift:3, select_top:2, margin:1, offset:5, tab_color:"#F4F3EE", data_color:"#F0F8FF" },
		"dark_blue":{ left:2, right:2, select_shift:3, select_top:2, margin:1, offset:5 },
		"glassy_blue":{ left:2, right:3, select_shift:3, select_top:2, margin:1, offset:5 },
		"dhx_terrace":{ left:7, right:7, select_shift:0, select_top:0, margin:-1, offset:0, tab_color:"", data_color:"#ffffff" },
		
		"dhx_black":{ left:2, right:2, select_shift:3, select_top:0, margin:1, offset:5},
		"dhx_blue":{ left:2, right:2, select_shift:3, select_top:0, margin:1, offset:5, tab_color:"#F4F3EE", data_color:"#F0F8FF" },
		"dhx_skyblue":{ left:3, right:3, select_shift:0, select_top:0, margin:-1, offset:5 , data_color:"white", hover:true },
		"dhx_web":{ left:3, right:3, select_shift:1, select_top:0, margin:5, offset:15 , data_color:"white" }
	};
	
	if (typeof(parentObject)!="object")
            parentObject = document.getElementById(parentObject);
    this.entBox=parentObject;
    this.entBox.className+=" dhx_tabbar_zone_"+this._s.mode;
	if (dhtmlx.image_path) this.setImagePath(dhtmlx.image_path);
	
	this.setStyle("default"); this.__skin = false;
    this._createSelf();            //generate TabBar DOM structure

    if (_isIE) this.preventIECashing(true);
    return this;
}

dhtmlXTabBar.prototype={
	_get_size:function(name,alter){
		var size = this.entBox.getAttribute(name) || this.entBox.style[name] || (window.getComputedStyle?window.getComputedStyle(this.entBox,null)[name]:(this.entBox.currentStyle?this.entBox.currentStyle[name]:0))
		if ((size||"").indexOf("%")!=-1)
			this.enableAutoReSize(true,true);
		if (!size||size.indexOf("%")!=-1||size=="auto")
			size=alter+"px";
		return size;
	},
	
	setStyle:function(name){
		this.setSkin(name);
	},
	_getSkin:function(tab){
		//if (tab && tab.skin) return this._styles[tab.skin];
		return this._a;
	},
/**
*     @desc: set style used for tabbar
*     @type: public
*     @param: name - any valid style name
*     @topic: 0
*/	
	setSkin:function(name){
		name=name.toLowerCase();
		if (!this._styles[name]) name="default";
		this._a=this._styles[name];
		this.skin=name;
		if (this._tabAll)
			this._tabAll.className='dhx_tabbar_zone dhx_tabbar_zone_'+this.skin;
		
		var sky_mode = name.indexOf("dhx_sky")==0;
		var simple_mode = name.indexOf("dhx_web")==0;
		var terrace_mode = name.indexOf("dhx_terrace")==0;
		
		if (terrace_mode&&!this._custom_height){
			this._s.line_height = 37;
			this._setRowSizes();
		}

		if (sky_mode) 
			this._s.skin_line=0;
		if (simple_mode){
			this._s.line_height = 29;
			this._s.ext_border = -1;
			this._s.expand = true;
		}
		if (sky_mode) {
			this._s.line_height=26;
			this._setRowSizes();
			if (this._s.expand)
				this._s.tab_margin = -1;
				
			this._s.skin_line_x=true;
			this._s.skin_line=-3;
			var r = this._s._rendered;
			if (r) for (var i=0; i < r.length; i++) {
				r[i].parentNode.removeChild(r[i]);
			}
				
			var d1 = document.createElement("DIV");
			d1.className="dhx_tabbar_lineA";
			this._tabAll.appendChild(d1);
			var d2 = document.createElement("DIV");
			d2.className="dhx_tabbar_lineB";
			this._tabAll.appendChild(d2);
			
			var d3 = document.createElement("DIV");
			d3.className="dhx_tabbar_lineC";
			this._tabAll.appendChild(d3);
			
			var d4 = document.createElement("DIV");
			d4.className="dhx_tabbar_lineD";
			this._tabAll.appendChild(d4);
		
			this._getCoverLine();
			this._s._rendered = [d1,d2,d3,d4];

			if (this._s.expand){
				this._conZone.style.borderWidth="0px 0px 0px 0px";
				this._tabZone.firstChild.style.borderWidth="0px 0px 0px 0px";
				d3.style.borderWidth="0px 0px 0px 0px";
				d4.style.left="0px";
				d3.style.right="0px";
				d1.style.borderWidth="0px 0px 0px 0px";
				if (this._s.mode=="top")
					this._lineA.style.borderWidth="1px 0px 0px 0px";
				
				d2.style.left = "1px"

				this._s.ext_border = 0;
				//this._s.skin_line_x=false;
			}
					
			var f = function(){
				this._lineA.style[this._dx]="1px"; 
				var _quirks=(_isIE && document.compatMode == "BackCompat");
				var w = this._tabAll[this._s._vMode?"offsetHeight":"offsetWidth"]+(_quirks?2:0);
				if (this._lastActive)
					w=Math.max(w,this._lastActive.parentNode[this._s._vMode?"scrollHeight":"scrollWidth"]);
				if (w<6) return;
				
				d1.style[this._py]=parseInt(this._conZone.style[this._py])-3+"px"; 
				d1.style[this._dx]=w-2+"px"; 
				
				d2.style[this._py]=parseInt(this._conZone.style[this._py])-3+"px"; 
				d2.style[this._dx]=w-(_quirks?6:4)+(this._s.expand?2:0)+"px"; 
				
				d3.style[this._dy]=parseInt(this._tabZone.style[this._dy])-3+"px"; 
				this._lineA.style[this._dx]=w-2+"px"; 
			}

			f.call(this);
			var bf = this._checkScroll;
			this._checkScroll=function(){
				f.apply(this,arguments);
				bf.apply(this,arguments);
			}
			var bs = this._scrollTo;
			this._scrollTo=function(){
				bs.apply(this,arguments);
				f.apply(this,arguments);
			}
			/*var bf2=this.addTab;
			this.addTab=function(){
				bf2.apply(this,arguments);
				f.apply(this,arguments);
			}*/
		}
		if (this._a.data_color && this._conZone)
			this._conZone.style.backgroundColor=this._a.data_color;
		this.__skin = true;
	},
/**
*     @desc: enable / disable auto adjusting height and width   to outer conteiner
*     @type: public
*     @param: mode - enable/disable
*     @topic: 0
*/
	
	enableAutoReSize:function(){
		var self=this;
		dhtmlxEvent(window,"resize",function(){
			window.setTimeout(function(){
				if (self && self._setSizes)
					self._setSizes();
			},1)		
		})
	},
	_createSelf:function(){
        this._tabAll=document.createElement("DIV");
        this._tabZone=document.createElement("DIV");
        this._conZone=document.createElement("DIV");

        this.entBox.appendChild(this._tabAll);
        this._tabAll.appendChild(this._tabZone);
		this._tabAll.appendChild(this._conZone);
        	
        this._tabAll.className='dhx_tabbar_zone dhx_tabbar_zone_'+this.skin;
        if (this._s._vMode)
        	this._tabAll.className+='V';
        if (this._s._bMode)
            this._tabAll.className+='B';
        this._tabZone.className='dhx_tablist_zone';
        this._conZone.className='dhx_tabcontent_zone';
        if (this.entBox._hideBorders) {
        	this._conZone.style.borderLeft = this._conZone.style.borderRight = this._conZone.style.borderBottom = "0px solid white";
        }
        if (this._a.data_color)
        	this._conZone.style.backgroundColor=this._a.data_color;

        this._tabZone.onselectstart = function(){ return false; };
        this._tabZone.onclick = this._onClickHandler;
        this._tabZone.onmouseover = this._onMouseOverHandler;
        this._tabZone[_isFF?"onmouseout":"onmouseleave"] = this._onMouseOutHandler;    
        this._tabZone.tabbar=this;

        this._createRow();
	},
	_createRow:function(){
		var z=document.createElement("DIV");
    	z.className='dhx_tabbar_row';
    	z.tabCount=0;
    	this._tabZone.appendChild(z);
		this._rows[this._rows.length]=z;

        this._setRowSizes();
	},
	_removeRow:function(row){
    	row.parentNode.removeChild(row);
    	var z=[];
    	for (var i=0; i<this._rows.length; i++)
        	if (this._rows[i]!=row) z[z.length]=this._rows[i];
	    this._rows=z;
	},
	_setSizes:function(x,y){
		var dim=["clientHeight","clientWidth"];
		if (this._dx!="width") dim.reverse();
		
		var _quirks=(_isIE && document.compatMode == "BackCompat");
		var outerBorder=(this._conZone.offsetWidth-this._conZone.clientWidth);		
		
		var _h=y||(this.entBox[dim[0]]+(_quirks?outerBorder:0));
		var _w=x||(this.entBox[dim[1]]+(_quirks?outerBorder:0));

		var _t=this._rows.length*(this._s.line_height-(this._s.skin_line_x?4:2))+(this._s.skin_line_x?2:0);
		this._tabZone.style[this._dy]=_t+"px";
		this._conZone.style[this._dy]=Math.max(0,_h-this._s.ext_border-_t-(this._s.skin_line_x?3:0)-this._s.tab_margin)+"px";		
		this._conZone.style[this._dx]=Math.max(0,_w - (this._s.expand?0:2))+"px";		
		//this._tabZone.style[this._py]=_t+"px";
		this._tabZone.style[this._py]=this._s.tab_margin+"px";
		this._conZone.style[this._py]=_t+this._s.tab_margin-this._s.skin_line+"px";
		this._checkScroll();
		
		var id = this.getActiveTab();		
		if (id)	this.cells(id).activate();
		/*for (var id in this._content)
			if (this._content[id])
				this._content[id].adjustContent(this._content[id].parentNode,0,0,false,0);
				*/
	},
	_checkScroll:function(){
		if (this._lineA){
			this._lineA.style[this._dx]="1px"; 
			var _quirks=(_isIE && document.compatMode == "BackCompat");
			var w = this._tabAll[this._s._vMode?"offsetHeight":"offsetWidth"]+(_quirks?2:0);
			if (this._lastActive)
				w=Math.max(w,this._lastActive.parentNode[this._s._vMode?"scrollHeight":"scrollWidth"]);
			if (w>2)
				this._lineA.style[this._dx]=w-2+"px"; 
		}	
					
//#scrollers:23052006{		
		if (this._s._vMode || !this._s.scrolls) return; //only x-scrolls
		for (var i=0; i<this._rows.length; i++)
			if ((this._rows[i].scrollWidth-this._rows[i].offsetWidth)>2)
				this._showScroll(i);
			else this._hideScroll(i);
//#}
	},
//#scrollers:23052006{	
	_showScroll:function(i){
		if (this._rows[i]._scroll) return;
		this.callEvent("onBeforeShowScroll",[i]);
		var a=this._rows[i]._scroll=[];
		var top = Math.max(0,this._s.line_height-23);
		a[0]=document.createElement("DIV");
		a[0].style.cssText="background-image:url("+this.imgUrl+this.skin+"/"+this.skin+"_scroll_left.gif); width:20px; height:21px;position:absolute;left:0px;z-index:990;top:"+top+"px;";
		a[0].className="dhx_tab_scroll_left";
		this._rows[i].appendChild(a[0]);
		
		a[1]=document.createElement("DIV");
		a[1].style.cssText="background-image:url("+this.imgUrl+this.skin+"/"+this.skin+"_scroll_right.gif); width:20px; height:21px;position:absolute;right:0px;z-index:990;top:"+top+"px;";
		a[1].className="dhx_tab_scroll_right";
		this._rows[i].appendChild(a[1]);
	},
	_hideScroll:function(i){
		if(this._rows[i]._scroll){
		    this.callEvent("onBeforeHideScroll",[i]);
        }
        if (!this._rows[i]._scroll) return;
		this._rows[i].removeChild(this._rows[i]._scroll[0])
		this._rows[i].removeChild(this._rows[i]._scroll[1])
		this._rows[i]._scroll=null;
	},
//#}	
	_setRowSizes:function(){
		for (var i=0; i<this._rows.length; i++){
			this._rows[i].style[this._dy]=this._s.line_height+"px";
			this._rows[i].style[this._py]=i*(this._s.line_height-(this._s.skin_line_x?4:2))-((_isIE && !window.postMessage && this._s._bMode)?0:0)+"px";	//dirty!
			this._rows[i].style.zIndex=10+i;
		}
		this._setSizes();
	},
	_setTabSizes:function(row){
		var pos=this._a.offset;
		var px = this._s.align?this._pxc:this._px;
		for (var i=0; i < row.tabCount; i++) {
			var tab=row.childNodes[i];
			if (tab.style.display=="none") continue;
			tab.style[px]=pos-(this._lastActive==tab?this._a.select_shift:0)+"px";
			pos+=tab._size+this._a.margin;
		}
	},
/**
*   @desc: add tab to TabBar
*   @param: id - tab id
*   @param: text - tab content
*   @param: size - width(height) of tab
*   @param: position - tab index , optional
*   @param: row - index of row, optional  [only in PRO version]
*   @type: public
*   @topic: 1
*/
	
	addTab:function(id, text, size, position, row){  
		if (!this.__skin && dhtmlx.skin) this.setSkin(dhtmlx.skin);
		row=row||0;
//#multiline:23052006{			
		for (var i=this._rows.length; i<=row; i++)
        	this._createRow();
//#}
		var z=this._rows[row].tabCount;
    	if ((!position)&&(position!==0)) position=z;

	    var tab=this._createTab(id, text, (size=="*"?10:size||this._s._tabSize));
		this._addTab(this._rows[row],tab,size,position);
		this._tabs[id]=tab;
		this.cells(id).hide();
		this._checkScroll();
	},
	getIndex:function(id){
		var tab = this._tabs[id];
		if (tab){
			var row = tab.parentNode;
			for (var i=0; i<row.childNodes.length; i++)
				if (row.childNodes[i] == tab)
					return i;
		}

		return -1;
	},
	moveTab:function(id, index){
		var tab = this._tabs[id];
		if (tab){
			var from = this.getIndex(id);
			var row = tab.parentNode;
			index = Math.min(index, row.tabCount-1);

			if (from == index) return;
			if (from < index) index++;

			if(tab.parentNode.childNodes[index])
				tab.parentNode.insertBefore(tab, tab.parentNode.childNodes[index]);
			else
				tab.parentNode.appendChild(tab);
			this._setTabSizes(tab.parentNode);

		}
	},
/**
*   @desc: remove tab from tabbar
*   @param: tab - id of tab
*   @param: mode - if set to true, selection jump from current tab to nearest one
*   @type: public
*   @topic: 1
*/
	
	removeTab:function(id,mode){
	    var tab=this._tabs[id];
    	if (!tab) return;
		this.cells(id)._dhxContDestruct();
		if (this._content[id] && this._content[id].parentNode)
			this._content[id].parentNode.removeChild(this._content[id]);
		this._content[id]=null;
		
		this._goToAny(tab,mode);

	    var row=tab.parentNode;
		tab.innerHTML = "";
    	row.removeChild(tab);
    	row.tabCount--;
    	
    	if ((row.tabCount==0)&&(this._rows.length>1))
        	this._removeRow(row);
        else
        	this._setTabSizes(row);
        	
    	delete this._tabs[id];
    	if (this._lastActive==tab) this._lastActive=null;
	    this._setRowSizes();	
	},
	_goToAny:function(tab,mode){
    	if (this._lastActive==tab){
    		
        	if (mode && this.goToNextTab()==tab)
        		this.goToPrevTab();
        	if (this._lastActive==tab)
        		this._lastActive=null;
    	}
	},
	_createTab:function(id,text,size){
 		var tab=document.createElement("DIV");
    	tab.className='dhx_tab_element dhx_tab_element_inactive';
    	var thml="<span>"+text+"</span><div></div><div></div><div></div>";
    	if (this._close) thml+="<IMG style='"+this._pxc+":4px; "+this._py+(this.skin=="dhx_web"?":7":":4")+"px; position:absolute;z-index:11;' src='"+this.imgUrl+this.skin+"/close.png' >";
    	tab.innerHTML=thml;
    	
    	tab.setAttribute("tab_id",id);
    	tab._size=parseInt(size);
    	tab.style[this._dx]=parseInt(size)+"px";
    	tab.style[this._dy]=this._s.line_height+"px";
    	tab.style[this._py]=this._a.select_top+"px";
    	tab.skin=this.skin;
    	if (this._a.tab_color)
    		tab.style.backgroundColor=this._a.tab_color;
    	if (this._c[id])
        	tab.childNodes[0].style.cssText=this._c[id].color;
        	
    	this._img_all(tab);
    	if (this._close){
    		var self=this;
    		tab.childNodes[4].onclick=function(e){ var id=this.parentNode.getAttribute("tab_id"); if (self.callEvent("onTabClose",[id])) self.removeTab(id,true); (e||event).cancelBubble=true; };
    	}
    	return tab;				
	},
	_img_all:function(tab){
		var a=this._getSkin(tab);
		var pf=tab._active?1:4;
		//this._img(tab,pf+"_middle");
    	this._img(tab.childNodes[1],pf,this._px,a.left);
    	this._img(tab.childNodes[2],pf+2,this._pxc,a.right);
    	this._img(tab.childNodes[3],pf+1,this._px,parseInt(tab.style[this._dx])-(a.left+a.right),a.left);
    	//ff3.0 thinks that 2==3, waiting for 3.5 
    	//tab.childNodes[1].style.backgroundRepeat="no-repeat";
	},
	_get_img_pos:function(ind){
		if (this._s._bMode && ind<7) ind=Math.abs(ind-6);
		ind=-5-ind*(this._s._vMode==1&&this.skin=="dhx_terrace"?245:45);
		if (this._s._vMode) return ind+"px 0px";
		else return "0px "+ind+"px";
		
	},
	_img:function(tag,y,pos,a,b){
		if (typeof(tag) == "undefined")
			return;
		tag.style.backgroundImage="url("+this.imgUrl+this.skin+"/"+this.skin+"_"+this._s.mode+".gif)";
		tag.style.backgroundPosition=this._get_img_pos(y);
		if (this._s._vMode == 1 && this.skin == "dhx_terrace") tag.style.width="240px";
		tag.style[this._py]="0px";
		if (pos){
			tag.style[this._dx]=Math.max(a,0)+"px";
			tag.style[pos]=(b||0)+"px";
		}
		//tag.style.backgroundPosition=this._px+" "+this._py;
	},
	_addTab:function(row,tab,size,position){
		var pos=this._a.offset;
		if (row.tabCount){
			var last=row.childNodes[row.tabCount-1];
			var pos=parseInt(last.style[this._s.align?this._pxc:this._px])+parseInt(last._size)+this._a.margin;
		}
		
		var next=row.childNodes[position];
		if (next)
			row.insertBefore(tab,next)
		else
			row.appendChild(tab);
		row.tabCount++;		
		if (size=="*"){
			tab.style.whiteSpace="nowrap";
			this.adjustTabSize(tab);
		}
		
		tab.style[this._s.align?this._pxc:this._px]=pos+"px";
		if (position!=row.tabCount-1) this._setTabSizes(row);
	},
	adjustTabSize:function(tab,size){
		var a=this._getSkin(a);
		if (!size){
			tab.style.fontWeight="bold";
			tab.childNodes[3].style[this._dx] = tab.style[this._dx]="10px";
			size=tab[this._s._vMode?"scrollHeight":"scrollWidth"]+10+(this._close?20:0);
			tab.style.fontWeight="";
		}
		tab.style[this._dx]=size+"px";
		tab._size=size;
		
		this._img_all(tab);
	},
	_onMouseOverHandler:function(e){
		var target = this.tabbar._getTabTarget(e?e.target:event.srcElement);
        this.tabbar._showHover(target);
	},
	_onMouseOutHandler:function(e){
    	this.tabbar._showHover();
	},
	_showHover:function(tab){
		if (tab==this._lastHower) return;
		if (this._lastHower && this._lastHower != this._lastActive){
			var a=this._getSkin(this._lastHower);
			this._lastHower.className=this._lastHower.className.replace(/[ ]*dhx_tab_hover/gi,"");
			
			if (a.hover)
				this._img_all(this._lastHower);
			else
				this._img(this._lastHower.childNodes[3],5,this._px,parseInt(this._lastHower.style[this._dx])-(a.left+a.right),a.left);
			//this._lastHower.style.zIndex=this._getCoverLine()._index-2;
			this._lastHower=null;
			
		}

		if (tab && ( tab == this._lastActive || tab._disabled)) return;
		
		this._lastHower=tab;	
		if(tab){
			var a=this._getSkin(tab);
			tab.className+=" dhx_tab_hover";
			if (a.hover){
	    		this._img(tab.childNodes[1],7,this._px,a.left);
    			this._img(tab.childNodes[2],8,this._pxc,a.right);
			}
			this._img(tab.childNodes[3],0,this._px,parseInt(tab.style[this._dx])-(a.left+a.right),a.left);
			//tab.style.zIndex=this._getCoverLine()._index-1;
		}
		
    },
    _getTabTarget:function(t){
		if (!t) return null;
    	while ((!t.className)||(t.className.indexOf("dhx_tab_element")==-1)){
        	if ((t.className)&&(t.className.indexOf("dhx_tabbar_zone")!=-1)) return null;
        	t=t.parentNode;
        	if (!t) return null;
        }
    	return t;
	},
	_onClickHandler:function(e){
		var src=e?e.target:event.srcElement;
        var target = this.tabbar._getTabTarget(src);
        if (target && !target._disabled)
	        this.tabbar._setTabActive(target);
	    else {
	    	var tag=null;
	    	if (src.className=="dhx_tab_scroll_left"){
	    		src.parentNode.scrollLeft=Math.max(0,src.parentNode.scrollLeft-src.parentNode.offsetWidth/2);
	    		tag=src;
	    		this.tabbar._setTabTop(this.tabbar._lastActive);
    		}
	    	else if (src.className=="dhx_tab_scroll_right"){
	    		src.parentNode.scrollLeft+=src.parentNode.offsetWidth/2;
	    		tag=src.previousSibling;
	    		this.tabbar._setTabTop(this.tabbar._lastActive);
    		}
    		if (tag && tag.parentNode&&tag.parentNode.tagName){
    			tag.style.left=tag.parentNode.scrollLeft+"px";
    			if (!_isIE || window.XMLHttpRequest)
    				tag.nextSibling.style.right=tag.parentNode.scrollLeft*(-1)+"px";
    			return false;
			}
	    }
	},
	_deactivateTab:function(){
		this._setTabInActive(this._lastActive);
		this._lastActive=null;
	},
	_setTabInActive:function(tab,mode){ 
		if (!tab || tab!=this._lastActive) return true;
		var a = this._getSkin(tab);
		var id = tab.getAttribute("tab_id");
		var px = this._s.align?this._pxc:this._px;
		
		tab.className=tab.className.replace("_active","_inactive");
		tab.style[this._py]=a.select_top+"px";
		tab.style[px]=parseInt(tab.style[px])+a.select_shift+"px";
	    tab.style[this._dx]=tab._size+"px";
	    
		tab._active=false;
		if (a.tab_color)
        	tab.style.backgroundColor=a.tab_color;
        if (this._c[id])
        	tab.childNodes[0].style.cssText=this._c[id].color;
        	
		this._img_all(tab);
		
		this.cells(id).hide();
	},
	_setTabActive:function(tab,mode){ 
		if (!tab) return true;
		var id = tab.getAttribute("tab_id");
		var last_id = this._lastActive?this._lastActive.getAttribute("tab_id"):null;
		var a = this._getSkin(tab);
		
		if (!mode)
			this.callEvent("onTabClick",[id,last_id]);
		if( tab==this._lastActive) return true;
		if (!mode)
			if (!this.callEvent("onSelect",[id,last_id])) return;
		var px = this._s.align?this._pxc:this._px;
		this._setTabInActive(this._lastActive);
		
	    tab.className=tab.className.replace("_inactive","_active");
	    tab.style[this._py]="0px";
	    tab.style[px]=parseInt(tab.style[px])-a.select_shift+"px";
	    tab.style[this._dx]=tab._size+a.select_shift*2+"px";
	    
        tab._active=true;
        if (a.data_color)
        	tab.style.backgroundColor=a.data_color;
        if (this._c[id])
        	tab.childNodes[0].style.cssText=this._c[id].scolor;
        	
    	//this._setContent(tab);    
    	this._img_all(tab);
	    this._setTabTop(tab);
	    
	    this._lastActive=tab;
	    this.cells(id).show();
	    this._scrollTo(tab);
	    return true;
	},
	_scrollTo:function(tab){ 
//#scrollers:23052006{			
		if (!this._s.scrolls) return;
		if (tab.offsetLeft<tab.parentNode.scrollLeft || (tab.offsetLeft+tab.offsetWidth)>(tab.parentNode.scrollLeft+tab.parentNode.offsetWidth)){
			tab.parentNode.scrollLeft = tab.offsetLeft;
			var tag = tab.parentNode._scroll;
			if (tag && tag[0]){
				tag[0].style.left=tag[0].parentNode.scrollLeft+"px";
				if (!_isIE || window.XMLHttpRequest)
	    			tag[1].style.right=tag[1].parentNode.scrollLeft*(-1)+"px";
			}
		}
//#}
	},
	_setTabTop:function(tab){
        if(!tab)
            return false;
//#multiline:23052006{		
		var t = this._rows.length-1;
	    for (var i=0; i<this._rows.length; i++)
	        if (this._rows[i]==tab.parentNode){
	        	var row=this._rows[i];
	        	if (i!=t){
	        		this._rows[i]=this._rows[t]
	        		this._rows[t]=row;
    	    	}
    	    	var line=this._getCoverLine();
    	    	row.appendChild(line);
    	    	line.style[this._dx]="1px";
    	    	
    	    	var wh=(this._s._vMode?Math.max(this._tabZone.offsetHeight,row.scrollHeight):Math.max(this._tabZone.offsetWidth,row.scrollWidth));
    	    	if (wh>0)
    				line.style[this._dx]=wh+"px";
    	    	tab.style.zIndex=(line._index++);
    	    	break;
	    	}
		this._setRowSizes();	        	
//#}
	},
	_getCoverLine:function(){
		if (!this._lineA){
			this._lineA=document.createElement("div");
        	this._lineA.className="dhx_tablist_line";
        	this._lineA.style[this._py]=this._s.line_height-3-(this._s.skin_line_x?1:0)+"px";
        	this._lineA.style[this._dx]="100%";
        	this._lineA._index=1;
		}
		this._lineA.style.zIndex=(this._lineA._index++);
		
		return this._lineA;
	},
	cells:function(id){
		if (!this._tabs[id]) return null;
		if (!this._content[id]){
			var d=document.createElement("DIV");
			d.style.cssText="width:100%;height:100%;visibility:hidden;overflow:hidden;position:absolute;top:0px; left:0px;";
			d.setAttribute("tab_id",id);
			d.skin = this.skin;
			this._conZone.appendChild(d);
			(new dhtmlXContainer(d)).setContent(d);
			if (this.skin=="dhx_web" && d._setPadding) d._setPadding(1, "dhxcont_tabbar_dhx_web"); // for headerless cell use d._setPadding(0, "");
			d._isTabbarCell = true;
			this._content[id]=d;
			
			var self=this; //can cause memory leak
			d.show = function(){ 
				if (self._s.hide)
					this.style.display="";
				this.style.visibility="";
				this.style.zIndex="1";
				this.autoSize();
				this._activate();
			}
			d.hide = function(){
				if (self._s.hide){
					this.style.visibility="";
					this.style.display="none";
				} else
					this.style.visibility="hidden";
				this.style.zIndex=-1;
				if (self._hrfmode=="iframe") this.attachURL("javascript:false");
			}
			d.autoSize = function(){
				if (self._awdj || self._ahdj){
					var cont = (this.vs?this.vs[this.av].dhxcont.mainCont[this.av]:this.mainCont);
					if (!cont.offsetWidth)
						cont.style.width=Math.max(0,self.entBox.offsetWidth - 2)+"px";
					if (self._ahdj)
						cont.style.height="1px";
						
					var dim = this._getContentDim();
					if (self._awdj){
						self.entBox.style.width=dim[0]+2+"px";
						cont.style.width=dim[0]+"px";
					}
					if (self._ahdj){
						self._tabAll.style.height = self.entBox.style.height=dim[1]+self._rows.length*(self._s.line_height-2)+(self._s.expand?0:2)+2+"px";
						cont.style.height=dim[1]+"px";
					}
					self._setSizes();
					self._setTabTop(self._lastActive);
				}
			};
			d._activate=function(){
				if (this._delay) 
					this._attachContent.apply(this,this._delay);
				this.activate();
				if (self._hrfmode!="iframe") 
					this._delay=null;
			};
			d._doOnResize=function(){
				this.activate();
			};
			d.activate=function(){
				this.adjustContent(this.parentNode,0,0,false,0);
				d.updateNestedObjects();
			}
			d._doOnAttachStatusBar = d.activate;
			d._doOnAttachMenu = d.activate;
			d._doOnAttachToolbar = d.activate;			
			d._getContentDim=function(){
				var cont = (this.vs?this.vs[this.av].dhxcont.mainCont[this.av]:this.mainCont);
				return [cont.scrollWidth,cont.scrollHeight];
			}
			d._doOnFrameContentLoaded=function(){
				if (self._awdj || self._ahdj)
					self.cells(id).autoSize();				
				self.callEvent("onXLE",[]);
				self.callEvent("onTabContentLoaded",[this.getAttribute("tab_id")]);
			}
			d._doOnBeforeAttachURL=function(){
				self.callEvent("onXLS",[]);
			}
			d.adjustContent(d.parentNode,0,0,false,0);
		}
		return this._content[id];
	},
/**
*     @desc: forcing to load tab in question
*     @type: public
*     @param: tabId - id of tab in question
*     @param: href - new href, optional
*     @topic: 0
*/
	
	forceLoad:function(id,href){
        this.setContentHref(id,href||this._hrefs[id]);
        this.cells(id)._activate();
	},
	
	
	
/**
*     @desc: enable disable auto adjusting height and width   to inner content
*     @type: public
*     @param: autoWidth - enable/disable auto adjusting width
*     @param: autoHeight - enable/disable auto adjusting height
*     @topic: 0
*/
	
	enableAutoSize:function(autoWidth,autoHeight){
	    this._ahdj=convertStringToBoolean(autoHeight);
	    this._awdj=convertStringToBoolean(autoWidth);
	},
	
/**
*   @desc: reinitialize  tabbar
*   @type: public
*   @topic: 0
*/
	
	clearAll:function(){
		for (var id in this._tabs)
			this.removeTab(id,false);
		if (this._lineA){
			var line=this._getCoverLine();
			if (line.parentNode) line.parentNode.removeChild(line);
		}
	},
/**
*   @desc: enable mode, in which each tab has close button, mode will be applied to the tabs created AFTER command
*   @param: bool - false/true - enable/disable
*   @type: public
*   @topic: 1
*/
	
	enableTabCloseButton:function(mode){
		this._close = convertStringToBoolean(mode);
	},	
	
	
	preventIECashing:function(mode){
    	this.no_cashe = convertStringToBoolean(mode);
    	if (this.XMLLoader) this.XMLLoader.rSeed=this.no_cashe;
	},
/**
*   @desc: switch tab to active state
*   @param: tabId - id of tab
*	@param: mode - if to run onSelect handler (true by default)
*   @type: public
*   @topic: 1
*/
	setTabActive:function(id,mode){
		this._setTabActive(this._tabs[id],mode===false);
	},
	setTabInActive:function(){
		var tab = this._lastActive;
		if (tab){
			this._deactivateTab();
			this._setTabTop(tab);
			this._getCoverLine();
		}
	},
/**
*     @desc: load tabbar from xml string
*     @type: public
*     @param: xmlString - XML string
*     @param: afterCall - function which will be called after xml loading
*     @topic: 0
*/
	
	loadXMLString:function(xmlString,call){
       	this.XMLLoader=new dtmlXMLLoaderObject(this._parseXML,this,true,this.no_cashe);
        this.XMLLoader.waitCall=call||0;
    	this.XMLLoader.loadXMLString(xmlString);
	},
/**
*     @desc: load tabbar from xml file
*     @type: public
*     @param: file - link too XML file
*     @param: afterCall - function which will be called after xml loading
*     @topic: 0
*/
	
	loadXML:function(url,call){
		this.callEvent("onXLS",[]);
		this.XMLLoader=new dtmlXMLLoaderObject(this._parseXML,this,true,this.no_cashe);
		this.XMLLoader.waitCall=call||0;
		this.XMLLoader.loadXML(url);
	},
	_parseXML:function(that,a,b,c,obj){
   		that.clearAll();
        var selected="";
        
        if (!obj) obj=that.XMLLoader;
          var atop=obj.getXMLTopNode("tabbar");
          var arows = obj.doXPath("//row",atop);
          var acs=atop.getAttribute("tabstyle");
          if (acs) that.setStyle(acs);
            
            that._hrfmode=atop.getAttribute("hrefmode")||that._hrfmode;
            that._a.margin =parseInt((atop.getAttribute("margin")||that._a.margin),10);
        
            acs=atop.getAttribute("align");
            if (acs)
            	that._s.align  = (acs=="right"||acs=="bottom");
            that._a.offset = parseInt((atop.getAttribute("offset")||that._a.offset),10);

            acs=atop.getAttribute("skinColors");
            if (acs) that.setSkinColors(acs.split(",")[0],acs.split(",")[1]);
            for (var i=0; i<arows.length; i++){
              var atabs = obj.doXPath("./tab",arows[i]);
                for (var j=0; j<atabs.length; j++){
                	
                    var width=atabs[j].getAttribute("width");
                    var name=that._getXMLContent(atabs[j]);
                    var id=atabs[j].getAttribute("id");
                    that.addTab(id,name,width,"",i);
                    if (atabs[j].getAttribute("selected")) selected=id;

                    if (that._hrfmode)
                        that.setContentHref(id,atabs[j].getAttribute("href"));
                    else
                    for (var k=0; k<atabs[j].childNodes.length; k++){
						var cont=atabs[j].childNodes[k];
                        if (cont.tagName=="content"){
							if (cont.getAttribute("id"))
							   that.setContent(id,cont.getAttribute("id"));
							else
    	                        that.setContentHTML(id,that._getXMLContent(cont));
							}
					}
                }
            }
        if (selected) that.setTabActive(selected);
        that.callEvent("onXLE",[]);
    },
    adjustOuterSize:function(){
    	this._setSizes();	
    },
	_getXMLContent:function(node){
       var text="";
       for (var i=0; i<node.childNodes.length; i++)
            {
                var z=node.childNodes[i];
                text+=(z.nodeValue===null?"":z.nodeValue);
            }
       return text;
	},
/**
*     @desc: enable/disable content zone (enabled by default)
*     @type: public
*     @param: mode - true/false
*     @topic: 0
*/
	
	enableContentZone:function(mode){
		this._conZone.style.display=((convertStringToBoolean(mode))?"":"none");
		this._setSizes();
	},
/**
*     @desc: enable/disable force hiding mode, solves IE problems with iframes in HTML content, but can cause problems for other dhtmlx components inside tabs
*     @type: public
*     @param: mode - true/false
*     @topic: 0
*/
	enableForceHiding:function(mode){
    	this._s.hide=convertStringToBoolean(mode);
	},

/**
*     @desc: set control size
*     @type: public
*     @param: width - new width
*     @param: height - new height
*     @topic: 0
*/
	
	setSize:function(x,y){
		this.entBox.style.width=x+"px";
		this.entBox.style.height=y+"px";
		this._setSizes();
	},
/**
*     @desc: allow to set skin specific color, must be used AFTER selecting skin
*     @type: public
*     @param: a_tab - color of activ tab
*     @param: p_tab - color of passive tab
*     @param: c_zone - color of content zone  (optional)
*     @topic: 0
*/
	
	setSkinColors:function(a,b,c){
		if (a) this._a.data_color=a;
		if (b) this._a.tab_color=b;
		var styleNode = document.createElement("style");
		styleNode.setAttribute("type", "text/css");
		styleNode.setAttribute("media", "screen");
		document.getElementsByTagName("head")[0].appendChild(styleNode);
		var lastStyle = document.styleSheets[document.styleSheets.length - 1];
		if(lastStyle.addRule)
			lastStyle.addRule("#"+this.entBox.id+" .dhx_tabcontent_zone > div", "background-color: "+(c||a)+";",0)
		else
			lastStyle.insertRule("#"+this.entBox.id+" .dhx_tabcontent_zone > div{ background-color: "+(c||a)+";}",0);
		this._conZone.style.backgroundColor=(c||a);
	},
/**
*   @desc: set specific colors for specific tab
*   @param: id - id of tab for which setting will be applied
*   @param: color - tab color
*   @param: color - scolor - color in selected state ( optional)
*   @param: css - css class will be attached to text of tab in question
*   @type: public
*   @topic: 1
*/
	
	setCustomStyle:function(id,color,scolor,style){
		var str="";
		this._c[id]={
			color:(";"+(color?("color:"+color+";"):"")+(style||"")),
			scolor:(";"+(scolor?("color:"+scolor+";"):"")+(style||""))
		};
		if (this._tabs[id])
			this._tabs[id].childNodes[0].style.cssText=((this._tabs[id]==this._lastActive)?this._c[id].scolor:this._c[id].color);
		
	},
/**
*   @desc: set path to image folder ( not affect already created element until their state changes ) 
*   @param: path - path to image folder
*   @type: public
*   @topic: 0
*/
	
	setImagePath:function(url){
		this.imgUrl=url;
	},
	getNext:function(tab,alt){
		alt=alt||"nextSibling";
		var next=tab[alt];
		if (next && next.className.indexOf("dhx_tab_element")==-1) next=null;
		if (!next && tab.parentNode[alt])
			next=tab.parentNode[alt].childNodes[0];
		return next||tab;
	},
/**
*     @desc: returns array of ids for all tabs
*     @type: public
*     @return: array
*     @topic: 0
*/
    getAllTabs:function(){
        var tabs = [];
        for(var id in this._tabs)
		    tabs.push(id);
		return tabs;
	},
/**
*     @desc: select tab next to active
*     @type: public
*     @return: id of current active tab
*     @topic: 0
*/
	
	goToNextTab:function(tab){
		do {tab=this.getNext(tab||this._lastActive)}while (!this._setTabActive(tab));
		return tab;
	},
/**
*     @desc: select tab previous to active
*     @type: public
*     @return: id of current active tab
*     @topic: 0
*/
	
	goToPrevTab:function(tab){
		do {tab=this.getNext((tab||this._lastActive),"previousSibling")}while (!this._setTabActive(tab));
		return tab;
	},
/**
*   @desc: disable tab in tabbar
*   @param: tab - id of tab
*   @param: mode - if set to true, selection jump from current tab to nearest one
*   @type: public
*   @topic: 1
*/
	
	disableTab:function(id){
		this._tabs[id]._disabled=true;
		this._tabs[id].className+=" dhx_tab_element_disabled"; 
		this._tabs[id].style.color="silver";
	},
/**
*   @desc: enable tab in tabbar
*   @param: tab - id of tab
*   @type: public
*   @topic: 1
*/
	
	enableTab:function(id){
		this._tabs[id]._disabled=false;
		if (this._tabs[id].className) this._tabs[id].className=this._tabs[id].className.replace(/dhx_tab_element_disabled/g,""); 
		this._tabs[id].style.color="";
	},
/**
*   @desc: show hidden tab in tabbar
*   @param: tab - id of tab
*   @type: public
*   @topic: 1
*/
	
	showTab:function(id){
		var tab=this._tabs[id];
		tab.style.display="";
		this._setTabSizes(tab.parentNode);
	},
/**
*   @desc: hide tab in tabbar
*   @param: tab - id of tab
*   @param: mode - if set to true, selection jump from current tab to nearest one
*   @type: public
*   @topic: 1
*/
	
	hideTab:function(id, mode){
		var tab=this._tabs[id];
		tab.style.display="none";
		if (tab == this._lastActive && mode !== false)
			this.goToNextTab();
		this._setTabSizes(tab.parentNode);
	},
/**
*     @desc: get id of current active tab
*     @type: public
*     @return: id of current active tab
*     @topic: 0
*/
	
	getActiveTab:function(){
		if (!this._lastActive) return null;
		return this._lastActive.getAttribute("tab_id");
	},
/**
*   @desc: set label of tab
*   @param: tab - id of tab
*   @param: value -  new label
*   @param: size -  tab size
*   @type: public
*   @topic: 1
*/
	
	setLabel:function(id,text,size){
	    var activeTab = this.getActiveTab();
		this._tabs[id].firstChild.innerHTML=text;
		this.adjustTabSize(this._tabs[id],size);
		this._setTabSizes(this._tabs[id].parentNode);
		this._checkScroll();
	},
/**
*   @desc: get label of tab
*   @param: tab - id of tab
*   @type: public
*   @topic: 1
*/
	getLabel:function(id){
			return this._tabs[id].firstChild.innerHTML;
	},	
/**
*   @desc:  set offset before first tab on tabbar
*   @param: offset - offset value
*   @type: public
*   @topic: 1
*/
	
	setOffset:function(n){
		this._a.offset=n*1;	
	},
/**
*   @desc: enable/disable scrollers ( enabled by default )
*   @param: mode - true/false
*   @type: public
*   @edition: Professional
*   @topic: 0
*/
	enableScroll:function(mode){
		this._s.scrolls=convertStringToBoolean(mode);
	},
/**
*   @desc:  set distance between tabs
*   @param: margin - margin value
*   @type: public
*   @topic: 1
*/
	
	setMargin:function(n){
		this._a.margin=n*1;	
	},
/**
*   @desc:  set align of tabs on tabbar
*   @param: align - left/right for gorizontal tabbar, top/bottom for vertical tabbar
*   @type: public
*   @topic: 1
*/
	
	setAlign:function(n){
		this._s.align=(n=="bottom"||n=="right");
	},
/**
*     @desc: return window of tab content for iframe based tabbar
*     @type: public
*     @param: tab_id - tab id
*     @topic: 1
*/
    tabWindow:function(tab_id){
		var win = null;
		if(this._content[tab_id]){
			var cell = this.cells(tab_id);
			win = (cell.vs?cell.vs[cell.av]:this._content[tab_id])._frame.contentWindow;
		}
    	return win;
    },
/**
*     @desc: set content of tab, as HTML string
*     @type: public
*     @param: id - id of tab
*     @param: html - html string
*     @topic: 1
*/    
	setContentHTML:function(id,value){
		this.cells(id).attachHTMLString(value);
	},
/**
*     @desc: set content of tab
*     @type: public
*     @param: id - id of tab
*     @param: nodeId - id of container, or container object
*     @topic: 1
*/
	
	setContent:function(id,value){
		this.cells(id).attachObject(value);
		this.cells(id).activate();
	},
/**
*     @desc: set mode of loading external content
*     @type: public
*     @param: mode - href mode - ifram/iframes/ajax
*     @topic: 0
*/
	
	setHrefMode:function(mode){
        this._hrfmode=mode;
    },	
/**
*     @desc: set content as a href to an external file
*     @type: public
*     @param: href - link too external file
*     @topic: 1
*/
    
	setContentHref:function(id,href){
		this._hrefs[id]=href;
		switch (this._hrfmode){
			case "iframes":
				this.cells(id).attachURL(href);	
				break;
			case "iframe":
			case "iframes-on-demand":
				this.cells(id)._delay=["url",href,false];
				break;
			
			case "ajax":
				var cell=this.cells(id);
				var that=this;
				cell._delay=["urlajax",href,true];
				if (!cell.attachHTMLStringA){
					cell.attachHTMLStringA=cell.attachHTMLString;
					cell.attachHTMLString=function(str,xml){
						if (xml) str=that._getXMLContent(xml.doXPath("//content")[0]);
						return this.attachHTMLStringA(str);
					}
				}
				//this.cells._doOnAttachURL();
				break;
			case "ajax-html":
				this.cells(id)._delay=["urlajax",href,true];
				break;
		}
		if (this._tabs[id]==this._lastActive) this.cells(id).show(true);
	},
//#multiline:23052006{	
/**
*   @desc: reformat tabbar to remove tab scrollers
*   @param: limit - width of tabbar zone, optional
*   @param: full - true | false - force to change size of tabs to make rows of equal width
*	@edition:  professional
*   @type: public
*   @topic: 1
*/

	normalize:function(limit,full){
		limit=limit||this._tabZone.offsetWidth;
		function correct_size(tab,i){
			tabs[i]._size=tabs[i]._size+(prev_size!=Infinity?(prev_size-size):0);
			tab.adjustTabSize(tabs[i],tabs[i]._size);
		}
		var tabs=[];
		for (var j=0; j<this._rows.length; j++)
			for (var i=0; i<this._rows[j].tabCount; i++)
				tabs.push(this._rows[j].removeChild(this._rows[j].childNodes[0]));
		this._tabZone.innerHTML="";
		this._rows=[];
		var t = this._lastActive; this._lastActive=null;
		this._createRow();
		
		var row=0; 
		var size=this._a.offset;
		var prev_size=Infinity;
		var last_tab=null;
		
		var i=0;
		for (i; i<tabs.length; i++)
			if ((size + tabs[i]._size + this._a.margin) < limit){
			    this._rows[row].appendChild(tabs[i]);
				this._rows[row].tabCount++;
				size+=tabs[i]._size + this._a.margin;
				}
			else {
				if (full && size<prev_size) correct_size(this,i-1);
				this._createRow(); 
				i--;	row++;     prev_size=size; size=this._a.offset;
				continue;
			}
		if (full && size<prev_size && prev_size!=Infinity) correct_size(this,i-1);
		
		for (var j=0; j < this._rows.length; j++)
			this._setTabSizes(this._rows[j]);
		this._setSizes();
		if (this._lastActive=t) this._setTabTop(this._lastActive);
	},
//#}
	showInnerScroll: function(){
		for (var i in this._tabs){
			var scrfix = dhtmlx.$customScroll;
			if(this.cells(i).vs){
				var view = this.cells(i).av;
				if (scrfix)
					dhtmlx.CustomScroll.enable(this.cells(i).vs[view].dhxcont.mainCont[view]);
				else
					this.cells(i).vs[view].dhxcont.mainCont[view].style.overflow="auto";
					
			}
			else{
				if (scrfix)
					dhtmlx.CustomScroll.enable(this.cells(i).dhxcont.mainCont);
				else
					this.cells(i).dhxcont.mainCont.style.overflow="auto";
					
			}
		}
	},
	
/** 
* @desc: returns the number of tabs in all rows 
* @type: public 
* @topic: 0 
*/ 
	getNumberOfTabs:function (){ 
		var tc = 0; 
		for(var i=0; i<this._rows.length; i++)
			tc+=this._rows[i].tabCount;
		return tc; 
	},
	
	destructor:function(){
	}

}





































if (!window.dhtmlXContainer){
window.dhtmlXContainer=function(obj) {
	
	var that = this;
	
	this.obj = obj;
	this.dhxcont = null;
	
	this.setContent = function(data) {
		this.dhxcont = data;
		this.dhxcont.innerHTML = "<div id='dhxMainCont' class='dhxcont_main_content'></div>"+
					 "<div id='dhxContBlocker' class='dhxcont_content_blocker' style='display: none;'></div>";
		this.dhxcont.mainCont = this.dhxcont.childNodes[0];
		this.obj.dhxcont = this.dhxcont;
	}
	
	this.obj._genStr = function(w) {
		var s = ""; var z = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
		for (var q=0; q<w; q++) { s = s + z.charAt(Math.round(Math.random() * z.length)); }
		return s;
	}
	
	this.obj.setMinContentSize = function(w, h) {
		this._minDataSizeW = w;
		this._minDataSizeH = h;
	}
	
	this.obj.moveContentTo = function(cont) {

		
		cont.updateNestedObjects();
	}
	
	this.obj.adjustContent = function(parentObj, offsetTop, marginTop, notCalcWidth, offsetBottom) {
		this.dhxcont.style.top = offsetTop+"px";
		this.dhxcont.style.left = "0px";
		
		if (notCalcWidth == true) {
			
		} else {
			this.dhxcont.style.width = parentObj.clientWidth+"px";
		}
		// park check
		var px = parentObj.clientHeight-offsetTop;
		if (px < 0) { px = 0; }
		//
		this.dhxcont.style.height = px+(marginTop!=null?marginTop:0)+"px";
		if (notCalcWidth == true) {
			
		} else {
			if (this.dhxcont.offsetWidth > parentObj.clientWidth) {
				this.dhxcont.style.width = Math.max(0,parentObj.clientWidth*2-this.dhxcont.offsetWidth)+"px";
			}
		}

		if (this.dhxcont.offsetHeight > parentObj.clientHeight - offsetTop) {
			
			
			// park check
			var px = (parentObj.clientHeight-offsetTop)*2-this.dhxcont.offsetHeight;
			if (px < 0) { px = 0; }
			//
			this.dhxcont.style.height = px+"px";
			
		}
		if (offsetBottom) {
			if (!isNaN(offsetBottom)) this.dhxcont.style.height = parseInt(this.dhxcont.style.height)-offsetBottom+"px";
		}
		// main window content
		// menu, toolbar, statusbar should be included
		//this.dhxcont.mainCont = this._engineGetWindowContent(win);//data.childNodes[0];
		
		
		if (this._minDataSizeH != null) {
			if (parseInt(this.dhxcont.style.height) < this._minDataSizeH) {
				// height for menu/toolbar/status bar should be included
				this.dhxcont.style.height = this._minDataSizeH+"px";
			}
		}
		if (this._minDataSizeW != null) {
			if (parseInt(this.dhxcont.style.width) < this._minDataSizeW) {
				this.dhxcont.style.width = this._minDataSizeW+"px";
			}
		}
		
		if (notCalcWidth == true) {
			
		} else {
			this.dhxcont.mainCont.style.width = this.dhxcont.clientWidth+"px";
		}
		
		var menuOffset = (this.menu!=null?(!this.menuHidden?this.menuHeight:0):0);
		var toolbarOffset = (this.toolbar!=null?(!this.toolbarHidden?this.toolbarHeight:0):0);
		var statusOffset = (this.sb!=null?(!this.sbHidden?this.sbHeight:0):0);
		
		this.dhxcont.mainCont.style.height = this.dhxcont.clientHeight-menuOffset-toolbarOffset-statusOffset+"px";
	}
	this.obj.updateNestedObjects = function() {
	}

	
	/**
	*   @desc: attaches an object into a window
	*   @param: obj - object or object id
	*   @param: autoSize - set true to adjust a window to object's dimension
	*   @type: public
	*/
	this.obj.attachObject = function(obj, autoSize) {
		if (typeof(obj) == "string") { obj = document.getElementById(obj); }
		if (autoSize) {
			obj.style.visibility = "hidden";
			obj.style.display = "";
			var objW = obj.offsetWidth;
			var objH = obj.offsetHeight;
		}
		this._attachContent("obj", obj);
		if (autoSize && this._isWindow) {
			obj.style.visibility = "";
			this._adjustToContent(objW, objH);
			// this._engineAdjustWindowToContent(this, objW, objH);
		}
	}
	/**
	*   @desc: appends an object into a window
	*   @param: obj - object or object id
	*   @type: public
	*/
	this.obj.appendObject = function(obj) {
		if (typeof(obj) == "string") { obj = document.getElementById(obj); }
		this._attachContent("obj", obj, true);
	}
	/**
	*   @desc: attaches an html string as an object into a window
	*   @param: str - html string
	*   @type: public
	*/
	this.obj.attachHTMLString = function(str) {
		this._attachContent("str", str);
		var z=str.match(/<script[^>]*>[^\f]*?<\/script>/g)||[];
		for (var i=0; i<z.length; i++){
			var s=z[i].replace(/<([\/]{0,1})script[^>]*>/g,"")
			if (window.execScript){
				var url = z[i].match(/<script[^>]*src\s*=\s*("|')([^"']+)("|')/);
				if (url)
					var s = dhtmlxAjax.getSync(url[2]).xmlDoc.responseText;
				if (s)
					window.execScript(s);
			}
			else window.eval(s);
		}
	}
	/**
	*   @desc: attaches an url into a window
	*   @param: url
	*   @param: ajax - loads an url with ajax
	*   @type: public
	*/
	this.obj.attachURL = function(url, ajax) {
		this._attachContent((ajax==true?"urlajax":"url"), url, false);
	}
	// attach content obj|url
	this.obj._attachContent = function(type, obj, append) {
		// clear old content
		if (append !== true) {
			while (that.dhxcont.mainCont.childNodes.length > 0) { that.dhxcont.mainCont.removeChild(that.dhxcont.mainCont.childNodes[0]); }
		}
		// attach
		if (type == "url") {
			var fr = document.createElement("IFRAME");
			fr.frameBorder = 0;
			fr.border = 0;
			fr.style.width = "100%";
			fr.style.height = "100%";
			that.dhxcont.mainCont.appendChild(fr);
			fr.src = obj;
			this._frame = fr;
			if (this._doOnFrameContentLoaded) this._doOnFrameContentLoaded(true);
		} else if (type == "urlajax") {
			var t = this;
			var xmlParser=function(){
				t.attachHTMLString(this.xmlDoc.responseText,this);
				if (t._doOnFrameContentLoaded) t._doOnFrameContentLoaded(false);
				this.destructor();
			}
			var xmlLoader = new dtmlXMLLoaderObject(xmlParser, window);
			xmlLoader.loadXML(obj);
			if (t._doOnBeforeAttachURL) t._doOnBeforeAttachURL(false);
		} else if (type == "obj") {
			that.dhxcont._frame = null;
			that.dhxcont.mainCont.appendChild(obj);
			// this._engineGetWindowContent(win).style.overflow = (append===true?"auto":"hidden");
			// win._content.childNodes[2].appendChild(obj);
			that.dhxcont.mainCont.style.overflow = (append===true?"auto":"hidden");
			obj.style.display = "";
		} else if (type == "str") {
			that.dhxcont._frame = null;
			that.dhxcont.mainCont.innerHTML = obj;
		}
	}

	
	this.obj._dhxContDestruct = function() {
	}
	
}

}

//tabbar
(function(){
	
	dhtmlx.extend_api("dhtmlXTabBar",{
		_init:function(obj){
			return [obj.parent,obj.mode,obj.height];
		},
		tabs:"tabs",
		skin:"setSkin",
		offset:"setOffset",
		margin:"setMargin",
		image_path:"setImagePath",
		href_mode:"setHrefMode",
		align:"setAlign",
		xml:"loadXML",
		close_button:"enableTabCloseButton",
		scroll:"enableScroll",
		forced:"enableForceHiding",
		content_zone:"enableContentZone",
		size_by_content:"enableAutoSize",
		auto_size:"enableAutoReSize"
	},{
		tabs:function(arr){
			for (var i=0; i<arr.length; i++){
				var t=arr[i];
				this.addTab(t.id,t.label, t.width, t.index, t.row);
				if (t.active) this.setTabActive(t.id);  
			}
		}
	});
	
})();
//v.3.6 build 131108

/*
Copyright DHTMLX LTD. http://www.dhtmlx.com
To use this component please contact sales@dhtmlx.com to obtain license
*/
function dhx_init_tabbars(){
    var z=document.getElementsByTagName("div");
    for (var i=0; i<z.length; i++)
	    if(z[i].className.indexOf("dhtmlxTabBar")!=-1){
            var n=z[i];  var id=n.id; n.className="";

                    var k=new Array();
                    for (var j=0; j<n.childNodes.length; j++)
                    if (n.childNodes[j].tagName && n.childNodes[j].tagName!="!")
                        k[k.length]=n.childNodes[j];

            var w=new dhtmlXTabBar(id,n.getAttribute("mode")||"top",n.getAttribute("tabheight")||20);
            
			window[id]=w;
			acs=n.getAttribute("onbeforeinit");
			if (acs) eval(acs);
			
			if (n.getAttribute("enableForceHiding")) w.enableForceHiding(true);

            w.setImagePath(n.getAttribute("imgpath"));

            var acs=n.getAttribute("margin");
            if (acs!=null) w._margin=acs;

            acs=n.getAttribute("align");
            if (acs) w._align=acs;

            acs=n.getAttribute("hrefmode");
            if (acs) w.setHrefMode(acs);

            acs=n.getAttribute("offset");
            if (acs!=null) w._offset=acs;

            acs=n.getAttribute("tabstyle");
            if (acs!=null) w.setStyle(acs);

			acs=n.getAttribute("select");

            var clrs=n.getAttribute("skinColors");
            if (clrs) w.setSkinColors(clrs.split(",")[0],clrs.split(",")[1]);

                    for (var j=0; j<k.length; j++)
                        {
                        var m=k[j];
                        m.parentNode.removeChild(m)
                        w.addTab(m.id,m.getAttribute("name"),m.getAttribute("width"),null,m.getAttribute("row"));
						var href=m.getAttribute("href");
						if (href) w.setContentHref(m.id,href);
						else w.setContent(m.id,m);

                        if ((!w._dspN)&&(m.style.display=="none"))
                            m.style.display="";
                        }
            if (k.length) w.setTabActive(acs||k[0].id);
            
			acs=n.getAttribute("oninit");
			if (acs) eval(acs);
        }
    }
dhtmlxEvent(window,"load",dhx_init_tabbars);


//(c)dhtmlx ltd. www.dhtmlx.com

dhtmlx.skin='dhx_skyblue';